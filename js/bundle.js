/******/ (function(modules) { // webpackBootstrap
/******/ 	var parentHotUpdateCallback = this["webpackHotUpdate"];
/******/ 	this["webpackHotUpdate"] = 
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if(parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadUpdateChunk(chunkId) { // eslint-disable-line no-unused-vars
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.type = "text/javascript";
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		head.appendChild(script);
/******/ 	}
/******/ 	
/******/ 	function hotDownloadManifest(callback) { // eslint-disable-line no-unused-vars
/******/ 		if(typeof XMLHttpRequest === "undefined")
/******/ 			return callback(new Error("No browser support"));
/******/ 		try {
/******/ 			var request = new XMLHttpRequest();
/******/ 			var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 			request.open("GET", requestPath, true);
/******/ 			request.timeout = 10000;
/******/ 			request.send(null);
/******/ 		} catch(err) {
/******/ 			return callback(err);
/******/ 		}
/******/ 		request.onreadystatechange = function() {
/******/ 			if(request.readyState !== 4) return;
/******/ 			if(request.status === 0) {
/******/ 				// timeout
/******/ 				callback(new Error("Manifest request to " + requestPath + " timed out."));
/******/ 			} else if(request.status === 404) {
/******/ 				// no update available
/******/ 				callback();
/******/ 			} else if(request.status !== 200 && request.status !== 304) {
/******/ 				// other failure
/******/ 				callback(new Error("Manifest request to " + requestPath + " failed."));
/******/ 			} else {
/******/ 				// success
/******/ 				try {
/******/ 					var update = JSON.parse(request.responseText);
/******/ 				} catch(e) {
/******/ 					callback(e);
/******/ 					return;
/******/ 				}
/******/ 				callback(null, update);
/******/ 			}
/******/ 		};
/******/ 	}
/******/
/******/ 	
/******/ 	
/******/ 	// Copied from https://github.com/facebook/react/blob/bef45b0/src/shared/utils/canDefineProperty.js
/******/ 	var canDefineProperty = false;
/******/ 	try {
/******/ 		Object.defineProperty({}, "x", {
/******/ 			get: function() {}
/******/ 		});
/******/ 		canDefineProperty = true;
/******/ 	} catch(x) {
/******/ 		// IE will fail on defineProperty
/******/ 	}
/******/ 	
/******/ 	var hotApplyOnUpdate = true;
/******/ 	var hotCurrentHash = "478fc63448d0c099fd40"; // eslint-disable-line no-unused-vars
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentParents = []; // eslint-disable-line no-unused-vars
/******/ 	
/******/ 	function hotCreateRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var me = installedModules[moduleId];
/******/ 		if(!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if(me.hot.active) {
/******/ 				if(installedModules[request]) {
/******/ 					if(installedModules[request].parents.indexOf(moduleId) < 0)
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					if(me.children.indexOf(request) < 0)
/******/ 						me.children.push(request);
/******/ 				} else hotCurrentParents = [moduleId];
/******/ 			} else {
/******/ 				console.warn("[HMR] unexpected require(" + request + ") from disposed module " + moduleId);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		for(var name in __webpack_require__) {
/******/ 			if(Object.prototype.hasOwnProperty.call(__webpack_require__, name)) {
/******/ 				if(canDefineProperty) {
/******/ 					Object.defineProperty(fn, name, (function(name) {
/******/ 						return {
/******/ 							configurable: true,
/******/ 							enumerable: true,
/******/ 							get: function() {
/******/ 								return __webpack_require__[name];
/******/ 							},
/******/ 							set: function(value) {
/******/ 								__webpack_require__[name] = value;
/******/ 							}
/******/ 						};
/******/ 					}(name)));
/******/ 				} else {
/******/ 					fn[name] = __webpack_require__[name];
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		function ensure(chunkId, callback) {
/******/ 			if(hotStatus === "ready")
/******/ 				hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			__webpack_require__.e(chunkId, function() {
/******/ 				try {
/******/ 					callback.call(null, fn);
/******/ 				} finally {
/******/ 					finishChunkLoading();
/******/ 				}
/******/ 	
/******/ 				function finishChunkLoading() {
/******/ 					hotChunksLoading--;
/******/ 					if(hotStatus === "prepare") {
/******/ 						if(!hotWaitingFilesMap[chunkId]) {
/******/ 							hotEnsureUpdateChunk(chunkId);
/******/ 						}
/******/ 						if(hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 							hotUpdateDownloaded();
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		}
/******/ 		if(canDefineProperty) {
/******/ 			Object.defineProperty(fn, "e", {
/******/ 				enumerable: true,
/******/ 				value: ensure
/******/ 			});
/******/ 		} else {
/******/ 			fn.e = ensure;
/******/ 		}
/******/ 		return fn;
/******/ 	}
/******/ 	
/******/ 	function hotCreateModule(moduleId) { // eslint-disable-line no-unused-vars
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 	
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfAccepted = true;
/******/ 				else if(typeof dep === "function")
/******/ 					hot._selfAccepted = dep;
/******/ 				else if(typeof dep === "object")
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback;
/******/ 				else
/******/ 					hot._acceptedDependencies[dep] = callback;
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if(typeof dep === "undefined")
/******/ 					hot._selfDeclined = true;
/******/ 				else if(typeof dep === "number")
/******/ 					hot._declinedDependencies[dep] = true;
/******/ 				else
/******/ 					for(var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if(idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if(!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if(idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/ 	
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		return hot;
/******/ 	}
/******/ 	
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/ 	
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for(var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/ 	
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailibleFilesMap = {};
/******/ 	var hotCallback;
/******/ 	
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/ 	
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = (+id) + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/ 	
/******/ 	function hotCheck(apply, callback) {
/******/ 		if(hotStatus !== "idle") throw new Error("check() is only allowed in idle status");
/******/ 		if(typeof apply === "function") {
/******/ 			hotApplyOnUpdate = false;
/******/ 			callback = apply;
/******/ 		} else {
/******/ 			hotApplyOnUpdate = apply;
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 		hotSetStatus("check");
/******/ 		hotDownloadManifest(function(err, update) {
/******/ 			if(err) return callback(err);
/******/ 			if(!update) {
/******/ 				hotSetStatus("idle");
/******/ 				callback(null, null);
/******/ 				return;
/******/ 			}
/******/ 	
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotAvailibleFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			for(var i = 0; i < update.c.length; i++)
/******/ 				hotAvailibleFilesMap[update.c[i]] = true;
/******/ 			hotUpdateNewHash = update.h;
/******/ 	
/******/ 			hotSetStatus("prepare");
/******/ 			hotCallback = callback;
/******/ 			hotUpdate = {};
/******/ 			var chunkId = 0;
/******/ 			{ // eslint-disable-line no-lone-blocks
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if(hotStatus === "prepare" && hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 		});
/******/ 	}
/******/ 	
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) { // eslint-disable-line no-unused-vars
/******/ 		if(!hotAvailibleFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for(var moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if(!hotAvailibleFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var callback = hotCallback;
/******/ 		hotCallback = null;
/******/ 		if(!callback) return;
/******/ 		if(hotApplyOnUpdate) {
/******/ 			hotApply(hotApplyOnUpdate, callback);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for(var id in hotUpdate) {
/******/ 				if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			callback(null, outdatedModules);
/******/ 		}
/******/ 	}
/******/ 	
/******/ 	function hotApply(options, callback) {
/******/ 		if(hotStatus !== "ready") throw new Error("apply() is only allowed in ready status");
/******/ 		if(typeof options === "function") {
/******/ 			callback = options;
/******/ 			options = {};
/******/ 		} else if(options && typeof options === "object") {
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		} else {
/******/ 			options = {};
/******/ 			callback = callback || function(err) {
/******/ 				if(err) throw err;
/******/ 			};
/******/ 		}
/******/ 	
/******/ 		function getAffectedStuff(module) {
/******/ 			var outdatedModules = [module];
/******/ 			var outdatedDependencies = {};
/******/ 	
/******/ 			var queue = outdatedModules.slice();
/******/ 			while(queue.length > 0) {
/******/ 				var moduleId = queue.pop();
/******/ 				var module = installedModules[moduleId];
/******/ 				if(!module || module.hot._selfAccepted)
/******/ 					continue;
/******/ 				if(module.hot._selfDeclined) {
/******/ 					return new Error("Aborted because of self decline: " + moduleId);
/******/ 				}
/******/ 				if(moduleId === 0) {
/******/ 					return;
/******/ 				}
/******/ 				for(var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if(parent.hot._declinedDependencies[moduleId]) {
/******/ 						return new Error("Aborted because of declined dependency: " + moduleId + " in " + parentId);
/******/ 					}
/******/ 					if(outdatedModules.indexOf(parentId) >= 0) continue;
/******/ 					if(parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if(!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push(parentId);
/******/ 				}
/******/ 			}
/******/ 	
/******/ 			return [outdatedModules, outdatedDependencies];
/******/ 		}
/******/ 	
/******/ 		function addAllToSet(a, b) {
/******/ 			for(var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if(a.indexOf(item) < 0)
/******/ 					a.push(item);
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/ 		for(var id in hotUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				var moduleId = toModuleId(id);
/******/ 				var result = getAffectedStuff(moduleId);
/******/ 				if(!result) {
/******/ 					if(options.ignoreUnaccepted)
/******/ 						continue;
/******/ 					hotSetStatus("abort");
/******/ 					return callback(new Error("Aborted because " + moduleId + " is not accepted"));
/******/ 				}
/******/ 				if(result instanceof Error) {
/******/ 					hotSetStatus("abort");
/******/ 					return callback(result);
/******/ 				}
/******/ 				appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 				addAllToSet(outdatedModules, result[0]);
/******/ 				for(var moduleId in result[1]) {
/******/ 					if(Object.prototype.hasOwnProperty.call(result[1], moduleId)) {
/******/ 						if(!outdatedDependencies[moduleId])
/******/ 							outdatedDependencies[moduleId] = [];
/******/ 						addAllToSet(outdatedDependencies[moduleId], result[1][moduleId]);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for(var i = 0; i < outdatedModules.length; i++) {
/******/ 			var moduleId = outdatedModules[i];
/******/ 			if(installedModules[moduleId] && installedModules[moduleId].hot._selfAccepted)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/ 	
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		var queue = outdatedModules.slice();
/******/ 		while(queue.length > 0) {
/******/ 			var moduleId = queue.pop();
/******/ 			var module = installedModules[moduleId];
/******/ 			if(!module) continue;
/******/ 	
/******/ 			var data = {};
/******/ 	
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for(var j = 0; j < disposeHandlers.length; j++) {
/******/ 				var cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/ 	
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/ 	
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/ 	
/******/ 			// remove "parents" references from all children
/******/ 			for(var j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if(!child) continue;
/******/ 				var idx = child.parents.indexOf(moduleId);
/******/ 				if(idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// remove outdated dependency from module children
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				for(var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 					var dependency = moduleOutdatedDependencies[j];
/******/ 					var idx = module.children.indexOf(dependency);
/******/ 					if(idx >= 0) module.children.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/ 	
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/ 	
/******/ 		// insert new code
/******/ 		for(var moduleId in appliedUpdate) {
/******/ 			if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for(var moduleId in outdatedDependencies) {
/******/ 			if(Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)) {
/******/ 				var module = installedModules[moduleId];
/******/ 				var moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 				var callbacks = [];
/******/ 				for(var i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 					var dependency = moduleOutdatedDependencies[i];
/******/ 					var cb = module.hot._acceptedDependencies[dependency];
/******/ 					if(callbacks.indexOf(cb) >= 0) continue;
/******/ 					callbacks.push(cb);
/******/ 				}
/******/ 				for(var i = 0; i < callbacks.length; i++) {
/******/ 					var cb = callbacks[i];
/******/ 					try {
/******/ 						cb(outdatedDependencies);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// Load self accepted modules
/******/ 		for(var i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			var moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch(err) {
/******/ 				if(typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch(err) {
/******/ 						if(!error)
/******/ 							error = err;
/******/ 					}
/******/ 				} else if(!error)
/******/ 					error = err;
/******/ 			}
/******/ 		}
/******/ 	
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if(error) {
/******/ 			hotSetStatus("fail");
/******/ 			return callback(error);
/******/ 		}
/******/ 	
/******/ 		hotSetStatus("idle");
/******/ 		callback(null, outdatedModules);
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: hotCurrentParents,
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire(0)(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(68);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(8);
	var toSubscriber_1 = __webpack_require__(344);
	var observable_1 = __webpack_require__(22);
	/**
	 * A representation of any set of values over any amount of time. This the most basic building block
	 * of RxJS.
	 *
	 * @class Observable<T>
	 */
	var Observable = (function () {
	    /**
	     * @constructor
	     * @param {Function} subscribe the function that is  called when the Observable is
	     * initially subscribed to. This function is given a Subscriber, to which new values
	     * can be `next`ed, or an `error` method can be called to raise an error, or
	     * `complete` can be called to notify of a successful completion.
	     */
	    function Observable(subscribe) {
	        this._isScalar = false;
	        if (subscribe) {
	            this._subscribe = subscribe;
	        }
	    }
	    /**
	     * Creates a new Observable, with this Observable as the source, and the passed
	     * operator defined as the new observable's operator.
	     * @method lift
	     * @param {Operator} operator the operator defining the operation to take on the observable
	     * @return {Observable} a new observable with the Operator applied
	     */
	    Observable.prototype.lift = function (operator) {
	        var observable = new Observable();
	        observable.source = this;
	        observable.operator = operator;
	        return observable;
	    };
	    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
	        var operator = this.operator;
	        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
	        if (operator) {
	            operator.call(sink, this.source);
	        }
	        else {
	            sink.add(this._trySubscribe(sink));
	        }
	        if (sink.syncErrorThrowable) {
	            sink.syncErrorThrowable = false;
	            if (sink.syncErrorThrown) {
	                throw sink.syncErrorValue;
	            }
	        }
	        return sink;
	    };
	    Observable.prototype._trySubscribe = function (sink) {
	        try {
	            return this._subscribe(sink);
	        }
	        catch (err) {
	            sink.syncErrorThrown = true;
	            sink.syncErrorValue = err;
	            sink.error(err);
	        }
	    };
	    /**
	     * @method forEach
	     * @param {Function} next a handler for each value emitted by the observable
	     * @param {PromiseConstructor} [PromiseCtor] a constructor function used to instantiate the Promise
	     * @return {Promise} a promise that either resolves on observable completion or
	     *  rejects with the handled error
	     */
	    Observable.prototype.forEach = function (next, PromiseCtor) {
	        var _this = this;
	        if (!PromiseCtor) {
	            if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	                PromiseCtor = root_1.root.Rx.config.Promise;
	            }
	            else if (root_1.root.Promise) {
	                PromiseCtor = root_1.root.Promise;
	            }
	        }
	        if (!PromiseCtor) {
	            throw new Error('no Promise impl found');
	        }
	        return new PromiseCtor(function (resolve, reject) {
	            // Must be declared in a separate statement to avoid a RefernceError when
	            // accessing subscription below in the closure due to Temporal Dead Zone.
	            var subscription;
	            subscription = _this.subscribe(function (value) {
	                if (subscription) {
	                    // if there is a subscription, then we can surmise
	                    // the next handling is asynchronous. Any errors thrown
	                    // need to be rejected explicitly and unsubscribe must be
	                    // called manually
	                    try {
	                        next(value);
	                    }
	                    catch (err) {
	                        reject(err);
	                        subscription.unsubscribe();
	                    }
	                }
	                else {
	                    // if there is NO subscription, then we're getting a nexted
	                    // value synchronously during subscription. We can just call it.
	                    // If it errors, Observable's `subscribe` will ensure the
	                    // unsubscription logic is called, then synchronously rethrow the error.
	                    // After that, Promise will trap the error and send it
	                    // down the rejection path.
	                    next(value);
	                }
	            }, reject, resolve);
	        });
	    };
	    Observable.prototype._subscribe = function (subscriber) {
	        return this.source.subscribe(subscriber);
	    };
	    /**
	     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
	     * @method Symbol.observable
	     * @return {Observable} this instance of the observable
	     */
	    Observable.prototype[observable_1.observable] = function () {
	        return this;
	    };
	    // HACK: Since TypeScript inherits static properties too, we have to
	    // fight against TypeScript here so Subject can have a different static create signature
	    /**
	     * Creates a new cold Observable by calling the Observable constructor
	     * @static true
	     * @owner Observable
	     * @method create
	     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
	     * @return {Observable} a new cold observable
	     */
	    Observable.create = function (subscribe) {
	        return new Observable(subscribe);
	    };
	    return Observable;
	}());
	exports.Observable = Observable;


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1 = __webpack_require__(28);
	var Subscription_1 = __webpack_require__(5);
	var Observer_1 = __webpack_require__(39);
	var rxSubscriber_1 = __webpack_require__(23);
	/**
	 * Implements the {@link Observer} interface and extends the
	 * {@link Subscription} class. While the {@link Observer} is the public API for
	 * consuming the values of an {@link Observable}, all Observers get converted to
	 * a Subscriber, in order to provide Subscription-like capabilities such as
	 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
	 * implementing operators, but it is rarely used as a public API.
	 *
	 * @class Subscriber<T>
	 */
	var Subscriber = (function (_super) {
	    __extends(Subscriber, _super);
	    /**
	     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
	     * defined Observer or a `next` callback function.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     */
	    function Subscriber(destinationOrNext, error, complete) {
	        _super.call(this);
	        this.syncErrorValue = null;
	        this.syncErrorThrown = false;
	        this.syncErrorThrowable = false;
	        this.isStopped = false;
	        switch (arguments.length) {
	            case 0:
	                this.destination = Observer_1.empty;
	                break;
	            case 1:
	                if (!destinationOrNext) {
	                    this.destination = Observer_1.empty;
	                    break;
	                }
	                if (typeof destinationOrNext === 'object') {
	                    if (destinationOrNext instanceof Subscriber) {
	                        this.destination = destinationOrNext;
	                        this.destination.add(this);
	                    }
	                    else {
	                        this.syncErrorThrowable = true;
	                        this.destination = new SafeSubscriber(this, destinationOrNext);
	                    }
	                    break;
	                }
	            default:
	                this.syncErrorThrowable = true;
	                this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
	                break;
	        }
	    }
	    Subscriber.prototype[rxSubscriber_1.rxSubscriber] = function () { return this; };
	    /**
	     * A static factory for a Subscriber, given a (potentially partial) definition
	     * of an Observer.
	     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
	     * @param {function(e: ?any): void} [error] The `error` callback of an
	     * Observer.
	     * @param {function(): void} [complete] The `complete` callback of an
	     * Observer.
	     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
	     * Observer represented by the given arguments.
	     */
	    Subscriber.create = function (next, error, complete) {
	        var subscriber = new Subscriber(next, error, complete);
	        subscriber.syncErrorThrowable = false;
	        return subscriber;
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `next` from
	     * the Observable, with a value. The Observable may call this method 0 or more
	     * times.
	     * @param {T} [value] The `next` value.
	     * @return {void}
	     */
	    Subscriber.prototype.next = function (value) {
	        if (!this.isStopped) {
	            this._next(value);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive notifications of type `error` from
	     * the Observable, with an attached {@link Error}. Notifies the Observer that
	     * the Observable has experienced an error condition.
	     * @param {any} [err] The `error` exception.
	     * @return {void}
	     */
	    Subscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._error(err);
	        }
	    };
	    /**
	     * The {@link Observer} callback to receive a valueless notification of type
	     * `complete` from the Observable. Notifies the Observer that the Observable
	     * has finished sending push-based notifications.
	     * @return {void}
	     */
	    Subscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            this.isStopped = true;
	            this._complete();
	        }
	    };
	    Subscriber.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.isStopped = true;
	        _super.prototype.unsubscribe.call(this);
	    };
	    Subscriber.prototype._next = function (value) {
	        this.destination.next(value);
	    };
	    Subscriber.prototype._error = function (err) {
	        this.destination.error(err);
	        this.unsubscribe();
	    };
	    Subscriber.prototype._complete = function () {
	        this.destination.complete();
	        this.unsubscribe();
	    };
	    Subscriber.prototype._unsubscribeAndRecycle = function () {
	        var _a = this, _parent = _a._parent, _parents = _a._parents;
	        this._parent = null;
	        this._parents = null;
	        this.unsubscribe();
	        this.closed = false;
	        this.isStopped = false;
	        this._parent = _parent;
	        this._parents = _parents;
	        return this;
	    };
	    return Subscriber;
	}(Subscription_1.Subscription));
	exports.Subscriber = Subscriber;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SafeSubscriber = (function (_super) {
	    __extends(SafeSubscriber, _super);
	    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
	        _super.call(this);
	        this._parentSubscriber = _parentSubscriber;
	        var next;
	        var context = this;
	        if (isFunction_1.isFunction(observerOrNext)) {
	            next = observerOrNext;
	        }
	        else if (observerOrNext) {
	            next = observerOrNext.next;
	            error = observerOrNext.error;
	            complete = observerOrNext.complete;
	            if (observerOrNext !== Observer_1.empty) {
	                context = Object.create(observerOrNext);
	                if (isFunction_1.isFunction(context.unsubscribe)) {
	                    this.add(context.unsubscribe.bind(context));
	                }
	                context.unsubscribe = this.unsubscribe.bind(this);
	            }
	        }
	        this._context = context;
	        this._next = next;
	        this._error = error;
	        this._complete = complete;
	    }
	    SafeSubscriber.prototype.next = function (value) {
	        if (!this.isStopped && this._next) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (!_parentSubscriber.syncErrorThrowable) {
	                this.__tryOrUnsub(this._next, value);
	            }
	            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (this._error) {
	                if (!_parentSubscriber.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._error, err);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parentSubscriber, this._error, err);
	                    this.unsubscribe();
	                }
	            }
	            else if (!_parentSubscriber.syncErrorThrowable) {
	                this.unsubscribe();
	                throw err;
	            }
	            else {
	                _parentSubscriber.syncErrorValue = err;
	                _parentSubscriber.syncErrorThrown = true;
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            var _parentSubscriber = this._parentSubscriber;
	            if (this._complete) {
	                if (!_parentSubscriber.syncErrorThrowable) {
	                    this.__tryOrUnsub(this._complete);
	                    this.unsubscribe();
	                }
	                else {
	                    this.__tryOrSetError(_parentSubscriber, this._complete);
	                    this.unsubscribe();
	                }
	            }
	            else {
	                this.unsubscribe();
	            }
	        }
	    };
	    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            this.unsubscribe();
	            throw err;
	        }
	    };
	    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
	        try {
	            fn.call(this._context, value);
	        }
	        catch (err) {
	            parent.syncErrorValue = err;
	            parent.syncErrorThrown = true;
	            return true;
	        }
	        return false;
	    };
	    SafeSubscriber.prototype._unsubscribe = function () {
	        var _parentSubscriber = this._parentSubscriber;
	        this._context = null;
	        this._parentSubscriber = null;
	        _parentSubscriber.unsubscribe();
	    };
	    return SafeSubscriber;
	}(Subscriber));


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var OuterSubscriber = (function (_super) {
	    __extends(OuterSubscriber, _super);
	    function OuterSubscriber() {
	        _super.apply(this, arguments);
	    }
	    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(innerValue);
	    };
	    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
	        this.destination.error(error);
	    };
	    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.destination.complete();
	    };
	    return OuterSubscriber;
	}(Subscriber_1.Subscriber));
	exports.OuterSubscriber = OuterSubscriber;


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(8);
	var isArrayLike_1 = __webpack_require__(63);
	var isPromise_1 = __webpack_require__(65);
	var isObject_1 = __webpack_require__(64);
	var Observable_1 = __webpack_require__(1);
	var iterator_1 = __webpack_require__(19);
	var InnerSubscriber_1 = __webpack_require__(70);
	var observable_1 = __webpack_require__(22);
	function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
	    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
	    if (destination.closed) {
	        return null;
	    }
	    if (result instanceof Observable_1.Observable) {
	        if (result._isScalar) {
	            destination.next(result.value);
	            destination.complete();
	            return null;
	        }
	        else {
	            return result.subscribe(destination);
	        }
	    }
	    else if (isArrayLike_1.isArrayLike(result)) {
	        for (var i = 0, len = result.length; i < len && !destination.closed; i++) {
	            destination.next(result[i]);
	        }
	        if (!destination.closed) {
	            destination.complete();
	        }
	    }
	    else if (isPromise_1.isPromise(result)) {
	        result.then(function (value) {
	            if (!destination.closed) {
	                destination.next(value);
	                destination.complete();
	            }
	        }, function (err) { return destination.error(err); })
	            .then(null, function (err) {
	            // Escaping the Promise trap: globally throw unhandled errors
	            root_1.root.setTimeout(function () { throw err; });
	        });
	        return destination;
	    }
	    else if (result && typeof result[iterator_1.iterator] === 'function') {
	        var iterator = result[iterator_1.iterator]();
	        do {
	            var item = iterator.next();
	            if (item.done) {
	                destination.complete();
	                break;
	            }
	            destination.next(item.value);
	            if (destination.closed) {
	                break;
	            }
	        } while (true);
	    }
	    else if (result && typeof result[observable_1.observable] === 'function') {
	        var obs = result[observable_1.observable]();
	        if (typeof obs.subscribe !== 'function') {
	            destination.error(new TypeError('Provided object does not correctly implement Symbol.observable'));
	        }
	        else {
	            return obs.subscribe(new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex));
	        }
	    }
	    else {
	        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
	        var msg = ("You provided " + value + " where a stream was expected.")
	            + ' You can provide an Observable, Promise, Array, or Iterable.';
	        destination.error(new TypeError(msg));
	    }
	    return null;
	}
	exports.subscribeToResult = subscribeToResult;


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isArray_1 = __webpack_require__(12);
	var isObject_1 = __webpack_require__(64);
	var isFunction_1 = __webpack_require__(28);
	var tryCatch_1 = __webpack_require__(9);
	var errorObject_1 = __webpack_require__(7);
	var UnsubscriptionError_1 = __webpack_require__(61);
	/**
	 * Represents a disposable resource, such as the execution of an Observable. A
	 * Subscription has one important method, `unsubscribe`, that takes no argument
	 * and just disposes the resource held by the subscription.
	 *
	 * Additionally, subscriptions may be grouped together through the `add()`
	 * method, which will attach a child Subscription to the current Subscription.
	 * When a Subscription is unsubscribed, all its children (and its grandchildren)
	 * will be unsubscribed as well.
	 *
	 * @class Subscription
	 */
	var Subscription = (function () {
	    /**
	     * @param {function(): void} [unsubscribe] A function describing how to
	     * perform the disposal of resources when the `unsubscribe` method is called.
	     */
	    function Subscription(unsubscribe) {
	        /**
	         * A flag to indicate whether this Subscription has already been unsubscribed.
	         * @type {boolean}
	         */
	        this.closed = false;
	        this._parent = null;
	        this._parents = null;
	        this._subscriptions = null;
	        if (unsubscribe) {
	            this._unsubscribe = unsubscribe;
	        }
	    }
	    /**
	     * Disposes the resources held by the subscription. May, for instance, cancel
	     * an ongoing Observable execution or cancel any other type of work that
	     * started when the Subscription was created.
	     * @return {void}
	     */
	    Subscription.prototype.unsubscribe = function () {
	        var hasErrors = false;
	        var errors;
	        if (this.closed) {
	            return;
	        }
	        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
	        this.closed = true;
	        this._parent = null;
	        this._parents = null;
	        // null out _subscriptions first so any child subscriptions that attempt
	        // to remove themselves from this subscription will noop
	        this._subscriptions = null;
	        var index = -1;
	        var len = _parents ? _parents.length : 0;
	        // if this._parent is null, then so is this._parents, and we
	        // don't have to remove ourselves from any parent subscriptions.
	        while (_parent) {
	            _parent.remove(this);
	            // if this._parents is null or index >= len,
	            // then _parent is set to null, and the loop exits
	            _parent = ++index < len && _parents[index] || null;
	        }
	        if (isFunction_1.isFunction(_unsubscribe)) {
	            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
	            if (trial === errorObject_1.errorObject) {
	                hasErrors = true;
	                errors = errors || (errorObject_1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
	                    flattenUnsubscriptionErrors(errorObject_1.errorObject.e.errors) : [errorObject_1.errorObject.e]);
	            }
	        }
	        if (isArray_1.isArray(_subscriptions)) {
	            index = -1;
	            len = _subscriptions.length;
	            while (++index < len) {
	                var sub = _subscriptions[index];
	                if (isObject_1.isObject(sub)) {
	                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
	                    if (trial === errorObject_1.errorObject) {
	                        hasErrors = true;
	                        errors = errors || [];
	                        var err = errorObject_1.errorObject.e;
	                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
	                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
	                        }
	                        else {
	                            errors.push(err);
	                        }
	                    }
	                }
	            }
	        }
	        if (hasErrors) {
	            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
	        }
	    };
	    /**
	     * Adds a tear down to be called during the unsubscribe() of this
	     * Subscription.
	     *
	     * If the tear down being added is a subscription that is already
	     * unsubscribed, is the same reference `add` is being called on, or is
	     * `Subscription.EMPTY`, it will not be added.
	     *
	     * If this subscription is already in an `closed` state, the passed
	     * tear down logic will be executed immediately.
	     *
	     * @param {TeardownLogic} teardown The additional logic to execute on
	     * teardown.
	     * @return {Subscription} Returns the Subscription used or created to be
	     * added to the inner subscriptions list. This Subscription can be used with
	     * `remove()` to remove the passed teardown logic from the inner subscriptions
	     * list.
	     */
	    Subscription.prototype.add = function (teardown) {
	        if (!teardown || (teardown === Subscription.EMPTY)) {
	            return Subscription.EMPTY;
	        }
	        if (teardown === this) {
	            return this;
	        }
	        var subscription = teardown;
	        switch (typeof teardown) {
	            case 'function':
	                subscription = new Subscription(teardown);
	            case 'object':
	                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
	                    return subscription;
	                }
	                else if (this.closed) {
	                    subscription.unsubscribe();
	                    return subscription;
	                }
	                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
	                    var tmp = subscription;
	                    subscription = new Subscription();
	                    subscription._subscriptions = [tmp];
	                }
	                break;
	            default:
	                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
	        }
	        var subscriptions = this._subscriptions || (this._subscriptions = []);
	        subscriptions.push(subscription);
	        subscription._addParent(this);
	        return subscription;
	    };
	    /**
	     * Removes a Subscription from the internal list of subscriptions that will
	     * unsubscribe during the unsubscribe process of this Subscription.
	     * @param {Subscription} subscription The subscription to remove.
	     * @return {void}
	     */
	    Subscription.prototype.remove = function (subscription) {
	        var subscriptions = this._subscriptions;
	        if (subscriptions) {
	            var subscriptionIndex = subscriptions.indexOf(subscription);
	            if (subscriptionIndex !== -1) {
	                subscriptions.splice(subscriptionIndex, 1);
	            }
	        }
	    };
	    Subscription.prototype._addParent = function (parent) {
	        var _a = this, _parent = _a._parent, _parents = _a._parents;
	        if (!_parent || _parent === parent) {
	            // If we don't have a parent, or the new parent is the same as the
	            // current parent, then set this._parent to the new parent.
	            this._parent = parent;
	        }
	        else if (!_parents) {
	            // If there's already one parent, but not multiple, allocate an Array to
	            // store the rest of the parent Subscriptions.
	            this._parents = [parent];
	        }
	        else if (_parents.indexOf(parent) === -1) {
	            // Only add the new parent to the _parents list if it's not already there.
	            _parents.push(parent);
	        }
	    };
	    Subscription.EMPTY = (function (empty) {
	        empty.closed = true;
	        return empty;
	    }(new Subscription()));
	    return Subscription;
	}());
	exports.Subscription = Subscription;
	function flattenUnsubscriptionErrors(errors) {
	    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
	}


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	var Subscriber_1 = __webpack_require__(2);
	var Subscription_1 = __webpack_require__(5);
	var ObjectUnsubscribedError_1 = __webpack_require__(26);
	var SubjectSubscription_1 = __webpack_require__(40);
	var rxSubscriber_1 = __webpack_require__(23);
	/**
	 * @class SubjectSubscriber<T>
	 */
	var SubjectSubscriber = (function (_super) {
	    __extends(SubjectSubscriber, _super);
	    function SubjectSubscriber(destination) {
	        _super.call(this, destination);
	        this.destination = destination;
	    }
	    return SubjectSubscriber;
	}(Subscriber_1.Subscriber));
	exports.SubjectSubscriber = SubjectSubscriber;
	/**
	 * @class Subject<T>
	 */
	var Subject = (function (_super) {
	    __extends(Subject, _super);
	    function Subject() {
	        _super.call(this);
	        this.observers = [];
	        this.closed = false;
	        this.isStopped = false;
	        this.hasError = false;
	        this.thrownError = null;
	    }
	    Subject.prototype[rxSubscriber_1.rxSubscriber] = function () {
	        return new SubjectSubscriber(this);
	    };
	    Subject.prototype.lift = function (operator) {
	        var subject = new AnonymousSubject(this, this);
	        subject.operator = operator;
	        return subject;
	    };
	    Subject.prototype.next = function (value) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        if (!this.isStopped) {
	            var observers = this.observers;
	            var len = observers.length;
	            var copy = observers.slice();
	            for (var i = 0; i < len; i++) {
	                copy[i].next(value);
	            }
	        }
	    };
	    Subject.prototype.error = function (err) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        this.hasError = true;
	        this.thrownError = err;
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].error(err);
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.complete = function () {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        this.isStopped = true;
	        var observers = this.observers;
	        var len = observers.length;
	        var copy = observers.slice();
	        for (var i = 0; i < len; i++) {
	            copy[i].complete();
	        }
	        this.observers.length = 0;
	    };
	    Subject.prototype.unsubscribe = function () {
	        this.isStopped = true;
	        this.closed = true;
	        this.observers = null;
	    };
	    Subject.prototype._trySubscribe = function (subscriber) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        else {
	            return _super.prototype._trySubscribe.call(this, subscriber);
	        }
	    };
	    Subject.prototype._subscribe = function (subscriber) {
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        else if (this.hasError) {
	            subscriber.error(this.thrownError);
	            return Subscription_1.Subscription.EMPTY;
	        }
	        else if (this.isStopped) {
	            subscriber.complete();
	            return Subscription_1.Subscription.EMPTY;
	        }
	        else {
	            this.observers.push(subscriber);
	            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
	        }
	    };
	    Subject.prototype.asObservable = function () {
	        var observable = new Observable_1.Observable();
	        observable.source = this;
	        return observable;
	    };
	    Subject.create = function (destination, source) {
	        return new AnonymousSubject(destination, source);
	    };
	    return Subject;
	}(Observable_1.Observable));
	exports.Subject = Subject;
	/**
	 * @class AnonymousSubject<T>
	 */
	var AnonymousSubject = (function (_super) {
	    __extends(AnonymousSubject, _super);
	    function AnonymousSubject(destination, source) {
	        _super.call(this);
	        this.destination = destination;
	        this.source = source;
	    }
	    AnonymousSubject.prototype.next = function (value) {
	        var destination = this.destination;
	        if (destination && destination.next) {
	            destination.next(value);
	        }
	    };
	    AnonymousSubject.prototype.error = function (err) {
	        var destination = this.destination;
	        if (destination && destination.error) {
	            this.destination.error(err);
	        }
	    };
	    AnonymousSubject.prototype.complete = function () {
	        var destination = this.destination;
	        if (destination && destination.complete) {
	            this.destination.complete();
	        }
	    };
	    AnonymousSubject.prototype._subscribe = function (subscriber) {
	        var source = this.source;
	        if (source) {
	            return this.source.subscribe(subscriber);
	        }
	        else {
	            return Subscription_1.Subscription.EMPTY;
	        }
	    };
	    return AnonymousSubject;
	}(Subject));
	exports.AnonymousSubject = AnonymousSubject;


/***/ },
/* 7 */
/***/ function(module, exports) {

	"use strict";
	// typeof any so that it we don't have to cast when comparing a result to the error object
	exports.errorObject = { e: {} };


/***/ },
/* 8 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	/**
	 * window: browser in DOM main thread
	 * self: browser in WebWorker
	 * global: Node.js/other
	 */
	exports.root = (typeof window == 'object' && window.window === window && window
	    || typeof self == 'object' && self.self === self && self
	    || typeof global == 'object' && global.global === global && global);
	if (!exports.root) {
	    throw new Error('RxJS could not find any global context (window, self, global)');
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var errorObject_1 = __webpack_require__(7);
	var tryCatchTarget;
	function tryCatcher() {
	    try {
	        return tryCatchTarget.apply(this, arguments);
	    }
	    catch (e) {
	        errorObject_1.errorObject.e = e;
	        return errorObject_1.errorObject;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}
	exports.tryCatch = tryCatch;
	;


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AsyncAction_1 = __webpack_require__(17);
	var AsyncScheduler_1 = __webpack_require__(18);
	/**
	 *
	 * Async Scheduler
	 *
	 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
	 *
	 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
	 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
	 * in intervals.
	 *
	 * If you just want to "defer" task, that is to perform it right after currently
	 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
	 * better choice will be the {@link asap} scheduler.
	 *
	 * @example <caption>Use async scheduler to delay task</caption>
	 * const task = () => console.log('it works!');
	 *
	 * Rx.Scheduler.async.schedule(task, 2000);
	 *
	 * // After 2 seconds logs:
	 * // "it works!"
	 *
	 *
	 * @example <caption>Use async scheduler to repeat task in intervals</caption>
	 * function task(state) {
	 *   console.log(state);
	 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
	 *                                   // which we reschedule with new state and delay
	 * }
	 *
	 * Rx.Scheduler.async.schedule(task, 3000, 0);
	 *
	 * // Logs:
	 * // 0 after 3s
	 * // 1 after 4s
	 * // 2 after 5s
	 * // 3 after 6s
	 *
	 * @static true
	 * @name async
	 * @owner Scheduler
	 */
	exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	var ScalarObservable_1 = __webpack_require__(31);
	var EmptyObservable_1 = __webpack_require__(14);
	var isScheduler_1 = __webpack_require__(13);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ArrayObservable = (function (_super) {
	    __extends(ArrayObservable, _super);
	    function ArrayObservable(array, scheduler) {
	        _super.call(this);
	        this.array = array;
	        this.scheduler = scheduler;
	        if (!scheduler && array.length === 1) {
	            this._isScalar = true;
	            this.value = array[0];
	        }
	    }
	    ArrayObservable.create = function (array, scheduler) {
	        return new ArrayObservable(array, scheduler);
	    };
	    /**
	     * Creates an Observable that emits some values you specify as arguments,
	     * immediately one after the other, and then emits a complete notification.
	     *
	     * <span class="informal">Emits the arguments you provide, then completes.
	     * </span>
	     *
	     * <img src="./img/of.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that only
	     * emits the arguments given, and the complete notification thereafter. It can
	     * be used for composing with other Observables, such as with {@link concat}.
	     * By default, it uses a `null` IScheduler, which means the `next`
	     * notifications are sent synchronously, although with a different IScheduler
	     * it is possible to determine when those notifications will be delivered.
	     *
	     * @example <caption>Emit 10, 20, 30, then 'a', 'b', 'c', then start ticking every second.</caption>
	     * var numbers = Rx.Observable.of(10, 20, 30);
	     * var letters = Rx.Observable.of('a', 'b', 'c');
	     * var interval = Rx.Observable.interval(1000);
	     * var result = numbers.concat(letters).concat(interval);
	     * result.subscribe(x => console.log(x));
	     *
	     * @see {@link create}
	     * @see {@link empty}
	     * @see {@link never}
	     * @see {@link throw}
	     *
	     * @param {...T} values Arguments that represent `next` values to be emitted.
	     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
	     * the emissions of the `next` notifications.
	     * @return {Observable<T>} An Observable that emits each given input value.
	     * @static true
	     * @name of
	     * @owner Observable
	     */
	    ArrayObservable.of = function () {
	        var array = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            array[_i - 0] = arguments[_i];
	        }
	        var scheduler = array[array.length - 1];
	        if (isScheduler_1.isScheduler(scheduler)) {
	            array.pop();
	        }
	        else {
	            scheduler = null;
	        }
	        var len = array.length;
	        if (len > 1) {
	            return new ArrayObservable(array, scheduler);
	        }
	        else if (len === 1) {
	            return new ScalarObservable_1.ScalarObservable(array[0], scheduler);
	        }
	        else {
	            return new EmptyObservable_1.EmptyObservable(scheduler);
	        }
	    };
	    ArrayObservable.dispatch = function (state) {
	        var array = state.array, index = state.index, count = state.count, subscriber = state.subscriber;
	        if (index >= count) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(array[index]);
	        if (subscriber.closed) {
	            return;
	        }
	        state.index = index + 1;
	        this.schedule(state);
	    };
	    ArrayObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var array = this.array;
	        var count = array.length;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(ArrayObservable.dispatch, 0, {
	                array: array, index: index, count: count, subscriber: subscriber
	            });
	        }
	        else {
	            for (var i = 0; i < count && !subscriber.closed; i++) {
	                subscriber.next(array[i]);
	            }
	            subscriber.complete();
	        }
	    };
	    return ArrayObservable;
	}(Observable_1.Observable));
	exports.ArrayObservable = ArrayObservable;


/***/ },
/* 12 */
/***/ function(module, exports) {

	"use strict";
	exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });


/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";
	function isScheduler(value) {
	    return value && typeof value.schedule === 'function';
	}
	exports.isScheduler = isScheduler;


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var EmptyObservable = (function (_super) {
	    __extends(EmptyObservable, _super);
	    function EmptyObservable(scheduler) {
	        _super.call(this);
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable that emits no items to the Observer and immediately
	     * emits a complete notification.
	     *
	     * <span class="informal">Just emits 'complete', and nothing else.
	     * </span>
	     *
	     * <img src="./img/empty.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that only
	     * emits the complete notification. It can be used for composing with other
	     * Observables, such as in a {@link mergeMap}.
	     *
	     * @example <caption>Emit the number 7, then complete.</caption>
	     * var result = Rx.Observable.empty().startWith(7);
	     * result.subscribe(x => console.log(x));
	     *
	     * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
	     * var interval = Rx.Observable.interval(1000);
	     * var result = interval.mergeMap(x =>
	     *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
	     * );
	     * result.subscribe(x => console.log(x));
	     *
	     * // Results in the following to the console:
	     * // x is equal to the count on the interval eg(0,1,2,3,...)
	     * // x will occur every 1000ms
	     * // if x % 2 is equal to 1 print abc
	     * // if x % 2 is not equal to 1 nothing will be output
	     *
	     * @see {@link create}
	     * @see {@link never}
	     * @see {@link of}
	     * @see {@link throw}
	     *
	     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
	     * the emission of the complete notification.
	     * @return {Observable} An "empty" Observable: emits only the complete
	     * notification.
	     * @static true
	     * @name empty
	     * @owner Observable
	     */
	    EmptyObservable.create = function (scheduler) {
	        return new EmptyObservable(scheduler);
	    };
	    EmptyObservable.dispatch = function (arg) {
	        var subscriber = arg.subscriber;
	        subscriber.complete();
	    };
	    EmptyObservable.prototype._subscribe = function (subscriber) {
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(EmptyObservable.dispatch, 0, { subscriber: subscriber });
	        }
	        else {
	            subscriber.complete();
	        }
	    };
	    return EmptyObservable;
	}(Observable_1.Observable));
	exports.EmptyObservable = EmptyObservable;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ConnectableObservable_1 = __webpack_require__(41);
	/* tslint:enable:max-line-length */
	/**
	 * Returns an Observable that emits the results of invoking a specified selector on items
	 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
	 *
	 * <img src="./img/multicast.png" width="100%">
	 *
	 * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through
	 * which the source sequence's elements will be multicast to the selector function
	 * or Subject to push source elements into.
	 * @param {Function} [selector] - Optional selector function that can use the multicasted source stream
	 * as many times as needed, without causing multiple subscriptions to the source stream.
	 * Subscribers to the given source will receive all notifications of the source from the
	 * time of the subscription forward.
	 * @return {Observable} An Observable that emits the results of invoking the selector
	 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
	 * the underlying stream.
	 * @method multicast
	 * @owner Observable
	 */
	function multicast(subjectOrSubjectFactory, selector) {
	    var subjectFactory;
	    if (typeof subjectOrSubjectFactory === 'function') {
	        subjectFactory = subjectOrSubjectFactory;
	    }
	    else {
	        subjectFactory = function subjectFactory() {
	            return subjectOrSubjectFactory;
	        };
	    }
	    if (typeof selector === 'function') {
	        return this.lift(new MulticastOperator(subjectFactory, selector));
	    }
	    var connectable = Object.create(this, ConnectableObservable_1.connectableObservableDescriptor);
	    connectable.source = this;
	    connectable.subjectFactory = subjectFactory;
	    return connectable;
	}
	exports.multicast = multicast;
	var MulticastOperator = (function () {
	    function MulticastOperator(subjectFactory, selector) {
	        this.subjectFactory = subjectFactory;
	        this.selector = selector;
	    }
	    MulticastOperator.prototype.call = function (subscriber, source) {
	        var selector = this.selector;
	        var subject = this.subjectFactory();
	        var subscription = selector(subject).subscribe(subscriber);
	        subscription.add(source.subscribe(subject));
	        return subscription;
	    };
	    return MulticastOperator;
	}());
	exports.MulticastOperator = MulticastOperator;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	/**
	 * Represents a push-based event or value that an {@link Observable} can emit.
	 * This class is particularly useful for operators that manage notifications,
	 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
	 * others. Besides wrapping the actual delivered value, it also annotates it
	 * with metadata of, for instance, what type of push message it is (`next`,
	 * `error`, or `complete`).
	 *
	 * @see {@link materialize}
	 * @see {@link dematerialize}
	 * @see {@link observeOn}
	 *
	 * @class Notification<T>
	 */
	var Notification = (function () {
	    function Notification(kind, value, error) {
	        this.kind = kind;
	        this.value = value;
	        this.error = error;
	        this.hasValue = kind === 'N';
	    }
	    /**
	     * Delivers to the given `observer` the value wrapped by this Notification.
	     * @param {Observer} observer
	     * @return
	     */
	    Notification.prototype.observe = function (observer) {
	        switch (this.kind) {
	            case 'N':
	                return observer.next && observer.next(this.value);
	            case 'E':
	                return observer.error && observer.error(this.error);
	            case 'C':
	                return observer.complete && observer.complete();
	        }
	    };
	    /**
	     * Given some {@link Observer} callbacks, deliver the value represented by the
	     * current Notification to the correctly corresponding callback.
	     * @param {function(value: T): void} next An Observer `next` callback.
	     * @param {function(err: any): void} [error] An Observer `error` callback.
	     * @param {function(): void} [complete] An Observer `complete` callback.
	     * @return {any}
	     */
	    Notification.prototype.do = function (next, error, complete) {
	        var kind = this.kind;
	        switch (kind) {
	            case 'N':
	                return next && next(this.value);
	            case 'E':
	                return error && error(this.error);
	            case 'C':
	                return complete && complete();
	        }
	    };
	    /**
	     * Takes an Observer or its individual callback functions, and calls `observe`
	     * or `do` methods accordingly.
	     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
	     * the `next` callback.
	     * @param {function(err: any): void} [error] An Observer `error` callback.
	     * @param {function(): void} [complete] An Observer `complete` callback.
	     * @return {any}
	     */
	    Notification.prototype.accept = function (nextOrObserver, error, complete) {
	        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
	            return this.observe(nextOrObserver);
	        }
	        else {
	            return this.do(nextOrObserver, error, complete);
	        }
	    };
	    /**
	     * Returns a simple Observable that just delivers the notification represented
	     * by this Notification instance.
	     * @return {any}
	     */
	    Notification.prototype.toObservable = function () {
	        var kind = this.kind;
	        switch (kind) {
	            case 'N':
	                return Observable_1.Observable.of(this.value);
	            case 'E':
	                return Observable_1.Observable.throw(this.error);
	            case 'C':
	                return Observable_1.Observable.empty();
	        }
	        throw new Error('unexpected notification kind value');
	    };
	    /**
	     * A shortcut to create a Notification instance of the type `next` from a
	     * given value.
	     * @param {T} value The `next` value.
	     * @return {Notification<T>} The "next" Notification representing the
	     * argument.
	     */
	    Notification.createNext = function (value) {
	        if (typeof value !== 'undefined') {
	            return new Notification('N', value);
	        }
	        return this.undefinedValueNotification;
	    };
	    /**
	     * A shortcut to create a Notification instance of the type `error` from a
	     * given error.
	     * @param {any} [err] The `error` error.
	     * @return {Notification<T>} The "error" Notification representing the
	     * argument.
	     */
	    Notification.createError = function (err) {
	        return new Notification('E', undefined, err);
	    };
	    /**
	     * A shortcut to create a Notification instance of the type `complete`.
	     * @return {Notification<any>} The valueless "complete" Notification.
	     */
	    Notification.createComplete = function () {
	        return this.completeNotification;
	    };
	    Notification.completeNotification = new Notification('C');
	    Notification.undefinedValueNotification = new Notification('N', undefined);
	    return Notification;
	}());
	exports.Notification = Notification;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1 = __webpack_require__(8);
	var Action_1 = __webpack_require__(325);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AsyncAction = (function (_super) {
	    __extends(AsyncAction, _super);
	    function AsyncAction(scheduler, work) {
	        _super.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	        this.pending = false;
	    }
	    AsyncAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (this.closed) {
	            return this;
	        }
	        // Always replace the current state with the new state.
	        this.state = state;
	        // Set the pending flag indicating that this action has been scheduled, or
	        // has recursively rescheduled itself.
	        this.pending = true;
	        var id = this.id;
	        var scheduler = this.scheduler;
	        //
	        // Important implementation note:
	        //
	        // Actions only execute once by default, unless rescheduled from within the
	        // scheduled callback. This allows us to implement single and repeat
	        // actions via the same code path, without adding API surface area, as well
	        // as mimic traditional recursion but across asynchronous boundaries.
	        //
	        // However, JS runtimes and timers distinguish between intervals achieved by
	        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
	        // serial `setTimeout` calls can be individually delayed, which delays
	        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
	        // guarantee the interval callback will be invoked more precisely to the
	        // interval period, regardless of load.
	        //
	        // Therefore, we use `setInterval` to schedule single and repeat actions.
	        // If the action reschedules itself with the same delay, the interval is not
	        // canceled. If the action doesn't reschedule, or reschedules with a
	        // different delay, the interval will be canceled after scheduled callback
	        // execution.
	        //
	        if (id != null) {
	            this.id = this.recycleAsyncId(scheduler, id, delay);
	        }
	        this.delay = delay;
	        // If this action has already an async Id, don't request a new one.
	        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
	        return this;
	    };
	    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        return root_1.root.setInterval(scheduler.flush.bind(scheduler, this), delay);
	    };
	    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If this action is rescheduled with the same delay time, don't clear the interval id.
	        if (delay !== null && this.delay === delay) {
	            return id;
	        }
	        // Otherwise, if the action's delay time is different from the current delay,
	        // clear the interval id
	        return root_1.root.clearInterval(id) && undefined || undefined;
	    };
	    /**
	     * Immediately executes this action and the `work` it contains.
	     * @return {any}
	     */
	    AsyncAction.prototype.execute = function (state, delay) {
	        if (this.closed) {
	            return new Error('executing a cancelled action');
	        }
	        this.pending = false;
	        var error = this._execute(state, delay);
	        if (error) {
	            return error;
	        }
	        else if (this.pending === false && this.id != null) {
	            // Dequeue if the action didn't reschedule itself. Don't call
	            // unsubscribe(), because the action could reschedule later.
	            // For example:
	            // ```
	            // scheduler.schedule(function doWork(counter) {
	            //   /* ... I'm a busy worker bee ... */
	            //   var originalAction = this;
	            //   /* wait 100ms before rescheduling the action */
	            //   setTimeout(function () {
	            //     originalAction.schedule(counter + 1);
	            //   }, 100);
	            // }, 1000);
	            // ```
	            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
	        }
	    };
	    AsyncAction.prototype._execute = function (state, delay) {
	        var errored = false;
	        var errorValue = undefined;
	        try {
	            this.work(state);
	        }
	        catch (e) {
	            errored = true;
	            errorValue = !!e && e || new Error(e);
	        }
	        if (errored) {
	            this.unsubscribe();
	            return errorValue;
	        }
	    };
	    AsyncAction.prototype._unsubscribe = function () {
	        var id = this.id;
	        var scheduler = this.scheduler;
	        var actions = scheduler.actions;
	        var index = actions.indexOf(this);
	        this.work = null;
	        this.delay = null;
	        this.state = null;
	        this.pending = false;
	        this.scheduler = null;
	        if (index !== -1) {
	            actions.splice(index, 1);
	        }
	        if (id != null) {
	            this.id = this.recycleAsyncId(scheduler, id, null);
	        }
	    };
	    return AsyncAction;
	}(Action_1.Action));
	exports.AsyncAction = AsyncAction;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Scheduler_1 = __webpack_require__(72);
	var AsyncScheduler = (function (_super) {
	    __extends(AsyncScheduler, _super);
	    function AsyncScheduler() {
	        _super.apply(this, arguments);
	        this.actions = [];
	        /**
	         * A flag to indicate whether the Scheduler is currently executing a batch of
	         * queued actions.
	         * @type {boolean}
	         */
	        this.active = false;
	        /**
	         * An internal ID used to track the latest asynchronous task such as those
	         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
	         * others.
	         * @type {any}
	         */
	        this.scheduled = undefined;
	    }
	    AsyncScheduler.prototype.flush = function (action) {
	        var actions = this.actions;
	        if (this.active) {
	            actions.push(action);
	            return;
	        }
	        var error;
	        this.active = true;
	        do {
	            if (error = action.execute(action.state, action.delay)) {
	                break;
	            }
	        } while (action = actions.shift()); // exhaust the scheduler queue
	        this.active = false;
	        if (error) {
	            while (action = actions.shift()) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AsyncScheduler;
	}(Scheduler_1.Scheduler));
	exports.AsyncScheduler = AsyncScheduler;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(8);
	function symbolIteratorPonyfill(root) {
	    var Symbol = root.Symbol;
	    if (typeof Symbol === 'function') {
	        if (!Symbol.iterator) {
	            Symbol.iterator = Symbol('iterator polyfill');
	        }
	        return Symbol.iterator;
	    }
	    else {
	        // [for Mozilla Gecko 27-35:](https://mzl.la/2ewE1zC)
	        var Set_1 = root.Set;
	        if (Set_1 && typeof new Set_1()['@@iterator'] === 'function') {
	            return '@@iterator';
	        }
	        var Map_1 = root.Map;
	        // required for compatability with es6-shim
	        if (Map_1) {
	            var keys = Object.getOwnPropertyNames(Map_1.prototype);
	            for (var i = 0; i < keys.length; ++i) {
	                var key = keys[i];
	                // according to spec, Map.prototype[@@iterator] and Map.orototype.entries must be equal.
	                if (key !== 'entries' && key !== 'size' && Map_1.prototype[key] === Map_1.prototype['entries']) {
	                    return key;
	                }
	            }
	        }
	        return '@@iterator';
	    }
	}
	exports.symbolIteratorPonyfill = symbolIteratorPonyfill;
	exports.iterator = symbolIteratorPonyfill(root_1.root);
	/**
	 * @deprecated use iterator instead
	 */
	exports.$$iterator = exports.iterator;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var Subscription_1 = __webpack_require__(5);
	/**
	 * @class AsyncSubject<T>
	 */
	var AsyncSubject = (function (_super) {
	    __extends(AsyncSubject, _super);
	    function AsyncSubject() {
	        _super.apply(this, arguments);
	        this.value = null;
	        this.hasNext = false;
	        this.hasCompleted = false;
	    }
	    AsyncSubject.prototype._subscribe = function (subscriber) {
	        if (this.hasError) {
	            subscriber.error(this.thrownError);
	            return Subscription_1.Subscription.EMPTY;
	        }
	        else if (this.hasCompleted && this.hasNext) {
	            subscriber.next(this.value);
	            subscriber.complete();
	            return Subscription_1.Subscription.EMPTY;
	        }
	        return _super.prototype._subscribe.call(this, subscriber);
	    };
	    AsyncSubject.prototype.next = function (value) {
	        if (!this.hasCompleted) {
	            this.value = value;
	            this.hasNext = true;
	        }
	    };
	    AsyncSubject.prototype.error = function (error) {
	        if (!this.hasCompleted) {
	            _super.prototype.error.call(this, error);
	        }
	    };
	    AsyncSubject.prototype.complete = function () {
	        this.hasCompleted = true;
	        if (this.hasNext) {
	            _super.prototype.next.call(this, this.value);
	        }
	        _super.prototype.complete.call(this);
	    };
	    return AsyncSubject;
	}(Subject_1.Subject));
	exports.AsyncSubject = AsyncSubject;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/**
	 * Converts a higher-order Observable into a first-order Observable which
	 * concurrently delivers all values that are emitted on the inner Observables.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables.</span>
	 *
	 * <img src="./img/mergeAll.png" width="100%">
	 *
	 * `mergeAll` subscribes to an Observable that emits Observables, also known as
	 * a higher-order Observable. Each time it observes one of these emitted inner
	 * Observables, it subscribes to that and delivers all the values from the
	 * inner Observable on the output Observable. The output Observable only
	 * completes once all inner Observables have completed. Any error delivered by
	 * a inner Observable will be immediately emitted on the output Observable.
	 *
	 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
	 * var firstOrder = higherOrder.mergeAll();
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
	 * var firstOrder = higherOrder.mergeAll(2);
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * @see {@link combineAll}
	 * @see {@link concatAll}
	 * @see {@link exhaust}
	 * @see {@link merge}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 * @see {@link switch}
	 * @see {@link zipAll}
	 *
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
	 * Observables being subscribed to concurrently.
	 * @return {Observable} An Observable that emits values coming from all the
	 * inner Observables emitted by the source Observable.
	 * @method mergeAll
	 * @owner Observable
	 */
	function mergeAll(concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    return this.lift(new MergeAllOperator(concurrent));
	}
	exports.mergeAll = mergeAll;
	var MergeAllOperator = (function () {
	    function MergeAllOperator(concurrent) {
	        this.concurrent = concurrent;
	    }
	    MergeAllOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new MergeAllSubscriber(observer, this.concurrent));
	    };
	    return MergeAllOperator;
	}());
	exports.MergeAllOperator = MergeAllOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeAllSubscriber = (function (_super) {
	    __extends(MergeAllSubscriber, _super);
	    function MergeAllSubscriber(destination, concurrent) {
	        _super.call(this, destination);
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	    }
	    MergeAllSubscriber.prototype._next = function (observable) {
	        if (this.active < this.concurrent) {
	            this.active++;
	            this.add(subscribeToResult_1.subscribeToResult(this, observable));
	        }
	        else {
	            this.buffer.push(observable);
	        }
	    };
	    MergeAllSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	    MergeAllSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeAllSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.MergeAllSubscriber = MergeAllSubscriber;


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(8);
	function getSymbolObservable(context) {
	    var $$observable;
	    var Symbol = context.Symbol;
	    if (typeof Symbol === 'function') {
	        if (Symbol.observable) {
	            $$observable = Symbol.observable;
	        }
	        else {
	            $$observable = Symbol('observable');
	            Symbol.observable = $$observable;
	        }
	    }
	    else {
	        $$observable = '@@observable';
	    }
	    return $$observable;
	}
	exports.getSymbolObservable = getSymbolObservable;
	exports.observable = getSymbolObservable(root_1.root);
	/**
	 * @deprecated use observable instead
	 */
	exports.$$observable = exports.observable;


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(8);
	var Symbol = root_1.root.Symbol;
	exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function') ?
	    Symbol.for('rxSubscriber') : '@@rxSubscriber';
	/**
	 * @deprecated use rxSubscriber instead
	 */
	exports.$$rxSubscriber = exports.rxSubscriber;


/***/ },
/* 24 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an element was queried at a certain index of an
	 * Observable, but no such index or position exists in that sequence.
	 *
	 * @see {@link elementAt}
	 * @see {@link take}
	 * @see {@link takeLast}
	 *
	 * @class ArgumentOutOfRangeError
	 */
	var ArgumentOutOfRangeError = (function (_super) {
	    __extends(ArgumentOutOfRangeError, _super);
	    function ArgumentOutOfRangeError() {
	        var err = _super.call(this, 'argument out of range');
	        this.name = err.name = 'ArgumentOutOfRangeError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return ArgumentOutOfRangeError;
	}(Error));
	exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;


/***/ },
/* 25 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an Observable or a sequence was queried but has no
	 * elements.
	 *
	 * @see {@link first}
	 * @see {@link last}
	 * @see {@link single}
	 *
	 * @class EmptyError
	 */
	var EmptyError = (function (_super) {
	    __extends(EmptyError, _super);
	    function EmptyError() {
	        var err = _super.call(this, 'no elements in sequence');
	        this.name = err.name = 'EmptyError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return EmptyError;
	}(Error));
	exports.EmptyError = EmptyError;


/***/ },
/* 26 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when an action is invalid because the object has been
	 * unsubscribed.
	 *
	 * @see {@link Subject}
	 * @see {@link BehaviorSubject}
	 *
	 * @class ObjectUnsubscribedError
	 */
	var ObjectUnsubscribedError = (function (_super) {
	    __extends(ObjectUnsubscribedError, _super);
	    function ObjectUnsubscribedError() {
	        var err = _super.call(this, 'object unsubscribed');
	        this.name = err.name = 'ObjectUnsubscribedError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return ObjectUnsubscribedError;
	}(Error));
	exports.ObjectUnsubscribedError = ObjectUnsubscribedError;


/***/ },
/* 27 */
/***/ function(module, exports) {

	"use strict";
	function isDate(value) {
	    return value instanceof Date && !isNaN(+value);
	}
	exports.isDate = isDate;


/***/ },
/* 28 */
/***/ function(module, exports) {

	"use strict";
	function isFunction(x) {
	    return typeof x === 'function';
	}
	exports.isFunction = isFunction;


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isArray_1 = __webpack_require__(12);
	function isNumeric(val) {
	    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
	    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
	    // subtraction forces infinities to NaN
	    // adding 1 corrects loss of precision from parseFloat (#15100)
	    return !isArray_1.isArray(val) && (val - parseFloat(val) + 1) >= 0;
	}
	exports.isNumeric = isNumeric;
	;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var queue_1 = __webpack_require__(57);
	var Subscription_1 = __webpack_require__(5);
	var observeOn_1 = __webpack_require__(35);
	var ObjectUnsubscribedError_1 = __webpack_require__(26);
	var SubjectSubscription_1 = __webpack_require__(40);
	/**
	 * @class ReplaySubject<T>
	 */
	var ReplaySubject = (function (_super) {
	    __extends(ReplaySubject, _super);
	    function ReplaySubject(bufferSize, windowTime, scheduler) {
	        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
	        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
	        _super.call(this);
	        this.scheduler = scheduler;
	        this._events = [];
	        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
	        this._windowTime = windowTime < 1 ? 1 : windowTime;
	    }
	    ReplaySubject.prototype.next = function (value) {
	        var now = this._getNow();
	        this._events.push(new ReplayEvent(now, value));
	        this._trimBufferThenGetEvents();
	        _super.prototype.next.call(this, value);
	    };
	    ReplaySubject.prototype._subscribe = function (subscriber) {
	        var _events = this._trimBufferThenGetEvents();
	        var scheduler = this.scheduler;
	        var subscription;
	        if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        else if (this.hasError) {
	            subscription = Subscription_1.Subscription.EMPTY;
	        }
	        else if (this.isStopped) {
	            subscription = Subscription_1.Subscription.EMPTY;
	        }
	        else {
	            this.observers.push(subscriber);
	            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
	        }
	        if (scheduler) {
	            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
	        }
	        var len = _events.length;
	        for (var i = 0; i < len && !subscriber.closed; i++) {
	            subscriber.next(_events[i].value);
	        }
	        if (this.hasError) {
	            subscriber.error(this.thrownError);
	        }
	        else if (this.isStopped) {
	            subscriber.complete();
	        }
	        return subscription;
	    };
	    ReplaySubject.prototype._getNow = function () {
	        return (this.scheduler || queue_1.queue).now();
	    };
	    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
	        var now = this._getNow();
	        var _bufferSize = this._bufferSize;
	        var _windowTime = this._windowTime;
	        var _events = this._events;
	        var eventsCount = _events.length;
	        var spliceCount = 0;
	        // Trim events that fall out of the time window.
	        // Start at the front of the list. Break early once
	        // we encounter an event that falls within the window.
	        while (spliceCount < eventsCount) {
	            if ((now - _events[spliceCount].time) < _windowTime) {
	                break;
	            }
	            spliceCount++;
	        }
	        if (eventsCount > _bufferSize) {
	            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
	        }
	        if (spliceCount > 0) {
	            _events.splice(0, spliceCount);
	        }
	        return _events;
	    };
	    return ReplaySubject;
	}(Subject_1.Subject));
	exports.ReplaySubject = ReplaySubject;
	var ReplayEvent = (function () {
	    function ReplayEvent(time, value) {
	        this.time = time;
	        this.value = value;
	    }
	    return ReplayEvent;
	}());


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ScalarObservable = (function (_super) {
	    __extends(ScalarObservable, _super);
	    function ScalarObservable(value, scheduler) {
	        _super.call(this);
	        this.value = value;
	        this.scheduler = scheduler;
	        this._isScalar = true;
	        if (scheduler) {
	            this._isScalar = false;
	        }
	    }
	    ScalarObservable.create = function (value, scheduler) {
	        return new ScalarObservable(value, scheduler);
	    };
	    ScalarObservable.dispatch = function (state) {
	        var done = state.done, value = state.value, subscriber = state.subscriber;
	        if (done) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(value);
	        if (subscriber.closed) {
	            return;
	        }
	        state.done = true;
	        this.schedule(state);
	    };
	    ScalarObservable.prototype._subscribe = function (subscriber) {
	        var value = this.value;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(ScalarObservable.dispatch, 0, {
	                done: false, value: value, subscriber: subscriber
	            });
	        }
	        else {
	            subscriber.next(value);
	            if (!subscriber.closed) {
	                subscriber.complete();
	            }
	        }
	    };
	    return ScalarObservable;
	}(Observable_1.Observable));
	exports.ScalarObservable = ScalarObservable;


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ArrayObservable_1 = __webpack_require__(11);
	var isArray_1 = __webpack_require__(12);
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	var none = {};
	/* tslint:enable:max-line-length */
	/**
	 * Combines multiple Observables to create an Observable whose values are
	 * calculated from the latest values of each of its input Observables.
	 *
	 * <span class="informal">Whenever any input Observable emits a value, it
	 * computes a formula using the latest values from all the inputs, then emits
	 * the output of that formula.</span>
	 *
	 * <img src="./img/combineLatest.png" width="100%">
	 *
	 * `combineLatest` combines the values from this Observable with values from
	 * Observables passed as arguments. This is done by subscribing to each
	 * Observable, in order, and collecting an array of each of the most recent
	 * values any time any of the input Observables emits, then either taking that
	 * array and passing it as arguments to an optional `project` function and
	 * emitting the return value of that, or just emitting the array of recent
	 * values directly if there is no `project` function.
	 *
	 * @example <caption>Dynamically calculate the Body-Mass Index from an Observable of weight and one for height</caption>
	 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
	 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
	 * var bmi = weight.combineLatest(height, (w, h) => w / (h * h));
	 * bmi.subscribe(x => console.log('BMI is ' + x));
	 *
	 * // With output to console:
	 * // BMI is 24.212293388429753
	 * // BMI is 23.93948099205209
	 * // BMI is 23.671253629592222
	 *
	 * @see {@link combineAll}
	 * @see {@link merge}
	 * @see {@link withLatestFrom}
	 *
	 * @param {ObservableInput} other An input Observable to combine with the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {function} [project] An optional function to project the values from
	 * the combined latest values into a new value on the output Observable.
	 * @return {Observable} An Observable of projected values from the most recent
	 * values from each input Observable, or an array of the most recent values from
	 * each input Observable.
	 * @method combineLatest
	 * @owner Observable
	 */
	function combineLatest() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var project = null;
	    if (typeof observables[observables.length - 1] === 'function') {
	        project = observables.pop();
	    }
	    // if the first and only other argument besides the resultSelector is an array
	    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
	    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
	        observables = observables[0].slice();
	    }
	    observables.unshift(this);
	    return this.lift.call(new ArrayObservable_1.ArrayObservable(observables), new CombineLatestOperator(project));
	}
	exports.combineLatest = combineLatest;
	var CombineLatestOperator = (function () {
	    function CombineLatestOperator(project) {
	        this.project = project;
	    }
	    CombineLatestOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new CombineLatestSubscriber(subscriber, this.project));
	    };
	    return CombineLatestOperator;
	}());
	exports.CombineLatestOperator = CombineLatestOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var CombineLatestSubscriber = (function (_super) {
	    __extends(CombineLatestSubscriber, _super);
	    function CombineLatestSubscriber(destination, project) {
	        _super.call(this, destination);
	        this.project = project;
	        this.active = 0;
	        this.values = [];
	        this.observables = [];
	    }
	    CombineLatestSubscriber.prototype._next = function (observable) {
	        this.values.push(none);
	        this.observables.push(observable);
	    };
	    CombineLatestSubscriber.prototype._complete = function () {
	        var observables = this.observables;
	        var len = observables.length;
	        if (len === 0) {
	            this.destination.complete();
	        }
	        else {
	            this.active = len;
	            this.toRespond = len;
	            for (var i = 0; i < len; i++) {
	                var observable = observables[i];
	                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
	            }
	        }
	    };
	    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
	        if ((this.active -= 1) === 0) {
	            this.destination.complete();
	        }
	    };
	    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var values = this.values;
	        var oldVal = values[outerIndex];
	        var toRespond = !this.toRespond
	            ? 0
	            : oldVal === none ? --this.toRespond : this.toRespond;
	        values[outerIndex] = innerValue;
	        if (toRespond === 0) {
	            if (this.project) {
	                this._tryProject(values);
	            }
	            else {
	                this.destination.next(values.slice());
	            }
	        }
	    };
	    CombineLatestSubscriber.prototype._tryProject = function (values) {
	        var result;
	        try {
	            result = this.project.apply(this, values);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return CombineLatestSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.CombineLatestSubscriber = CombineLatestSubscriber;


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var isScheduler_1 = __webpack_require__(13);
	var ArrayObservable_1 = __webpack_require__(11);
	var mergeAll_1 = __webpack_require__(21);
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which sequentially emits all values from every
	 * given input Observable after the current Observable.
	 *
	 * <span class="informal">Concatenates multiple Observables together by
	 * sequentially emitting their values, one Observable after the other.</span>
	 *
	 * <img src="./img/concat.png" width="100%">
	 *
	 * Joins this Observable with multiple other Observables by subscribing to them
	 * one at a time, starting with the source, and merging their results into the
	 * output Observable. Will wait for each Observable to complete before moving
	 * on to the next.
	 *
	 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
	 * var timer = Rx.Observable.interval(1000).take(4);
	 * var sequence = Rx.Observable.range(1, 10);
	 * var result = timer.concat(sequence);
	 * result.subscribe(x => console.log(x));
	 *
	 * // results in:
	 * // 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
	 *
	 * @example <caption>Concatenate 3 Observables</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var result = timer1.concat(timer2, timer3);
	 * result.subscribe(x => console.log(x));
	 *
	 * // results in the following:
	 * // (Prints to console sequentially)
	 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
	 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
	 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
	 *
	 * @see {@link concatAll}
	 * @see {@link concatMap}
	 * @see {@link concatMapTo}
	 *
	 * @param {ObservableInput} other An input Observable to concatenate after the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
	 * Observable subscription on.
	 * @return {Observable} All values of each passed Observable merged into a
	 * single Observable, in order, in serial fashion.
	 * @method concat
	 * @owner Observable
	 */
	function concat() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    return this.lift.call(concatStatic.apply(void 0, [this].concat(observables)));
	}
	exports.concat = concat;
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which sequentially emits all values from given
	 * Observable and then moves on to the next.
	 *
	 * <span class="informal">Concatenates multiple Observables together by
	 * sequentially emitting their values, one Observable after the other.</span>
	 *
	 * <img src="./img/concat.png" width="100%">
	 *
	 * `concat` joins multiple Observables together, by subscribing to them one at a time and
	 * merging their results into the output Observable. You can pass either an array of
	 * Observables, or put them directly as arguments. Passing an empty array will result
	 * in Observable that completes immediately.
	 *
	 * `concat` will subscribe to first input Observable and emit all its values, without
	 * changing or affecting them in any way. When that Observable completes, it will
	 * subscribe to then next Observable passed and, again, emit its values. This will be
	 * repeated, until the operator runs out of Observables. When last input Observable completes,
	 * `concat` will complete as well. At any given moment only one Observable passed to operator
	 * emits values. If you would like to emit values from passed Observables concurrently, check out
	 * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,
	 * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.
	 *
	 * Note that if some input Observable never completes, `concat` will also never complete
	 * and Observables following the one that did not complete will never be subscribed. On the other
	 * hand, if some Observable simply completes immediately after it is subscribed, it will be
	 * invisible for `concat`, which will just move on to the next Observable.
	 *
	 * If any Observable in chain errors, instead of passing control to the next Observable,
	 * `concat` will error immediately as well. Observables that would be subscribed after
	 * the one that emitted error, never will.
	 *
	 * If you pass to `concat` the same Observable many times, its stream of values
	 * will be "replayed" on every subscription, which means you can repeat given Observable
	 * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,
	 * you can always use {@link repeat}.
	 *
	 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
	 * var timer = Rx.Observable.interval(1000).take(4);
	 * var sequence = Rx.Observable.range(1, 10);
	 * var result = Rx.Observable.concat(timer, sequence);
	 * result.subscribe(x => console.log(x));
	 *
	 * // results in:
	 * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
	 *
	 *
	 * @example <caption>Concatenate an array of 3 Observables</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed
	 * result.subscribe(x => console.log(x));
	 *
	 * // results in the following:
	 * // (Prints to console sequentially)
	 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
	 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
	 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
	 *
	 *
	 * @example <caption>Concatenate the same Observable to repeat it</caption>
	 * const timer = Rx.Observable.interval(1000).take(2);
	 *
	 * Rx.Observable.concat(timer, timer) // concating the same Observable!
	 * .subscribe(
	 *   value => console.log(value),
	 *   err => {},
	 *   () => console.log('...and it is done!')
	 * );
	 *
	 * // Logs:
	 * // 0 after 1s
	 * // 1 after 2s
	 * // 0 after 3s
	 * // 1 after 4s
	 * // "...and it is done!" also after 4s
	 *
	 * @see {@link concatAll}
	 * @see {@link concatMap}
	 * @see {@link concatMapTo}
	 *
	 * @param {ObservableInput} input1 An input Observable to concatenate with others.
	 * @param {ObservableInput} input2 An input Observable to concatenate with others.
	 * More than one input Observables may be given as argument.
	 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
	 * Observable subscription on.
	 * @return {Observable} All values of each passed Observable merged into a
	 * single Observable, in order, in serial fashion.
	 * @static true
	 * @name concat
	 * @owner Observable
	 */
	function concatStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var scheduler = null;
	    var args = observables;
	    if (isScheduler_1.isScheduler(args[observables.length - 1])) {
	        scheduler = args.pop();
	    }
	    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
	        return observables[0];
	    }
	    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(1));
	}
	exports.concatStatic = concatStatic;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/**
	 * Applies a given `project` function to each value emitted by the source
	 * Observable, and emits the resulting values as an Observable.
	 *
	 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
	 * it passes each source value through a transformation function to get
	 * corresponding output values.</span>
	 *
	 * <img src="./img/map.png" width="100%">
	 *
	 * Similar to the well known `Array.prototype.map` function, this operator
	 * applies a projection to each value and emits that projection in the output
	 * Observable.
	 *
	 * @example <caption>Map every every click to the clientX position of that click</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var positions = clicks.map(ev => ev.clientX);
	 * positions.subscribe(x => console.log(x));
	 *
	 * @see {@link mapTo}
	 * @see {@link pluck}
	 *
	 * @param {function(value: T, index: number): R} project The function to apply
	 * to each `value` emitted by the source Observable. The `index` parameter is
	 * the number `i` for the i-th emission that has happened since the
	 * subscription, starting from the number `0`.
	 * @param {any} [thisArg] An optional argument to define what `this` is in the
	 * `project` function.
	 * @return {Observable<R>} An Observable that emits the values from the source
	 * Observable transformed by the given `project` function.
	 * @method map
	 * @owner Observable
	 */
	function map(project, thisArg) {
	    if (typeof project !== 'function') {
	        throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
	    }
	    return this.lift(new MapOperator(project, thisArg));
	}
	exports.map = map;
	var MapOperator = (function () {
	    function MapOperator(project, thisArg) {
	        this.project = project;
	        this.thisArg = thisArg;
	    }
	    MapOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
	    };
	    return MapOperator;
	}());
	exports.MapOperator = MapOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MapSubscriber = (function (_super) {
	    __extends(MapSubscriber, _super);
	    function MapSubscriber(destination, project, thisArg) {
	        _super.call(this, destination);
	        this.project = project;
	        this.count = 0;
	        this.thisArg = thisArg || this;
	    }
	    // NOTE: This looks unoptimized, but it's actually purposefully NOT
	    // using try/catch optimizations.
	    MapSubscriber.prototype._next = function (value) {
	        var result;
	        try {
	            result = this.project.call(this.thisArg, value, this.count++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return MapSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var Notification_1 = __webpack_require__(16);
	/**
	 * @see {@link Notification}
	 *
	 * @param scheduler
	 * @param delay
	 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
	 * @method observeOn
	 * @owner Observable
	 */
	function observeOn(scheduler, delay) {
	    if (delay === void 0) { delay = 0; }
	    return this.lift(new ObserveOnOperator(scheduler, delay));
	}
	exports.observeOn = observeOn;
	var ObserveOnOperator = (function () {
	    function ObserveOnOperator(scheduler, delay) {
	        if (delay === void 0) { delay = 0; }
	        this.scheduler = scheduler;
	        this.delay = delay;
	    }
	    ObserveOnOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
	    };
	    return ObserveOnOperator;
	}());
	exports.ObserveOnOperator = ObserveOnOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ObserveOnSubscriber = (function (_super) {
	    __extends(ObserveOnSubscriber, _super);
	    function ObserveOnSubscriber(destination, scheduler, delay) {
	        if (delay === void 0) { delay = 0; }
	        _super.call(this, destination);
	        this.scheduler = scheduler;
	        this.delay = delay;
	    }
	    ObserveOnSubscriber.dispatch = function (arg) {
	        var notification = arg.notification, destination = arg.destination;
	        notification.observe(destination);
	        this.unsubscribe();
	    };
	    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
	        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
	    };
	    ObserveOnSubscriber.prototype._next = function (value) {
	        this.scheduleMessage(Notification_1.Notification.createNext(value));
	    };
	    ObserveOnSubscriber.prototype._error = function (err) {
	        this.scheduleMessage(Notification_1.Notification.createError(err));
	    };
	    ObserveOnSubscriber.prototype._complete = function () {
	        this.scheduleMessage(Notification_1.Notification.createComplete());
	    };
	    return ObserveOnSubscriber;
	}(Subscriber_1.Subscriber));
	exports.ObserveOnSubscriber = ObserveOnSubscriber;
	var ObserveOnMessage = (function () {
	    function ObserveOnMessage(notification, destination) {
	        this.notification = notification;
	        this.destination = destination;
	    }
	    return ObserveOnMessage;
	}());
	exports.ObserveOnMessage = ObserveOnMessage;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/* tslint:enable:max-line-length */
	/**
	 * Applies an accumulator function over the source Observable, and returns the
	 * accumulated result when the source completes, given an optional seed value.
	 *
	 * <span class="informal">Combines together all values emitted on the source,
	 * using an accumulator function that knows how to join a new source value into
	 * the accumulation from the past.</span>
	 *
	 * <img src="./img/reduce.png" width="100%">
	 *
	 * Like
	 * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),
	 * `reduce` applies an `accumulator` function against an accumulation and each
	 * value of the source Observable (from the past) to reduce it to a single
	 * value, emitted on the output Observable. Note that `reduce` will only emit
	 * one value, only when the source Observable completes. It is equivalent to
	 * applying operator {@link scan} followed by operator {@link last}.
	 *
	 * Returns an Observable that applies a specified `accumulator` function to each
	 * item emitted by the source Observable. If a `seed` value is specified, then
	 * that value will be used as the initial value for the accumulator. If no seed
	 * value is specified, the first item of the source is used as the seed.
	 *
	 * @example <caption>Count the number of click events that happened in 5 seconds</caption>
	 * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')
	 *   .takeUntil(Rx.Observable.interval(5000));
	 * var ones = clicksInFiveSeconds.mapTo(1);
	 * var seed = 0;
	 * var count = ones.reduce((acc, one) => acc + one, seed);
	 * count.subscribe(x => console.log(x));
	 *
	 * @see {@link count}
	 * @see {@link expand}
	 * @see {@link mergeScan}
	 * @see {@link scan}
	 *
	 * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function
	 * called on each source value.
	 * @param {R} [seed] The initial accumulation value.
	 * @return {Observable<R>} An Observable that emits a single value that is the
	 * result of accumulating the values emitted by the source Observable.
	 * @method reduce
	 * @owner Observable
	 */
	function reduce(accumulator, seed) {
	    var hasSeed = false;
	    // providing a seed of `undefined` *should* be valid and trigger
	    // hasSeed! so don't use `seed !== undefined` checks!
	    // For this reason, we have to check it here at the original call site
	    // otherwise inside Operator/Subscriber we won't know if `undefined`
	    // means they didn't provide anything or if they literally provided `undefined`
	    if (arguments.length >= 2) {
	        hasSeed = true;
	    }
	    return this.lift(new ReduceOperator(accumulator, seed, hasSeed));
	}
	exports.reduce = reduce;
	var ReduceOperator = (function () {
	    function ReduceOperator(accumulator, seed, hasSeed) {
	        if (hasSeed === void 0) { hasSeed = false; }
	        this.accumulator = accumulator;
	        this.seed = seed;
	        this.hasSeed = hasSeed;
	    }
	    ReduceOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ReduceSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
	    };
	    return ReduceOperator;
	}());
	exports.ReduceOperator = ReduceOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ReduceSubscriber = (function (_super) {
	    __extends(ReduceSubscriber, _super);
	    function ReduceSubscriber(destination, accumulator, seed, hasSeed) {
	        _super.call(this, destination);
	        this.accumulator = accumulator;
	        this.hasSeed = hasSeed;
	        this.index = 0;
	        this.hasValue = false;
	        this.acc = seed;
	        if (!this.hasSeed) {
	            this.index++;
	        }
	    }
	    ReduceSubscriber.prototype._next = function (value) {
	        if (this.hasValue || (this.hasValue = this.hasSeed)) {
	            this._tryReduce(value);
	        }
	        else {
	            this.acc = value;
	            this.hasValue = true;
	        }
	    };
	    ReduceSubscriber.prototype._tryReduce = function (value) {
	        var result;
	        try {
	            result = this.accumulator(this.acc, value, this.index++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.acc = result;
	    };
	    ReduceSubscriber.prototype._complete = function () {
	        if (this.hasValue || this.hasSeed) {
	            this.destination.next(this.acc);
	        }
	        this.destination.complete();
	    };
	    return ReduceSubscriber;
	}(Subscriber_1.Subscriber));
	exports.ReduceSubscriber = ReduceSubscriber;


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ArrayObservable_1 = __webpack_require__(11);
	var isArray_1 = __webpack_require__(12);
	var Subscriber_1 = __webpack_require__(2);
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	var iterator_1 = __webpack_require__(19);
	/* tslint:enable:max-line-length */
	/**
	 * @param observables
	 * @return {Observable<R>}
	 * @method zip
	 * @owner Observable
	 */
	function zipProto() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    return this.lift.call(zipStatic.apply(void 0, [this].concat(observables)));
	}
	exports.zipProto = zipProto;
	/* tslint:enable:max-line-length */
	/**
	 * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
	 * of its input Observables.
	 *
	 * If the latest parameter is a function, this function is used to compute the created value from the input values.
	 * Otherwise, an array of the input values is returned.
	 *
	 * @example <caption>Combine age and name from different sources</caption>
	 *
	 * let age$ = Observable.of<number>(27, 25, 29);
	 * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
	 * let isDev$ = Observable.of<boolean>(true, true, false);
	 *
	 * Observable
	 *     .zip(age$,
	 *          name$,
	 *          isDev$,
	 *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
	 *     .subscribe(x => console.log(x));
	 *
	 * // outputs
	 * // { age: 27, name: 'Foo', isDev: true }
	 * // { age: 25, name: 'Bar', isDev: true }
	 * // { age: 29, name: 'Beer', isDev: false }
	 *
	 * @param observables
	 * @return {Observable<R>}
	 * @static true
	 * @name zip
	 * @owner Observable
	 */
	function zipStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var project = observables[observables.length - 1];
	    if (typeof project === 'function') {
	        observables.pop();
	    }
	    return new ArrayObservable_1.ArrayObservable(observables).lift(new ZipOperator(project));
	}
	exports.zipStatic = zipStatic;
	var ZipOperator = (function () {
	    function ZipOperator(project) {
	        this.project = project;
	    }
	    ZipOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ZipSubscriber(subscriber, this.project));
	    };
	    return ZipOperator;
	}());
	exports.ZipOperator = ZipOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ZipSubscriber = (function (_super) {
	    __extends(ZipSubscriber, _super);
	    function ZipSubscriber(destination, project, values) {
	        if (values === void 0) { values = Object.create(null); }
	        _super.call(this, destination);
	        this.iterators = [];
	        this.active = 0;
	        this.project = (typeof project === 'function') ? project : null;
	        this.values = values;
	    }
	    ZipSubscriber.prototype._next = function (value) {
	        var iterators = this.iterators;
	        if (isArray_1.isArray(value)) {
	            iterators.push(new StaticArrayIterator(value));
	        }
	        else if (typeof value[iterator_1.iterator] === 'function') {
	            iterators.push(new StaticIterator(value[iterator_1.iterator]()));
	        }
	        else {
	            iterators.push(new ZipBufferIterator(this.destination, this, value));
	        }
	    };
	    ZipSubscriber.prototype._complete = function () {
	        var iterators = this.iterators;
	        var len = iterators.length;
	        if (len === 0) {
	            this.destination.complete();
	            return;
	        }
	        this.active = len;
	        for (var i = 0; i < len; i++) {
	            var iterator = iterators[i];
	            if (iterator.stillUnsubscribed) {
	                this.add(iterator.subscribe(iterator, i));
	            }
	            else {
	                this.active--; // not an observable
	            }
	        }
	    };
	    ZipSubscriber.prototype.notifyInactive = function () {
	        this.active--;
	        if (this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    ZipSubscriber.prototype.checkIterators = function () {
	        var iterators = this.iterators;
	        var len = iterators.length;
	        var destination = this.destination;
	        // abort if not all of them have values
	        for (var i = 0; i < len; i++) {
	            var iterator = iterators[i];
	            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
	                return;
	            }
	        }
	        var shouldComplete = false;
	        var args = [];
	        for (var i = 0; i < len; i++) {
	            var iterator = iterators[i];
	            var result = iterator.next();
	            // check to see if it's completed now that you've gotten
	            // the next value.
	            if (iterator.hasCompleted()) {
	                shouldComplete = true;
	            }
	            if (result.done) {
	                destination.complete();
	                return;
	            }
	            args.push(result.value);
	        }
	        if (this.project) {
	            this._tryProject(args);
	        }
	        else {
	            destination.next(args);
	        }
	        if (shouldComplete) {
	            destination.complete();
	        }
	    };
	    ZipSubscriber.prototype._tryProject = function (args) {
	        var result;
	        try {
	            result = this.project.apply(this, args);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return ZipSubscriber;
	}(Subscriber_1.Subscriber));
	exports.ZipSubscriber = ZipSubscriber;
	var StaticIterator = (function () {
	    function StaticIterator(iterator) {
	        this.iterator = iterator;
	        this.nextResult = iterator.next();
	    }
	    StaticIterator.prototype.hasValue = function () {
	        return true;
	    };
	    StaticIterator.prototype.next = function () {
	        var result = this.nextResult;
	        this.nextResult = this.iterator.next();
	        return result;
	    };
	    StaticIterator.prototype.hasCompleted = function () {
	        var nextResult = this.nextResult;
	        return nextResult && nextResult.done;
	    };
	    return StaticIterator;
	}());
	var StaticArrayIterator = (function () {
	    function StaticArrayIterator(array) {
	        this.array = array;
	        this.index = 0;
	        this.length = 0;
	        this.length = array.length;
	    }
	    StaticArrayIterator.prototype[iterator_1.iterator] = function () {
	        return this;
	    };
	    StaticArrayIterator.prototype.next = function (value) {
	        var i = this.index++;
	        var array = this.array;
	        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
	    };
	    StaticArrayIterator.prototype.hasValue = function () {
	        return this.array.length > this.index;
	    };
	    StaticArrayIterator.prototype.hasCompleted = function () {
	        return this.array.length === this.index;
	    };
	    return StaticArrayIterator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ZipBufferIterator = (function (_super) {
	    __extends(ZipBufferIterator, _super);
	    function ZipBufferIterator(destination, parent, observable) {
	        _super.call(this, destination);
	        this.parent = parent;
	        this.observable = observable;
	        this.stillUnsubscribed = true;
	        this.buffer = [];
	        this.isComplete = false;
	    }
	    ZipBufferIterator.prototype[iterator_1.iterator] = function () {
	        return this;
	    };
	    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
	    //    this is legit because `next()` will never be called by a subscription in this case.
	    ZipBufferIterator.prototype.next = function () {
	        var buffer = this.buffer;
	        if (buffer.length === 0 && this.isComplete) {
	            return { value: null, done: true };
	        }
	        else {
	            return { value: buffer.shift(), done: false };
	        }
	    };
	    ZipBufferIterator.prototype.hasValue = function () {
	        return this.buffer.length > 0;
	    };
	    ZipBufferIterator.prototype.hasCompleted = function () {
	        return this.buffer.length === 0 && this.isComplete;
	    };
	    ZipBufferIterator.prototype.notifyComplete = function () {
	        if (this.buffer.length > 0) {
	            this.isComplete = true;
	            this.parent.notifyInactive();
	        }
	        else {
	            this.destination.complete();
	        }
	    };
	    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.buffer.push(innerValue);
	        this.parent.checkIterators();
	    };
	    ZipBufferIterator.prototype.subscribe = function (value, index) {
	        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
	    };
	    return ZipBufferIterator;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var ObjectUnsubscribedError_1 = __webpack_require__(26);
	/**
	 * @class BehaviorSubject<T>
	 */
	var BehaviorSubject = (function (_super) {
	    __extends(BehaviorSubject, _super);
	    function BehaviorSubject(_value) {
	        _super.call(this);
	        this._value = _value;
	    }
	    Object.defineProperty(BehaviorSubject.prototype, "value", {
	        get: function () {
	            return this.getValue();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BehaviorSubject.prototype._subscribe = function (subscriber) {
	        var subscription = _super.prototype._subscribe.call(this, subscriber);
	        if (subscription && !subscription.closed) {
	            subscriber.next(this._value);
	        }
	        return subscription;
	    };
	    BehaviorSubject.prototype.getValue = function () {
	        if (this.hasError) {
	            throw this.thrownError;
	        }
	        else if (this.closed) {
	            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
	        }
	        else {
	            return this._value;
	        }
	    };
	    BehaviorSubject.prototype.next = function (value) {
	        _super.prototype.next.call(this, this._value = value);
	    };
	    return BehaviorSubject;
	}(Subject_1.Subject));
	exports.BehaviorSubject = BehaviorSubject;


/***/ },
/* 39 */
/***/ function(module, exports) {

	"use strict";
	exports.empty = {
	    closed: true,
	    next: function (value) { },
	    error: function (err) { throw err; },
	    complete: function () { }
	};


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(5);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubjectSubscription = (function (_super) {
	    __extends(SubjectSubscription, _super);
	    function SubjectSubscription(subject, subscriber) {
	        _super.call(this);
	        this.subject = subject;
	        this.subscriber = subscriber;
	        this.closed = false;
	    }
	    SubjectSubscription.prototype.unsubscribe = function () {
	        if (this.closed) {
	            return;
	        }
	        this.closed = true;
	        var subject = this.subject;
	        var observers = subject.observers;
	        this.subject = null;
	        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
	            return;
	        }
	        var subscriberIndex = observers.indexOf(this.subscriber);
	        if (subscriberIndex !== -1) {
	            observers.splice(subscriberIndex, 1);
	        }
	    };
	    return SubjectSubscription;
	}(Subscription_1.Subscription));
	exports.SubjectSubscription = SubjectSubscription;


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var Observable_1 = __webpack_require__(1);
	var Subscriber_1 = __webpack_require__(2);
	var Subscription_1 = __webpack_require__(5);
	/**
	 * @class ConnectableObservable<T>
	 */
	var ConnectableObservable = (function (_super) {
	    __extends(ConnectableObservable, _super);
	    function ConnectableObservable(source, subjectFactory) {
	        _super.call(this);
	        this.source = source;
	        this.subjectFactory = subjectFactory;
	        this._refCount = 0;
	    }
	    ConnectableObservable.prototype._subscribe = function (subscriber) {
	        return this.getSubject().subscribe(subscriber);
	    };
	    ConnectableObservable.prototype.getSubject = function () {
	        var subject = this._subject;
	        if (!subject || subject.isStopped) {
	            this._subject = this.subjectFactory();
	        }
	        return this._subject;
	    };
	    ConnectableObservable.prototype.connect = function () {
	        var connection = this._connection;
	        if (!connection) {
	            connection = this._connection = new Subscription_1.Subscription();
	            connection.add(this.source
	                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
	            if (connection.closed) {
	                this._connection = null;
	                connection = Subscription_1.Subscription.EMPTY;
	            }
	            else {
	                this._connection = connection;
	            }
	        }
	        return connection;
	    };
	    ConnectableObservable.prototype.refCount = function () {
	        return this.lift(new RefCountOperator(this));
	    };
	    return ConnectableObservable;
	}(Observable_1.Observable));
	exports.ConnectableObservable = ConnectableObservable;
	exports.connectableObservableDescriptor = {
	    operator: { value: null },
	    _refCount: { value: 0, writable: true },
	    _subject: { value: null, writable: true },
	    _connection: { value: null, writable: true },
	    _subscribe: { value: ConnectableObservable.prototype._subscribe },
	    getSubject: { value: ConnectableObservable.prototype.getSubject },
	    connect: { value: ConnectableObservable.prototype.connect },
	    refCount: { value: ConnectableObservable.prototype.refCount }
	};
	var ConnectableSubscriber = (function (_super) {
	    __extends(ConnectableSubscriber, _super);
	    function ConnectableSubscriber(destination, connectable) {
	        _super.call(this, destination);
	        this.connectable = connectable;
	    }
	    ConnectableSubscriber.prototype._error = function (err) {
	        this._unsubscribe();
	        _super.prototype._error.call(this, err);
	    };
	    ConnectableSubscriber.prototype._complete = function () {
	        this._unsubscribe();
	        _super.prototype._complete.call(this);
	    };
	    ConnectableSubscriber.prototype._unsubscribe = function () {
	        var connectable = this.connectable;
	        if (connectable) {
	            this.connectable = null;
	            var connection = connectable._connection;
	            connectable._refCount = 0;
	            connectable._subject = null;
	            connectable._connection = null;
	            if (connection) {
	                connection.unsubscribe();
	            }
	        }
	    };
	    return ConnectableSubscriber;
	}(Subject_1.SubjectSubscriber));
	var RefCountOperator = (function () {
	    function RefCountOperator(connectable) {
	        this.connectable = connectable;
	    }
	    RefCountOperator.prototype.call = function (subscriber, source) {
	        var connectable = this.connectable;
	        connectable._refCount++;
	        var refCounter = new RefCountSubscriber(subscriber, connectable);
	        var subscription = source.subscribe(refCounter);
	        if (!refCounter.closed) {
	            refCounter.connection = connectable.connect();
	        }
	        return subscription;
	    };
	    return RefCountOperator;
	}());
	var RefCountSubscriber = (function (_super) {
	    __extends(RefCountSubscriber, _super);
	    function RefCountSubscriber(destination, connectable) {
	        _super.call(this, destination);
	        this.connectable = connectable;
	    }
	    RefCountSubscriber.prototype._unsubscribe = function () {
	        var connectable = this.connectable;
	        if (!connectable) {
	            this.connection = null;
	            return;
	        }
	        this.connectable = null;
	        var refCount = connectable._refCount;
	        if (refCount <= 0) {
	            this.connection = null;
	            return;
	        }
	        connectable._refCount = refCount - 1;
	        if (refCount > 1) {
	            this.connection = null;
	            return;
	        }
	        ///
	        // Compare the local RefCountSubscriber's connection Subscription to the
	        // connection Subscription on the shared ConnectableObservable. In cases
	        // where the ConnectableObservable source synchronously emits values, and
	        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
	        // execution continues to here before the RefCountOperator has a chance to
	        // supply the RefCountSubscriber with the shared connection Subscription.
	        // For example:
	        // ```
	        // Observable.range(0, 10)
	        //   .publish()
	        //   .refCount()
	        //   .take(5)
	        //   .subscribe();
	        // ```
	        // In order to account for this case, RefCountSubscriber should only dispose
	        // the ConnectableObservable's shared connection Subscription if the
	        // connection Subscription exists, *and* either:
	        //   a. RefCountSubscriber doesn't have a reference to the shared connection
	        //      Subscription yet, or,
	        //   b. RefCountSubscriber's connection Subscription reference is identical
	        //      to the shared connection Subscription
	        ///
	        var connection = this.connection;
	        var sharedConnection = connectable._connection;
	        this.connection = null;
	        if (sharedConnection && (!connection || sharedConnection === connection)) {
	            sharedConnection.unsubscribe();
	        }
	    };
	    return RefCountSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isArray_1 = __webpack_require__(12);
	var isArrayLike_1 = __webpack_require__(63);
	var isPromise_1 = __webpack_require__(65);
	var PromiseObservable_1 = __webpack_require__(43);
	var IteratorObservable_1 = __webpack_require__(211);
	var ArrayObservable_1 = __webpack_require__(11);
	var ArrayLikeObservable_1 = __webpack_require__(200);
	var iterator_1 = __webpack_require__(19);
	var Observable_1 = __webpack_require__(1);
	var observeOn_1 = __webpack_require__(35);
	var observable_1 = __webpack_require__(22);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var FromObservable = (function (_super) {
	    __extends(FromObservable, _super);
	    function FromObservable(ish, scheduler) {
	        _super.call(this, null);
	        this.ish = ish;
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable from an Array, an array-like object, a Promise, an
	     * iterable object, or an Observable-like object.
	     *
	     * <span class="informal">Converts almost anything to an Observable.</span>
	     *
	     * <img src="./img/from.png" width="100%">
	     *
	     * Convert various other objects and data types into Observables. `from`
	     * converts a Promise or an array-like or an
	     * [iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable)
	     * object into an Observable that emits the items in that promise or array or
	     * iterable. A String, in this context, is treated as an array of characters.
	     * Observable-like objects (contains a function named with the ES2015 Symbol
	     * for Observable) can also be converted through this operator.
	     *
	     * @example <caption>Converts an array to an Observable</caption>
	     * var array = [10, 20, 30];
	     * var result = Rx.Observable.from(array);
	     * result.subscribe(x => console.log(x));
	     *
	     * // Results in the following:
	     * // 10 20 30
	     *
	     * @example <caption>Convert an infinite iterable (from a generator) to an Observable</caption>
	     * function* generateDoubles(seed) {
	     *   var i = seed;
	     *   while (true) {
	     *     yield i;
	     *     i = 2 * i; // double it
	     *   }
	     * }
	     *
	     * var iterator = generateDoubles(3);
	     * var result = Rx.Observable.from(iterator).take(10);
	     * result.subscribe(x => console.log(x));
	     *
	     * // Results in the following:
	     * // 3 6 12 24 48 96 192 384 768 1536
	     *
	     * @see {@link create}
	     * @see {@link fromEvent}
	     * @see {@link fromEventPattern}
	     * @see {@link fromPromise}
	     *
	     * @param {ObservableInput<T>} ish A subscribable object, a Promise, an
	     * Observable-like, an Array, an iterable or an array-like object to be
	     * converted.
	     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
	     * emissions of values.
	     * @return {Observable<T>} The Observable whose values are originally from the
	     * input object that was converted.
	     * @static true
	     * @name from
	     * @owner Observable
	     */
	    FromObservable.create = function (ish, scheduler) {
	        if (ish != null) {
	            if (typeof ish[observable_1.observable] === 'function') {
	                if (ish instanceof Observable_1.Observable && !scheduler) {
	                    return ish;
	                }
	                return new FromObservable(ish, scheduler);
	            }
	            else if (isArray_1.isArray(ish)) {
	                return new ArrayObservable_1.ArrayObservable(ish, scheduler);
	            }
	            else if (isPromise_1.isPromise(ish)) {
	                return new PromiseObservable_1.PromiseObservable(ish, scheduler);
	            }
	            else if (typeof ish[iterator_1.iterator] === 'function' || typeof ish === 'string') {
	                return new IteratorObservable_1.IteratorObservable(ish, scheduler);
	            }
	            else if (isArrayLike_1.isArrayLike(ish)) {
	                return new ArrayLikeObservable_1.ArrayLikeObservable(ish, scheduler);
	            }
	        }
	        throw new TypeError((ish !== null && typeof ish || ish) + ' is not observable');
	    };
	    FromObservable.prototype._subscribe = function (subscriber) {
	        var ish = this.ish;
	        var scheduler = this.scheduler;
	        if (scheduler == null) {
	            return ish[observable_1.observable]().subscribe(subscriber);
	        }
	        else {
	            return ish[observable_1.observable]().subscribe(new observeOn_1.ObserveOnSubscriber(subscriber, scheduler, 0));
	        }
	    };
	    return FromObservable;
	}(Observable_1.Observable));
	exports.FromObservable = FromObservable;


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1 = __webpack_require__(8);
	var Observable_1 = __webpack_require__(1);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var PromiseObservable = (function (_super) {
	    __extends(PromiseObservable, _super);
	    function PromiseObservable(promise, scheduler) {
	        _super.call(this);
	        this.promise = promise;
	        this.scheduler = scheduler;
	    }
	    /**
	     * Converts a Promise to an Observable.
	     *
	     * <span class="informal">Returns an Observable that just emits the Promise's
	     * resolved value, then completes.</span>
	     *
	     * Converts an ES2015 Promise or a Promises/A+ spec compliant Promise to an
	     * Observable. If the Promise resolves with a value, the output Observable
	     * emits that resolved value as a `next`, and then completes. If the Promise
	     * is rejected, then the output Observable emits the corresponding Error.
	     *
	     * @example <caption>Convert the Promise returned by Fetch to an Observable</caption>
	     * var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     * @see {@link bindCallback}
	     * @see {@link from}
	     *
	     * @param {Promise<T>} promise The promise to be converted.
	     * @param {Scheduler} [scheduler] An optional IScheduler to use for scheduling
	     * the delivery of the resolved value (or the rejection).
	     * @return {Observable<T>} An Observable which wraps the Promise.
	     * @static true
	     * @name fromPromise
	     * @owner Observable
	     */
	    PromiseObservable.create = function (promise, scheduler) {
	        return new PromiseObservable(promise, scheduler);
	    };
	    PromiseObservable.prototype._subscribe = function (subscriber) {
	        var _this = this;
	        var promise = this.promise;
	        var scheduler = this.scheduler;
	        if (scheduler == null) {
	            if (this._isScalar) {
	                if (!subscriber.closed) {
	                    subscriber.next(this.value);
	                    subscriber.complete();
	                }
	            }
	            else {
	                promise.then(function (value) {
	                    _this.value = value;
	                    _this._isScalar = true;
	                    if (!subscriber.closed) {
	                        subscriber.next(value);
	                        subscriber.complete();
	                    }
	                }, function (err) {
	                    if (!subscriber.closed) {
	                        subscriber.error(err);
	                    }
	                })
	                    .then(null, function (err) {
	                    // escape the promise trap, throw unhandled errors
	                    root_1.root.setTimeout(function () { throw err; });
	                });
	            }
	        }
	        else {
	            if (this._isScalar) {
	                if (!subscriber.closed) {
	                    return scheduler.schedule(dispatchNext, 0, { value: this.value, subscriber: subscriber });
	                }
	            }
	            else {
	                promise.then(function (value) {
	                    _this.value = value;
	                    _this._isScalar = true;
	                    if (!subscriber.closed) {
	                        subscriber.add(scheduler.schedule(dispatchNext, 0, { value: value, subscriber: subscriber }));
	                    }
	                }, function (err) {
	                    if (!subscriber.closed) {
	                        subscriber.add(scheduler.schedule(dispatchError, 0, { err: err, subscriber: subscriber }));
	                    }
	                })
	                    .then(null, function (err) {
	                    // escape the promise trap, throw unhandled errors
	                    root_1.root.setTimeout(function () { throw err; });
	                });
	            }
	        }
	    };
	    return PromiseObservable;
	}(Observable_1.Observable));
	exports.PromiseObservable = PromiseObservable;
	function dispatchNext(arg) {
	    var value = arg.value, subscriber = arg.subscriber;
	    if (!subscriber.closed) {
	        subscriber.next(value);
	        subscriber.complete();
	    }
	}
	function dispatchError(arg) {
	    var err = arg.err, subscriber = arg.subscriber;
	    if (!subscriber.closed) {
	        subscriber.error(err);
	    }
	}


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1 = __webpack_require__(8);
	var tryCatch_1 = __webpack_require__(9);
	var errorObject_1 = __webpack_require__(7);
	var Observable_1 = __webpack_require__(1);
	var Subscriber_1 = __webpack_require__(2);
	var map_1 = __webpack_require__(34);
	function getCORSRequest() {
	    if (root_1.root.XMLHttpRequest) {
	        return new root_1.root.XMLHttpRequest();
	    }
	    else if (!!root_1.root.XDomainRequest) {
	        return new root_1.root.XDomainRequest();
	    }
	    else {
	        throw new Error('CORS is not supported by your browser');
	    }
	}
	function getXMLHttpRequest() {
	    if (root_1.root.XMLHttpRequest) {
	        return new root_1.root.XMLHttpRequest();
	    }
	    else {
	        var progId = void 0;
	        try {
	            var progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
	            for (var i = 0; i < 3; i++) {
	                try {
	                    progId = progIds[i];
	                    if (new root_1.root.ActiveXObject(progId)) {
	                        break;
	                    }
	                }
	                catch (e) {
	                }
	            }
	            return new root_1.root.ActiveXObject(progId);
	        }
	        catch (e) {
	            throw new Error('XMLHttpRequest is not supported by your browser');
	        }
	    }
	}
	function ajaxGet(url, headers) {
	    if (headers === void 0) { headers = null; }
	    return new AjaxObservable({ method: 'GET', url: url, headers: headers });
	}
	exports.ajaxGet = ajaxGet;
	;
	function ajaxPost(url, body, headers) {
	    return new AjaxObservable({ method: 'POST', url: url, body: body, headers: headers });
	}
	exports.ajaxPost = ajaxPost;
	;
	function ajaxDelete(url, headers) {
	    return new AjaxObservable({ method: 'DELETE', url: url, headers: headers });
	}
	exports.ajaxDelete = ajaxDelete;
	;
	function ajaxPut(url, body, headers) {
	    return new AjaxObservable({ method: 'PUT', url: url, body: body, headers: headers });
	}
	exports.ajaxPut = ajaxPut;
	;
	function ajaxPatch(url, body, headers) {
	    return new AjaxObservable({ method: 'PATCH', url: url, body: body, headers: headers });
	}
	exports.ajaxPatch = ajaxPatch;
	;
	function ajaxGetJSON(url, headers) {
	    return new AjaxObservable({ method: 'GET', url: url, responseType: 'json', headers: headers })
	        .lift(new map_1.MapOperator(function (x, index) { return x.response; }, null));
	}
	exports.ajaxGetJSON = ajaxGetJSON;
	;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var AjaxObservable = (function (_super) {
	    __extends(AjaxObservable, _super);
	    function AjaxObservable(urlOrRequest) {
	        _super.call(this);
	        var request = {
	            async: true,
	            createXHR: function () {
	                return this.crossDomain ? getCORSRequest.call(this) : getXMLHttpRequest();
	            },
	            crossDomain: false,
	            withCredentials: false,
	            headers: {},
	            method: 'GET',
	            responseType: 'json',
	            timeout: 0
	        };
	        if (typeof urlOrRequest === 'string') {
	            request.url = urlOrRequest;
	        }
	        else {
	            for (var prop in urlOrRequest) {
	                if (urlOrRequest.hasOwnProperty(prop)) {
	                    request[prop] = urlOrRequest[prop];
	                }
	            }
	        }
	        this.request = request;
	    }
	    AjaxObservable.prototype._subscribe = function (subscriber) {
	        return new AjaxSubscriber(subscriber, this.request);
	    };
	    /**
	     * Creates an observable for an Ajax request with either a request object with
	     * url, headers, etc or a string for a URL.
	     *
	     * @example
	     * source = Rx.Observable.ajax('/products');
	     * source = Rx.Observable.ajax({ url: 'products', method: 'GET' });
	     *
	     * @param {string|Object} request Can be one of the following:
	     *   A string of the URL to make the Ajax call.
	     *   An object with the following properties
	     *   - url: URL of the request
	     *   - body: The body of the request
	     *   - method: Method of the request, such as GET, POST, PUT, PATCH, DELETE
	     *   - async: Whether the request is async
	     *   - headers: Optional headers
	     *   - crossDomain: true if a cross domain request, else false
	     *   - createXHR: a function to override if you need to use an alternate
	     *   XMLHttpRequest implementation.
	     *   - resultSelector: a function to use to alter the output value type of
	     *   the Observable. Gets {@link AjaxResponse} as an argument.
	     * @return {Observable} An observable sequence containing the XMLHttpRequest.
	     * @static true
	     * @name ajax
	     * @owner Observable
	    */
	    AjaxObservable.create = (function () {
	        var create = function (urlOrRequest) {
	            return new AjaxObservable(urlOrRequest);
	        };
	        create.get = ajaxGet;
	        create.post = ajaxPost;
	        create.delete = ajaxDelete;
	        create.put = ajaxPut;
	        create.patch = ajaxPatch;
	        create.getJSON = ajaxGetJSON;
	        return create;
	    })();
	    return AjaxObservable;
	}(Observable_1.Observable));
	exports.AjaxObservable = AjaxObservable;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AjaxSubscriber = (function (_super) {
	    __extends(AjaxSubscriber, _super);
	    function AjaxSubscriber(destination, request) {
	        _super.call(this, destination);
	        this.request = request;
	        this.done = false;
	        var headers = request.headers = request.headers || {};
	        // force CORS if requested
	        if (!request.crossDomain && !headers['X-Requested-With']) {
	            headers['X-Requested-With'] = 'XMLHttpRequest';
	        }
	        // ensure content type is set
	        if (!('Content-Type' in headers) && !(root_1.root.FormData && request.body instanceof root_1.root.FormData) && typeof request.body !== 'undefined') {
	            headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8';
	        }
	        // properly serialize body
	        request.body = this.serializeBody(request.body, request.headers['Content-Type']);
	        this.send();
	    }
	    AjaxSubscriber.prototype.next = function (e) {
	        this.done = true;
	        var _a = this, xhr = _a.xhr, request = _a.request, destination = _a.destination;
	        var response = new AjaxResponse(e, xhr, request);
	        destination.next(response);
	    };
	    AjaxSubscriber.prototype.send = function () {
	        var _a = this, request = _a.request, _b = _a.request, user = _b.user, method = _b.method, url = _b.url, async = _b.async, password = _b.password, headers = _b.headers, body = _b.body;
	        var createXHR = request.createXHR;
	        var xhr = tryCatch_1.tryCatch(createXHR).call(request);
	        if (xhr === errorObject_1.errorObject) {
	            this.error(errorObject_1.errorObject.e);
	        }
	        else {
	            this.xhr = xhr;
	            // set up the events before open XHR
	            // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
	            // You need to add the event listeners before calling open() on the request.
	            // Otherwise the progress events will not fire.
	            this.setupEvents(xhr, request);
	            // open XHR
	            var result = void 0;
	            if (user) {
	                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async, user, password);
	            }
	            else {
	                result = tryCatch_1.tryCatch(xhr.open).call(xhr, method, url, async);
	            }
	            if (result === errorObject_1.errorObject) {
	                this.error(errorObject_1.errorObject.e);
	                return null;
	            }
	            // timeout, responseType and withCredentials can be set once the XHR is open
	            xhr.timeout = request.timeout;
	            xhr.responseType = request.responseType;
	            if ('withCredentials' in xhr) {
	                xhr.withCredentials = !!request.withCredentials;
	            }
	            // set headers
	            this.setHeaders(xhr, headers);
	            // finally send the request
	            result = body ? tryCatch_1.tryCatch(xhr.send).call(xhr, body) : tryCatch_1.tryCatch(xhr.send).call(xhr);
	            if (result === errorObject_1.errorObject) {
	                this.error(errorObject_1.errorObject.e);
	                return null;
	            }
	        }
	        return xhr;
	    };
	    AjaxSubscriber.prototype.serializeBody = function (body, contentType) {
	        if (!body || typeof body === 'string') {
	            return body;
	        }
	        else if (root_1.root.FormData && body instanceof root_1.root.FormData) {
	            return body;
	        }
	        if (contentType) {
	            var splitIndex = contentType.indexOf(';');
	            if (splitIndex !== -1) {
	                contentType = contentType.substring(0, splitIndex);
	            }
	        }
	        switch (contentType) {
	            case 'application/x-www-form-urlencoded':
	                return Object.keys(body).map(function (key) { return (encodeURI(key) + "=" + encodeURI(body[key])); }).join('&');
	            case 'application/json':
	                return JSON.stringify(body);
	            default:
	                return body;
	        }
	    };
	    AjaxSubscriber.prototype.setHeaders = function (xhr, headers) {
	        for (var key in headers) {
	            if (headers.hasOwnProperty(key)) {
	                xhr.setRequestHeader(key, headers[key]);
	            }
	        }
	    };
	    AjaxSubscriber.prototype.setupEvents = function (xhr, request) {
	        var progressSubscriber = request.progressSubscriber;
	        function xhrTimeout(e) {
	            var _a = xhrTimeout, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;
	            if (progressSubscriber) {
	                progressSubscriber.error(e);
	            }
	            subscriber.error(new AjaxTimeoutError(this, request)); //TODO: Make betterer.
	        }
	        ;
	        xhr.ontimeout = xhrTimeout;
	        xhrTimeout.request = request;
	        xhrTimeout.subscriber = this;
	        xhrTimeout.progressSubscriber = progressSubscriber;
	        if (xhr.upload && 'withCredentials' in xhr) {
	            if (progressSubscriber) {
	                var xhrProgress_1;
	                xhrProgress_1 = function (e) {
	                    var progressSubscriber = xhrProgress_1.progressSubscriber;
	                    progressSubscriber.next(e);
	                };
	                if (root_1.root.XDomainRequest) {
	                    xhr.onprogress = xhrProgress_1;
	                }
	                else {
	                    xhr.upload.onprogress = xhrProgress_1;
	                }
	                xhrProgress_1.progressSubscriber = progressSubscriber;
	            }
	            var xhrError_1;
	            xhrError_1 = function (e) {
	                var _a = xhrError_1, progressSubscriber = _a.progressSubscriber, subscriber = _a.subscriber, request = _a.request;
	                if (progressSubscriber) {
	                    progressSubscriber.error(e);
	                }
	                subscriber.error(new AjaxError('ajax error', this, request));
	            };
	            xhr.onerror = xhrError_1;
	            xhrError_1.request = request;
	            xhrError_1.subscriber = this;
	            xhrError_1.progressSubscriber = progressSubscriber;
	        }
	        function xhrReadyStateChange(e) {
	            var _a = xhrReadyStateChange, subscriber = _a.subscriber, progressSubscriber = _a.progressSubscriber, request = _a.request;
	            if (this.readyState === 4) {
	                // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
	                var status_1 = this.status === 1223 ? 204 : this.status;
	                var response = (this.responseType === 'text' ? (this.response || this.responseText) : this.response);
	                // fix status code when it is 0 (0 status is undocumented).
	                // Occurs when accessing file resources or on Android 4.1 stock browser
	                // while retrieving files from application cache.
	                if (status_1 === 0) {
	                    status_1 = response ? 200 : 0;
	                }
	                if (200 <= status_1 && status_1 < 300) {
	                    if (progressSubscriber) {
	                        progressSubscriber.complete();
	                    }
	                    subscriber.next(e);
	                    subscriber.complete();
	                }
	                else {
	                    if (progressSubscriber) {
	                        progressSubscriber.error(e);
	                    }
	                    subscriber.error(new AjaxError('ajax error ' + status_1, this, request));
	                }
	            }
	        }
	        ;
	        xhr.onreadystatechange = xhrReadyStateChange;
	        xhrReadyStateChange.subscriber = this;
	        xhrReadyStateChange.progressSubscriber = progressSubscriber;
	        xhrReadyStateChange.request = request;
	    };
	    AjaxSubscriber.prototype.unsubscribe = function () {
	        var _a = this, done = _a.done, xhr = _a.xhr;
	        if (!done && xhr && xhr.readyState !== 4 && typeof xhr.abort === 'function') {
	            xhr.abort();
	        }
	        _super.prototype.unsubscribe.call(this);
	    };
	    return AjaxSubscriber;
	}(Subscriber_1.Subscriber));
	exports.AjaxSubscriber = AjaxSubscriber;
	/**
	 * A normalized AJAX response.
	 *
	 * @see {@link ajax}
	 *
	 * @class AjaxResponse
	 */
	var AjaxResponse = (function () {
	    function AjaxResponse(originalEvent, xhr, request) {
	        this.originalEvent = originalEvent;
	        this.xhr = xhr;
	        this.request = request;
	        this.status = xhr.status;
	        this.responseType = xhr.responseType || request.responseType;
	        switch (this.responseType) {
	            case 'json':
	                if ('response' in xhr) {
	                    //IE does not support json as responseType, parse it internally
	                    this.response = xhr.responseType ? xhr.response : JSON.parse(xhr.response || xhr.responseText || 'null');
	                }
	                else {
	                    this.response = JSON.parse(xhr.responseText || 'null');
	                }
	                break;
	            case 'xml':
	                this.response = xhr.responseXML;
	                break;
	            case 'text':
	            default:
	                this.response = ('response' in xhr) ? xhr.response : xhr.responseText;
	                break;
	        }
	    }
	    return AjaxResponse;
	}());
	exports.AjaxResponse = AjaxResponse;
	/**
	 * A normalized AJAX error.
	 *
	 * @see {@link ajax}
	 *
	 * @class AjaxError
	 */
	var AjaxError = (function (_super) {
	    __extends(AjaxError, _super);
	    function AjaxError(message, xhr, request) {
	        _super.call(this, message);
	        this.message = message;
	        this.xhr = xhr;
	        this.request = request;
	        this.status = xhr.status;
	    }
	    return AjaxError;
	}(Error));
	exports.AjaxError = AjaxError;
	/**
	 * @see {@link ajax}
	 *
	 * @class AjaxTimeoutError
	 */
	var AjaxTimeoutError = (function (_super) {
	    __extends(AjaxTimeoutError, _super);
	    function AjaxTimeoutError(xhr, request) {
	        _super.call(this, 'ajax timeout', xhr, request);
	    }
	    return AjaxTimeoutError;
	}(AjaxError));
	exports.AjaxTimeoutError = AjaxTimeoutError;


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var tryCatch_1 = __webpack_require__(9);
	var errorObject_1 = __webpack_require__(7);
	/* tslint:enable:max-line-length */
	/**
	 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
	 *
	 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
	 *
	 * If a comparator function is not provided, an equality check is used by default.
	 *
	 * @example <caption>A simple example with numbers</caption>
	 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
	 *   .distinctUntilChanged()
	 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
	 *
	 * @example <caption>An example using a compare function</caption>
	 * interface Person {
	 *    age: number,
	 *    name: string
	 * }
	 *
	 * Observable.of<Person>(
	 *     { age: 4, name: 'Foo'},
	 *     { age: 7, name: 'Bar'},
	 *     { age: 5, name: 'Foo'})
	 *     { age: 6, name: 'Foo'})
	 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
	 *     .subscribe(x => console.log(x));
	 *
	 * // displays:
	 * // { age: 4, name: 'Foo' }
	 * // { age: 7, name: 'Bar' }
	 * // { age: 5, name: 'Foo' }
	 *
	 * @see {@link distinct}
	 * @see {@link distinctUntilKeyChanged}
	 *
	 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
	 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
	 * @method distinctUntilChanged
	 * @owner Observable
	 */
	function distinctUntilChanged(compare, keySelector) {
	    return this.lift(new DistinctUntilChangedOperator(compare, keySelector));
	}
	exports.distinctUntilChanged = distinctUntilChanged;
	var DistinctUntilChangedOperator = (function () {
	    function DistinctUntilChangedOperator(compare, keySelector) {
	        this.compare = compare;
	        this.keySelector = keySelector;
	    }
	    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
	    };
	    return DistinctUntilChangedOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DistinctUntilChangedSubscriber = (function (_super) {
	    __extends(DistinctUntilChangedSubscriber, _super);
	    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
	        _super.call(this, destination);
	        this.keySelector = keySelector;
	        this.hasKey = false;
	        if (typeof compare === 'function') {
	            this.compare = compare;
	        }
	    }
	    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
	        return x === y;
	    };
	    DistinctUntilChangedSubscriber.prototype._next = function (value) {
	        var keySelector = this.keySelector;
	        var key = value;
	        if (keySelector) {
	            key = tryCatch_1.tryCatch(this.keySelector)(value);
	            if (key === errorObject_1.errorObject) {
	                return this.destination.error(errorObject_1.errorObject.e);
	            }
	        }
	        var result = false;
	        if (this.hasKey) {
	            result = tryCatch_1.tryCatch(this.compare)(this.key, key);
	            if (result === errorObject_1.errorObject) {
	                return this.destination.error(errorObject_1.errorObject.e);
	            }
	        }
	        else {
	            this.hasKey = true;
	        }
	        if (Boolean(result) === false) {
	            this.key = key;
	            this.destination.next(value);
	        }
	    };
	    return DistinctUntilChangedSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/* tslint:enable:max-line-length */
	/**
	 * Filter items emitted by the source Observable by only emitting those that
	 * satisfy a specified predicate.
	 *
	 * <span class="informal">Like
	 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
	 * it only emits a value from the source if it passes a criterion function.</span>
	 *
	 * <img src="./img/filter.png" width="100%">
	 *
	 * Similar to the well-known `Array.prototype.filter` method, this operator
	 * takes values from the source Observable, passes them through a `predicate`
	 * function and only emits those values that yielded `true`.
	 *
	 * @example <caption>Emit only click events whose target was a DIV element</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
	 * clicksOnDivs.subscribe(x => console.log(x));
	 *
	 * @see {@link distinct}
	 * @see {@link distinctUntilChanged}
	 * @see {@link distinctUntilKeyChanged}
	 * @see {@link ignoreElements}
	 * @see {@link partition}
	 * @see {@link skip}
	 *
	 * @param {function(value: T, index: number): boolean} predicate A function that
	 * evaluates each value emitted by the source Observable. If it returns `true`,
	 * the value is emitted, if `false` the value is not passed to the output
	 * Observable. The `index` parameter is the number `i` for the i-th source
	 * emission that has happened since the subscription, starting from the number
	 * `0`.
	 * @param {any} [thisArg] An optional argument to determine the value of `this`
	 * in the `predicate` function.
	 * @return {Observable} An Observable of values from the source that were
	 * allowed by the `predicate` function.
	 * @method filter
	 * @owner Observable
	 */
	function filter(predicate, thisArg) {
	    return this.lift(new FilterOperator(predicate, thisArg));
	}
	exports.filter = filter;
	var FilterOperator = (function () {
	    function FilterOperator(predicate, thisArg) {
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	    }
	    FilterOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
	    };
	    return FilterOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FilterSubscriber = (function (_super) {
	    __extends(FilterSubscriber, _super);
	    function FilterSubscriber(destination, predicate, thisArg) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.count = 0;
	        this.predicate = predicate;
	    }
	    // the try catch block below is left specifically for
	    // optimization and perf reasons. a tryCatcher is not necessary here.
	    FilterSubscriber.prototype._next = function (value) {
	        var result;
	        try {
	            result = this.predicate.call(this.thisArg, value, this.count++);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            this.destination.next(value);
	        }
	    };
	    return FilterSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/* tslint:enable:max-line-length */
	/**
	 * Emits only the first value emitted by the source Observable that meets some
	 * condition.
	 *
	 * <span class="informal">Finds the first value that passes some test and emits
	 * that.</span>
	 *
	 * <img src="./img/find.png" width="100%">
	 *
	 * `find` searches for the first item in the source Observable that matches the
	 * specified condition embodied by the `predicate`, and returns the first
	 * occurrence in the source. Unlike {@link first}, the `predicate` is required
	 * in `find`, and does not emit an error if a valid value is not found.
	 *
	 * @example <caption>Find and emit the first click that happens on a DIV element</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.find(ev => ev.target.tagName === 'DIV');
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link filter}
	 * @see {@link first}
	 * @see {@link findIndex}
	 * @see {@link take}
	 *
	 * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
	 * A function called with each item to test for condition matching.
	 * @param {any} [thisArg] An optional argument to determine the value of `this`
	 * in the `predicate` function.
	 * @return {Observable<T>} An Observable of the first item that matches the
	 * condition.
	 * @method find
	 * @owner Observable
	 */
	function find(predicate, thisArg) {
	    if (typeof predicate !== 'function') {
	        throw new TypeError('predicate is not a function');
	    }
	    return this.lift(new FindValueOperator(predicate, this, false, thisArg));
	}
	exports.find = find;
	var FindValueOperator = (function () {
	    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
	        this.predicate = predicate;
	        this.source = source;
	        this.yieldIndex = yieldIndex;
	        this.thisArg = thisArg;
	    }
	    FindValueOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
	    };
	    return FindValueOperator;
	}());
	exports.FindValueOperator = FindValueOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FindValueSubscriber = (function (_super) {
	    __extends(FindValueSubscriber, _super);
	    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.source = source;
	        this.yieldIndex = yieldIndex;
	        this.thisArg = thisArg;
	        this.index = 0;
	    }
	    FindValueSubscriber.prototype.notifyComplete = function (value) {
	        var destination = this.destination;
	        destination.next(value);
	        destination.complete();
	    };
	    FindValueSubscriber.prototype._next = function (value) {
	        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
	        var index = this.index++;
	        try {
	            var result = predicate.call(thisArg || this, value, index, this.source);
	            if (result) {
	                this.notifyComplete(this.yieldIndex ? index : value);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    FindValueSubscriber.prototype._complete = function () {
	        this.notifyComplete(this.yieldIndex ? -1 : undefined);
	    };
	    return FindValueSubscriber;
	}(Subscriber_1.Subscriber));
	exports.FindValueSubscriber = FindValueSubscriber;


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var ArrayObservable_1 = __webpack_require__(11);
	var mergeAll_1 = __webpack_require__(21);
	var isScheduler_1 = __webpack_require__(13);
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which concurrently emits all values from every
	 * given input Observable.
	 *
	 * <span class="informal">Flattens multiple Observables together by blending
	 * their values into one Observable.</span>
	 *
	 * <img src="./img/merge.png" width="100%">
	 *
	 * `merge` subscribes to each given input Observable (either the source or an
	 * Observable given as argument), and simply forwards (without doing any
	 * transformation) all the values from all the input Observables to the output
	 * Observable. The output Observable only completes once all input Observables
	 * have completed. Any error delivered by an input Observable will be immediately
	 * emitted on the output Observable.
	 *
	 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var timer = Rx.Observable.interval(1000);
	 * var clicksOrTimer = clicks.merge(timer);
	 * clicksOrTimer.subscribe(x => console.log(x));
	 *
	 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var concurrent = 2; // the argument
	 * var merged = timer1.merge(timer2, timer3, concurrent);
	 * merged.subscribe(x => console.log(x));
	 *
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 *
	 * @param {ObservableInput} other An input Observable to merge with the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
	 * concurrency of input Observables.
	 * @return {Observable} An Observable that emits items that are the result of
	 * every input Observable.
	 * @method merge
	 * @owner Observable
	 */
	function merge() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    return this.lift.call(mergeStatic.apply(void 0, [this].concat(observables)));
	}
	exports.merge = merge;
	/* tslint:enable:max-line-length */
	/**
	 * Creates an output Observable which concurrently emits all values from every
	 * given input Observable.
	 *
	 * <span class="informal">Flattens multiple Observables together by blending
	 * their values into one Observable.</span>
	 *
	 * <img src="./img/merge.png" width="100%">
	 *
	 * `merge` subscribes to each given input Observable (as arguments), and simply
	 * forwards (without doing any transformation) all the values from all the input
	 * Observables to the output Observable. The output Observable only completes
	 * once all input Observables have completed. Any error delivered by an input
	 * Observable will be immediately emitted on the output Observable.
	 *
	 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var timer = Rx.Observable.interval(1000);
	 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
	 * clicksOrTimer.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // timer will emit ascending values, one every second(1000ms) to console
	 * // clicks logs MouseEvents to console everytime the "document" is clicked
	 * // Since the two streams are merged you see these happening
	 * // as they occur.
	 *
	 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
	 * var timer1 = Rx.Observable.interval(1000).take(10);
	 * var timer2 = Rx.Observable.interval(2000).take(6);
	 * var timer3 = Rx.Observable.interval(500).take(10);
	 * var concurrent = 2; // the argument
	 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
	 * merged.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // - First timer1 and timer2 will run concurrently
	 * // - timer1 will emit a value every 1000ms for 10 iterations
	 * // - timer2 will emit a value every 2000ms for 6 iterations
	 * // - after timer1 hits it's max iteration, timer2 will
	 * //   continue, and timer3 will start to run concurrently with timer2
	 * // - when timer2 hits it's max iteration it terminates, and
	 * //   timer3 will continue to emit a value every 500ms until it is complete
	 *
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 *
	 * @param {...ObservableInput} observables Input Observables to merge together.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
	 * concurrency of input Observables.
	 * @return {Observable} an Observable that emits items that are the result of
	 * every input Observable.
	 * @static true
	 * @name merge
	 * @owner Observable
	 */
	function mergeStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var concurrent = Number.POSITIVE_INFINITY;
	    var scheduler = null;
	    var last = observables[observables.length - 1];
	    if (isScheduler_1.isScheduler(last)) {
	        scheduler = observables.pop();
	        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
	            concurrent = observables.pop();
	        }
	    }
	    else if (typeof last === 'number') {
	        concurrent = observables.pop();
	    }
	    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
	        return observables[0];
	    }
	    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new mergeAll_1.MergeAllOperator(concurrent));
	}
	exports.mergeStatic = mergeStatic;


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var subscribeToResult_1 = __webpack_require__(4);
	var OuterSubscriber_1 = __webpack_require__(3);
	/* tslint:enable:max-line-length */
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link mergeAll}.</span>
	 *
	 * <img src="./img/mergeMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an Observable, and then merging those resulting Observables and
	 * emitting the results of this merger.
	 *
	 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
	 * var letters = Rx.Observable.of('a', 'b', 'c');
	 * var result = letters.mergeMap(x =>
	 *   Rx.Observable.interval(1000).map(i => x+i)
	 * );
	 * result.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // a0
	 * // b0
	 * // c0
	 * // a1
	 * // b1
	 * // c1
	 * // continues to list a,b,c with respective ascending integers
	 *
	 * @see {@link concatMap}
	 * @see {@link exhaustMap}
	 * @see {@link merge}
	 * @see {@link mergeAll}
	 * @see {@link mergeMapTo}
	 * @see {@link mergeScan}
	 * @see {@link switchMap}
	 *
	 * @param {function(value: T, ?index: number): ObservableInput} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and merging the results of the Observables obtained
	 * from this transformation.
	 * @method mergeMap
	 * @owner Observable
	 */
	function mergeMap(project, resultSelector, concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	        resultSelector = null;
	    }
	    return this.lift(new MergeMapOperator(project, resultSelector, concurrent));
	}
	exports.mergeMap = mergeMap;
	var MergeMapOperator = (function () {
	    function MergeMapOperator(project, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	    }
	    MergeMapOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.resultSelector, this.concurrent));
	    };
	    return MergeMapOperator;
	}());
	exports.MergeMapOperator = MergeMapOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeMapSubscriber = (function (_super) {
	    __extends(MergeMapSubscriber, _super);
	    function MergeMapSubscriber(destination, project, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        _super.call(this, destination);
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	        this.index = 0;
	    }
	    MergeMapSubscriber.prototype._next = function (value) {
	        if (this.active < this.concurrent) {
	            this._tryNext(value);
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    MergeMapSubscriber.prototype._tryNext = function (value) {
	        var result;
	        var index = this.index++;
	        try {
	            result = this.project(value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.active++;
	        this._innerSub(result, value, index);
	    };
	    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
	        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
	    };
	    MergeMapSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (this.resultSelector) {
	            this._notifyResultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            this.destination.next(innerValue);
	        }
	    };
	    MergeMapSubscriber.prototype._notifyResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var result;
	        try {
	            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeMapSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.MergeMapSubscriber = MergeMapSubscriber;


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/* tslint:enable:max-line-length */
	/**
	 * Projects each source value to the same Observable which is merged multiple
	 * times in the output Observable.
	 *
	 * <span class="informal">It's like {@link mergeMap}, but maps each value always
	 * to the same inner Observable.</span>
	 *
	 * <img src="./img/mergeMapTo.png" width="100%">
	 *
	 * Maps each source value to the given Observable `innerObservable` regardless
	 * of the source value, and then merges those resulting Observables into one
	 * single Observable, which is the output Observable.
	 *
	 * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMapTo}
	 * @see {@link merge}
	 * @see {@link mergeAll}
	 * @see {@link mergeMap}
	 * @see {@link mergeScan}
	 * @see {@link switchMapTo}
	 *
	 * @param {ObservableInput} innerObservable An Observable to replace each value from
	 * the source Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @return {Observable} An Observable that emits items from the given
	 * `innerObservable` (and optionally transformed through `resultSelector`) every
	 * time a value is emitted on the source Observable.
	 * @method mergeMapTo
	 * @owner Observable
	 */
	function mergeMapTo(innerObservable, resultSelector, concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    if (typeof resultSelector === 'number') {
	        concurrent = resultSelector;
	        resultSelector = null;
	    }
	    return this.lift(new MergeMapToOperator(innerObservable, resultSelector, concurrent));
	}
	exports.mergeMapTo = mergeMapTo;
	// TODO: Figure out correct signature here: an Operator<Observable<T>, R>
	//       needs to implement call(observer: Subscriber<R>): Subscriber<Observable<T>>
	var MergeMapToOperator = (function () {
	    function MergeMapToOperator(ish, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        this.ish = ish;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	    }
	    MergeMapToOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new MergeMapToSubscriber(observer, this.ish, this.resultSelector, this.concurrent));
	    };
	    return MergeMapToOperator;
	}());
	exports.MergeMapToOperator = MergeMapToOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeMapToSubscriber = (function (_super) {
	    __extends(MergeMapToSubscriber, _super);
	    function MergeMapToSubscriber(destination, ish, resultSelector, concurrent) {
	        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	        _super.call(this, destination);
	        this.ish = ish;
	        this.resultSelector = resultSelector;
	        this.concurrent = concurrent;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	        this.index = 0;
	    }
	    MergeMapToSubscriber.prototype._next = function (value) {
	        if (this.active < this.concurrent) {
	            var resultSelector = this.resultSelector;
	            var index = this.index++;
	            var ish = this.ish;
	            var destination = this.destination;
	            this.active++;
	            this._innerSub(ish, destination, resultSelector, value, index);
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    MergeMapToSubscriber.prototype._innerSub = function (ish, destination, resultSelector, value, index) {
	        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
	    };
	    MergeMapToSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            this.destination.complete();
	        }
	    };
	    MergeMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        if (resultSelector) {
	            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            destination.next(innerValue);
	        }
	    };
	    MergeMapToSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        var result;
	        try {
	            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            destination.error(err);
	            return;
	        }
	        destination.next(result);
	    };
	    MergeMapToSubscriber.prototype.notifyError = function (err) {
	        this.destination.error(err);
	    };
	    MergeMapToSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return MergeMapToSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.MergeMapToSubscriber = MergeMapToSubscriber;


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var FromObservable_1 = __webpack_require__(42);
	var isArray_1 = __webpack_require__(12);
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/* tslint:enable:max-line-length */
	function onErrorResumeNext() {
	    var nextSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        nextSources[_i - 0] = arguments[_i];
	    }
	    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
	        nextSources = nextSources[0];
	    }
	    return this.lift(new OnErrorResumeNextOperator(nextSources));
	}
	exports.onErrorResumeNext = onErrorResumeNext;
	/* tslint:enable:max-line-length */
	function onErrorResumeNextStatic() {
	    var nextSources = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        nextSources[_i - 0] = arguments[_i];
	    }
	    var source = null;
	    if (nextSources.length === 1 && isArray_1.isArray(nextSources[0])) {
	        nextSources = nextSources[0];
	    }
	    source = nextSources.shift();
	    return new FromObservable_1.FromObservable(source, null).lift(new OnErrorResumeNextOperator(nextSources));
	}
	exports.onErrorResumeNextStatic = onErrorResumeNextStatic;
	var OnErrorResumeNextOperator = (function () {
	    function OnErrorResumeNextOperator(nextSources) {
	        this.nextSources = nextSources;
	    }
	    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
	    };
	    return OnErrorResumeNextOperator;
	}());
	var OnErrorResumeNextSubscriber = (function (_super) {
	    __extends(OnErrorResumeNextSubscriber, _super);
	    function OnErrorResumeNextSubscriber(destination, nextSources) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.nextSources = nextSources;
	    }
	    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
	        this.subscribeToNextSource();
	    };
	    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.subscribeToNextSource();
	    };
	    OnErrorResumeNextSubscriber.prototype._error = function (err) {
	        this.subscribeToNextSource();
	    };
	    OnErrorResumeNextSubscriber.prototype._complete = function () {
	        this.subscribeToNextSource();
	    };
	    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
	        var next = this.nextSources.shift();
	        if (next) {
	            this.add(subscribeToResult_1.subscribeToResult(this, next));
	        }
	        else {
	            this.destination.complete();
	        }
	    };
	    return OnErrorResumeNextSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isArray_1 = __webpack_require__(12);
	var ArrayObservable_1 = __webpack_require__(11);
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/* tslint:enable:max-line-length */
	/**
	 * Returns an Observable that mirrors the first source Observable to emit an item
	 * from the combination of this Observable and supplied Observables.
	 * @param {...Observables} ...observables Sources used to race for which Observable emits first.
	 * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.
	 * @method race
	 * @owner Observable
	 */
	function race() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    // if the only argument is an array, it was most likely called with
	    // `pair([obs1, obs2, ...])`
	    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
	        observables = observables[0];
	    }
	    return this.lift.call(raceStatic.apply(void 0, [this].concat(observables)));
	}
	exports.race = race;
	function raceStatic() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    // if the only argument is an array, it was most likely called with
	    // `pair([obs1, obs2, ...])`
	    if (observables.length === 1) {
	        if (isArray_1.isArray(observables[0])) {
	            observables = observables[0];
	        }
	        else {
	            return observables[0];
	        }
	    }
	    return new ArrayObservable_1.ArrayObservable(observables).lift(new RaceOperator());
	}
	exports.raceStatic = raceStatic;
	var RaceOperator = (function () {
	    function RaceOperator() {
	    }
	    RaceOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RaceSubscriber(subscriber));
	    };
	    return RaceOperator;
	}());
	exports.RaceOperator = RaceOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var RaceSubscriber = (function (_super) {
	    __extends(RaceSubscriber, _super);
	    function RaceSubscriber(destination) {
	        _super.call(this, destination);
	        this.hasFirst = false;
	        this.observables = [];
	        this.subscriptions = [];
	    }
	    RaceSubscriber.prototype._next = function (observable) {
	        this.observables.push(observable);
	    };
	    RaceSubscriber.prototype._complete = function () {
	        var observables = this.observables;
	        var len = observables.length;
	        if (len === 0) {
	            this.destination.complete();
	        }
	        else {
	            for (var i = 0; i < len && !this.hasFirst; i++) {
	                var observable = observables[i];
	                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);
	                if (this.subscriptions) {
	                    this.subscriptions.push(subscription);
	                }
	                this.add(subscription);
	            }
	            this.observables = null;
	        }
	    };
	    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (!this.hasFirst) {
	            this.hasFirst = true;
	            for (var i = 0; i < this.subscriptions.length; i++) {
	                if (i !== outerIndex) {
	                    var subscription = this.subscriptions[i];
	                    subscription.unsubscribe();
	                    this.remove(subscription);
	                }
	            }
	            this.subscriptions = null;
	        }
	        this.destination.next(innerValue);
	    };
	    return RaceSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.RaceSubscriber = RaceSubscriber;


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var async_1 = __webpack_require__(10);
	/**
	 * @param scheduler
	 * @return {Observable<TimeInterval<any>>|WebSocketSubject<T>|Observable<T>}
	 * @method timeInterval
	 * @owner Observable
	 */
	function timeInterval(scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new TimeIntervalOperator(scheduler));
	}
	exports.timeInterval = timeInterval;
	var TimeInterval = (function () {
	    function TimeInterval(value, interval) {
	        this.value = value;
	        this.interval = interval;
	    }
	    return TimeInterval;
	}());
	exports.TimeInterval = TimeInterval;
	;
	var TimeIntervalOperator = (function () {
	    function TimeIntervalOperator(scheduler) {
	        this.scheduler = scheduler;
	    }
	    TimeIntervalOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new TimeIntervalSubscriber(observer, this.scheduler));
	    };
	    return TimeIntervalOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TimeIntervalSubscriber = (function (_super) {
	    __extends(TimeIntervalSubscriber, _super);
	    function TimeIntervalSubscriber(destination, scheduler) {
	        _super.call(this, destination);
	        this.scheduler = scheduler;
	        this.lastTime = 0;
	        this.lastTime = scheduler.now();
	    }
	    TimeIntervalSubscriber.prototype._next = function (value) {
	        var now = this.scheduler.now();
	        var span = now - this.lastTime;
	        this.lastTime = now;
	        this.destination.next(new TimeInterval(value, span));
	    };
	    return TimeIntervalSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var async_1 = __webpack_require__(10);
	/**
	 * @param scheduler
	 * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}
	 * @method timestamp
	 * @owner Observable
	 */
	function timestamp(scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new TimestampOperator(scheduler));
	}
	exports.timestamp = timestamp;
	var Timestamp = (function () {
	    function Timestamp(value, timestamp) {
	        this.value = value;
	        this.timestamp = timestamp;
	    }
	    return Timestamp;
	}());
	exports.Timestamp = Timestamp;
	;
	var TimestampOperator = (function () {
	    function TimestampOperator(scheduler) {
	        this.scheduler = scheduler;
	    }
	    TimestampOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new TimestampSubscriber(observer, this.scheduler));
	    };
	    return TimestampOperator;
	}());
	var TimestampSubscriber = (function (_super) {
	    __extends(TimestampSubscriber, _super);
	    function TimestampSubscriber(destination, scheduler) {
	        _super.call(this, destination);
	        this.scheduler = scheduler;
	    }
	    TimestampSubscriber.prototype._next = function (value) {
	        var now = this.scheduler.now();
	        this.destination.next(new Timestamp(value, now));
	    };
	    return TimestampSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsyncAction_1 = __webpack_require__(17);
	var AsyncScheduler_1 = __webpack_require__(18);
	var VirtualTimeScheduler = (function (_super) {
	    __extends(VirtualTimeScheduler, _super);
	    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
	        var _this = this;
	        if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }
	        if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }
	        _super.call(this, SchedulerAction, function () { return _this.frame; });
	        this.maxFrames = maxFrames;
	        this.frame = 0;
	        this.index = -1;
	    }
	    /**
	     * Prompt the Scheduler to execute all of its queued actions, therefore
	     * clearing its queue.
	     * @return {void}
	     */
	    VirtualTimeScheduler.prototype.flush = function () {
	        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
	        var error, action;
	        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {
	            if (error = action.execute(action.state, action.delay)) {
	                break;
	            }
	        }
	        if (error) {
	            while (action = actions.shift()) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    VirtualTimeScheduler.frameTimeFactor = 10;
	    return VirtualTimeScheduler;
	}(AsyncScheduler_1.AsyncScheduler));
	exports.VirtualTimeScheduler = VirtualTimeScheduler;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var VirtualAction = (function (_super) {
	    __extends(VirtualAction, _super);
	    function VirtualAction(scheduler, work, index) {
	        if (index === void 0) { index = scheduler.index += 1; }
	        _super.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	        this.index = index;
	        this.active = true;
	        this.index = scheduler.index = index;
	    }
	    VirtualAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (!this.id) {
	            return _super.prototype.schedule.call(this, state, delay);
	        }
	        this.active = false;
	        // If an action is rescheduled, we save allocations by mutating its state,
	        // pushing it to the end of the scheduler queue, and recycling the action.
	        // But since the VirtualTimeScheduler is used for testing, VirtualActions
	        // must be immutable so they can be inspected later.
	        var action = new VirtualAction(this.scheduler, this.work);
	        this.add(action);
	        return action.schedule(state, delay);
	    };
	    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        this.delay = scheduler.frame + delay;
	        var actions = scheduler.actions;
	        actions.push(this);
	        actions.sort(VirtualAction.sortActions);
	        return true;
	    };
	    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        return undefined;
	    };
	    VirtualAction.prototype._execute = function (state, delay) {
	        if (this.active === true) {
	            return _super.prototype._execute.call(this, state, delay);
	        }
	    };
	    VirtualAction.sortActions = function (a, b) {
	        if (a.delay === b.delay) {
	            if (a.index === b.index) {
	                return 0;
	            }
	            else if (a.index > b.index) {
	                return 1;
	            }
	            else {
	                return -1;
	            }
	        }
	        else if (a.delay > b.delay) {
	            return 1;
	        }
	        else {
	            return -1;
	        }
	    };
	    return VirtualAction;
	}(AsyncAction_1.AsyncAction));
	exports.VirtualAction = VirtualAction;


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AsapAction_1 = __webpack_require__(328);
	var AsapScheduler_1 = __webpack_require__(329);
	/**
	 *
	 * Asap Scheduler
	 *
	 * <span class="informal">Perform task as fast as it can be performed asynchronously</span>
	 *
	 * `asap` scheduler behaves the same as {@link async} scheduler when you use it to delay task
	 * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing
	 * code to end and then it will try to execute given task as fast as possible.
	 *
	 * `asap` scheduler will do its best to minimize time between end of currently executing code
	 * and start of scheduled task. This makes it best candidate for performing so called "deferring".
	 * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves
	 * some (although minimal) unwanted delay.
	 *
	 * Note that using `asap` scheduler does not necessarily mean that your task will be first to process
	 * after currently executing code. In particular, if some task was also scheduled with `asap` before,
	 * that task will execute first. That being said, if you need to schedule task asynchronously, but
	 * as soon as possible, `asap` scheduler is your best bet.
	 *
	 * @example <caption>Compare async and asap scheduler</caption>
	 *
	 * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...
	 * Rx.Scheduler.asap.schedule(() => console.log('asap'));
	 *
	 * // Logs:
	 * // "asap"
	 * // "async"
	 * // ... but 'asap' goes first!
	 *
	 * @static true
	 * @name asap
	 * @owner Scheduler
	 */
	exports.asap = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var QueueAction_1 = __webpack_require__(330);
	var QueueScheduler_1 = __webpack_require__(331);
	/**
	 *
	 * Queue Scheduler
	 *
	 * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
	 *
	 * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.
	 *
	 * When used without delay, it schedules given task synchronously - executes it right when
	 * it is scheduled. However when called recursively, that is when inside the scheduled task,
	 * another task is scheduled with queue scheduler, instead of executing immediately as well,
	 * that task will be put on a queue and wait for current one to finish.
	 *
	 * This means that when you execute task with `queue` scheduler, you are sure it will end
	 * before any other task scheduled with that scheduler will start.
	 *
	 * @examples <caption>Schedule recursively first, then do something</caption>
	 *
	 * Rx.Scheduler.queue.schedule(() => {
	 *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
	 *
	 *   console.log('first');
	 * });
	 *
	 * // Logs:
	 * // "first"
	 * // "second"
	 *
	 *
	 * @example <caption>Reschedule itself recursively</caption>
	 *
	 * Rx.Scheduler.queue.schedule(function(state) {
	 *   if (state !== 0) {
	 *     console.log('before', state);
	 *     this.schedule(state - 1); // `this` references currently executing Action,
	 *                               // which we reschedule with new state
	 *     console.log('after', state);
	 *   }
	 * }, 0, 3);
	 *
	 * // In scheduler that runs recursively, you would expect:
	 * // "before", 3
	 * // "before", 2
	 * // "before", 1
	 * // "after", 1
	 * // "after", 2
	 * // "after", 3
	 *
	 * // But with queue it logs:
	 * // "before", 3
	 * // "after", 3
	 * // "before", 2
	 * // "after", 2
	 * // "before", 1
	 * // "after", 1
	 *
	 *
	 * @static true
	 * @name queue
	 * @owner Scheduler
	 */
	exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);


/***/ },
/* 58 */
/***/ function(module, exports) {

	"use strict";
	var SubscriptionLog = (function () {
	    function SubscriptionLog(subscribedFrame, unsubscribedFrame) {
	        if (unsubscribedFrame === void 0) { unsubscribedFrame = Number.POSITIVE_INFINITY; }
	        this.subscribedFrame = subscribedFrame;
	        this.unsubscribedFrame = unsubscribedFrame;
	    }
	    return SubscriptionLog;
	}());
	exports.SubscriptionLog = SubscriptionLog;


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var SubscriptionLog_1 = __webpack_require__(58);
	var SubscriptionLoggable = (function () {
	    function SubscriptionLoggable() {
	        this.subscriptions = [];
	    }
	    SubscriptionLoggable.prototype.logSubscribedFrame = function () {
	        this.subscriptions.push(new SubscriptionLog_1.SubscriptionLog(this.scheduler.now()));
	        return this.subscriptions.length - 1;
	    };
	    SubscriptionLoggable.prototype.logUnsubscribedFrame = function (index) {
	        var subscriptionLogs = this.subscriptions;
	        var oldSubscriptionLog = subscriptionLogs[index];
	        subscriptionLogs[index] = new SubscriptionLog_1.SubscriptionLog(oldSubscriptionLog.subscribedFrame, this.scheduler.now());
	    };
	    return SubscriptionLoggable;
	}());
	exports.SubscriptionLoggable = SubscriptionLoggable;


/***/ },
/* 60 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when duetime elapses.
	 *
	 * @see {@link timeout}
	 *
	 * @class TimeoutError
	 */
	var TimeoutError = (function (_super) {
	    __extends(TimeoutError, _super);
	    function TimeoutError() {
	        var err = _super.call(this, 'Timeout has occurred');
	        this.name = err.name = 'TimeoutError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return TimeoutError;
	}(Error));
	exports.TimeoutError = TimeoutError;


/***/ },
/* 61 */
/***/ function(module, exports) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	/**
	 * An error thrown when one or more errors have occurred during the
	 * `unsubscribe` of a {@link Subscription}.
	 */
	var UnsubscriptionError = (function (_super) {
	    __extends(UnsubscriptionError, _super);
	    function UnsubscriptionError(errors) {
	        _super.call(this);
	        this.errors = errors;
	        var err = Error.call(this, errors ?
	            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return ((i + 1) + ") " + err.toString()); }).join('\n  ') : '');
	        this.name = err.name = 'UnsubscriptionError';
	        this.stack = err.stack;
	        this.message = err.message;
	    }
	    return UnsubscriptionError;
	}(Error));
	exports.UnsubscriptionError = UnsubscriptionError;


/***/ },
/* 62 */
/***/ function(module, exports) {

	"use strict";
	function applyMixins(derivedCtor, baseCtors) {
	    for (var i = 0, len = baseCtors.length; i < len; i++) {
	        var baseCtor = baseCtors[i];
	        var propertyKeys = Object.getOwnPropertyNames(baseCtor.prototype);
	        for (var j = 0, len2 = propertyKeys.length; j < len2; j++) {
	            var name_1 = propertyKeys[j];
	            derivedCtor.prototype[name_1] = baseCtor.prototype[name_1];
	        }
	    }
	}
	exports.applyMixins = applyMixins;


/***/ },
/* 63 */
/***/ function(module, exports) {

	"use strict";
	exports.isArrayLike = (function (x) { return x && typeof x.length === 'number'; });


/***/ },
/* 64 */
/***/ function(module, exports) {

	"use strict";
	function isObject(x) {
	    return x != null && typeof x === 'object';
	}
	exports.isObject = isObject;


/***/ },
/* 65 */
/***/ function(module, exports) {

	"use strict";
	function isPromise(value) {
	    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
	}
	exports.isPromise = isPromise;


/***/ },
/* 66 */
/***/ function(module, exports) {

	"use strict";
	/* tslint:disable:no-empty */
	function noop() { }
	exports.noop = noop;


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	var apply = Function.prototype.apply;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) {
	  if (timeout) {
	    timeout.close();
	  }
	};
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// setimmediate attaches itself to the global object
	__webpack_require__(345);
	exports.setImmediate = setImmediate;
	exports.clearImmediate = clearImmediate;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _Rx = __webpack_require__(71);
	
	var _Rx2 = _interopRequireDefault(_Rx);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var colors = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];
	var name = ['blue', 'red', 'yellow', 'green', 'black', 'white', 'gray', 'pink', '#3D262A', '#127C56'];
	var nameList = [{ src: './images/1.jpg', name: '史考特' }, { src: './images/2.jpg', name: '立涵' }, { src: './images/3.jpg', name: '先豪' }, { src: './images/4.jpg', name: '辰豪' }, { src: './images/5.jpg', name: '筱涵' }, { src: './images/6.jpg', name: '士豪' }, { src: './images/7.jpg', name: '鄭立文' }, { src: './images/8.jpg', name: '大寶哥' }, { src: './images/9.jpg', name: '祐誠' }, { src: './images/10.jpg', name: '維尼' }, { src: './images/1.jpg', name: '史考特' }, { src: './images/2.jpg', name: '立涵' }, { src: './images/3.jpg', name: '先豪' }, { src: './images/4.jpg', name: '辰豪' }, { src: './images/5.jpg', name: '筱涵' }, { src: './images/6.jpg', name: '士豪' }, { src: './images/7.jpg', name: '鄭立文' }, { src: './images/8.jpg', name: '大寶哥' }, { src: './images/9.jpg', name: '祐誠' }, { src: './images/10.jpg', name: '維尼' }];
	var start = document.getElementById('arm');
	var stop = document.getElementById('stop');
	var startClick = _Rx2.default.Observable.fromEvent(start, 'click');
	var stopClick = _Rx2.default.Observable.fromEvent(stop, 'click');
	var timer = function timer(speed) {
	  return _Rx2.default.Observable.timer(100 + speed);
	};
	var source = function source(RandomNumbers) {
	  return _Rx2.default.Observable.interval(100).take(RandomNumbers).map(function (e) {
	    return timer(e * 10).map(function () {
	      return e;
	    });
	  }).concatAll().takeUntil(stopClick).do({
	    next: function next(e) {
	      // const slot = Math.floor(Math.random() * 20);
	      // const top = -slot * 300;
	      var top = e * -300;
	      if ($('#slotmachine img').length < 50) {
	        var imgElement = document.createElement('img');
	        imgElement.src = nameList[e % 20].src;
	        imgElement.name = nameList[e % 20].name;
	        imgElement.class = 'color';
	        document.getElementById('slotmachine').appendChild(imgElement);
	      }
	      TweenLite.to($('#slotmachine'), 2.5, { ease: Bounce.easeOut, y: top - 300 });
	      $('.colorRed').removeClass('colorRed');
	      // const maxNum = e;
	      // const minNum = 0;
	      // const index = Math.floor(Math.random() * (maxNum - minNum + 1)) + minNum;
	      // $('#reel')[0].src = nameList[index % nameList.length].src;
	
	      // $(`#circle_0${colors[index]}`).addClass('colorRed');
	      $('#circle_0' + e % 20).addClass('colorRed');
	    },
	    complete: function complete() {
	      $('#arm').removeClass('disabledButton');
	      // TweenLite.to($('#slotmachine'), 2.5, { ease: Bounce.easeOut, y: top });
	      setTimeout(function () {
	        return alert($('.colorRed')[0].name);
	      }, 2500);
	    }
	  });
	};
	startClick.map(function () {
	  $('#arm').addClass('clicked');
	  $('#arm')[0].disabled = true;
	  //setTimeout(() => { arm.removeClass; }, 500);
	  TweenLite.to($('#slotmachine'), 0.5, { ease: Power0.easeNone, y: 0 });
	  var RandomNumbers = Math.floor(Math.random() * 10) + 30;
	  return source(RandomNumbers);
	}).delay(1000).concatAll().subscribe({
	  next: function next() {
	    $('#arm').removeClass('clicked');
	    $('#arm').addClass('disabledButton');
	  },
	  complete: function complete() {
	    $('#arm').removeClass('disabledButton');
	  }
	});

/***/ },
/* 69 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var InnerSubscriber = (function (_super) {
	    __extends(InnerSubscriber, _super);
	    function InnerSubscriber(parent, outerValue, outerIndex) {
	        _super.call(this);
	        this.parent = parent;
	        this.outerValue = outerValue;
	        this.outerIndex = outerIndex;
	        this.index = 0;
	    }
	    InnerSubscriber.prototype._next = function (value) {
	        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
	    };
	    InnerSubscriber.prototype._error = function (error) {
	        this.parent.notifyError(error, this);
	        this.unsubscribe();
	    };
	    InnerSubscriber.prototype._complete = function () {
	        this.parent.notifyComplete(this);
	        this.unsubscribe();
	    };
	    return InnerSubscriber;
	}(Subscriber_1.Subscriber));
	exports.InnerSubscriber = InnerSubscriber;


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/* tslint:disable:no-unused-variable */
	// Subject imported before Observable to bypass circular dependency issue since
	// Subject extends Observable and Observable references Subject in it's
	// definition
	var Subject_1 = __webpack_require__(6);
	exports.Subject = Subject_1.Subject;
	exports.AnonymousSubject = Subject_1.AnonymousSubject;
	/* tslint:enable:no-unused-variable */
	var Observable_1 = __webpack_require__(1);
	exports.Observable = Observable_1.Observable;
	// statics
	/* tslint:disable:no-use-before-declare */
	__webpack_require__(73);
	__webpack_require__(74);
	__webpack_require__(75);
	__webpack_require__(76);
	__webpack_require__(77);
	__webpack_require__(80);
	__webpack_require__(81);
	__webpack_require__(82);
	__webpack_require__(83);
	__webpack_require__(84);
	__webpack_require__(85);
	__webpack_require__(86);
	__webpack_require__(87);
	__webpack_require__(88);
	__webpack_require__(89);
	__webpack_require__(94);
	__webpack_require__(90);
	__webpack_require__(91);
	__webpack_require__(92);
	__webpack_require__(93);
	__webpack_require__(95);
	__webpack_require__(98);
	__webpack_require__(96);
	__webpack_require__(97);
	__webpack_require__(99);
	//dom
	__webpack_require__(78);
	__webpack_require__(79);
	//operators
	__webpack_require__(102);
	__webpack_require__(103);
	__webpack_require__(104);
	__webpack_require__(105);
	__webpack_require__(106);
	__webpack_require__(107);
	__webpack_require__(108);
	__webpack_require__(109);
	__webpack_require__(110);
	__webpack_require__(111);
	__webpack_require__(112);
	__webpack_require__(113);
	__webpack_require__(114);
	__webpack_require__(120);
	__webpack_require__(115);
	__webpack_require__(116);
	__webpack_require__(117);
	__webpack_require__(118);
	__webpack_require__(119);
	__webpack_require__(121);
	__webpack_require__(122);
	__webpack_require__(123);
	__webpack_require__(124);
	__webpack_require__(127);
	__webpack_require__(128);
	__webpack_require__(129);
	__webpack_require__(125);
	__webpack_require__(130);
	__webpack_require__(131);
	__webpack_require__(132);
	__webpack_require__(133);
	__webpack_require__(134);
	__webpack_require__(135);
	__webpack_require__(136);
	__webpack_require__(137);
	__webpack_require__(100);
	__webpack_require__(101);
	__webpack_require__(138);
	__webpack_require__(139);
	__webpack_require__(126);
	__webpack_require__(140);
	__webpack_require__(141);
	__webpack_require__(142);
	__webpack_require__(143);
	__webpack_require__(144);
	__webpack_require__(145);
	__webpack_require__(146);
	__webpack_require__(147);
	__webpack_require__(148);
	__webpack_require__(149);
	__webpack_require__(150);
	__webpack_require__(151);
	__webpack_require__(152);
	__webpack_require__(153);
	__webpack_require__(154);
	__webpack_require__(155);
	__webpack_require__(156);
	__webpack_require__(157);
	__webpack_require__(159);
	__webpack_require__(158);
	__webpack_require__(160);
	__webpack_require__(161);
	__webpack_require__(162);
	__webpack_require__(163);
	__webpack_require__(164);
	__webpack_require__(165);
	__webpack_require__(166);
	__webpack_require__(167);
	__webpack_require__(168);
	__webpack_require__(169);
	__webpack_require__(170);
	__webpack_require__(171);
	__webpack_require__(172);
	__webpack_require__(173);
	__webpack_require__(174);
	__webpack_require__(175);
	__webpack_require__(176);
	__webpack_require__(177);
	__webpack_require__(178);
	__webpack_require__(179);
	__webpack_require__(180);
	__webpack_require__(181);
	__webpack_require__(182);
	__webpack_require__(183);
	__webpack_require__(184);
	__webpack_require__(185);
	__webpack_require__(186);
	__webpack_require__(187);
	__webpack_require__(188);
	__webpack_require__(189);
	__webpack_require__(190);
	__webpack_require__(191);
	__webpack_require__(192);
	__webpack_require__(193);
	__webpack_require__(194);
	__webpack_require__(195);
	__webpack_require__(196);
	__webpack_require__(197);
	__webpack_require__(198);
	__webpack_require__(199);
	/* tslint:disable:no-unused-variable */
	var Subscription_1 = __webpack_require__(5);
	exports.Subscription = Subscription_1.Subscription;
	var Subscriber_1 = __webpack_require__(2);
	exports.Subscriber = Subscriber_1.Subscriber;
	var AsyncSubject_1 = __webpack_require__(20);
	exports.AsyncSubject = AsyncSubject_1.AsyncSubject;
	var ReplaySubject_1 = __webpack_require__(30);
	exports.ReplaySubject = ReplaySubject_1.ReplaySubject;
	var BehaviorSubject_1 = __webpack_require__(38);
	exports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;
	var ConnectableObservable_1 = __webpack_require__(41);
	exports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;
	var Notification_1 = __webpack_require__(16);
	exports.Notification = Notification_1.Notification;
	var EmptyError_1 = __webpack_require__(25);
	exports.EmptyError = EmptyError_1.EmptyError;
	var ArgumentOutOfRangeError_1 = __webpack_require__(24);
	exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
	var ObjectUnsubscribedError_1 = __webpack_require__(26);
	exports.ObjectUnsubscribedError = ObjectUnsubscribedError_1.ObjectUnsubscribedError;
	var TimeoutError_1 = __webpack_require__(60);
	exports.TimeoutError = TimeoutError_1.TimeoutError;
	var UnsubscriptionError_1 = __webpack_require__(61);
	exports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;
	var timeInterval_1 = __webpack_require__(53);
	exports.TimeInterval = timeInterval_1.TimeInterval;
	var timestamp_1 = __webpack_require__(54);
	exports.Timestamp = timestamp_1.Timestamp;
	var TestScheduler_1 = __webpack_require__(335);
	exports.TestScheduler = TestScheduler_1.TestScheduler;
	var VirtualTimeScheduler_1 = __webpack_require__(55);
	exports.VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;
	var AjaxObservable_1 = __webpack_require__(44);
	exports.AjaxResponse = AjaxObservable_1.AjaxResponse;
	exports.AjaxError = AjaxObservable_1.AjaxError;
	exports.AjaxTimeoutError = AjaxObservable_1.AjaxTimeoutError;
	var asap_1 = __webpack_require__(56);
	var async_1 = __webpack_require__(10);
	var queue_1 = __webpack_require__(57);
	var animationFrame_1 = __webpack_require__(332);
	var rxSubscriber_1 = __webpack_require__(23);
	var iterator_1 = __webpack_require__(19);
	var observable_1 = __webpack_require__(22);
	/* tslint:enable:no-unused-variable */
	/**
	 * @typedef {Object} Rx.Scheduler
	 * @property {Scheduler} queue Schedules on a queue in the current event frame
	 * (trampoline scheduler). Use this for iteration operations.
	 * @property {Scheduler} asap Schedules on the micro task queue, which uses the
	 * fastest transport mechanism available, either Node.js' `process.nextTick()`
	 * or Web Worker MessageChannel or setTimeout or others. Use this for
	 * asynchronous conversions.
	 * @property {Scheduler} async Schedules work with `setInterval`. Use this for
	 * time-based operations.
	 * @property {Scheduler} animationFrame Schedules work with `requestAnimationFrame`.
	 * Use this for synchronizing with the platform's painting
	 */
	var Scheduler = {
	    asap: asap_1.asap,
	    queue: queue_1.queue,
	    animationFrame: animationFrame_1.animationFrame,
	    async: async_1.async
	};
	exports.Scheduler = Scheduler;
	/**
	 * @typedef {Object} Rx.Symbol
	 * @property {Symbol|string} rxSubscriber A symbol to use as a property name to
	 * retrieve an "Rx safe" Observer from an object. "Rx safety" can be defined as
	 * an object that has all of the traits of an Rx Subscriber, including the
	 * ability to add and remove subscriptions to the subscription chain and
	 * guarantees involving event triggering (can't "next" after unsubscription,
	 * etc).
	 * @property {Symbol|string} observable A symbol to use as a property name to
	 * retrieve an Observable as defined by the [ECMAScript "Observable" spec](https://github.com/zenparsing/es-observable).
	 * @property {Symbol|string} iterator The ES6 symbol to use as a property name
	 * to retrieve an iterator from an object.
	 */
	var Symbol = {
	    rxSubscriber: rxSubscriber_1.rxSubscriber,
	    observable: observable_1.observable,
	    iterator: iterator_1.iterator
	};
	exports.Symbol = Symbol;


/***/ },
/* 72 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * An execution context and a data structure to order tasks and schedule their
	 * execution. Provides a notion of (potentially virtual) time, through the
	 * `now()` getter method.
	 *
	 * Each unit of work in a Scheduler is called an {@link Action}.
	 *
	 * ```ts
	 * class Scheduler {
	 *   now(): number;
	 *   schedule(work, delay?, state?): Subscription;
	 * }
	 * ```
	 *
	 * @class Scheduler
	 */
	var Scheduler = (function () {
	    function Scheduler(SchedulerAction, now) {
	        if (now === void 0) { now = Scheduler.now; }
	        this.SchedulerAction = SchedulerAction;
	        this.now = now;
	    }
	    /**
	     * Schedules a function, `work`, for execution. May happen at some point in
	     * the future, according to the `delay` parameter, if specified. May be passed
	     * some context object, `state`, which will be passed to the `work` function.
	     *
	     * The given arguments will be processed an stored as an Action object in a
	     * queue of actions.
	     *
	     * @param {function(state: ?T): ?Subscription} work A function representing a
	     * task, or some unit of work to be executed by the Scheduler.
	     * @param {number} [delay] Time to wait before executing the work, where the
	     * time unit is implicit and defined by the Scheduler itself.
	     * @param {T} [state] Some contextual data that the `work` function uses when
	     * called by the Scheduler.
	     * @return {Subscription} A subscription in order to be able to unsubscribe
	     * the scheduled work.
	     */
	    Scheduler.prototype.schedule = function (work, delay, state) {
	        if (delay === void 0) { delay = 0; }
	        return new this.SchedulerAction(this, work).schedule(state, delay);
	    };
	    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };
	    return Scheduler;
	}());
	exports.Scheduler = Scheduler;


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var bindCallback_1 = __webpack_require__(218);
	Observable_1.Observable.bindCallback = bindCallback_1.bindCallback;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var bindNodeCallback_1 = __webpack_require__(219);
	Observable_1.Observable.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var combineLatest_1 = __webpack_require__(220);
	Observable_1.Observable.combineLatest = combineLatest_1.combineLatest;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var concat_1 = __webpack_require__(221);
	Observable_1.Observable.concat = concat_1.concat;


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var defer_1 = __webpack_require__(222);
	Observable_1.Observable.defer = defer_1.defer;


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var ajax_1 = __webpack_require__(224);
	Observable_1.Observable.ajax = ajax_1.ajax;


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var webSocket_1 = __webpack_require__(225);
	Observable_1.Observable.webSocket = webSocket_1.webSocket;


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var empty_1 = __webpack_require__(226);
	Observable_1.Observable.empty = empty_1.empty;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var forkJoin_1 = __webpack_require__(227);
	Observable_1.Observable.forkJoin = forkJoin_1.forkJoin;


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var from_1 = __webpack_require__(228);
	Observable_1.Observable.from = from_1.from;


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var fromEvent_1 = __webpack_require__(229);
	Observable_1.Observable.fromEvent = fromEvent_1.fromEvent;


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var fromEventPattern_1 = __webpack_require__(230);
	Observable_1.Observable.fromEventPattern = fromEventPattern_1.fromEventPattern;


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var fromPromise_1 = __webpack_require__(231);
	Observable_1.Observable.fromPromise = fromPromise_1.fromPromise;


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var GenerateObservable_1 = __webpack_require__(208);
	Observable_1.Observable.generate = GenerateObservable_1.GenerateObservable.create;


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var if_1 = __webpack_require__(232);
	Observable_1.Observable.if = if_1._if;


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var interval_1 = __webpack_require__(233);
	Observable_1.Observable.interval = interval_1.interval;


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var merge_1 = __webpack_require__(234);
	Observable_1.Observable.merge = merge_1.merge;


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var never_1 = __webpack_require__(235);
	Observable_1.Observable.never = never_1.never;


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var of_1 = __webpack_require__(236);
	Observable_1.Observable.of = of_1.of;


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var onErrorResumeNext_1 = __webpack_require__(51);
	Observable_1.Observable.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNextStatic;


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var pairs_1 = __webpack_require__(237);
	Observable_1.Observable.pairs = pairs_1.pairs;


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var race_1 = __webpack_require__(52);
	Observable_1.Observable.race = race_1.raceStatic;


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var range_1 = __webpack_require__(238);
	Observable_1.Observable.range = range_1.range;


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var throw_1 = __webpack_require__(239);
	Observable_1.Observable.throw = throw_1._throw;


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var timer_1 = __webpack_require__(240);
	Observable_1.Observable.timer = timer_1.timer;


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var using_1 = __webpack_require__(241);
	Observable_1.Observable.using = using_1.using;


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var zip_1 = __webpack_require__(242);
	Observable_1.Observable.zip = zip_1.zip;


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var audit_1 = __webpack_require__(243);
	Observable_1.Observable.prototype.audit = audit_1.audit;


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var auditTime_1 = __webpack_require__(244);
	Observable_1.Observable.prototype.auditTime = auditTime_1.auditTime;


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var buffer_1 = __webpack_require__(245);
	Observable_1.Observable.prototype.buffer = buffer_1.buffer;


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var bufferCount_1 = __webpack_require__(246);
	Observable_1.Observable.prototype.bufferCount = bufferCount_1.bufferCount;


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var bufferTime_1 = __webpack_require__(247);
	Observable_1.Observable.prototype.bufferTime = bufferTime_1.bufferTime;


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var bufferToggle_1 = __webpack_require__(248);
	Observable_1.Observable.prototype.bufferToggle = bufferToggle_1.bufferToggle;


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var bufferWhen_1 = __webpack_require__(249);
	Observable_1.Observable.prototype.bufferWhen = bufferWhen_1.bufferWhen;


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var catch_1 = __webpack_require__(250);
	Observable_1.Observable.prototype.catch = catch_1._catch;
	Observable_1.Observable.prototype._catch = catch_1._catch;


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var combineAll_1 = __webpack_require__(251);
	Observable_1.Observable.prototype.combineAll = combineAll_1.combineAll;


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var combineLatest_1 = __webpack_require__(32);
	Observable_1.Observable.prototype.combineLatest = combineLatest_1.combineLatest;


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var concat_1 = __webpack_require__(33);
	Observable_1.Observable.prototype.concat = concat_1.concat;


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var concatAll_1 = __webpack_require__(252);
	Observable_1.Observable.prototype.concatAll = concatAll_1.concatAll;


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var concatMap_1 = __webpack_require__(253);
	Observable_1.Observable.prototype.concatMap = concatMap_1.concatMap;


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var concatMapTo_1 = __webpack_require__(254);
	Observable_1.Observable.prototype.concatMapTo = concatMapTo_1.concatMapTo;


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var count_1 = __webpack_require__(255);
	Observable_1.Observable.prototype.count = count_1.count;


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var debounce_1 = __webpack_require__(256);
	Observable_1.Observable.prototype.debounce = debounce_1.debounce;


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var debounceTime_1 = __webpack_require__(257);
	Observable_1.Observable.prototype.debounceTime = debounceTime_1.debounceTime;


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var defaultIfEmpty_1 = __webpack_require__(258);
	Observable_1.Observable.prototype.defaultIfEmpty = defaultIfEmpty_1.defaultIfEmpty;


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var delay_1 = __webpack_require__(259);
	Observable_1.Observable.prototype.delay = delay_1.delay;


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var delayWhen_1 = __webpack_require__(260);
	Observable_1.Observable.prototype.delayWhen = delayWhen_1.delayWhen;


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var dematerialize_1 = __webpack_require__(261);
	Observable_1.Observable.prototype.dematerialize = dematerialize_1.dematerialize;


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var distinct_1 = __webpack_require__(262);
	Observable_1.Observable.prototype.distinct = distinct_1.distinct;


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var distinctUntilChanged_1 = __webpack_require__(45);
	Observable_1.Observable.prototype.distinctUntilChanged = distinctUntilChanged_1.distinctUntilChanged;


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var distinctUntilKeyChanged_1 = __webpack_require__(263);
	Observable_1.Observable.prototype.distinctUntilKeyChanged = distinctUntilKeyChanged_1.distinctUntilKeyChanged;


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var do_1 = __webpack_require__(264);
	Observable_1.Observable.prototype.do = do_1._do;
	Observable_1.Observable.prototype._do = do_1._do;


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var elementAt_1 = __webpack_require__(265);
	Observable_1.Observable.prototype.elementAt = elementAt_1.elementAt;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var every_1 = __webpack_require__(266);
	Observable_1.Observable.prototype.every = every_1.every;


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var exhaust_1 = __webpack_require__(267);
	Observable_1.Observable.prototype.exhaust = exhaust_1.exhaust;


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var exhaustMap_1 = __webpack_require__(268);
	Observable_1.Observable.prototype.exhaustMap = exhaustMap_1.exhaustMap;


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var expand_1 = __webpack_require__(269);
	Observable_1.Observable.prototype.expand = expand_1.expand;


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var filter_1 = __webpack_require__(46);
	Observable_1.Observable.prototype.filter = filter_1.filter;


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var finally_1 = __webpack_require__(270);
	Observable_1.Observable.prototype.finally = finally_1._finally;
	Observable_1.Observable.prototype._finally = finally_1._finally;


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var find_1 = __webpack_require__(47);
	Observable_1.Observable.prototype.find = find_1.find;


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var findIndex_1 = __webpack_require__(271);
	Observable_1.Observable.prototype.findIndex = findIndex_1.findIndex;


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var first_1 = __webpack_require__(272);
	Observable_1.Observable.prototype.first = first_1.first;


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var groupBy_1 = __webpack_require__(273);
	Observable_1.Observable.prototype.groupBy = groupBy_1.groupBy;


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var ignoreElements_1 = __webpack_require__(274);
	Observable_1.Observable.prototype.ignoreElements = ignoreElements_1.ignoreElements;


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var isEmpty_1 = __webpack_require__(275);
	Observable_1.Observable.prototype.isEmpty = isEmpty_1.isEmpty;


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var last_1 = __webpack_require__(276);
	Observable_1.Observable.prototype.last = last_1.last;


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var let_1 = __webpack_require__(277);
	Observable_1.Observable.prototype.let = let_1.letProto;
	Observable_1.Observable.prototype.letBind = let_1.letProto;


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var map_1 = __webpack_require__(34);
	Observable_1.Observable.prototype.map = map_1.map;


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var mapTo_1 = __webpack_require__(278);
	Observable_1.Observable.prototype.mapTo = mapTo_1.mapTo;


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var materialize_1 = __webpack_require__(279);
	Observable_1.Observable.prototype.materialize = materialize_1.materialize;


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var max_1 = __webpack_require__(280);
	Observable_1.Observable.prototype.max = max_1.max;


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var merge_1 = __webpack_require__(48);
	Observable_1.Observable.prototype.merge = merge_1.merge;


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var mergeAll_1 = __webpack_require__(21);
	Observable_1.Observable.prototype.mergeAll = mergeAll_1.mergeAll;


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var mergeMap_1 = __webpack_require__(49);
	Observable_1.Observable.prototype.mergeMap = mergeMap_1.mergeMap;
	Observable_1.Observable.prototype.flatMap = mergeMap_1.mergeMap;


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var mergeMapTo_1 = __webpack_require__(50);
	Observable_1.Observable.prototype.flatMapTo = mergeMapTo_1.mergeMapTo;
	Observable_1.Observable.prototype.mergeMapTo = mergeMapTo_1.mergeMapTo;


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var mergeScan_1 = __webpack_require__(281);
	Observable_1.Observable.prototype.mergeScan = mergeScan_1.mergeScan;


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var min_1 = __webpack_require__(282);
	Observable_1.Observable.prototype.min = min_1.min;


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var multicast_1 = __webpack_require__(15);
	Observable_1.Observable.prototype.multicast = multicast_1.multicast;


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var observeOn_1 = __webpack_require__(35);
	Observable_1.Observable.prototype.observeOn = observeOn_1.observeOn;


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var onErrorResumeNext_1 = __webpack_require__(51);
	Observable_1.Observable.prototype.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var pairwise_1 = __webpack_require__(283);
	Observable_1.Observable.prototype.pairwise = pairwise_1.pairwise;


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var partition_1 = __webpack_require__(284);
	Observable_1.Observable.prototype.partition = partition_1.partition;


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var pluck_1 = __webpack_require__(285);
	Observable_1.Observable.prototype.pluck = pluck_1.pluck;


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var publish_1 = __webpack_require__(286);
	Observable_1.Observable.prototype.publish = publish_1.publish;


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var publishBehavior_1 = __webpack_require__(287);
	Observable_1.Observable.prototype.publishBehavior = publishBehavior_1.publishBehavior;


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var publishLast_1 = __webpack_require__(288);
	Observable_1.Observable.prototype.publishLast = publishLast_1.publishLast;


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var publishReplay_1 = __webpack_require__(289);
	Observable_1.Observable.prototype.publishReplay = publishReplay_1.publishReplay;


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var race_1 = __webpack_require__(52);
	Observable_1.Observable.prototype.race = race_1.race;


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var reduce_1 = __webpack_require__(36);
	Observable_1.Observable.prototype.reduce = reduce_1.reduce;


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var repeat_1 = __webpack_require__(290);
	Observable_1.Observable.prototype.repeat = repeat_1.repeat;


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var repeatWhen_1 = __webpack_require__(291);
	Observable_1.Observable.prototype.repeatWhen = repeatWhen_1.repeatWhen;


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var retry_1 = __webpack_require__(292);
	Observable_1.Observable.prototype.retry = retry_1.retry;


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var retryWhen_1 = __webpack_require__(293);
	Observable_1.Observable.prototype.retryWhen = retryWhen_1.retryWhen;


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var sample_1 = __webpack_require__(294);
	Observable_1.Observable.prototype.sample = sample_1.sample;


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var sampleTime_1 = __webpack_require__(295);
	Observable_1.Observable.prototype.sampleTime = sampleTime_1.sampleTime;


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var scan_1 = __webpack_require__(296);
	Observable_1.Observable.prototype.scan = scan_1.scan;


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var sequenceEqual_1 = __webpack_require__(297);
	Observable_1.Observable.prototype.sequenceEqual = sequenceEqual_1.sequenceEqual;


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var share_1 = __webpack_require__(298);
	Observable_1.Observable.prototype.share = share_1.share;


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var single_1 = __webpack_require__(299);
	Observable_1.Observable.prototype.single = single_1.single;


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var skip_1 = __webpack_require__(300);
	Observable_1.Observable.prototype.skip = skip_1.skip;


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var skipUntil_1 = __webpack_require__(301);
	Observable_1.Observable.prototype.skipUntil = skipUntil_1.skipUntil;


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var skipWhile_1 = __webpack_require__(302);
	Observable_1.Observable.prototype.skipWhile = skipWhile_1.skipWhile;


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var startWith_1 = __webpack_require__(303);
	Observable_1.Observable.prototype.startWith = startWith_1.startWith;


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var subscribeOn_1 = __webpack_require__(304);
	Observable_1.Observable.prototype.subscribeOn = subscribeOn_1.subscribeOn;


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var switch_1 = __webpack_require__(305);
	Observable_1.Observable.prototype.switch = switch_1._switch;
	Observable_1.Observable.prototype._switch = switch_1._switch;


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var switchMap_1 = __webpack_require__(306);
	Observable_1.Observable.prototype.switchMap = switchMap_1.switchMap;


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var switchMapTo_1 = __webpack_require__(307);
	Observable_1.Observable.prototype.switchMapTo = switchMapTo_1.switchMapTo;


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var take_1 = __webpack_require__(308);
	Observable_1.Observable.prototype.take = take_1.take;


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var takeLast_1 = __webpack_require__(309);
	Observable_1.Observable.prototype.takeLast = takeLast_1.takeLast;


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var takeUntil_1 = __webpack_require__(310);
	Observable_1.Observable.prototype.takeUntil = takeUntil_1.takeUntil;


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var takeWhile_1 = __webpack_require__(311);
	Observable_1.Observable.prototype.takeWhile = takeWhile_1.takeWhile;


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var throttle_1 = __webpack_require__(312);
	Observable_1.Observable.prototype.throttle = throttle_1.throttle;


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var throttleTime_1 = __webpack_require__(313);
	Observable_1.Observable.prototype.throttleTime = throttleTime_1.throttleTime;


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var timeInterval_1 = __webpack_require__(53);
	Observable_1.Observable.prototype.timeInterval = timeInterval_1.timeInterval;


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var timeout_1 = __webpack_require__(314);
	Observable_1.Observable.prototype.timeout = timeout_1.timeout;


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var timeoutWith_1 = __webpack_require__(315);
	Observable_1.Observable.prototype.timeoutWith = timeoutWith_1.timeoutWith;


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var timestamp_1 = __webpack_require__(54);
	Observable_1.Observable.prototype.timestamp = timestamp_1.timestamp;


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var toArray_1 = __webpack_require__(316);
	Observable_1.Observable.prototype.toArray = toArray_1.toArray;


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var toPromise_1 = __webpack_require__(317);
	Observable_1.Observable.prototype.toPromise = toPromise_1.toPromise;


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var window_1 = __webpack_require__(318);
	Observable_1.Observable.prototype.window = window_1.window;


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var windowCount_1 = __webpack_require__(319);
	Observable_1.Observable.prototype.windowCount = windowCount_1.windowCount;


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var windowTime_1 = __webpack_require__(320);
	Observable_1.Observable.prototype.windowTime = windowTime_1.windowTime;


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var windowToggle_1 = __webpack_require__(321);
	Observable_1.Observable.prototype.windowToggle = windowToggle_1.windowToggle;


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var windowWhen_1 = __webpack_require__(322);
	Observable_1.Observable.prototype.windowWhen = windowWhen_1.windowWhen;


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var withLatestFrom_1 = __webpack_require__(323);
	Observable_1.Observable.prototype.withLatestFrom = withLatestFrom_1.withLatestFrom;


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var zip_1 = __webpack_require__(37);
	Observable_1.Observable.prototype.zip = zip_1.zipProto;


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Observable_1 = __webpack_require__(1);
	var zipAll_1 = __webpack_require__(324);
	Observable_1.Observable.prototype.zipAll = zipAll_1.zipAll;


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	var ScalarObservable_1 = __webpack_require__(31);
	var EmptyObservable_1 = __webpack_require__(14);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ArrayLikeObservable = (function (_super) {
	    __extends(ArrayLikeObservable, _super);
	    function ArrayLikeObservable(arrayLike, scheduler) {
	        _super.call(this);
	        this.arrayLike = arrayLike;
	        this.scheduler = scheduler;
	        if (!scheduler && arrayLike.length === 1) {
	            this._isScalar = true;
	            this.value = arrayLike[0];
	        }
	    }
	    ArrayLikeObservable.create = function (arrayLike, scheduler) {
	        var length = arrayLike.length;
	        if (length === 0) {
	            return new EmptyObservable_1.EmptyObservable();
	        }
	        else if (length === 1) {
	            return new ScalarObservable_1.ScalarObservable(arrayLike[0], scheduler);
	        }
	        else {
	            return new ArrayLikeObservable(arrayLike, scheduler);
	        }
	    };
	    ArrayLikeObservable.dispatch = function (state) {
	        var arrayLike = state.arrayLike, index = state.index, length = state.length, subscriber = state.subscriber;
	        if (subscriber.closed) {
	            return;
	        }
	        if (index >= length) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(arrayLike[index]);
	        state.index = index + 1;
	        this.schedule(state);
	    };
	    ArrayLikeObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var _a = this, arrayLike = _a.arrayLike, scheduler = _a.scheduler;
	        var length = arrayLike.length;
	        if (scheduler) {
	            return scheduler.schedule(ArrayLikeObservable.dispatch, 0, {
	                arrayLike: arrayLike, index: index, length: length, subscriber: subscriber
	            });
	        }
	        else {
	            for (var i = 0; i < length && !subscriber.closed; i++) {
	                subscriber.next(arrayLike[i]);
	            }
	            subscriber.complete();
	        }
	    };
	    return ArrayLikeObservable;
	}(Observable_1.Observable));
	exports.ArrayLikeObservable = ArrayLikeObservable;


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	var tryCatch_1 = __webpack_require__(9);
	var errorObject_1 = __webpack_require__(7);
	var AsyncSubject_1 = __webpack_require__(20);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var BoundCallbackObservable = (function (_super) {
	    __extends(BoundCallbackObservable, _super);
	    function BoundCallbackObservable(callbackFunc, selector, args, context, scheduler) {
	        _super.call(this);
	        this.callbackFunc = callbackFunc;
	        this.selector = selector;
	        this.args = args;
	        this.context = context;
	        this.scheduler = scheduler;
	    }
	    /* tslint:enable:max-line-length */
	    /**
	     * Converts a callback API to a function that returns an Observable.
	     *
	     * <span class="informal">Give it a function `f` of type `f(x, callback)` and
	     * it will return a function `g` that when called as `g(x)` will output an
	     * Observable.</span>
	     *
	     * `bindCallback` is not an operator because its input and output are not
	     * Observables. The input is a function `func` with some parameters, but the
	     * last parameter must be a callback function that `func` calls when it is
	     * done.
	     *
	     * The output of `bindCallback` is a function that takes the same parameters
	     * as `func`, except the last one (the callback). When the output function
	     * is called with arguments, it will return an Observable. If `func` function
	     * calls its callback with one argument, the Observable will emit that value.
	     * If on the other hand callback is called with multiple values, resulting
	     * Observable will emit an array with these arguments.
	     *
	     * It is very important to remember, that input function `func` is not called
	     * when output function is, but rather when Observable returned by output
	     * function is subscribed. This means if `func` makes AJAX request, that request
	     * will be made every time someone subscribes to resulting Observable, but not before.
	     *
	     * Optionally, selector function can be passed to `bindObservable`. That function
	     * takes the same arguments as callback, and returns value
	     * that will be emitted by Observable instead of callback parameters themselves.
	     * Even though by default multiple arguments passed to callback appear in the stream as array,
	     * selector function will be called with arguments directly, just as callback would.
	     * This means you can imagine default selector (when one is not provided explicitly)
	     * as function that aggregates all its arguments into array, or simply returns first argument,
	     * if there is only one.
	     *
	     * Last optional parameter - {@link Scheduler} - can be used to control when call
	     * to `func` happens after someone subscribes to Observable, as well as when results
	     * passed to callback will be emitted. By default subscription to Observable calls `func`
	     * synchronously, but using `Scheduler.async` as last parameter will defer call to input function,
	     * just like wrapping that call in `setTimeout` with time `0` would. So if you use async Scheduler
	     * and call `subscribe` on output Observable, all function calls that are currently executing,
	     * will end before `func` is invoked.
	     *
	     * When it comes to emitting results passed to callback, by default they are emitted
	     * immediately after `func` invokes callback. In particular, if callback is called synchronously,
	     * then subscription to resulting Observable will call `next` function synchronously as well.
	     * If you want to defer that call, using `Scheduler.async` will, again, do the job.
	     * This means that by using `Scheduler.async` you can, in a sense, ensure that `func`
	     * always calls its callback asynchronously, thus avoiding terrifying Zalgo.
	     *
	     * Note that Observable created by output function will always emit only one value
	     * and then complete right after. Even if `func` calls callback multiple times, values from
	     * second and following calls will never appear in the stream. If you need to
	     * listen for multiple calls, you probably want to use {@link fromEvent} or
	     * {@link fromEventPattern} instead.
	     *
	     * If `func` depends on some context (`this` property), that context will be set
	     * to the same context that output function has at call time. In particular, if `func`
	     * is called as method of some object, in order to preserve proper behaviour,
	     * it is recommended to set context of output function to that object as well,
	     * provided `func` is not already bound.
	     *
	     * If input function calls its callback in "node style" (i.e. first argument to callback is
	     * optional error parameter signaling whether call failed or not), {@link bindNodeCallback}
	     * provides convenient error handling and probably is a better choice.
	     * `bindCallback` will treat such functions without any difference and error parameter
	     * (whether passed or not) will always be interpreted as regular callback argument.
	     *
	     *
	     * @example <caption>Convert jQuery's getJSON to an Observable API</caption>
	     * // Suppose we have jQuery.getJSON('/my/url', callback)
	     * var getJSONAsObservable = Rx.Observable.bindCallback(jQuery.getJSON);
	     * var result = getJSONAsObservable('/my/url');
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     *
	     * @example <caption>Receive array of arguments passed to callback</caption>
	     * someFunction((a, b, c) => {
	     *   console.log(a); // 5
	     *   console.log(b); // 'some string'
	     *   console.log(c); // {someProperty: 'someValue'}
	     * });
	     *
	     * const boundSomeFunction = Rx.Observable.bindCallback(someFunction);
	     * boundSomeFunction().subscribe(values => {
	     *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]
	     * });
	     *
	     *
	     * @example <caption>Use bindCallback with selector function</caption>
	     * someFunction((a, b, c) => {
	     *   console.log(a); // 'a'
	     *   console.log(b); // 'b'
	     *   console.log(c); // 'c'
	     * });
	     *
	     * const boundSomeFunction = Rx.Observable.bindCallback(someFunction, (a, b, c) => a + b + c);
	     * boundSomeFunction().subscribe(value => {
	     *   console.log(value) // 'abc'
	     * });
	     *
	     *
	     * @example <caption>Compare behaviour with and without async Scheduler</caption>
	     * function iCallMyCallbackSynchronously(cb) {
	     *   cb();
	     * }
	     *
	     * const boundSyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously);
	     * const boundAsyncFn = Rx.Observable.bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);
	     *
	     * boundSyncFn().subscribe(() => console.log('I was sync!'));
	     * boundAsyncFn().subscribe(() => console.log('I was async!'));
	     * console.log('This happened...');
	     *
	     * // Logs:
	     * // I was sync!
	     * // This happened...
	     * // I was async!
	     *
	     *
	     * @example <caption>Use bindCallback on object method</caption>
	     * const boundMethod = Rx.Observable.bindCallback(someObject.methodWithCallback);
	     * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject
	     * .subscribe(subscriber);
	     *
	     *
	     * @see {@link bindNodeCallback}
	     * @see {@link from}
	     * @see {@link fromPromise}
	     *
	     * @param {function} func Function with a callback as the last parameter.
	     * @param {function} [selector] A function which takes the arguments from the
	     * callback and maps those to a value to emit on the output Observable.
	     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
	     * callbacks.
	     * @return {function(...params: *): Observable} A function which returns the
	     * Observable that delivers the same values the callback would deliver.
	     * @static true
	     * @name bindCallback
	     * @owner Observable
	     */
	    BoundCallbackObservable.create = function (func, selector, scheduler) {
	        if (selector === void 0) { selector = undefined; }
	        return function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            return new BoundCallbackObservable(func, selector, args, this, scheduler);
	        };
	    };
	    BoundCallbackObservable.prototype._subscribe = function (subscriber) {
	        var callbackFunc = this.callbackFunc;
	        var args = this.args;
	        var scheduler = this.scheduler;
	        var subject = this.subject;
	        if (!scheduler) {
	            if (!subject) {
	                subject = this.subject = new AsyncSubject_1.AsyncSubject();
	                var handler = function handlerFn() {
	                    var innerArgs = [];
	                    for (var _i = 0; _i < arguments.length; _i++) {
	                        innerArgs[_i - 0] = arguments[_i];
	                    }
	                    var source = handlerFn.source;
	                    var selector = source.selector, subject = source.subject;
	                    if (selector) {
	                        var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
	                        if (result_1 === errorObject_1.errorObject) {
	                            subject.error(errorObject_1.errorObject.e);
	                        }
	                        else {
	                            subject.next(result_1);
	                            subject.complete();
	                        }
	                    }
	                    else {
	                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
	                        subject.complete();
	                    }
	                };
	                // use named function instance to avoid closure.
	                handler.source = this;
	                var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));
	                if (result === errorObject_1.errorObject) {
	                    subject.error(errorObject_1.errorObject.e);
	                }
	            }
	            return subject.subscribe(subscriber);
	        }
	        else {
	            return scheduler.schedule(BoundCallbackObservable.dispatch, 0, { source: this, subscriber: subscriber, context: this.context });
	        }
	    };
	    BoundCallbackObservable.dispatch = function (state) {
	        var self = this;
	        var source = state.source, subscriber = state.subscriber, context = state.context;
	        var callbackFunc = source.callbackFunc, args = source.args, scheduler = source.scheduler;
	        var subject = source.subject;
	        if (!subject) {
	            subject = source.subject = new AsyncSubject_1.AsyncSubject();
	            var handler = function handlerFn() {
	                var innerArgs = [];
	                for (var _i = 0; _i < arguments.length; _i++) {
	                    innerArgs[_i - 0] = arguments[_i];
	                }
	                var source = handlerFn.source;
	                var selector = source.selector, subject = source.subject;
	                if (selector) {
	                    var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
	                    if (result_2 === errorObject_1.errorObject) {
	                        self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));
	                    }
	                    else {
	                        self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));
	                    }
	                }
	                else {
	                    var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
	                    self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
	                }
	            };
	            // use named function to pass values in without closure
	            handler.source = source;
	            var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));
	            if (result === errorObject_1.errorObject) {
	                subject.error(errorObject_1.errorObject.e);
	            }
	        }
	        self.add(subject.subscribe(subscriber));
	    };
	    return BoundCallbackObservable;
	}(Observable_1.Observable));
	exports.BoundCallbackObservable = BoundCallbackObservable;
	function dispatchNext(arg) {
	    var value = arg.value, subject = arg.subject;
	    subject.next(value);
	    subject.complete();
	}
	function dispatchError(arg) {
	    var err = arg.err, subject = arg.subject;
	    subject.error(err);
	}


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	var tryCatch_1 = __webpack_require__(9);
	var errorObject_1 = __webpack_require__(7);
	var AsyncSubject_1 = __webpack_require__(20);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var BoundNodeCallbackObservable = (function (_super) {
	    __extends(BoundNodeCallbackObservable, _super);
	    function BoundNodeCallbackObservable(callbackFunc, selector, args, context, scheduler) {
	        _super.call(this);
	        this.callbackFunc = callbackFunc;
	        this.selector = selector;
	        this.args = args;
	        this.context = context;
	        this.scheduler = scheduler;
	    }
	    /* tslint:enable:max-line-length */
	    /**
	     * Converts a Node.js-style callback API to a function that returns an
	     * Observable.
	     *
	     * <span class="informal">It's just like {@link bindCallback}, but the
	     * callback is expected to be of type `callback(error, result)`.</span>
	     *
	     * `bindNodeCallback` is not an operator because its input and output are not
	     * Observables. The input is a function `func` with some parameters, but the
	     * last parameter must be a callback function that `func` calls when it is
	     * done. The callback function is expected to follow Node.js conventions,
	     * where the first argument to the callback is an error object, signaling
	     * whether call was successful. If that object is passed to callback, it means
	     * something went wrong.
	     *
	     * The output of `bindNodeCallback` is a function that takes the same
	     * parameters as `func`, except the last one (the callback). When the output
	     * function is called with arguments, it will return an Observable.
	     * If `func` calls its callback with error parameter present, Observable will
	     * error with that value as well. If error parameter is not passed, Observable will emit
	     * second parameter. If there are more parameters (third and so on),
	     * Observable will emit an array with all arguments, except first error argument.
	     *
	     * Optionally `bindNodeCallback` accepts selector function, which allows you to
	     * make resulting Observable emit value computed by selector, instead of regular
	     * callback arguments. It works similarly to {@link bindCallback} selector, but
	     * Node.js-style error argument will never be passed to that function.
	     *
	     * Note that `func` will not be called at the same time output function is,
	     * but rather whenever resulting Observable is subscribed. By default call to
	     * `func` will happen synchronously after subscription, but that can be changed
	     * with proper {@link Scheduler} provided as optional third parameter. Scheduler
	     * can also control when values from callback will be emitted by Observable.
	     * To find out more, check out documentation for {@link bindCallback}, where
	     * Scheduler works exactly the same.
	     *
	     * As in {@link bindCallback}, context (`this` property) of input function will be set to context
	     * of returned function, when it is called.
	     *
	     * After Observable emits value, it will complete immediately. This means
	     * even if `func` calls callback again, values from second and consecutive
	     * calls will never appear on the stream. If you need to handle functions
	     * that call callbacks multiple times, check out {@link fromEvent} or
	     * {@link fromEventPattern} instead.
	     *
	     * Note that `bindNodeCallback` can be used in non-Node.js environments as well.
	     * "Node.js-style" callbacks are just a convention, so if you write for
	     * browsers or any other environment and API you use implements that callback style,
	     * `bindNodeCallback` can be safely used on that API functions as well.
	     *
	     * Remember that Error object passed to callback does not have to be an instance
	     * of JavaScript built-in `Error` object. In fact, it does not even have to an object.
	     * Error parameter of callback function is interpreted as "present", when value
	     * of that parameter is truthy. It could be, for example, non-zero number, non-empty
	     * string or boolean `true`. In all of these cases resulting Observable would error
	     * with that value. This means usually regular style callbacks will fail very often when
	     * `bindNodeCallback` is used. If your Observable errors much more often then you
	     * would expect, check if callback really is called in Node.js-style and, if not,
	     * switch to {@link bindCallback} instead.
	     *
	     * Note that even if error parameter is technically present in callback, but its value
	     * is falsy, it still won't appear in array emitted by Observable or in selector function.
	     *
	     *
	     * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>
	     * import * as fs from 'fs';
	     * var readFileAsObservable = Rx.Observable.bindNodeCallback(fs.readFile);
	     * var result = readFileAsObservable('./roadNames.txt', 'utf8');
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     *
	     * @example <caption>Use on function calling callback with multiple arguments</caption>
	     * someFunction((err, a, b) => {
	     *   console.log(err); // null
	     *   console.log(a); // 5
	     *   console.log(b); // "some string"
	     * });
	     * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);
	     * boundSomeFunction()
	     * .subscribe(value => {
	     *   console.log(value); // [5, "some string"]
	     * });
	     *
	     *
	     * @example <caption>Use with selector function</caption>
	     * someFunction((err, a, b) => {
	     *   console.log(err); // undefined
	     *   console.log(a); // "abc"
	     *   console.log(b); // "DEF"
	     * });
	     * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction, (a, b) => a + b);
	     * boundSomeFunction()
	     * .subscribe(value => {
	     *   console.log(value); // "abcDEF"
	     * });
	     *
	     *
	     * @example <caption>Use on function calling callback in regular style</caption>
	     * someFunction(a => {
	     *   console.log(a); // 5
	     * });
	     * var boundSomeFunction = Rx.Observable.bindNodeCallback(someFunction);
	     * boundSomeFunction()
	     * .subscribe(
	     *   value => {}             // never gets called
	     *   err => console.log(err) // 5
	     *);
	     *
	     *
	     * @see {@link bindCallback}
	     * @see {@link from}
	     * @see {@link fromPromise}
	     *
	     * @param {function} func Function with a Node.js-style callback as the last parameter.
	     * @param {function} [selector] A function which takes the arguments from the
	     * callback and maps those to a value to emit on the output Observable.
	     * @param {Scheduler} [scheduler] The scheduler on which to schedule the
	     * callbacks.
	     * @return {function(...params: *): Observable} A function which returns the
	     * Observable that delivers the same values the Node.js callback would
	     * deliver.
	     * @static true
	     * @name bindNodeCallback
	     * @owner Observable
	     */
	    BoundNodeCallbackObservable.create = function (func, selector, scheduler) {
	        if (selector === void 0) { selector = undefined; }
	        return function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            return new BoundNodeCallbackObservable(func, selector, args, this, scheduler);
	        };
	    };
	    BoundNodeCallbackObservable.prototype._subscribe = function (subscriber) {
	        var callbackFunc = this.callbackFunc;
	        var args = this.args;
	        var scheduler = this.scheduler;
	        var subject = this.subject;
	        if (!scheduler) {
	            if (!subject) {
	                subject = this.subject = new AsyncSubject_1.AsyncSubject();
	                var handler = function handlerFn() {
	                    var innerArgs = [];
	                    for (var _i = 0; _i < arguments.length; _i++) {
	                        innerArgs[_i - 0] = arguments[_i];
	                    }
	                    var source = handlerFn.source;
	                    var selector = source.selector, subject = source.subject;
	                    var err = innerArgs.shift();
	                    if (err) {
	                        subject.error(err);
	                    }
	                    else if (selector) {
	                        var result_1 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
	                        if (result_1 === errorObject_1.errorObject) {
	                            subject.error(errorObject_1.errorObject.e);
	                        }
	                        else {
	                            subject.next(result_1);
	                            subject.complete();
	                        }
	                    }
	                    else {
	                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
	                        subject.complete();
	                    }
	                };
	                // use named function instance to avoid closure.
	                handler.source = this;
	                var result = tryCatch_1.tryCatch(callbackFunc).apply(this.context, args.concat(handler));
	                if (result === errorObject_1.errorObject) {
	                    subject.error(errorObject_1.errorObject.e);
	                }
	            }
	            return subject.subscribe(subscriber);
	        }
	        else {
	            return scheduler.schedule(dispatch, 0, { source: this, subscriber: subscriber, context: this.context });
	        }
	    };
	    return BoundNodeCallbackObservable;
	}(Observable_1.Observable));
	exports.BoundNodeCallbackObservable = BoundNodeCallbackObservable;
	function dispatch(state) {
	    var self = this;
	    var source = state.source, subscriber = state.subscriber, context = state.context;
	    // XXX: cast to `any` to access to the private field in `source`.
	    var _a = source, callbackFunc = _a.callbackFunc, args = _a.args, scheduler = _a.scheduler;
	    var subject = source.subject;
	    if (!subject) {
	        subject = source.subject = new AsyncSubject_1.AsyncSubject();
	        var handler = function handlerFn() {
	            var innerArgs = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                innerArgs[_i - 0] = arguments[_i];
	            }
	            var source = handlerFn.source;
	            var selector = source.selector, subject = source.subject;
	            var err = innerArgs.shift();
	            if (err) {
	                self.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
	            }
	            else if (selector) {
	                var result_2 = tryCatch_1.tryCatch(selector).apply(this, innerArgs);
	                if (result_2 === errorObject_1.errorObject) {
	                    self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));
	                }
	                else {
	                    self.add(scheduler.schedule(dispatchNext, 0, { value: result_2, subject: subject }));
	                }
	            }
	            else {
	                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
	                self.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
	            }
	        };
	        // use named function to pass values in without closure
	        handler.source = source;
	        var result = tryCatch_1.tryCatch(callbackFunc).apply(context, args.concat(handler));
	        if (result === errorObject_1.errorObject) {
	            self.add(scheduler.schedule(dispatchError, 0, { err: errorObject_1.errorObject.e, subject: subject }));
	        }
	    }
	    self.add(subject.subscribe(subscriber));
	}
	function dispatchNext(arg) {
	    var value = arg.value, subject = arg.subject;
	    subject.next(value);
	    subject.complete();
	}
	function dispatchError(arg) {
	    var err = arg.err, subject = arg.subject;
	    subject.error(err);
	}


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	var subscribeToResult_1 = __webpack_require__(4);
	var OuterSubscriber_1 = __webpack_require__(3);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var DeferObservable = (function (_super) {
	    __extends(DeferObservable, _super);
	    function DeferObservable(observableFactory) {
	        _super.call(this);
	        this.observableFactory = observableFactory;
	    }
	    /**
	     * Creates an Observable that, on subscribe, calls an Observable factory to
	     * make an Observable for each new Observer.
	     *
	     * <span class="informal">Creates the Observable lazily, that is, only when it
	     * is subscribed.
	     * </span>
	     *
	     * <img src="./img/defer.png" width="100%">
	     *
	     * `defer` allows you to create the Observable only when the Observer
	     * subscribes, and create a fresh Observable for each Observer. It waits until
	     * an Observer subscribes to it, and then it generates an Observable,
	     * typically with an Observable factory function. It does this afresh for each
	     * subscriber, so although each subscriber may think it is subscribing to the
	     * same Observable, in fact each subscriber gets its own individual
	     * Observable.
	     *
	     * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
	     * var clicksOrInterval = Rx.Observable.defer(function () {
	     *   if (Math.random() > 0.5) {
	     *     return Rx.Observable.fromEvent(document, 'click');
	     *   } else {
	     *     return Rx.Observable.interval(1000);
	     *   }
	     * });
	     * clicksOrInterval.subscribe(x => console.log(x));
	     *
	     * // Results in the following behavior:
	     * // If the result of Math.random() is greater than 0.5 it will listen
	     * // for clicks anywhere on the "document"; when document is clicked it
	     * // will log a MouseEvent object to the console. If the result is less
	     * // than 0.5 it will emit ascending numbers, one every second(1000ms).
	     *
	     * @see {@link create}
	     *
	     * @param {function(): SubscribableOrPromise} observableFactory The Observable
	     * factory function to invoke for each Observer that subscribes to the output
	     * Observable. May also return a Promise, which will be converted on the fly
	     * to an Observable.
	     * @return {Observable} An Observable whose Observers' subscriptions trigger
	     * an invocation of the given Observable factory function.
	     * @static true
	     * @name defer
	     * @owner Observable
	     */
	    DeferObservable.create = function (observableFactory) {
	        return new DeferObservable(observableFactory);
	    };
	    DeferObservable.prototype._subscribe = function (subscriber) {
	        return new DeferSubscriber(subscriber, this.observableFactory);
	    };
	    return DeferObservable;
	}(Observable_1.Observable));
	exports.DeferObservable = DeferObservable;
	var DeferSubscriber = (function (_super) {
	    __extends(DeferSubscriber, _super);
	    function DeferSubscriber(destination, factory) {
	        _super.call(this, destination);
	        this.factory = factory;
	        this.tryDefer();
	    }
	    DeferSubscriber.prototype.tryDefer = function () {
	        try {
	            this._callFactory();
	        }
	        catch (err) {
	            this._error(err);
	        }
	    };
	    DeferSubscriber.prototype._callFactory = function () {
	        var result = this.factory();
	        if (result) {
	            this.add(subscribeToResult_1.subscribeToResult(this, result));
	        }
	    };
	    return DeferSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ErrorObservable = (function (_super) {
	    __extends(ErrorObservable, _super);
	    function ErrorObservable(error, scheduler) {
	        _super.call(this);
	        this.error = error;
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable that emits no items to the Observer and immediately
	     * emits an error notification.
	     *
	     * <span class="informal">Just emits 'error', and nothing else.
	     * </span>
	     *
	     * <img src="./img/throw.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that only
	     * emits the error notification. It can be used for composing with other
	     * Observables, such as in a {@link mergeMap}.
	     *
	     * @example <caption>Emit the number 7, then emit an error.</caption>
	     * var result = Rx.Observable.throw(new Error('oops!')).startWith(7);
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
	     * var interval = Rx.Observable.interval(1000);
	     * var result = interval.mergeMap(x =>
	     *   x === 13 ?
	     *     Rx.Observable.throw('Thirteens are bad') :
	     *     Rx.Observable.of('a', 'b', 'c')
	     * );
	     * result.subscribe(x => console.log(x), e => console.error(e));
	     *
	     * @see {@link create}
	     * @see {@link empty}
	     * @see {@link never}
	     * @see {@link of}
	     *
	     * @param {any} error The particular Error to pass to the error notification.
	     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
	     * the emission of the error notification.
	     * @return {Observable} An error Observable: emits only the error notification
	     * using the given error argument.
	     * @static true
	     * @name throw
	     * @owner Observable
	     */
	    ErrorObservable.create = function (error, scheduler) {
	        return new ErrorObservable(error, scheduler);
	    };
	    ErrorObservable.dispatch = function (arg) {
	        var error = arg.error, subscriber = arg.subscriber;
	        subscriber.error(error);
	    };
	    ErrorObservable.prototype._subscribe = function (subscriber) {
	        var error = this.error;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(ErrorObservable.dispatch, 0, {
	                error: error, subscriber: subscriber
	            });
	        }
	        else {
	            subscriber.error(error);
	        }
	    };
	    return ErrorObservable;
	}(Observable_1.Observable));
	exports.ErrorObservable = ErrorObservable;


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	var EmptyObservable_1 = __webpack_require__(14);
	var isArray_1 = __webpack_require__(12);
	var subscribeToResult_1 = __webpack_require__(4);
	var OuterSubscriber_1 = __webpack_require__(3);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var ForkJoinObservable = (function (_super) {
	    __extends(ForkJoinObservable, _super);
	    function ForkJoinObservable(sources, resultSelector) {
	        _super.call(this);
	        this.sources = sources;
	        this.resultSelector = resultSelector;
	    }
	    /* tslint:enable:max-line-length */
	    /**
	     * @param sources
	     * @return {any}
	     * @static true
	     * @name forkJoin
	     * @owner Observable
	     */
	    ForkJoinObservable.create = function () {
	        var sources = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            sources[_i - 0] = arguments[_i];
	        }
	        if (sources === null || arguments.length === 0) {
	            return new EmptyObservable_1.EmptyObservable();
	        }
	        var resultSelector = null;
	        if (typeof sources[sources.length - 1] === 'function') {
	            resultSelector = sources.pop();
	        }
	        // if the first and only other argument besides the resultSelector is an array
	        // assume it's been called with `forkJoin([obs1, obs2, obs3], resultSelector)`
	        if (sources.length === 1 && isArray_1.isArray(sources[0])) {
	            sources = sources[0];
	        }
	        if (sources.length === 0) {
	            return new EmptyObservable_1.EmptyObservable();
	        }
	        return new ForkJoinObservable(sources, resultSelector);
	    };
	    ForkJoinObservable.prototype._subscribe = function (subscriber) {
	        return new ForkJoinSubscriber(subscriber, this.sources, this.resultSelector);
	    };
	    return ForkJoinObservable;
	}(Observable_1.Observable));
	exports.ForkJoinObservable = ForkJoinObservable;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ForkJoinSubscriber = (function (_super) {
	    __extends(ForkJoinSubscriber, _super);
	    function ForkJoinSubscriber(destination, sources, resultSelector) {
	        _super.call(this, destination);
	        this.sources = sources;
	        this.resultSelector = resultSelector;
	        this.completed = 0;
	        this.haveValues = 0;
	        var len = sources.length;
	        this.total = len;
	        this.values = new Array(len);
	        for (var i = 0; i < len; i++) {
	            var source = sources[i];
	            var innerSubscription = subscribeToResult_1.subscribeToResult(this, source, null, i);
	            if (innerSubscription) {
	                innerSubscription.outerIndex = i;
	                this.add(innerSubscription);
	            }
	        }
	    }
	    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.values[outerIndex] = innerValue;
	        if (!innerSub._hasValue) {
	            innerSub._hasValue = true;
	            this.haveValues++;
	        }
	    };
	    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {
	        var destination = this.destination;
	        var _a = this, haveValues = _a.haveValues, resultSelector = _a.resultSelector, values = _a.values;
	        var len = values.length;
	        if (!innerSub._hasValue) {
	            destination.complete();
	            return;
	        }
	        this.completed++;
	        if (this.completed !== len) {
	            return;
	        }
	        if (haveValues === len) {
	            var value = resultSelector ? resultSelector.apply(this, values) : values;
	            destination.next(value);
	        }
	        destination.complete();
	    };
	    return ForkJoinSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	var tryCatch_1 = __webpack_require__(9);
	var isFunction_1 = __webpack_require__(28);
	var errorObject_1 = __webpack_require__(7);
	var Subscription_1 = __webpack_require__(5);
	var toString = Object.prototype.toString;
	function isNodeStyleEventEmitter(sourceObj) {
	    return !!sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
	}
	function isJQueryStyleEventEmitter(sourceObj) {
	    return !!sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
	}
	function isNodeList(sourceObj) {
	    return !!sourceObj && toString.call(sourceObj) === '[object NodeList]';
	}
	function isHTMLCollection(sourceObj) {
	    return !!sourceObj && toString.call(sourceObj) === '[object HTMLCollection]';
	}
	function isEventTarget(sourceObj) {
	    return !!sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
	}
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var FromEventObservable = (function (_super) {
	    __extends(FromEventObservable, _super);
	    function FromEventObservable(sourceObj, eventName, selector, options) {
	        _super.call(this);
	        this.sourceObj = sourceObj;
	        this.eventName = eventName;
	        this.selector = selector;
	        this.options = options;
	    }
	    /* tslint:enable:max-line-length */
	    /**
	     * Creates an Observable that emits events of a specific type coming from the
	     * given event target.
	     *
	     * <span class="informal">Creates an Observable from DOM events, or Node
	     * EventEmitter events or others.</span>
	     *
	     * <img src="./img/fromEvent.png" width="100%">
	     *
	     * Creates an Observable by attaching an event listener to an "event target",
	     * which may be an object with `addEventListener` and `removeEventListener`,
	     * a Node.js EventEmitter, a jQuery style EventEmitter, a NodeList from the
	     * DOM, or an HTMLCollection from the DOM. The event handler is attached when
	     * the output Observable is subscribed, and removed when the Subscription is
	     * unsubscribed.
	     *
	     * @example <caption>Emits clicks happening on the DOM document</caption>
	     * var clicks = Rx.Observable.fromEvent(document, 'click');
	     * clicks.subscribe(x => console.log(x));
	     *
	     * // Results in:
	     * // MouseEvent object logged to console everytime a click
	     * // occurs on the document.
	     *
	     * @see {@link from}
	     * @see {@link fromEventPattern}
	     *
	     * @param {EventTargetLike} target The DOMElement, event target, Node.js
	     * EventEmitter, NodeList or HTMLCollection to attach the event handler to.
	     * @param {string} eventName The event name of interest, being emitted by the
	     * `target`.
	     * @param {EventListenerOptions} [options] Options to pass through to addEventListener
	     * @param {SelectorMethodSignature<T>} [selector] An optional function to
	     * post-process results. It takes the arguments from the event handler and
	     * should return a single value.
	     * @return {Observable<T>}
	     * @static true
	     * @name fromEvent
	     * @owner Observable
	     */
	    FromEventObservable.create = function (target, eventName, options, selector) {
	        if (isFunction_1.isFunction(options)) {
	            selector = options;
	            options = undefined;
	        }
	        return new FromEventObservable(target, eventName, selector, options);
	    };
	    FromEventObservable.setupSubscription = function (sourceObj, eventName, handler, subscriber, options) {
	        var unsubscribe;
	        if (isNodeList(sourceObj) || isHTMLCollection(sourceObj)) {
	            for (var i = 0, len = sourceObj.length; i < len; i++) {
	                FromEventObservable.setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
	            }
	        }
	        else if (isEventTarget(sourceObj)) {
	            var source_1 = sourceObj;
	            sourceObj.addEventListener(eventName, handler, options);
	            unsubscribe = function () { return source_1.removeEventListener(eventName, handler); };
	        }
	        else if (isJQueryStyleEventEmitter(sourceObj)) {
	            var source_2 = sourceObj;
	            sourceObj.on(eventName, handler);
	            unsubscribe = function () { return source_2.off(eventName, handler); };
	        }
	        else if (isNodeStyleEventEmitter(sourceObj)) {
	            var source_3 = sourceObj;
	            sourceObj.addListener(eventName, handler);
	            unsubscribe = function () { return source_3.removeListener(eventName, handler); };
	        }
	        else {
	            throw new TypeError('Invalid event target');
	        }
	        subscriber.add(new Subscription_1.Subscription(unsubscribe));
	    };
	    FromEventObservable.prototype._subscribe = function (subscriber) {
	        var sourceObj = this.sourceObj;
	        var eventName = this.eventName;
	        var options = this.options;
	        var selector = this.selector;
	        var handler = selector ? function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            var result = tryCatch_1.tryCatch(selector).apply(void 0, args);
	            if (result === errorObject_1.errorObject) {
	                subscriber.error(errorObject_1.errorObject.e);
	            }
	            else {
	                subscriber.next(result);
	            }
	        } : function (e) { return subscriber.next(e); };
	        FromEventObservable.setupSubscription(sourceObj, eventName, handler, subscriber, options);
	    };
	    return FromEventObservable;
	}(Observable_1.Observable));
	exports.FromEventObservable = FromEventObservable;


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isFunction_1 = __webpack_require__(28);
	var Observable_1 = __webpack_require__(1);
	var Subscription_1 = __webpack_require__(5);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var FromEventPatternObservable = (function (_super) {
	    __extends(FromEventPatternObservable, _super);
	    function FromEventPatternObservable(addHandler, removeHandler, selector) {
	        _super.call(this);
	        this.addHandler = addHandler;
	        this.removeHandler = removeHandler;
	        this.selector = selector;
	    }
	    /**
	     * Creates an Observable from an API based on addHandler/removeHandler
	     * functions.
	     *
	     * <span class="informal">Converts any addHandler/removeHandler API to an
	     * Observable.</span>
	     *
	     * <img src="./img/fromEventPattern.png" width="100%">
	     *
	     * Creates an Observable by using the `addHandler` and `removeHandler`
	     * functions to add and remove the handlers, with an optional selector
	     * function to project the event arguments to a result. The `addHandler` is
	     * called when the output Observable is subscribed, and `removeHandler` is
	     * called when the Subscription is unsubscribed.
	     *
	     * @example <caption>Emits clicks happening on the DOM document</caption>
	     * function addClickHandler(handler) {
	     *   document.addEventListener('click', handler);
	     * }
	     *
	     * function removeClickHandler(handler) {
	     *   document.removeEventListener('click', handler);
	     * }
	     *
	     * var clicks = Rx.Observable.fromEventPattern(
	     *   addClickHandler,
	     *   removeClickHandler
	     * );
	     * clicks.subscribe(x => console.log(x));
	     *
	     * @see {@link from}
	     * @see {@link fromEvent}
	     *
	     * @param {function(handler: Function): any} addHandler A function that takes
	     * a `handler` function as argument and attaches it somehow to the actual
	     * source of events.
	     * @param {function(handler: Function, signal?: any): void} [removeHandler] An optional function that
	     * takes a `handler` function as argument and removes it in case it was
	     * previously attached using `addHandler`. if addHandler returns signal to teardown when remove,
	     * removeHandler function will forward it.
	     * @param {function(...args: any): T} [selector] An optional function to
	     * post-process results. It takes the arguments from the event handler and
	     * should return a single value.
	     * @return {Observable<T>}
	     * @static true
	     * @name fromEventPattern
	     * @owner Observable
	     */
	    FromEventPatternObservable.create = function (addHandler, removeHandler, selector) {
	        return new FromEventPatternObservable(addHandler, removeHandler, selector);
	    };
	    FromEventPatternObservable.prototype._subscribe = function (subscriber) {
	        var _this = this;
	        var removeHandler = this.removeHandler;
	        var handler = !!this.selector ? function () {
	            var args = [];
	            for (var _i = 0; _i < arguments.length; _i++) {
	                args[_i - 0] = arguments[_i];
	            }
	            _this._callSelector(subscriber, args);
	        } : function (e) { subscriber.next(e); };
	        var retValue = this._callAddHandler(handler, subscriber);
	        if (!isFunction_1.isFunction(removeHandler)) {
	            return;
	        }
	        subscriber.add(new Subscription_1.Subscription(function () {
	            //TODO: determine whether or not to forward to error handler
	            removeHandler(handler, retValue);
	        }));
	    };
	    FromEventPatternObservable.prototype._callSelector = function (subscriber, args) {
	        try {
	            var result = this.selector.apply(this, args);
	            subscriber.next(result);
	        }
	        catch (e) {
	            subscriber.error(e);
	        }
	    };
	    FromEventPatternObservable.prototype._callAddHandler = function (handler, errorSubscriber) {
	        try {
	            return this.addHandler(handler) || null;
	        }
	        catch (e) {
	            errorSubscriber.error(e);
	        }
	    };
	    return FromEventPatternObservable;
	}(Observable_1.Observable));
	exports.FromEventPatternObservable = FromEventPatternObservable;


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	var isScheduler_1 = __webpack_require__(13);
	var selfSelector = function (value) { return value; };
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var GenerateObservable = (function (_super) {
	    __extends(GenerateObservable, _super);
	    function GenerateObservable(initialState, condition, iterate, resultSelector, scheduler) {
	        _super.call(this);
	        this.initialState = initialState;
	        this.condition = condition;
	        this.iterate = iterate;
	        this.resultSelector = resultSelector;
	        this.scheduler = scheduler;
	    }
	    GenerateObservable.create = function (initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
	        if (arguments.length == 1) {
	            return new GenerateObservable(initialStateOrOptions.initialState, initialStateOrOptions.condition, initialStateOrOptions.iterate, initialStateOrOptions.resultSelector || selfSelector, initialStateOrOptions.scheduler);
	        }
	        if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {
	            return new GenerateObservable(initialStateOrOptions, condition, iterate, selfSelector, resultSelectorOrObservable);
	        }
	        return new GenerateObservable(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler);
	    };
	    GenerateObservable.prototype._subscribe = function (subscriber) {
	        var state = this.initialState;
	        if (this.scheduler) {
	            return this.scheduler.schedule(GenerateObservable.dispatch, 0, {
	                subscriber: subscriber,
	                iterate: this.iterate,
	                condition: this.condition,
	                resultSelector: this.resultSelector,
	                state: state });
	        }
	        var _a = this, condition = _a.condition, resultSelector = _a.resultSelector, iterate = _a.iterate;
	        do {
	            if (condition) {
	                var conditionResult = void 0;
	                try {
	                    conditionResult = condition(state);
	                }
	                catch (err) {
	                    subscriber.error(err);
	                    return;
	                }
	                if (!conditionResult) {
	                    subscriber.complete();
	                    break;
	                }
	            }
	            var value = void 0;
	            try {
	                value = resultSelector(state);
	            }
	            catch (err) {
	                subscriber.error(err);
	                return;
	            }
	            subscriber.next(value);
	            if (subscriber.closed) {
	                break;
	            }
	            try {
	                state = iterate(state);
	            }
	            catch (err) {
	                subscriber.error(err);
	                return;
	            }
	        } while (true);
	    };
	    GenerateObservable.dispatch = function (state) {
	        var subscriber = state.subscriber, condition = state.condition;
	        if (subscriber.closed) {
	            return;
	        }
	        if (state.needIterate) {
	            try {
	                state.state = state.iterate(state.state);
	            }
	            catch (err) {
	                subscriber.error(err);
	                return;
	            }
	        }
	        else {
	            state.needIterate = true;
	        }
	        if (condition) {
	            var conditionResult = void 0;
	            try {
	                conditionResult = condition(state.state);
	            }
	            catch (err) {
	                subscriber.error(err);
	                return;
	            }
	            if (!conditionResult) {
	                subscriber.complete();
	                return;
	            }
	            if (subscriber.closed) {
	                return;
	            }
	        }
	        var value;
	        try {
	            value = state.resultSelector(state.state);
	        }
	        catch (err) {
	            subscriber.error(err);
	            return;
	        }
	        if (subscriber.closed) {
	            return;
	        }
	        subscriber.next(value);
	        if (subscriber.closed) {
	            return;
	        }
	        return this.schedule(state);
	    };
	    return GenerateObservable;
	}(Observable_1.Observable));
	exports.GenerateObservable = GenerateObservable;


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	var subscribeToResult_1 = __webpack_require__(4);
	var OuterSubscriber_1 = __webpack_require__(3);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var IfObservable = (function (_super) {
	    __extends(IfObservable, _super);
	    function IfObservable(condition, thenSource, elseSource) {
	        _super.call(this);
	        this.condition = condition;
	        this.thenSource = thenSource;
	        this.elseSource = elseSource;
	    }
	    IfObservable.create = function (condition, thenSource, elseSource) {
	        return new IfObservable(condition, thenSource, elseSource);
	    };
	    IfObservable.prototype._subscribe = function (subscriber) {
	        var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;
	        return new IfSubscriber(subscriber, condition, thenSource, elseSource);
	    };
	    return IfObservable;
	}(Observable_1.Observable));
	exports.IfObservable = IfObservable;
	var IfSubscriber = (function (_super) {
	    __extends(IfSubscriber, _super);
	    function IfSubscriber(destination, condition, thenSource, elseSource) {
	        _super.call(this, destination);
	        this.condition = condition;
	        this.thenSource = thenSource;
	        this.elseSource = elseSource;
	        this.tryIf();
	    }
	    IfSubscriber.prototype.tryIf = function () {
	        var _a = this, condition = _a.condition, thenSource = _a.thenSource, elseSource = _a.elseSource;
	        var result;
	        try {
	            result = condition();
	            var source = result ? thenSource : elseSource;
	            if (source) {
	                this.add(subscribeToResult_1.subscribeToResult(this, source));
	            }
	            else {
	                this._complete();
	            }
	        }
	        catch (err) {
	            this._error(err);
	        }
	    };
	    return IfSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isNumeric_1 = __webpack_require__(29);
	var Observable_1 = __webpack_require__(1);
	var async_1 = __webpack_require__(10);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var IntervalObservable = (function (_super) {
	    __extends(IntervalObservable, _super);
	    function IntervalObservable(period, scheduler) {
	        if (period === void 0) { period = 0; }
	        if (scheduler === void 0) { scheduler = async_1.async; }
	        _super.call(this);
	        this.period = period;
	        this.scheduler = scheduler;
	        if (!isNumeric_1.isNumeric(period) || period < 0) {
	            this.period = 0;
	        }
	        if (!scheduler || typeof scheduler.schedule !== 'function') {
	            this.scheduler = async_1.async;
	        }
	    }
	    /**
	     * Creates an Observable that emits sequential numbers every specified
	     * interval of time, on a specified IScheduler.
	     *
	     * <span class="informal">Emits incremental numbers periodically in time.
	     * </span>
	     *
	     * <img src="./img/interval.png" width="100%">
	     *
	     * `interval` returns an Observable that emits an infinite sequence of
	     * ascending integers, with a constant interval of time of your choosing
	     * between those emissions. The first emission is not sent immediately, but
	     * only after the first period has passed. By default, this operator uses the
	     * `async` IScheduler to provide a notion of time, but you may pass any
	     * IScheduler to it.
	     *
	     * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>
	     * var numbers = Rx.Observable.interval(1000);
	     * numbers.subscribe(x => console.log(x));
	     *
	     * @see {@link timer}
	     * @see {@link delay}
	     *
	     * @param {number} [period=0] The interval size in milliseconds (by default)
	     * or the time unit determined by the scheduler's clock.
	     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
	     * the emission of values, and providing a notion of "time".
	     * @return {Observable} An Observable that emits a sequential number each time
	     * interval.
	     * @static true
	     * @name interval
	     * @owner Observable
	     */
	    IntervalObservable.create = function (period, scheduler) {
	        if (period === void 0) { period = 0; }
	        if (scheduler === void 0) { scheduler = async_1.async; }
	        return new IntervalObservable(period, scheduler);
	    };
	    IntervalObservable.dispatch = function (state) {
	        var index = state.index, subscriber = state.subscriber, period = state.period;
	        subscriber.next(index);
	        if (subscriber.closed) {
	            return;
	        }
	        state.index += 1;
	        this.schedule(state, period);
	    };
	    IntervalObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var period = this.period;
	        var scheduler = this.scheduler;
	        subscriber.add(scheduler.schedule(IntervalObservable.dispatch, period, {
	            index: index, subscriber: subscriber, period: period
	        }));
	    };
	    return IntervalObservable;
	}(Observable_1.Observable));
	exports.IntervalObservable = IntervalObservable;


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var root_1 = __webpack_require__(8);
	var Observable_1 = __webpack_require__(1);
	var iterator_1 = __webpack_require__(19);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var IteratorObservable = (function (_super) {
	    __extends(IteratorObservable, _super);
	    function IteratorObservable(iterator, scheduler) {
	        _super.call(this);
	        this.scheduler = scheduler;
	        if (iterator == null) {
	            throw new Error('iterator cannot be null.');
	        }
	        this.iterator = getIterator(iterator);
	    }
	    IteratorObservable.create = function (iterator, scheduler) {
	        return new IteratorObservable(iterator, scheduler);
	    };
	    IteratorObservable.dispatch = function (state) {
	        var index = state.index, hasError = state.hasError, iterator = state.iterator, subscriber = state.subscriber;
	        if (hasError) {
	            subscriber.error(state.error);
	            return;
	        }
	        var result = iterator.next();
	        if (result.done) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(result.value);
	        state.index = index + 1;
	        if (subscriber.closed) {
	            if (typeof iterator.return === 'function') {
	                iterator.return();
	            }
	            return;
	        }
	        this.schedule(state);
	    };
	    IteratorObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var _a = this, iterator = _a.iterator, scheduler = _a.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(IteratorObservable.dispatch, 0, {
	                index: index, iterator: iterator, subscriber: subscriber
	            });
	        }
	        else {
	            do {
	                var result = iterator.next();
	                if (result.done) {
	                    subscriber.complete();
	                    break;
	                }
	                else {
	                    subscriber.next(result.value);
	                }
	                if (subscriber.closed) {
	                    if (typeof iterator.return === 'function') {
	                        iterator.return();
	                    }
	                    break;
	                }
	            } while (true);
	        }
	    };
	    return IteratorObservable;
	}(Observable_1.Observable));
	exports.IteratorObservable = IteratorObservable;
	var StringIterator = (function () {
	    function StringIterator(str, idx, len) {
	        if (idx === void 0) { idx = 0; }
	        if (len === void 0) { len = str.length; }
	        this.str = str;
	        this.idx = idx;
	        this.len = len;
	    }
	    StringIterator.prototype[iterator_1.iterator] = function () { return (this); };
	    StringIterator.prototype.next = function () {
	        return this.idx < this.len ? {
	            done: false,
	            value: this.str.charAt(this.idx++)
	        } : {
	            done: true,
	            value: undefined
	        };
	    };
	    return StringIterator;
	}());
	var ArrayIterator = (function () {
	    function ArrayIterator(arr, idx, len) {
	        if (idx === void 0) { idx = 0; }
	        if (len === void 0) { len = toLength(arr); }
	        this.arr = arr;
	        this.idx = idx;
	        this.len = len;
	    }
	    ArrayIterator.prototype[iterator_1.iterator] = function () { return this; };
	    ArrayIterator.prototype.next = function () {
	        return this.idx < this.len ? {
	            done: false,
	            value: this.arr[this.idx++]
	        } : {
	            done: true,
	            value: undefined
	        };
	    };
	    return ArrayIterator;
	}());
	function getIterator(obj) {
	    var i = obj[iterator_1.iterator];
	    if (!i && typeof obj === 'string') {
	        return new StringIterator(obj);
	    }
	    if (!i && obj.length !== undefined) {
	        return new ArrayIterator(obj);
	    }
	    if (!i) {
	        throw new TypeError('object is not iterable');
	    }
	    return obj[iterator_1.iterator]();
	}
	var maxSafeInteger = Math.pow(2, 53) - 1;
	function toLength(o) {
	    var len = +o.length;
	    if (isNaN(len)) {
	        return 0;
	    }
	    if (len === 0 || !numberIsFinite(len)) {
	        return len;
	    }
	    len = sign(len) * Math.floor(Math.abs(len));
	    if (len <= 0) {
	        return 0;
	    }
	    if (len > maxSafeInteger) {
	        return maxSafeInteger;
	    }
	    return len;
	}
	function numberIsFinite(value) {
	    return typeof value === 'number' && root_1.root.isFinite(value);
	}
	function sign(value) {
	    var valueAsNumber = +value;
	    if (valueAsNumber === 0) {
	        return valueAsNumber;
	    }
	    if (isNaN(valueAsNumber)) {
	        return valueAsNumber;
	    }
	    return valueAsNumber < 0 ? -1 : 1;
	}


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	var noop_1 = __webpack_require__(66);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var NeverObservable = (function (_super) {
	    __extends(NeverObservable, _super);
	    function NeverObservable() {
	        _super.call(this);
	    }
	    /**
	     * Creates an Observable that emits no items to the Observer.
	     *
	     * <span class="informal">An Observable that never emits anything.</span>
	     *
	     * <img src="./img/never.png" width="100%">
	     *
	     * This static operator is useful for creating a simple Observable that emits
	     * neither values nor errors nor the completion notification. It can be used
	     * for testing purposes or for composing with other Observables. Please not
	     * that by never emitting a complete notification, this Observable keeps the
	     * subscription from being disposed automatically. Subscriptions need to be
	     * manually disposed.
	     *
	     * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>
	     * function info() {
	     *   console.log('Will not be called');
	     * }
	     * var result = Rx.Observable.never().startWith(7);
	     * result.subscribe(x => console.log(x), info, info);
	     *
	     * @see {@link create}
	     * @see {@link empty}
	     * @see {@link of}
	     * @see {@link throw}
	     *
	     * @return {Observable} A "never" Observable: never emits anything.
	     * @static true
	     * @name never
	     * @owner Observable
	     */
	    NeverObservable.create = function () {
	        return new NeverObservable();
	    };
	    NeverObservable.prototype._subscribe = function (subscriber) {
	        noop_1.noop();
	    };
	    return NeverObservable;
	}(Observable_1.Observable));
	exports.NeverObservable = NeverObservable;


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	function dispatch(state) {
	    var obj = state.obj, keys = state.keys, length = state.length, index = state.index, subscriber = state.subscriber;
	    if (index === length) {
	        subscriber.complete();
	        return;
	    }
	    var key = keys[index];
	    subscriber.next([key, obj[key]]);
	    state.index = index + 1;
	    this.schedule(state);
	}
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var PairsObservable = (function (_super) {
	    __extends(PairsObservable, _super);
	    function PairsObservable(obj, scheduler) {
	        _super.call(this);
	        this.obj = obj;
	        this.scheduler = scheduler;
	        this.keys = Object.keys(obj);
	    }
	    /**
	     * Convert an object into an observable sequence of [key, value] pairs
	     * using an optional IScheduler to enumerate the object.
	     *
	     * @example <caption>Converts a javascript object to an Observable</caption>
	     * var obj = {
	     *   foo: 42,
	     *   bar: 56,
	     *   baz: 78
	     * };
	     *
	     * var source = Rx.Observable.pairs(obj);
	     *
	     * var subscription = source.subscribe(
	     *   function (x) {
	     *     console.log('Next: %s', x);
	     *   },
	     *   function (err) {
	     *     console.log('Error: %s', err);
	     *   },
	     *   function () {
	     *     console.log('Completed');
	     *   });
	     *
	     * @param {Object} obj The object to inspect and turn into an
	     * Observable sequence.
	     * @param {Scheduler} [scheduler] An optional IScheduler to run the
	     * enumeration of the input sequence on.
	     * @returns {(Observable<Array<string | T>>)} An observable sequence of
	     * [key, value] pairs from the object.
	     */
	    PairsObservable.create = function (obj, scheduler) {
	        return new PairsObservable(obj, scheduler);
	    };
	    PairsObservable.prototype._subscribe = function (subscriber) {
	        var _a = this, keys = _a.keys, scheduler = _a.scheduler;
	        var length = keys.length;
	        if (scheduler) {
	            return scheduler.schedule(dispatch, 0, {
	                obj: this.obj, keys: keys, length: length, index: 0, subscriber: subscriber
	            });
	        }
	        else {
	            for (var idx = 0; idx < length; idx++) {
	                var key = keys[idx];
	                subscriber.next([key, this.obj[key]]);
	            }
	            subscriber.complete();
	        }
	    };
	    return PairsObservable;
	}(Observable_1.Observable));
	exports.PairsObservable = PairsObservable;


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var RangeObservable = (function (_super) {
	    __extends(RangeObservable, _super);
	    function RangeObservable(start, count, scheduler) {
	        _super.call(this);
	        this.start = start;
	        this._count = count;
	        this.scheduler = scheduler;
	    }
	    /**
	     * Creates an Observable that emits a sequence of numbers within a specified
	     * range.
	     *
	     * <span class="informal">Emits a sequence of numbers in a range.</span>
	     *
	     * <img src="./img/range.png" width="100%">
	     *
	     * `range` operator emits a range of sequential integers, in order, where you
	     * select the `start` of the range and its `length`. By default, uses no
	     * IScheduler and just delivers the notifications synchronously, but may use
	     * an optional IScheduler to regulate those deliveries.
	     *
	     * @example <caption>Emits the numbers 1 to 10</caption>
	     * var numbers = Rx.Observable.range(1, 10);
	     * numbers.subscribe(x => console.log(x));
	     *
	     * @see {@link timer}
	     * @see {@link interval}
	     *
	     * @param {number} [start=0] The value of the first integer in the sequence.
	     * @param {number} [count=0] The number of sequential integers to generate.
	     * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
	     * the emissions of the notifications.
	     * @return {Observable} An Observable of numbers that emits a finite range of
	     * sequential integers.
	     * @static true
	     * @name range
	     * @owner Observable
	     */
	    RangeObservable.create = function (start, count, scheduler) {
	        if (start === void 0) { start = 0; }
	        if (count === void 0) { count = 0; }
	        return new RangeObservable(start, count, scheduler);
	    };
	    RangeObservable.dispatch = function (state) {
	        var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
	        if (index >= count) {
	            subscriber.complete();
	            return;
	        }
	        subscriber.next(start);
	        if (subscriber.closed) {
	            return;
	        }
	        state.index = index + 1;
	        state.start = start + 1;
	        this.schedule(state);
	    };
	    RangeObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var start = this.start;
	        var count = this._count;
	        var scheduler = this.scheduler;
	        if (scheduler) {
	            return scheduler.schedule(RangeObservable.dispatch, 0, {
	                index: index, count: count, start: start, subscriber: subscriber
	            });
	        }
	        else {
	            do {
	                if (index++ >= count) {
	                    subscriber.complete();
	                    break;
	                }
	                subscriber.next(start++);
	                if (subscriber.closed) {
	                    break;
	                }
	            } while (true);
	        }
	    };
	    return RangeObservable;
	}(Observable_1.Observable));
	exports.RangeObservable = RangeObservable;


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	var asap_1 = __webpack_require__(56);
	var isNumeric_1 = __webpack_require__(29);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var SubscribeOnObservable = (function (_super) {
	    __extends(SubscribeOnObservable, _super);
	    function SubscribeOnObservable(source, delayTime, scheduler) {
	        if (delayTime === void 0) { delayTime = 0; }
	        if (scheduler === void 0) { scheduler = asap_1.asap; }
	        _super.call(this);
	        this.source = source;
	        this.delayTime = delayTime;
	        this.scheduler = scheduler;
	        if (!isNumeric_1.isNumeric(delayTime) || delayTime < 0) {
	            this.delayTime = 0;
	        }
	        if (!scheduler || typeof scheduler.schedule !== 'function') {
	            this.scheduler = asap_1.asap;
	        }
	    }
	    SubscribeOnObservable.create = function (source, delay, scheduler) {
	        if (delay === void 0) { delay = 0; }
	        if (scheduler === void 0) { scheduler = asap_1.asap; }
	        return new SubscribeOnObservable(source, delay, scheduler);
	    };
	    SubscribeOnObservable.dispatch = function (arg) {
	        var source = arg.source, subscriber = arg.subscriber;
	        return this.add(source.subscribe(subscriber));
	    };
	    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
	        var delay = this.delayTime;
	        var source = this.source;
	        var scheduler = this.scheduler;
	        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
	            source: source, subscriber: subscriber
	        });
	    };
	    return SubscribeOnObservable;
	}(Observable_1.Observable));
	exports.SubscribeOnObservable = SubscribeOnObservable;


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var isNumeric_1 = __webpack_require__(29);
	var Observable_1 = __webpack_require__(1);
	var async_1 = __webpack_require__(10);
	var isScheduler_1 = __webpack_require__(13);
	var isDate_1 = __webpack_require__(27);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var TimerObservable = (function (_super) {
	    __extends(TimerObservable, _super);
	    function TimerObservable(dueTime, period, scheduler) {
	        if (dueTime === void 0) { dueTime = 0; }
	        _super.call(this);
	        this.period = -1;
	        this.dueTime = 0;
	        if (isNumeric_1.isNumeric(period)) {
	            this.period = Number(period) < 1 && 1 || Number(period);
	        }
	        else if (isScheduler_1.isScheduler(period)) {
	            scheduler = period;
	        }
	        if (!isScheduler_1.isScheduler(scheduler)) {
	            scheduler = async_1.async;
	        }
	        this.scheduler = scheduler;
	        this.dueTime = isDate_1.isDate(dueTime) ?
	            (+dueTime - this.scheduler.now()) :
	            dueTime;
	    }
	    /**
	     * Creates an Observable that starts emitting after an `initialDelay` and
	     * emits ever increasing numbers after each `period` of time thereafter.
	     *
	     * <span class="informal">Its like {@link interval}, but you can specify when
	     * should the emissions start.</span>
	     *
	     * <img src="./img/timer.png" width="100%">
	     *
	     * `timer` returns an Observable that emits an infinite sequence of ascending
	     * integers, with a constant interval of time, `period` of your choosing
	     * between those emissions. The first emission happens after the specified
	     * `initialDelay`. The initial delay may be a {@link Date}. By default, this
	     * operator uses the `async` IScheduler to provide a notion of time, but you
	     * may pass any IScheduler to it. If `period` is not specified, the output
	     * Observable emits only one value, `0`. Otherwise, it emits an infinite
	     * sequence.
	     *
	     * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
	     * var numbers = Rx.Observable.timer(3000, 1000);
	     * numbers.subscribe(x => console.log(x));
	     *
	     * @example <caption>Emits one number after five seconds</caption>
	     * var numbers = Rx.Observable.timer(5000);
	     * numbers.subscribe(x => console.log(x));
	     *
	     * @see {@link interval}
	     * @see {@link delay}
	     *
	     * @param {number|Date} initialDelay The initial delay time to wait before
	     * emitting the first value of `0`.
	     * @param {number} [period] The period of time between emissions of the
	     * subsequent numbers.
	     * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
	     * the emission of values, and providing a notion of "time".
	     * @return {Observable} An Observable that emits a `0` after the
	     * `initialDelay` and ever increasing numbers after each `period` of time
	     * thereafter.
	     * @static true
	     * @name timer
	     * @owner Observable
	     */
	    TimerObservable.create = function (initialDelay, period, scheduler) {
	        if (initialDelay === void 0) { initialDelay = 0; }
	        return new TimerObservable(initialDelay, period, scheduler);
	    };
	    TimerObservable.dispatch = function (state) {
	        var index = state.index, period = state.period, subscriber = state.subscriber;
	        var action = this;
	        subscriber.next(index);
	        if (subscriber.closed) {
	            return;
	        }
	        else if (period === -1) {
	            return subscriber.complete();
	        }
	        state.index = index + 1;
	        action.schedule(state, period);
	    };
	    TimerObservable.prototype._subscribe = function (subscriber) {
	        var index = 0;
	        var _a = this, period = _a.period, dueTime = _a.dueTime, scheduler = _a.scheduler;
	        return scheduler.schedule(TimerObservable.dispatch, dueTime, {
	            index: index, period: period, subscriber: subscriber
	        });
	    };
	    return TimerObservable;
	}(Observable_1.Observable));
	exports.TimerObservable = TimerObservable;


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	var subscribeToResult_1 = __webpack_require__(4);
	var OuterSubscriber_1 = __webpack_require__(3);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var UsingObservable = (function (_super) {
	    __extends(UsingObservable, _super);
	    function UsingObservable(resourceFactory, observableFactory) {
	        _super.call(this);
	        this.resourceFactory = resourceFactory;
	        this.observableFactory = observableFactory;
	    }
	    UsingObservable.create = function (resourceFactory, observableFactory) {
	        return new UsingObservable(resourceFactory, observableFactory);
	    };
	    UsingObservable.prototype._subscribe = function (subscriber) {
	        var _a = this, resourceFactory = _a.resourceFactory, observableFactory = _a.observableFactory;
	        var resource;
	        try {
	            resource = resourceFactory();
	            return new UsingSubscriber(subscriber, resource, observableFactory);
	        }
	        catch (err) {
	            subscriber.error(err);
	        }
	    };
	    return UsingObservable;
	}(Observable_1.Observable));
	exports.UsingObservable = UsingObservable;
	var UsingSubscriber = (function (_super) {
	    __extends(UsingSubscriber, _super);
	    function UsingSubscriber(destination, resource, observableFactory) {
	        _super.call(this, destination);
	        this.resource = resource;
	        this.observableFactory = observableFactory;
	        destination.add(resource);
	        this.tryUse();
	    }
	    UsingSubscriber.prototype.tryUse = function () {
	        try {
	            var source = this.observableFactory.call(this, this.resource);
	            if (source) {
	                this.add(subscribeToResult_1.subscribeToResult(this, source));
	            }
	        }
	        catch (err) {
	            this._error(err);
	        }
	    };
	    return UsingSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var BoundCallbackObservable_1 = __webpack_require__(201);
	exports.bindCallback = BoundCallbackObservable_1.BoundCallbackObservable.create;


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var BoundNodeCallbackObservable_1 = __webpack_require__(202);
	exports.bindNodeCallback = BoundNodeCallbackObservable_1.BoundNodeCallbackObservable.create;


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var isScheduler_1 = __webpack_require__(13);
	var isArray_1 = __webpack_require__(12);
	var ArrayObservable_1 = __webpack_require__(11);
	var combineLatest_1 = __webpack_require__(32);
	/* tslint:enable:max-line-length */
	/**
	 * Combines multiple Observables to create an Observable whose values are
	 * calculated from the latest values of each of its input Observables.
	 *
	 * <span class="informal">Whenever any input Observable emits a value, it
	 * computes a formula using the latest values from all the inputs, then emits
	 * the output of that formula.</span>
	 *
	 * <img src="./img/combineLatest.png" width="100%">
	 *
	 * `combineLatest` combines the values from all the Observables passed as
	 * arguments. This is done by subscribing to each Observable in order and,
	 * whenever any Observable emits, collecting an array of the most recent
	 * values from each Observable. So if you pass `n` Observables to operator,
	 * returned Observable will always emit an array of `n` values, in order
	 * corresponding to order of passed Observables (value from the first Observable
	 * on the first place and so on).
	 *
	 * Static version of `combineLatest` accepts either an array of Observables
	 * or each Observable can be put directly as an argument. Note that array of
	 * Observables is good choice, if you don't know beforehand how many Observables
	 * you will combine. Passing empty array will result in Observable that
	 * completes immediately.
	 *
	 * To ensure output array has always the same length, `combineLatest` will
	 * actually wait for all input Observables to emit at least once,
	 * before it starts emitting results. This means if some Observable emits
	 * values before other Observables started emitting, all that values but last
	 * will be lost. On the other hand, is some Observable does not emit value but
	 * completes, resulting Observable will complete at the same moment without
	 * emitting anything, since it will be now impossible to include value from
	 * completed Observable in resulting array. Also, if some input Observable does
	 * not emit any value and never completes, `combineLatest` will also never emit
	 * and never complete, since, again, it will wait for all streams to emit some
	 * value.
	 *
	 * If at least one Observable was passed to `combineLatest` and all passed Observables
	 * emitted something, resulting Observable will complete when all combined
	 * streams complete. So even if some Observable completes, result of
	 * `combineLatest` will still emit values when other Observables do. In case
	 * of completed Observable, its value from now on will always be the last
	 * emitted value. On the other hand, if any Observable errors, `combineLatest`
	 * will error immediately as well, and all other Observables will be unsubscribed.
	 *
	 * `combineLatest` accepts as optional parameter `project` function, which takes
	 * as arguments all values that would normally be emitted by resulting Observable.
	 * `project` can return any kind of value, which will be then emitted by Observable
	 * instead of default array. Note that `project` does not take as argument that array
	 * of values, but values themselves. That means default `project` can be imagined
	 * as function that takes all its arguments and puts them into an array.
	 *
	 *
	 * @example <caption>Combine two timer Observables</caption>
	 * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
	 * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now
	 * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);
	 * combinedTimers.subscribe(value => console.log(value));
	 * // Logs
	 * // [0, 0] after 0.5s
	 * // [1, 0] after 1s
	 * // [1, 1] after 1.5s
	 * // [2, 1] after 2s
	 *
	 *
	 * @example <caption>Combine an array of Observables</caption>
	 * const observables = [1, 5, 10].map(
	 *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds
	 * );
	 * const combined = Rx.Observable.combineLatest(observables);
	 * combined.subscribe(value => console.log(value));
	 * // Logs
	 * // [0, 0, 0] immediately
	 * // [1, 0, 0] after 1s
	 * // [1, 5, 0] after 5s
	 * // [1, 5, 10] after 10s
	 *
	 *
	 * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>
	 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
	 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
	 * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));
	 * bmi.subscribe(x => console.log('BMI is ' + x));
	 *
	 * // With output to console:
	 * // BMI is 24.212293388429753
	 * // BMI is 23.93948099205209
	 * // BMI is 23.671253629592222
	 *
	 *
	 * @see {@link combineAll}
	 * @see {@link merge}
	 * @see {@link withLatestFrom}
	 *
	 * @param {ObservableInput} observable1 An input Observable to combine with other Observables.
	 * @param {ObservableInput} observable2 An input Observable to combine with other Observables.
	 * More than one input Observables may be given as arguments
	 * or an array of Observables may be given as the first argument.
	 * @param {function} [project] An optional function to project the values from
	 * the combined latest values into a new value on the output Observable.
	 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
	 * each input Observable.
	 * @return {Observable} An Observable of projected values from the most recent
	 * values from each input Observable, or an array of the most recent values from
	 * each input Observable.
	 * @static true
	 * @name combineLatest
	 * @owner Observable
	 */
	function combineLatest() {
	    var observables = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        observables[_i - 0] = arguments[_i];
	    }
	    var project = null;
	    var scheduler = null;
	    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
	        scheduler = observables.pop();
	    }
	    if (typeof observables[observables.length - 1] === 'function') {
	        project = observables.pop();
	    }
	    // if the first and only other argument besides the resultSelector is an array
	    // assume it's been called with `combineLatest([obs1, obs2, obs3], project)`
	    if (observables.length === 1 && isArray_1.isArray(observables[0])) {
	        observables = observables[0];
	    }
	    return new ArrayObservable_1.ArrayObservable(observables, scheduler).lift(new combineLatest_1.CombineLatestOperator(project));
	}
	exports.combineLatest = combineLatest;


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var concat_1 = __webpack_require__(33);
	exports.concat = concat_1.concatStatic;


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var DeferObservable_1 = __webpack_require__(203);
	exports.defer = DeferObservable_1.DeferObservable.create;


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var Subscriber_1 = __webpack_require__(2);
	var Observable_1 = __webpack_require__(1);
	var Subscription_1 = __webpack_require__(5);
	var root_1 = __webpack_require__(8);
	var ReplaySubject_1 = __webpack_require__(30);
	var tryCatch_1 = __webpack_require__(9);
	var errorObject_1 = __webpack_require__(7);
	var assign_1 = __webpack_require__(342);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @extends {Ignored}
	 * @hide true
	 */
	var WebSocketSubject = (function (_super) {
	    __extends(WebSocketSubject, _super);
	    function WebSocketSubject(urlConfigOrSource, destination) {
	        if (urlConfigOrSource instanceof Observable_1.Observable) {
	            _super.call(this, destination, urlConfigOrSource);
	        }
	        else {
	            _super.call(this);
	            this.WebSocketCtor = root_1.root.WebSocket;
	            this._output = new Subject_1.Subject();
	            if (typeof urlConfigOrSource === 'string') {
	                this.url = urlConfigOrSource;
	            }
	            else {
	                // WARNING: config object could override important members here.
	                assign_1.assign(this, urlConfigOrSource);
	            }
	            if (!this.WebSocketCtor) {
	                throw new Error('no WebSocket constructor can be found');
	            }
	            this.destination = new ReplaySubject_1.ReplaySubject();
	        }
	    }
	    WebSocketSubject.prototype.resultSelector = function (e) {
	        return JSON.parse(e.data);
	    };
	    /**
	     * Wrapper around the w3c-compatible WebSocket object provided by the browser.
	     *
	     * @example <caption>Wraps browser WebSocket</caption>
	     *
	     * let socket$ = Observable.webSocket('ws://localhost:8081');
	     *
	     * socket$.subscribe(
	     *    (msg) => console.log('message received: ' + msg),
	     *    (err) => console.log(err),
	     *    () => console.log('complete')
	     *  );
	     *
	     * socket$.next(JSON.stringify({ op: 'hello' }));
	     *
	     * @example <caption>Wraps WebSocket from nodejs-websocket (using node.js)</caption>
	     *
	     * import { w3cwebsocket } from 'websocket';
	     *
	     * let socket$ = Observable.webSocket({
	     *   url: 'ws://localhost:8081',
	     *   WebSocketCtor: w3cwebsocket
	     * });
	     *
	     * socket$.subscribe(
	     *    (msg) => console.log('message received: ' + msg),
	     *    (err) => console.log(err),
	     *    () => console.log('complete')
	     *  );
	     *
	     * socket$.next(JSON.stringify({ op: 'hello' }));
	     *
	     * @param {string | WebSocketSubjectConfig} urlConfigOrSource the source of the websocket as an url or a structure defining the websocket object
	     * @return {WebSocketSubject}
	     * @static true
	     * @name webSocket
	     * @owner Observable
	     */
	    WebSocketSubject.create = function (urlConfigOrSource) {
	        return new WebSocketSubject(urlConfigOrSource);
	    };
	    WebSocketSubject.prototype.lift = function (operator) {
	        var sock = new WebSocketSubject(this, this.destination);
	        sock.operator = operator;
	        return sock;
	    };
	    WebSocketSubject.prototype._resetState = function () {
	        this.socket = null;
	        if (!this.source) {
	            this.destination = new ReplaySubject_1.ReplaySubject();
	        }
	        this._output = new Subject_1.Subject();
	    };
	    // TODO: factor this out to be a proper Operator/Subscriber implementation and eliminate closures
	    WebSocketSubject.prototype.multiplex = function (subMsg, unsubMsg, messageFilter) {
	        var self = this;
	        return new Observable_1.Observable(function (observer) {
	            var result = tryCatch_1.tryCatch(subMsg)();
	            if (result === errorObject_1.errorObject) {
	                observer.error(errorObject_1.errorObject.e);
	            }
	            else {
	                self.next(result);
	            }
	            var subscription = self.subscribe(function (x) {
	                var result = tryCatch_1.tryCatch(messageFilter)(x);
	                if (result === errorObject_1.errorObject) {
	                    observer.error(errorObject_1.errorObject.e);
	                }
	                else if (result) {
	                    observer.next(x);
	                }
	            }, function (err) { return observer.error(err); }, function () { return observer.complete(); });
	            return function () {
	                var result = tryCatch_1.tryCatch(unsubMsg)();
	                if (result === errorObject_1.errorObject) {
	                    observer.error(errorObject_1.errorObject.e);
	                }
	                else {
	                    self.next(result);
	                }
	                subscription.unsubscribe();
	            };
	        });
	    };
	    WebSocketSubject.prototype._connectSocket = function () {
	        var _this = this;
	        var WebSocketCtor = this.WebSocketCtor;
	        var observer = this._output;
	        var socket = null;
	        try {
	            socket = this.protocol ?
	                new WebSocketCtor(this.url, this.protocol) :
	                new WebSocketCtor(this.url);
	            this.socket = socket;
	            if (this.binaryType) {
	                this.socket.binaryType = this.binaryType;
	            }
	        }
	        catch (e) {
	            observer.error(e);
	            return;
	        }
	        var subscription = new Subscription_1.Subscription(function () {
	            _this.socket = null;
	            if (socket && socket.readyState === 1) {
	                socket.close();
	            }
	        });
	        socket.onopen = function (e) {
	            var openObserver = _this.openObserver;
	            if (openObserver) {
	                openObserver.next(e);
	            }
	            var queue = _this.destination;
	            _this.destination = Subscriber_1.Subscriber.create(function (x) { return socket.readyState === 1 && socket.send(x); }, function (e) {
	                var closingObserver = _this.closingObserver;
	                if (closingObserver) {
	                    closingObserver.next(undefined);
	                }
	                if (e && e.code) {
	                    socket.close(e.code, e.reason);
	                }
	                else {
	                    observer.error(new TypeError('WebSocketSubject.error must be called with an object with an error code, ' +
	                        'and an optional reason: { code: number, reason: string }'));
	                }
	                _this._resetState();
	            }, function () {
	                var closingObserver = _this.closingObserver;
	                if (closingObserver) {
	                    closingObserver.next(undefined);
	                }
	                socket.close();
	                _this._resetState();
	            });
	            if (queue && queue instanceof ReplaySubject_1.ReplaySubject) {
	                subscription.add(queue.subscribe(_this.destination));
	            }
	        };
	        socket.onerror = function (e) {
	            _this._resetState();
	            observer.error(e);
	        };
	        socket.onclose = function (e) {
	            _this._resetState();
	            var closeObserver = _this.closeObserver;
	            if (closeObserver) {
	                closeObserver.next(e);
	            }
	            if (e.wasClean) {
	                observer.complete();
	            }
	            else {
	                observer.error(e);
	            }
	        };
	        socket.onmessage = function (e) {
	            var result = tryCatch_1.tryCatch(_this.resultSelector)(e);
	            if (result === errorObject_1.errorObject) {
	                observer.error(errorObject_1.errorObject.e);
	            }
	            else {
	                observer.next(result);
	            }
	        };
	    };
	    WebSocketSubject.prototype._subscribe = function (subscriber) {
	        var _this = this;
	        var source = this.source;
	        if (source) {
	            return source.subscribe(subscriber);
	        }
	        if (!this.socket) {
	            this._connectSocket();
	        }
	        var subscription = new Subscription_1.Subscription();
	        subscription.add(this._output.subscribe(subscriber));
	        subscription.add(function () {
	            var socket = _this.socket;
	            if (_this._output.observers.length === 0) {
	                if (socket && socket.readyState === 1) {
	                    socket.close();
	                }
	                _this._resetState();
	            }
	        });
	        return subscription;
	    };
	    WebSocketSubject.prototype.unsubscribe = function () {
	        var _a = this, source = _a.source, socket = _a.socket;
	        if (socket && socket.readyState === 1) {
	            socket.close();
	            this._resetState();
	        }
	        _super.prototype.unsubscribe.call(this);
	        if (!source) {
	            this.destination = new ReplaySubject_1.ReplaySubject();
	        }
	    };
	    return WebSocketSubject;
	}(Subject_1.AnonymousSubject));
	exports.WebSocketSubject = WebSocketSubject;


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AjaxObservable_1 = __webpack_require__(44);
	exports.ajax = AjaxObservable_1.AjaxObservable.create;


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var WebSocketSubject_1 = __webpack_require__(223);
	exports.webSocket = WebSocketSubject_1.WebSocketSubject.create;


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var EmptyObservable_1 = __webpack_require__(14);
	exports.empty = EmptyObservable_1.EmptyObservable.create;


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ForkJoinObservable_1 = __webpack_require__(205);
	exports.forkJoin = ForkJoinObservable_1.ForkJoinObservable.create;


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var FromObservable_1 = __webpack_require__(42);
	exports.from = FromObservable_1.FromObservable.create;


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var FromEventObservable_1 = __webpack_require__(206);
	exports.fromEvent = FromEventObservable_1.FromEventObservable.create;


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var FromEventPatternObservable_1 = __webpack_require__(207);
	exports.fromEventPattern = FromEventPatternObservable_1.FromEventPatternObservable.create;


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var PromiseObservable_1 = __webpack_require__(43);
	exports.fromPromise = PromiseObservable_1.PromiseObservable.create;


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var IfObservable_1 = __webpack_require__(209);
	exports._if = IfObservable_1.IfObservable.create;


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var IntervalObservable_1 = __webpack_require__(210);
	exports.interval = IntervalObservable_1.IntervalObservable.create;


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var merge_1 = __webpack_require__(48);
	exports.merge = merge_1.mergeStatic;


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var NeverObservable_1 = __webpack_require__(212);
	exports.never = NeverObservable_1.NeverObservable.create;


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ArrayObservable_1 = __webpack_require__(11);
	exports.of = ArrayObservable_1.ArrayObservable.of;


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var PairsObservable_1 = __webpack_require__(213);
	exports.pairs = PairsObservable_1.PairsObservable.create;


/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var RangeObservable_1 = __webpack_require__(214);
	exports.range = RangeObservable_1.RangeObservable.create;


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ErrorObservable_1 = __webpack_require__(204);
	exports._throw = ErrorObservable_1.ErrorObservable.create;


/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var TimerObservable_1 = __webpack_require__(216);
	exports.timer = TimerObservable_1.TimerObservable.create;


/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var UsingObservable_1 = __webpack_require__(217);
	exports.using = UsingObservable_1.UsingObservable.create;


/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var zip_1 = __webpack_require__(37);
	exports.zip = zip_1.zipStatic;


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var tryCatch_1 = __webpack_require__(9);
	var errorObject_1 = __webpack_require__(7);
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/**
	 * Ignores source values for a duration determined by another Observable, then
	 * emits the most recent value from the source Observable, then repeats this
	 * process.
	 *
	 * <span class="informal">It's like {@link auditTime}, but the silencing
	 * duration is determined by a second Observable.</span>
	 *
	 * <img src="./img/audit.png" width="100%">
	 *
	 * `audit` is similar to `throttle`, but emits the last value from the silenced
	 * time window, instead of the first value. `audit` emits the most recent value
	 * from the source Observable on the output Observable as soon as its internal
	 * timer becomes disabled, and ignores source values while the timer is enabled.
	 * Initially, the timer is disabled. As soon as the first source value arrives,
	 * the timer is enabled by calling the `durationSelector` function with the
	 * source value, which returns the "duration" Observable. When the duration
	 * Observable emits a value or completes, the timer is disabled, then the most
	 * recent source value is emitted on the output Observable, and this process
	 * repeats for the next source value.
	 *
	 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.audit(ev => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link auditTime}
	 * @see {@link debounce}
	 * @see {@link delayWhen}
	 * @see {@link sample}
	 * @see {@link throttle}
	 *
	 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
	 * that receives a value from the source Observable, for computing the silencing
	 * duration, returned as an Observable or a Promise.
	 * @return {Observable<T>} An Observable that performs rate-limiting of
	 * emissions from the source Observable.
	 * @method audit
	 * @owner Observable
	 */
	function audit(durationSelector) {
	    return this.lift(new AuditOperator(durationSelector));
	}
	exports.audit = audit;
	var AuditOperator = (function () {
	    function AuditOperator(durationSelector) {
	        this.durationSelector = durationSelector;
	    }
	    AuditOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
	    };
	    return AuditOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AuditSubscriber = (function (_super) {
	    __extends(AuditSubscriber, _super);
	    function AuditSubscriber(destination, durationSelector) {
	        _super.call(this, destination);
	        this.durationSelector = durationSelector;
	        this.hasValue = false;
	    }
	    AuditSubscriber.prototype._next = function (value) {
	        this.value = value;
	        this.hasValue = true;
	        if (!this.throttled) {
	            var duration = tryCatch_1.tryCatch(this.durationSelector)(value);
	            if (duration === errorObject_1.errorObject) {
	                this.destination.error(errorObject_1.errorObject.e);
	            }
	            else {
	                this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));
	            }
	        }
	    };
	    AuditSubscriber.prototype.clearThrottle = function () {
	        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
	        if (throttled) {
	            this.remove(throttled);
	            this.throttled = null;
	            throttled.unsubscribe();
	        }
	        if (hasValue) {
	            this.value = null;
	            this.hasValue = false;
	            this.destination.next(value);
	        }
	    };
	    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
	        this.clearThrottle();
	    };
	    AuditSubscriber.prototype.notifyComplete = function () {
	        this.clearThrottle();
	    };
	    return AuditSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1 = __webpack_require__(10);
	var Subscriber_1 = __webpack_require__(2);
	/**
	 * Ignores source values for `duration` milliseconds, then emits the most recent
	 * value from the source Observable, then repeats this process.
	 *
	 * <span class="informal">When it sees a source values, it ignores that plus
	 * the next ones for `duration` milliseconds, and then it emits the most recent
	 * value from the source.</span>
	 *
	 * <img src="./img/auditTime.png" width="100%">
	 *
	 * `auditTime` is similar to `throttleTime`, but emits the last value from the
	 * silenced time window, instead of the first value. `auditTime` emits the most
	 * recent value from the source Observable on the output Observable as soon as
	 * its internal timer becomes disabled, and ignores source values while the
	 * timer is enabled. Initially, the timer is disabled. As soon as the first
	 * source value arrives, the timer is enabled. After `duration` milliseconds (or
	 * the time unit determined internally by the optional `scheduler`) has passed,
	 * the timer is disabled, then the most recent source value is emitted on the
	 * output Observable, and this process repeats for the next source value.
	 * Optionally takes a {@link IScheduler} for managing timers.
	 *
	 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.auditTime(1000);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link audit}
	 * @see {@link debounceTime}
	 * @see {@link delay}
	 * @see {@link sampleTime}
	 * @see {@link throttleTime}
	 *
	 * @param {number} duration Time to wait before emitting the most recent source
	 * value, measured in milliseconds or the time unit determined internally
	 * by the optional `scheduler`.
	 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
	 * managing the timers that handle the rate-limiting behavior.
	 * @return {Observable<T>} An Observable that performs rate-limiting of
	 * emissions from the source Observable.
	 * @method auditTime
	 * @owner Observable
	 */
	function auditTime(duration, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new AuditTimeOperator(duration, scheduler));
	}
	exports.auditTime = auditTime;
	var AuditTimeOperator = (function () {
	    function AuditTimeOperator(duration, scheduler) {
	        this.duration = duration;
	        this.scheduler = scheduler;
	    }
	    AuditTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new AuditTimeSubscriber(subscriber, this.duration, this.scheduler));
	    };
	    return AuditTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AuditTimeSubscriber = (function (_super) {
	    __extends(AuditTimeSubscriber, _super);
	    function AuditTimeSubscriber(destination, duration, scheduler) {
	        _super.call(this, destination);
	        this.duration = duration;
	        this.scheduler = scheduler;
	        this.hasValue = false;
	    }
	    AuditTimeSubscriber.prototype._next = function (value) {
	        this.value = value;
	        this.hasValue = true;
	        if (!this.throttled) {
	            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, this));
	        }
	    };
	    AuditTimeSubscriber.prototype.clearThrottle = function () {
	        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
	        if (throttled) {
	            this.remove(throttled);
	            this.throttled = null;
	            throttled.unsubscribe();
	        }
	        if (hasValue) {
	            this.value = null;
	            this.hasValue = false;
	            this.destination.next(value);
	        }
	    };
	    return AuditTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchNext(subscriber) {
	    subscriber.clearThrottle();
	}


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/**
	 * Buffers the source Observable values until `closingNotifier` emits.
	 *
	 * <span class="informal">Collects values from the past as an array, and emits
	 * that array only when another Observable emits.</span>
	 *
	 * <img src="./img/buffer.png" width="100%">
	 *
	 * Buffers the incoming Observable values until the given `closingNotifier`
	 * Observable emits a value, at which point it emits the buffer on the output
	 * Observable and starts a new buffer internally, awaiting the next time
	 * `closingNotifier` emits.
	 *
	 * @example <caption>On every click, emit array of most recent interval events</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var interval = Rx.Observable.interval(1000);
	 * var buffered = interval.buffer(clicks);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link bufferCount}
	 * @see {@link bufferTime}
	 * @see {@link bufferToggle}
	 * @see {@link bufferWhen}
	 * @see {@link window}
	 *
	 * @param {Observable<any>} closingNotifier An Observable that signals the
	 * buffer to be emitted on the output Observable.
	 * @return {Observable<T[]>} An Observable of buffers, which are arrays of
	 * values.
	 * @method buffer
	 * @owner Observable
	 */
	function buffer(closingNotifier) {
	    return this.lift(new BufferOperator(closingNotifier));
	}
	exports.buffer = buffer;
	var BufferOperator = (function () {
	    function BufferOperator(closingNotifier) {
	        this.closingNotifier = closingNotifier;
	    }
	    BufferOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
	    };
	    return BufferOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferSubscriber = (function (_super) {
	    __extends(BufferSubscriber, _super);
	    function BufferSubscriber(destination, closingNotifier) {
	        _super.call(this, destination);
	        this.buffer = [];
	        this.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
	    }
	    BufferSubscriber.prototype._next = function (value) {
	        this.buffer.push(value);
	    };
	    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var buffer = this.buffer;
	        this.buffer = [];
	        this.destination.next(buffer);
	    };
	    return BufferSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/**
	 * Buffers the source Observable values until the size hits the maximum
	 * `bufferSize` given.
	 *
	 * <span class="informal">Collects values from the past as an array, and emits
	 * that array only when its size reaches `bufferSize`.</span>
	 *
	 * <img src="./img/bufferCount.png" width="100%">
	 *
	 * Buffers a number of values from the source Observable by `bufferSize` then
	 * emits the buffer and clears it, and starts a new buffer each
	 * `startBufferEvery` values. If `startBufferEvery` is not provided or is
	 * `null`, then new buffers are started immediately at the start of the source
	 * and when each buffer closes and is emitted.
	 *
	 * @example <caption>Emit the last two click events as an array</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferCount(2);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @example <caption>On every click, emit the last two click events as an array</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferCount(2, 1);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferTime}
	 * @see {@link bufferToggle}
	 * @see {@link bufferWhen}
	 * @see {@link pairwise}
	 * @see {@link windowCount}
	 *
	 * @param {number} bufferSize The maximum size of the buffer emitted.
	 * @param {number} [startBufferEvery] Interval at which to start a new buffer.
	 * For example if `startBufferEvery` is `2`, then a new buffer will be started
	 * on every other value from the source. A new buffer is started at the
	 * beginning of the source by default.
	 * @return {Observable<T[]>} An Observable of arrays of buffered values.
	 * @method bufferCount
	 * @owner Observable
	 */
	function bufferCount(bufferSize, startBufferEvery) {
	    if (startBufferEvery === void 0) { startBufferEvery = null; }
	    return this.lift(new BufferCountOperator(bufferSize, startBufferEvery));
	}
	exports.bufferCount = bufferCount;
	var BufferCountOperator = (function () {
	    function BufferCountOperator(bufferSize, startBufferEvery) {
	        this.bufferSize = bufferSize;
	        this.startBufferEvery = startBufferEvery;
	        if (!startBufferEvery || bufferSize === startBufferEvery) {
	            this.subscriberClass = BufferCountSubscriber;
	        }
	        else {
	            this.subscriberClass = BufferSkipCountSubscriber;
	        }
	    }
	    BufferCountOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
	    };
	    return BufferCountOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferCountSubscriber = (function (_super) {
	    __extends(BufferCountSubscriber, _super);
	    function BufferCountSubscriber(destination, bufferSize) {
	        _super.call(this, destination);
	        this.bufferSize = bufferSize;
	        this.buffer = [];
	    }
	    BufferCountSubscriber.prototype._next = function (value) {
	        var buffer = this.buffer;
	        buffer.push(value);
	        if (buffer.length == this.bufferSize) {
	            this.destination.next(buffer);
	            this.buffer = [];
	        }
	    };
	    BufferCountSubscriber.prototype._complete = function () {
	        var buffer = this.buffer;
	        if (buffer.length > 0) {
	            this.destination.next(buffer);
	        }
	        _super.prototype._complete.call(this);
	    };
	    return BufferCountSubscriber;
	}(Subscriber_1.Subscriber));
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferSkipCountSubscriber = (function (_super) {
	    __extends(BufferSkipCountSubscriber, _super);
	    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
	        _super.call(this, destination);
	        this.bufferSize = bufferSize;
	        this.startBufferEvery = startBufferEvery;
	        this.buffers = [];
	        this.count = 0;
	    }
	    BufferSkipCountSubscriber.prototype._next = function (value) {
	        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
	        this.count++;
	        if (count % startBufferEvery === 0) {
	            buffers.push([]);
	        }
	        for (var i = buffers.length; i--;) {
	            var buffer = buffers[i];
	            buffer.push(value);
	            if (buffer.length === bufferSize) {
	                buffers.splice(i, 1);
	                this.destination.next(buffer);
	            }
	        }
	    };
	    BufferSkipCountSubscriber.prototype._complete = function () {
	        var _a = this, buffers = _a.buffers, destination = _a.destination;
	        while (buffers.length > 0) {
	            var buffer = buffers.shift();
	            if (buffer.length > 0) {
	                destination.next(buffer);
	            }
	        }
	        _super.prototype._complete.call(this);
	    };
	    return BufferSkipCountSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1 = __webpack_require__(10);
	var Subscriber_1 = __webpack_require__(2);
	var isScheduler_1 = __webpack_require__(13);
	/* tslint:enable:max-line-length */
	/**
	 * Buffers the source Observable values for a specific time period.
	 *
	 * <span class="informal">Collects values from the past as an array, and emits
	 * those arrays periodically in time.</span>
	 *
	 * <img src="./img/bufferTime.png" width="100%">
	 *
	 * Buffers values from the source for a specific time duration `bufferTimeSpan`.
	 * Unless the optional argument `bufferCreationInterval` is given, it emits and
	 * resets the buffer every `bufferTimeSpan` milliseconds. If
	 * `bufferCreationInterval` is given, this operator opens the buffer every
	 * `bufferCreationInterval` milliseconds and closes (emits and resets) the
	 * buffer every `bufferTimeSpan` milliseconds. When the optional argument
	 * `maxBufferSize` is specified, the buffer will be closed either after
	 * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.
	 *
	 * @example <caption>Every second, emit an array of the recent click events</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferTime(1000);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferTime(2000, 5000);
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferCount}
	 * @see {@link bufferToggle}
	 * @see {@link bufferWhen}
	 * @see {@link windowTime}
	 *
	 * @param {number} bufferTimeSpan The amount of time to fill each buffer array.
	 * @param {number} [bufferCreationInterval] The interval at which to start new
	 * buffers.
	 * @param {number} [maxBufferSize] The maximum buffer size.
	 * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the
	 * intervals that determine buffer boundaries.
	 * @return {Observable<T[]>} An observable of arrays of buffered values.
	 * @method bufferTime
	 * @owner Observable
	 */
	function bufferTime(bufferTimeSpan) {
	    var length = arguments.length;
	    var scheduler = async_1.async;
	    if (isScheduler_1.isScheduler(arguments[arguments.length - 1])) {
	        scheduler = arguments[arguments.length - 1];
	        length--;
	    }
	    var bufferCreationInterval = null;
	    if (length >= 2) {
	        bufferCreationInterval = arguments[1];
	    }
	    var maxBufferSize = Number.POSITIVE_INFINITY;
	    if (length >= 3) {
	        maxBufferSize = arguments[2];
	    }
	    return this.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
	}
	exports.bufferTime = bufferTime;
	var BufferTimeOperator = (function () {
	    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
	        this.bufferTimeSpan = bufferTimeSpan;
	        this.bufferCreationInterval = bufferCreationInterval;
	        this.maxBufferSize = maxBufferSize;
	        this.scheduler = scheduler;
	    }
	    BufferTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
	    };
	    return BufferTimeOperator;
	}());
	var Context = (function () {
	    function Context() {
	        this.buffer = [];
	    }
	    return Context;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferTimeSubscriber = (function (_super) {
	    __extends(BufferTimeSubscriber, _super);
	    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
	        _super.call(this, destination);
	        this.bufferTimeSpan = bufferTimeSpan;
	        this.bufferCreationInterval = bufferCreationInterval;
	        this.maxBufferSize = maxBufferSize;
	        this.scheduler = scheduler;
	        this.contexts = [];
	        var context = this.openContext();
	        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
	        if (this.timespanOnly) {
	            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
	            this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
	        }
	        else {
	            var closeState = { subscriber: this, context: context };
	            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: this, scheduler: scheduler };
	            this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
	            this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
	        }
	    }
	    BufferTimeSubscriber.prototype._next = function (value) {
	        var contexts = this.contexts;
	        var len = contexts.length;
	        var filledBufferContext;
	        for (var i = 0; i < len; i++) {
	            var context = contexts[i];
	            var buffer = context.buffer;
	            buffer.push(value);
	            if (buffer.length == this.maxBufferSize) {
	                filledBufferContext = context;
	            }
	        }
	        if (filledBufferContext) {
	            this.onBufferFull(filledBufferContext);
	        }
	    };
	    BufferTimeSubscriber.prototype._error = function (err) {
	        this.contexts.length = 0;
	        _super.prototype._error.call(this, err);
	    };
	    BufferTimeSubscriber.prototype._complete = function () {
	        var _a = this, contexts = _a.contexts, destination = _a.destination;
	        while (contexts.length > 0) {
	            var context = contexts.shift();
	            destination.next(context.buffer);
	        }
	        _super.prototype._complete.call(this);
	    };
	    BufferTimeSubscriber.prototype._unsubscribe = function () {
	        this.contexts = null;
	    };
	    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
	        this.closeContext(context);
	        var closeAction = context.closeAction;
	        closeAction.unsubscribe();
	        this.remove(closeAction);
	        if (!this.closed && this.timespanOnly) {
	            context = this.openContext();
	            var bufferTimeSpan = this.bufferTimeSpan;
	            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
	            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
	        }
	    };
	    BufferTimeSubscriber.prototype.openContext = function () {
	        var context = new Context();
	        this.contexts.push(context);
	        return context;
	    };
	    BufferTimeSubscriber.prototype.closeContext = function (context) {
	        this.destination.next(context.buffer);
	        var contexts = this.contexts;
	        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
	        if (spliceIndex >= 0) {
	            contexts.splice(contexts.indexOf(context), 1);
	        }
	    };
	    return BufferTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchBufferTimeSpanOnly(state) {
	    var subscriber = state.subscriber;
	    var prevContext = state.context;
	    if (prevContext) {
	        subscriber.closeContext(prevContext);
	    }
	    if (!subscriber.closed) {
	        state.context = subscriber.openContext();
	        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
	    }
	}
	function dispatchBufferCreation(state) {
	    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
	    var context = subscriber.openContext();
	    var action = this;
	    if (!subscriber.closed) {
	        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
	        action.schedule(state, bufferCreationInterval);
	    }
	}
	function dispatchBufferClose(arg) {
	    var subscriber = arg.subscriber, context = arg.context;
	    subscriber.closeContext(context);
	}


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(5);
	var subscribeToResult_1 = __webpack_require__(4);
	var OuterSubscriber_1 = __webpack_require__(3);
	/**
	 * Buffers the source Observable values starting from an emission from
	 * `openings` and ending when the output of `closingSelector` emits.
	 *
	 * <span class="informal">Collects values from the past as an array. Starts
	 * collecting only when `opening` emits, and calls the `closingSelector`
	 * function to get an Observable that tells when to close the buffer.</span>
	 *
	 * <img src="./img/bufferToggle.png" width="100%">
	 *
	 * Buffers values from the source by opening the buffer via signals from an
	 * Observable provided to `openings`, and closing and sending the buffers when
	 * a Subscribable or Promise returned by the `closingSelector` function emits.
	 *
	 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var openings = Rx.Observable.interval(1000);
	 * var buffered = clicks.bufferToggle(openings, i =>
	 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
	 * );
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferCount}
	 * @see {@link bufferTime}
	 * @see {@link bufferWhen}
	 * @see {@link windowToggle}
	 *
	 * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new
	 * buffers.
	 * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes
	 * the value emitted by the `openings` observable and returns a Subscribable or Promise,
	 * which, when it emits, signals that the associated buffer should be emitted
	 * and cleared.
	 * @return {Observable<T[]>} An observable of arrays of buffered values.
	 * @method bufferToggle
	 * @owner Observable
	 */
	function bufferToggle(openings, closingSelector) {
	    return this.lift(new BufferToggleOperator(openings, closingSelector));
	}
	exports.bufferToggle = bufferToggle;
	var BufferToggleOperator = (function () {
	    function BufferToggleOperator(openings, closingSelector) {
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	    }
	    BufferToggleOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
	    };
	    return BufferToggleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferToggleSubscriber = (function (_super) {
	    __extends(BufferToggleSubscriber, _super);
	    function BufferToggleSubscriber(destination, openings, closingSelector) {
	        _super.call(this, destination);
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	        this.contexts = [];
	        this.add(subscribeToResult_1.subscribeToResult(this, openings));
	    }
	    BufferToggleSubscriber.prototype._next = function (value) {
	        var contexts = this.contexts;
	        var len = contexts.length;
	        for (var i = 0; i < len; i++) {
	            contexts[i].buffer.push(value);
	        }
	    };
	    BufferToggleSubscriber.prototype._error = function (err) {
	        var contexts = this.contexts;
	        while (contexts.length > 0) {
	            var context = contexts.shift();
	            context.subscription.unsubscribe();
	            context.buffer = null;
	            context.subscription = null;
	        }
	        this.contexts = null;
	        _super.prototype._error.call(this, err);
	    };
	    BufferToggleSubscriber.prototype._complete = function () {
	        var contexts = this.contexts;
	        while (contexts.length > 0) {
	            var context = contexts.shift();
	            this.destination.next(context.buffer);
	            context.subscription.unsubscribe();
	            context.buffer = null;
	            context.subscription = null;
	        }
	        this.contexts = null;
	        _super.prototype._complete.call(this);
	    };
	    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
	    };
	    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.closeBuffer(innerSub.context);
	    };
	    BufferToggleSubscriber.prototype.openBuffer = function (value) {
	        try {
	            var closingSelector = this.closingSelector;
	            var closingNotifier = closingSelector.call(this, value);
	            if (closingNotifier) {
	                this.trySubscribe(closingNotifier);
	            }
	        }
	        catch (err) {
	            this._error(err);
	        }
	    };
	    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
	        var contexts = this.contexts;
	        if (contexts && context) {
	            var buffer = context.buffer, subscription = context.subscription;
	            this.destination.next(buffer);
	            contexts.splice(contexts.indexOf(context), 1);
	            this.remove(subscription);
	            subscription.unsubscribe();
	        }
	    };
	    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
	        var contexts = this.contexts;
	        var buffer = [];
	        var subscription = new Subscription_1.Subscription();
	        var context = { buffer: buffer, subscription: subscription };
	        contexts.push(context);
	        var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
	        if (!innerSubscription || innerSubscription.closed) {
	            this.closeBuffer(context);
	        }
	        else {
	            innerSubscription.context = context;
	            this.add(innerSubscription);
	            subscription.add(innerSubscription);
	        }
	    };
	    return BufferToggleSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(5);
	var tryCatch_1 = __webpack_require__(9);
	var errorObject_1 = __webpack_require__(7);
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/**
	 * Buffers the source Observable values, using a factory function of closing
	 * Observables to determine when to close, emit, and reset the buffer.
	 *
	 * <span class="informal">Collects values from the past as an array. When it
	 * starts collecting values, it calls a function that returns an Observable that
	 * tells when to close the buffer and restart collecting.</span>
	 *
	 * <img src="./img/bufferWhen.png" width="100%">
	 *
	 * Opens a buffer immediately, then closes the buffer when the observable
	 * returned by calling `closingSelector` function emits a value. When it closes
	 * the buffer, it immediately opens a new buffer and repeats the process.
	 *
	 * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var buffered = clicks.bufferWhen(() =>
	 *   Rx.Observable.interval(1000 + Math.random() * 4000)
	 * );
	 * buffered.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferCount}
	 * @see {@link bufferTime}
	 * @see {@link bufferToggle}
	 * @see {@link windowWhen}
	 *
	 * @param {function(): Observable} closingSelector A function that takes no
	 * arguments and returns an Observable that signals buffer closure.
	 * @return {Observable<T[]>} An observable of arrays of buffered values.
	 * @method bufferWhen
	 * @owner Observable
	 */
	function bufferWhen(closingSelector) {
	    return this.lift(new BufferWhenOperator(closingSelector));
	}
	exports.bufferWhen = bufferWhen;
	var BufferWhenOperator = (function () {
	    function BufferWhenOperator(closingSelector) {
	        this.closingSelector = closingSelector;
	    }
	    BufferWhenOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
	    };
	    return BufferWhenOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var BufferWhenSubscriber = (function (_super) {
	    __extends(BufferWhenSubscriber, _super);
	    function BufferWhenSubscriber(destination, closingSelector) {
	        _super.call(this, destination);
	        this.closingSelector = closingSelector;
	        this.subscribing = false;
	        this.openBuffer();
	    }
	    BufferWhenSubscriber.prototype._next = function (value) {
	        this.buffer.push(value);
	    };
	    BufferWhenSubscriber.prototype._complete = function () {
	        var buffer = this.buffer;
	        if (buffer) {
	            this.destination.next(buffer);
	        }
	        _super.prototype._complete.call(this);
	    };
	    BufferWhenSubscriber.prototype._unsubscribe = function () {
	        this.buffer = null;
	        this.subscribing = false;
	    };
	    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.openBuffer();
	    };
	    BufferWhenSubscriber.prototype.notifyComplete = function () {
	        if (this.subscribing) {
	            this.complete();
	        }
	        else {
	            this.openBuffer();
	        }
	    };
	    BufferWhenSubscriber.prototype.openBuffer = function () {
	        var closingSubscription = this.closingSubscription;
	        if (closingSubscription) {
	            this.remove(closingSubscription);
	            closingSubscription.unsubscribe();
	        }
	        var buffer = this.buffer;
	        if (this.buffer) {
	            this.destination.next(buffer);
	        }
	        this.buffer = [];
	        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
	        if (closingNotifier === errorObject_1.errorObject) {
	            this.error(errorObject_1.errorObject.e);
	        }
	        else {
	            closingSubscription = new Subscription_1.Subscription();
	            this.closingSubscription = closingSubscription;
	            this.add(closingSubscription);
	            this.subscribing = true;
	            closingSubscription.add(subscribeToResult_1.subscribeToResult(this, closingNotifier));
	            this.subscribing = false;
	        }
	    };
	    return BufferWhenSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/**
	 * Catches errors on the observable to be handled by returning a new observable or throwing an error.
	 *
	 * <img src="./img/catch.png" width="100%">
	 *
	 * @example <caption>Continues with a different Observable when there's an error</caption>
	 *
	 * Observable.of(1, 2, 3, 4, 5)
	 *   .map(n => {
	 * 	   if (n == 4) {
	 * 	     throw 'four!';
	 *     }
	 *	   return n;
	 *   })
	 *   .catch(err => Observable.of('I', 'II', 'III', 'IV', 'V'))
	 *   .subscribe(x => console.log(x));
	 *   // 1, 2, 3, I, II, III, IV, V
	 *
	 * @example <caption>Retries the caught source Observable again in case of error, similar to retry() operator</caption>
	 *
	 * Observable.of(1, 2, 3, 4, 5)
	 *   .map(n => {
	 * 	   if (n === 4) {
	 * 	     throw 'four!';
	 *     }
	 * 	   return n;
	 *   })
	 *   .catch((err, caught) => caught)
	 *   .take(30)
	 *   .subscribe(x => console.log(x));
	 *   // 1, 2, 3, 1, 2, 3, ...
	 *
	 * @example <caption>Throws a new error when the source Observable throws an error</caption>
	 *
	 * Observable.of(1, 2, 3, 4, 5)
	 *   .map(n => {
	 *     if (n == 4) {
	 *       throw 'four!';
	 *     }
	 *     return n;
	 *   })
	 *   .catch(err => {
	 *     throw 'error in source. Details: ' + err;
	 *   })
	 *   .subscribe(
	 *     x => console.log(x),
	 *     err => console.log(err)
	 *   );
	 *   // 1, 2, 3, error in source. Details: four!
	 *
	 * @param {function} selector a function that takes as arguments `err`, which is the error, and `caught`, which
	 *  is the source observable, in case you'd like to "retry" that observable by returning it again. Whatever observable
	 *  is returned by the `selector` will be used to continue the observable chain.
	 * @return {Observable} An observable that originates from either the source or the observable returned by the
	 *  catch `selector` function.
	 * @method catch
	 * @name catch
	 * @owner Observable
	 */
	function _catch(selector) {
	    var operator = new CatchOperator(selector);
	    var caught = this.lift(operator);
	    return (operator.caught = caught);
	}
	exports._catch = _catch;
	var CatchOperator = (function () {
	    function CatchOperator(selector) {
	        this.selector = selector;
	    }
	    CatchOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
	    };
	    return CatchOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var CatchSubscriber = (function (_super) {
	    __extends(CatchSubscriber, _super);
	    function CatchSubscriber(destination, selector, caught) {
	        _super.call(this, destination);
	        this.selector = selector;
	        this.caught = caught;
	    }
	    // NOTE: overriding `error` instead of `_error` because we don't want
	    // to have this flag this subscriber as `isStopped`. We can mimic the
	    // behavior of the RetrySubscriber (from the `retry` operator), where
	    // we unsubscribe from our source chain, reset our Subscriber flags,
	    // then subscribe to the selector result.
	    CatchSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var result = void 0;
	            try {
	                result = this.selector(err, this.caught);
	            }
	            catch (err2) {
	                _super.prototype.error.call(this, err2);
	                return;
	            }
	            this._unsubscribeAndRecycle();
	            this.add(subscribeToResult_1.subscribeToResult(this, result));
	        }
	    };
	    return CatchSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var combineLatest_1 = __webpack_require__(32);
	/**
	 * Converts a higher-order Observable into a first-order Observable by waiting
	 * for the outer Observable to complete, then applying {@link combineLatest}.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables by applying
	 * {@link combineLatest} when the Observable-of-Observables completes.</span>
	 *
	 * <img src="./img/combineAll.png" width="100%">
	 *
	 * Takes an Observable of Observables, and collects all Observables from it.
	 * Once the outer Observable completes, it subscribes to all collected
	 * Observables and combines their values using the {@link combineLatest}
	 * strategy, such that:
	 * - Every time an inner Observable emits, the output Observable emits.
	 * - When the returned observable emits, it emits all of the latest values by:
	 *   - If a `project` function is provided, it is called with each recent value
	 *     from each inner Observable in whatever order they arrived, and the result
	 *     of the `project` function is what is emitted by the output Observable.
	 *   - If there is no `project` function, an array of all of the most recent
	 *     values is emitted by the output Observable.
	 *
	 * @example <caption>Map two click events to a finite interval Observable, then apply combineAll</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map(ev =>
	 *   Rx.Observable.interval(Math.random()*2000).take(3)
	 * ).take(2);
	 * var result = higherOrder.combineAll();
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link combineLatest}
	 * @see {@link mergeAll}
	 *
	 * @param {function} [project] An optional function to map the most recent
	 * values from each inner Observable into a new result. Takes each of the most
	 * recent values from each collected inner Observable as arguments, in order.
	 * @return {Observable} An Observable of projected results or arrays of recent
	 * values.
	 * @method combineAll
	 * @owner Observable
	 */
	function combineAll(project) {
	    return this.lift(new combineLatest_1.CombineLatestOperator(project));
	}
	exports.combineAll = combineAll;


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var mergeAll_1 = __webpack_require__(21);
	/* tslint:enable:max-line-length */
	/**
	 * Converts a higher-order Observable into a first-order Observable by
	 * concatenating the inner Observables in order.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables by putting one
	 * inner Observable after the other.</span>
	 *
	 * <img src="./img/concatAll.png" width="100%">
	 *
	 * Joins every Observable emitted by the source (a higher-order Observable), in
	 * a serial fashion. It subscribes to each inner Observable only after the
	 * previous inner Observable has completed, and merges all of their values into
	 * the returned observable.
	 *
	 * __Warning:__ If the source Observable emits Observables quickly and
	 * endlessly, and the inner Observables it emits generally complete slower than
	 * the source emits, you can run into memory issues as the incoming Observables
	 * collect in an unbounded buffer.
	 *
	 * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
	 * to `1`.
	 *
	 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
	 * var firstOrder = higherOrder.concatAll();
	 * firstOrder.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // (results are not concurrent)
	 * // For every click on the "document" it will emit values 0 to 3 spaced
	 * // on a 1000ms interval
	 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
	 *
	 * @see {@link combineAll}
	 * @see {@link concat}
	 * @see {@link concatMap}
	 * @see {@link concatMapTo}
	 * @see {@link exhaust}
	 * @see {@link mergeAll}
	 * @see {@link switch}
	 * @see {@link zipAll}
	 *
	 * @return {Observable} An Observable emitting values from all the inner
	 * Observables concatenated.
	 * @method concatAll
	 * @owner Observable
	 */
	function concatAll() {
	    return this.lift(new mergeAll_1.MergeAllOperator(1));
	}
	exports.concatAll = concatAll;


/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var mergeMap_1 = __webpack_require__(49);
	/* tslint:enable:max-line-length */
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable, in a serialized fashion waiting for each one to complete before
	 * merging the next.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link concatAll}.</span>
	 *
	 * <img src="./img/concatMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an (so-called "inner") Observable. Each new inner Observable is
	 * concatenated with the previous inner Observable.
	 *
	 * __Warning:__ if source values arrive endlessly and faster than their
	 * corresponding inner Observables can complete, it will result in memory issues
	 * as inner Observables amass in an unbounded buffer waiting for their turn to
	 * be subscribed to.
	 *
	 * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
	 * to `1`.
	 *
	 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
	 * result.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // (results are not concurrent)
	 * // For every click on the "document" it will emit values 0 to 3 spaced
	 * // on a 1000ms interval
	 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
	 *
	 * @see {@link concat}
	 * @see {@link concatAll}
	 * @see {@link concatMapTo}
	 * @see {@link exhaustMap}
	 * @see {@link mergeMap}
	 * @see {@link switchMap}
	 *
	 * @param {function(value: T, ?index: number): ObservableInput} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An observable of values merged from the projected
	 * Observables as they were subscribed to, one at a time. Optionally, these
	 * values may have been projected from a passed `projectResult` argument.
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and taking values from each projected inner
	 * Observable sequentially.
	 * @method concatMap
	 * @owner Observable
	 */
	function concatMap(project, resultSelector) {
	    return this.lift(new mergeMap_1.MergeMapOperator(project, resultSelector, 1));
	}
	exports.concatMap = concatMap;


/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var mergeMapTo_1 = __webpack_require__(50);
	/* tslint:enable:max-line-length */
	/**
	 * Projects each source value to the same Observable which is merged multiple
	 * times in a serialized fashion on the output Observable.
	 *
	 * <span class="informal">It's like {@link concatMap}, but maps each value
	 * always to the same inner Observable.</span>
	 *
	 * <img src="./img/concatMapTo.png" width="100%">
	 *
	 * Maps each source value to the given Observable `innerObservable` regardless
	 * of the source value, and then flattens those resulting Observables into one
	 * single Observable, which is the output Observable. Each new `innerObservable`
	 * instance emitted on the output Observable is concatenated with the previous
	 * `innerObservable` instance.
	 *
	 * __Warning:__ if source values arrive endlessly and faster than their
	 * corresponding inner Observables can complete, it will result in memory issues
	 * as inner Observables amass in an unbounded buffer waiting for their turn to
	 * be subscribed to.
	 *
	 * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter
	 * set to `1`.
	 *
	 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));
	 * result.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // (results are not concurrent)
	 * // For every click on the "document" it will emit values 0 to 3 spaced
	 * // on a 1000ms interval
	 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
	 *
	 * @see {@link concat}
	 * @see {@link concatAll}
	 * @see {@link concatMap}
	 * @see {@link mergeMapTo}
	 * @see {@link switchMapTo}
	 *
	 * @param {ObservableInput} innerObservable An Observable to replace each value from
	 * the source Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An observable of values merged together by joining the
	 * passed observable with itself, one after the other, for each value emitted
	 * from the source.
	 * @method concatMapTo
	 * @owner Observable
	 */
	function concatMapTo(innerObservable, resultSelector) {
	    return this.lift(new mergeMapTo_1.MergeMapToOperator(innerObservable, resultSelector, 1));
	}
	exports.concatMapTo = concatMapTo;


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/**
	 * Counts the number of emissions on the source and emits that number when the
	 * source completes.
	 *
	 * <span class="informal">Tells how many values were emitted, when the source
	 * completes.</span>
	 *
	 * <img src="./img/count.png" width="100%">
	 *
	 * `count` transforms an Observable that emits values into an Observable that
	 * emits a single value that represents the number of values emitted by the
	 * source Observable. If the source Observable terminates with an error, `count`
	 * will pass this error notification along without emitting a value first. If
	 * the source Observable does not terminate at all, `count` will neither emit
	 * a value nor terminate. This operator takes an optional `predicate` function
	 * as argument, in which case the output emission will represent the number of
	 * source values that matched `true` with the `predicate`.
	 *
	 * @example <caption>Counts how many seconds have passed before the first click happened</caption>
	 * var seconds = Rx.Observable.interval(1000);
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var secondsBeforeClick = seconds.takeUntil(clicks);
	 * var result = secondsBeforeClick.count();
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>
	 * var numbers = Rx.Observable.range(1, 7);
	 * var result = numbers.count(i => i % 2 === 1);
	 * result.subscribe(x => console.log(x));
	 *
	 * // Results in:
	 * // 4
	 *
	 * @see {@link max}
	 * @see {@link min}
	 * @see {@link reduce}
	 *
	 * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A
	 * boolean function to select what values are to be counted. It is provided with
	 * arguments of:
	 * - `value`: the value from the source Observable.
	 * - `index`: the (zero-based) "index" of the value from the source Observable.
	 * - `source`: the source Observable instance itself.
	 * @return {Observable} An Observable of one number that represents the count as
	 * described above.
	 * @method count
	 * @owner Observable
	 */
	function count(predicate) {
	    return this.lift(new CountOperator(predicate, this));
	}
	exports.count = count;
	var CountOperator = (function () {
	    function CountOperator(predicate, source) {
	        this.predicate = predicate;
	        this.source = source;
	    }
	    CountOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
	    };
	    return CountOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var CountSubscriber = (function (_super) {
	    __extends(CountSubscriber, _super);
	    function CountSubscriber(destination, predicate, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.source = source;
	        this.count = 0;
	        this.index = 0;
	    }
	    CountSubscriber.prototype._next = function (value) {
	        if (this.predicate) {
	            this._tryPredicate(value);
	        }
	        else {
	            this.count++;
	        }
	    };
	    CountSubscriber.prototype._tryPredicate = function (value) {
	        var result;
	        try {
	            result = this.predicate(value, this.index++, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            this.count++;
	        }
	    };
	    CountSubscriber.prototype._complete = function () {
	        this.destination.next(this.count);
	        this.destination.complete();
	    };
	    return CountSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/**
	 * Emits a value from the source Observable only after a particular time span
	 * determined by another Observable has passed without another source emission.
	 *
	 * <span class="informal">It's like {@link debounceTime}, but the time span of
	 * emission silence is determined by a second Observable.</span>
	 *
	 * <img src="./img/debounce.png" width="100%">
	 *
	 * `debounce` delays values emitted by the source Observable, but drops previous
	 * pending delayed emissions if a new value arrives on the source Observable.
	 * This operator keeps track of the most recent value from the source
	 * Observable, and spawns a duration Observable by calling the
	 * `durationSelector` function. The value is emitted only when the duration
	 * Observable emits a value or completes, and if no other value was emitted on
	 * the source Observable since the duration Observable was spawned. If a new
	 * value appears before the duration Observable emits, the previous value will
	 * be dropped and will not be emitted on the output Observable.
	 *
	 * Like {@link debounceTime}, this is a rate-limiting operator, and also a
	 * delay-like operator since output emissions do not necessarily occur at the
	 * same time as they did on the source Observable.
	 *
	 * @example <caption>Emit the most recent click after a burst of clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.debounce(() => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link audit}
	 * @see {@link debounceTime}
	 * @see {@link delayWhen}
	 * @see {@link throttle}
	 *
	 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
	 * that receives a value from the source Observable, for computing the timeout
	 * duration for each source value, returned as an Observable or a Promise.
	 * @return {Observable} An Observable that delays the emissions of the source
	 * Observable by the specified duration Observable returned by
	 * `durationSelector`, and may drop some values if they occur too frequently.
	 * @method debounce
	 * @owner Observable
	 */
	function debounce(durationSelector) {
	    return this.lift(new DebounceOperator(durationSelector));
	}
	exports.debounce = debounce;
	var DebounceOperator = (function () {
	    function DebounceOperator(durationSelector) {
	        this.durationSelector = durationSelector;
	    }
	    DebounceOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
	    };
	    return DebounceOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DebounceSubscriber = (function (_super) {
	    __extends(DebounceSubscriber, _super);
	    function DebounceSubscriber(destination, durationSelector) {
	        _super.call(this, destination);
	        this.durationSelector = durationSelector;
	        this.hasValue = false;
	        this.durationSubscription = null;
	    }
	    DebounceSubscriber.prototype._next = function (value) {
	        try {
	            var result = this.durationSelector.call(this, value);
	            if (result) {
	                this._tryNext(value, result);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    DebounceSubscriber.prototype._complete = function () {
	        this.emitValue();
	        this.destination.complete();
	    };
	    DebounceSubscriber.prototype._tryNext = function (value, duration) {
	        var subscription = this.durationSubscription;
	        this.value = value;
	        this.hasValue = true;
	        if (subscription) {
	            subscription.unsubscribe();
	            this.remove(subscription);
	        }
	        subscription = subscribeToResult_1.subscribeToResult(this, duration);
	        if (!subscription.closed) {
	            this.add(this.durationSubscription = subscription);
	        }
	    };
	    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.emitValue();
	    };
	    DebounceSubscriber.prototype.notifyComplete = function () {
	        this.emitValue();
	    };
	    DebounceSubscriber.prototype.emitValue = function () {
	        if (this.hasValue) {
	            var value = this.value;
	            var subscription = this.durationSubscription;
	            if (subscription) {
	                this.durationSubscription = null;
	                subscription.unsubscribe();
	                this.remove(subscription);
	            }
	            this.value = null;
	            this.hasValue = false;
	            _super.prototype._next.call(this, value);
	        }
	    };
	    return DebounceSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var async_1 = __webpack_require__(10);
	/**
	 * Emits a value from the source Observable only after a particular time span
	 * has passed without another source emission.
	 *
	 * <span class="informal">It's like {@link delay}, but passes only the most
	 * recent value from each burst of emissions.</span>
	 *
	 * <img src="./img/debounceTime.png" width="100%">
	 *
	 * `debounceTime` delays values emitted by the source Observable, but drops
	 * previous pending delayed emissions if a new value arrives on the source
	 * Observable. This operator keeps track of the most recent value from the
	 * source Observable, and emits that only when `dueTime` enough time has passed
	 * without any other value appearing on the source Observable. If a new value
	 * appears before `dueTime` silence occurs, the previous value will be dropped
	 * and will not be emitted on the output Observable.
	 *
	 * This is a rate-limiting operator, because it is impossible for more than one
	 * value to be emitted in any time window of duration `dueTime`, but it is also
	 * a delay-like operator since output emissions do not occur at the same time as
	 * they did on the source Observable. Optionally takes a {@link IScheduler} for
	 * managing timers.
	 *
	 * @example <caption>Emit the most recent click after a burst of clicks</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.debounceTime(1000);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link auditTime}
	 * @see {@link debounce}
	 * @see {@link delay}
	 * @see {@link sampleTime}
	 * @see {@link throttleTime}
	 *
	 * @param {number} dueTime The timeout duration in milliseconds (or the time
	 * unit determined internally by the optional `scheduler`) for the window of
	 * time required to wait for emission silence before emitting the most recent
	 * source value.
	 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
	 * managing the timers that handle the timeout for each value.
	 * @return {Observable} An Observable that delays the emissions of the source
	 * Observable by the specified `dueTime`, and may drop some values if they occur
	 * too frequently.
	 * @method debounceTime
	 * @owner Observable
	 */
	function debounceTime(dueTime, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new DebounceTimeOperator(dueTime, scheduler));
	}
	exports.debounceTime = debounceTime;
	var DebounceTimeOperator = (function () {
	    function DebounceTimeOperator(dueTime, scheduler) {
	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	    }
	    DebounceTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
	    };
	    return DebounceTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DebounceTimeSubscriber = (function (_super) {
	    __extends(DebounceTimeSubscriber, _super);
	    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
	        _super.call(this, destination);
	        this.dueTime = dueTime;
	        this.scheduler = scheduler;
	        this.debouncedSubscription = null;
	        this.lastValue = null;
	        this.hasValue = false;
	    }
	    DebounceTimeSubscriber.prototype._next = function (value) {
	        this.clearDebounce();
	        this.lastValue = value;
	        this.hasValue = true;
	        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
	    };
	    DebounceTimeSubscriber.prototype._complete = function () {
	        this.debouncedNext();
	        this.destination.complete();
	    };
	    DebounceTimeSubscriber.prototype.debouncedNext = function () {
	        this.clearDebounce();
	        if (this.hasValue) {
	            this.destination.next(this.lastValue);
	            this.lastValue = null;
	            this.hasValue = false;
	        }
	    };
	    DebounceTimeSubscriber.prototype.clearDebounce = function () {
	        var debouncedSubscription = this.debouncedSubscription;
	        if (debouncedSubscription !== null) {
	            this.remove(debouncedSubscription);
	            debouncedSubscription.unsubscribe();
	            this.debouncedSubscription = null;
	        }
	    };
	    return DebounceTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchNext(subscriber) {
	    subscriber.debouncedNext();
	}


/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/* tslint:enable:max-line-length */
	/**
	 * Emits a given value if the source Observable completes without emitting any
	 * `next` value, otherwise mirrors the source Observable.
	 *
	 * <span class="informal">If the source Observable turns out to be empty, then
	 * this operator will emit a default value.</span>
	 *
	 * <img src="./img/defaultIfEmpty.png" width="100%">
	 *
	 * `defaultIfEmpty` emits the values emitted by the source Observable or a
	 * specified default value if the source Observable is empty (completes without
	 * having emitted any `next` value).
	 *
	 * @example <caption>If no clicks happen in 5 seconds, then emit "no clicks"</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));
	 * var result = clicksBeforeFive.defaultIfEmpty('no clicks');
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link empty}
	 * @see {@link last}
	 *
	 * @param {any} [defaultValue=null] The default value used if the source
	 * Observable is empty.
	 * @return {Observable} An Observable that emits either the specified
	 * `defaultValue` if the source Observable emits no items, or the values emitted
	 * by the source Observable.
	 * @method defaultIfEmpty
	 * @owner Observable
	 */
	function defaultIfEmpty(defaultValue) {
	    if (defaultValue === void 0) { defaultValue = null; }
	    return this.lift(new DefaultIfEmptyOperator(defaultValue));
	}
	exports.defaultIfEmpty = defaultIfEmpty;
	var DefaultIfEmptyOperator = (function () {
	    function DefaultIfEmptyOperator(defaultValue) {
	        this.defaultValue = defaultValue;
	    }
	    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
	    };
	    return DefaultIfEmptyOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DefaultIfEmptySubscriber = (function (_super) {
	    __extends(DefaultIfEmptySubscriber, _super);
	    function DefaultIfEmptySubscriber(destination, defaultValue) {
	        _super.call(this, destination);
	        this.defaultValue = defaultValue;
	        this.isEmpty = true;
	    }
	    DefaultIfEmptySubscriber.prototype._next = function (value) {
	        this.isEmpty = false;
	        this.destination.next(value);
	    };
	    DefaultIfEmptySubscriber.prototype._complete = function () {
	        if (this.isEmpty) {
	            this.destination.next(this.defaultValue);
	        }
	        this.destination.complete();
	    };
	    return DefaultIfEmptySubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1 = __webpack_require__(10);
	var isDate_1 = __webpack_require__(27);
	var Subscriber_1 = __webpack_require__(2);
	var Notification_1 = __webpack_require__(16);
	/**
	 * Delays the emission of items from the source Observable by a given timeout or
	 * until a given Date.
	 *
	 * <span class="informal">Time shifts each item by some specified amount of
	 * milliseconds.</span>
	 *
	 * <img src="./img/delay.png" width="100%">
	 *
	 * If the delay argument is a Number, this operator time shifts the source
	 * Observable by that amount of time expressed in milliseconds. The relative
	 * time intervals between the values are preserved.
	 *
	 * If the delay argument is a Date, this operator time shifts the start of the
	 * Observable execution until the given date occurs.
	 *
	 * @example <caption>Delay each click by one second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
	 * delayedClicks.subscribe(x => console.log(x));
	 *
	 * @example <caption>Delay all clicks until a future date happens</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var date = new Date('March 15, 2050 12:00:00'); // in the future
	 * var delayedClicks = clicks.delay(date); // click emitted only after that date
	 * delayedClicks.subscribe(x => console.log(x));
	 *
	 * @see {@link debounceTime}
	 * @see {@link delayWhen}
	 *
	 * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
	 * a `Date` until which the emission of the source items is delayed.
	 * @param {Scheduler} [scheduler=async] The IScheduler to use for
	 * managing the timers that handle the time-shift for each item.
	 * @return {Observable} An Observable that delays the emissions of the source
	 * Observable by the specified timeout or Date.
	 * @method delay
	 * @owner Observable
	 */
	function delay(delay, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    var absoluteDelay = isDate_1.isDate(delay);
	    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
	    return this.lift(new DelayOperator(delayFor, scheduler));
	}
	exports.delay = delay;
	var DelayOperator = (function () {
	    function DelayOperator(delay, scheduler) {
	        this.delay = delay;
	        this.scheduler = scheduler;
	    }
	    DelayOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
	    };
	    return DelayOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DelaySubscriber = (function (_super) {
	    __extends(DelaySubscriber, _super);
	    function DelaySubscriber(destination, delay, scheduler) {
	        _super.call(this, destination);
	        this.delay = delay;
	        this.scheduler = scheduler;
	        this.queue = [];
	        this.active = false;
	        this.errored = false;
	    }
	    DelaySubscriber.dispatch = function (state) {
	        var source = state.source;
	        var queue = source.queue;
	        var scheduler = state.scheduler;
	        var destination = state.destination;
	        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
	            queue.shift().notification.observe(destination);
	        }
	        if (queue.length > 0) {
	            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
	            this.schedule(state, delay_1);
	        }
	        else {
	            source.active = false;
	        }
	    };
	    DelaySubscriber.prototype._schedule = function (scheduler) {
	        this.active = true;
	        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
	            source: this, destination: this.destination, scheduler: scheduler
	        }));
	    };
	    DelaySubscriber.prototype.scheduleNotification = function (notification) {
	        if (this.errored === true) {
	            return;
	        }
	        var scheduler = this.scheduler;
	        var message = new DelayMessage(scheduler.now() + this.delay, notification);
	        this.queue.push(message);
	        if (this.active === false) {
	            this._schedule(scheduler);
	        }
	    };
	    DelaySubscriber.prototype._next = function (value) {
	        this.scheduleNotification(Notification_1.Notification.createNext(value));
	    };
	    DelaySubscriber.prototype._error = function (err) {
	        this.errored = true;
	        this.queue = [];
	        this.destination.error(err);
	    };
	    DelaySubscriber.prototype._complete = function () {
	        this.scheduleNotification(Notification_1.Notification.createComplete());
	    };
	    return DelaySubscriber;
	}(Subscriber_1.Subscriber));
	var DelayMessage = (function () {
	    function DelayMessage(time, notification) {
	        this.time = time;
	        this.notification = notification;
	    }
	    return DelayMessage;
	}());


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var Observable_1 = __webpack_require__(1);
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/**
	 * Delays the emission of items from the source Observable by a given time span
	 * determined by the emissions of another Observable.
	 *
	 * <span class="informal">It's like {@link delay}, but the time span of the
	 * delay duration is determined by a second Observable.</span>
	 *
	 * <img src="./img/delayWhen.png" width="100%">
	 *
	 * `delayWhen` time shifts each emitted value from the source Observable by a
	 * time span determined by another Observable. When the source emits a value,
	 * the `delayDurationSelector` function is called with the source value as
	 * argument, and should return an Observable, called the "duration" Observable.
	 * The source value is emitted on the output Observable only when the duration
	 * Observable emits a value or completes.
	 *
	 * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which
	 * is an Observable. When `subscriptionDelay` emits its first value or
	 * completes, the source Observable is subscribed to and starts behaving like
	 * described in the previous paragraph. If `subscriptionDelay` is not provided,
	 * `delayWhen` will subscribe to the source Observable as soon as the output
	 * Observable is subscribed.
	 *
	 * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var delayedClicks = clicks.delayWhen(event =>
	 *   Rx.Observable.interval(Math.random() * 5000)
	 * );
	 * delayedClicks.subscribe(x => console.log(x));
	 *
	 * @see {@link debounce}
	 * @see {@link delay}
	 *
	 * @param {function(value: T): Observable} delayDurationSelector A function that
	 * returns an Observable for each value emitted by the source Observable, which
	 * is then used to delay the emission of that item on the output Observable
	 * until the Observable returned from this function emits a value.
	 * @param {Observable} subscriptionDelay An Observable that triggers the
	 * subscription to the source Observable once it emits any value.
	 * @return {Observable} An Observable that delays the emissions of the source
	 * Observable by an amount of time specified by the Observable returned by
	 * `delayDurationSelector`.
	 * @method delayWhen
	 * @owner Observable
	 */
	function delayWhen(delayDurationSelector, subscriptionDelay) {
	    if (subscriptionDelay) {
	        return new SubscriptionDelayObservable(this, subscriptionDelay)
	            .lift(new DelayWhenOperator(delayDurationSelector));
	    }
	    return this.lift(new DelayWhenOperator(delayDurationSelector));
	}
	exports.delayWhen = delayWhen;
	var DelayWhenOperator = (function () {
	    function DelayWhenOperator(delayDurationSelector) {
	        this.delayDurationSelector = delayDurationSelector;
	    }
	    DelayWhenOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
	    };
	    return DelayWhenOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DelayWhenSubscriber = (function (_super) {
	    __extends(DelayWhenSubscriber, _super);
	    function DelayWhenSubscriber(destination, delayDurationSelector) {
	        _super.call(this, destination);
	        this.delayDurationSelector = delayDurationSelector;
	        this.completed = false;
	        this.delayNotifierSubscriptions = [];
	        this.values = [];
	    }
	    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(outerValue);
	        this.removeSubscription(innerSub);
	        this.tryComplete();
	    };
	    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
	        var value = this.removeSubscription(innerSub);
	        if (value) {
	            this.destination.next(value);
	        }
	        this.tryComplete();
	    };
	    DelayWhenSubscriber.prototype._next = function (value) {
	        try {
	            var delayNotifier = this.delayDurationSelector(value);
	            if (delayNotifier) {
	                this.tryDelay(delayNotifier, value);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    DelayWhenSubscriber.prototype._complete = function () {
	        this.completed = true;
	        this.tryComplete();
	    };
	    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
	        subscription.unsubscribe();
	        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
	        var value = null;
	        if (subscriptionIdx !== -1) {
	            value = this.values[subscriptionIdx];
	            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
	            this.values.splice(subscriptionIdx, 1);
	        }
	        return value;
	    };
	    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
	        var notifierSubscription = subscribeToResult_1.subscribeToResult(this, delayNotifier, value);
	        this.add(notifierSubscription);
	        this.delayNotifierSubscriptions.push(notifierSubscription);
	        this.values.push(value);
	    };
	    DelayWhenSubscriber.prototype.tryComplete = function () {
	        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
	            this.destination.complete();
	        }
	    };
	    return DelayWhenSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubscriptionDelayObservable = (function (_super) {
	    __extends(SubscriptionDelayObservable, _super);
	    function SubscriptionDelayObservable(source, subscriptionDelay) {
	        _super.call(this);
	        this.source = source;
	        this.subscriptionDelay = subscriptionDelay;
	    }
	    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
	        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
	    };
	    return SubscriptionDelayObservable;
	}(Observable_1.Observable));
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SubscriptionDelaySubscriber = (function (_super) {
	    __extends(SubscriptionDelaySubscriber, _super);
	    function SubscriptionDelaySubscriber(parent, source) {
	        _super.call(this);
	        this.parent = parent;
	        this.source = source;
	        this.sourceSubscribed = false;
	    }
	    SubscriptionDelaySubscriber.prototype._next = function (unused) {
	        this.subscribeToSource();
	    };
	    SubscriptionDelaySubscriber.prototype._error = function (err) {
	        this.unsubscribe();
	        this.parent.error(err);
	    };
	    SubscriptionDelaySubscriber.prototype._complete = function () {
	        this.subscribeToSource();
	    };
	    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
	        if (!this.sourceSubscribed) {
	            this.sourceSubscribed = true;
	            this.unsubscribe();
	            this.source.subscribe(this.parent);
	        }
	    };
	    return SubscriptionDelaySubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/**
	 * Converts an Observable of {@link Notification} objects into the emissions
	 * that they represent.
	 *
	 * <span class="informal">Unwraps {@link Notification} objects as actual `next`,
	 * `error` and `complete` emissions. The opposite of {@link materialize}.</span>
	 *
	 * <img src="./img/dematerialize.png" width="100%">
	 *
	 * `dematerialize` is assumed to operate an Observable that only emits
	 * {@link Notification} objects as `next` emissions, and does not emit any
	 * `error`. Such Observable is the output of a `materialize` operation. Those
	 * notifications are then unwrapped using the metadata they contain, and emitted
	 * as `next`, `error`, and `complete` on the output Observable.
	 *
	 * Use this operator in conjunction with {@link materialize}.
	 *
	 * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>
	 * var notifA = new Rx.Notification('N', 'A');
	 * var notifB = new Rx.Notification('N', 'B');
	 * var notifE = new Rx.Notification('E', void 0,
	 *   new TypeError('x.toUpperCase is not a function')
	 * );
	 * var materialized = Rx.Observable.of(notifA, notifB, notifE);
	 * var upperCase = materialized.dematerialize();
	 * upperCase.subscribe(x => console.log(x), e => console.error(e));
	 *
	 * // Results in:
	 * // A
	 * // B
	 * // TypeError: x.toUpperCase is not a function
	 *
	 * @see {@link Notification}
	 * @see {@link materialize}
	 *
	 * @return {Observable} An Observable that emits items and notifications
	 * embedded in Notification objects emitted by the source Observable.
	 * @method dematerialize
	 * @owner Observable
	 */
	function dematerialize() {
	    return this.lift(new DeMaterializeOperator());
	}
	exports.dematerialize = dematerialize;
	var DeMaterializeOperator = (function () {
	    function DeMaterializeOperator() {
	    }
	    DeMaterializeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DeMaterializeSubscriber(subscriber));
	    };
	    return DeMaterializeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DeMaterializeSubscriber = (function (_super) {
	    __extends(DeMaterializeSubscriber, _super);
	    function DeMaterializeSubscriber(destination) {
	        _super.call(this, destination);
	    }
	    DeMaterializeSubscriber.prototype._next = function (value) {
	        value.observe(this.destination);
	    };
	    return DeMaterializeSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	var Set_1 = __webpack_require__(341);
	/**
	 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.
	 *
	 * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will
	 * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the
	 * source observable directly with an equality check against previous values.
	 *
	 * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.
	 *
	 * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the
	 * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`
	 * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so
	 * that the internal `Set` can be "flushed", basically clearing it of values.
	 *
	 * @example <caption>A simple example with numbers</caption>
	 * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)
	 *   .distinct()
	 *   .subscribe(x => console.log(x)); // 1, 2, 3, 4
	 *
	 * @example <caption>An example using a keySelector function</caption>
	 * interface Person {
	 *    age: number,
	 *    name: string
	 * }
	 *
	 * Observable.of<Person>(
	 *     { age: 4, name: 'Foo'},
	 *     { age: 7, name: 'Bar'},
	 *     { age: 5, name: 'Foo'})
	 *     .distinct((p: Person) => p.name)
	 *     .subscribe(x => console.log(x));
	 *
	 * // displays:
	 * // { age: 4, name: 'Foo' }
	 * // { age: 7, name: 'Bar' }
	 *
	 * @see {@link distinctUntilChanged}
	 * @see {@link distinctUntilKeyChanged}
	 *
	 * @param {function} [keySelector] Optional function to select which value you want to check as distinct.
	 * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.
	 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
	 * @method distinct
	 * @owner Observable
	 */
	function distinct(keySelector, flushes) {
	    return this.lift(new DistinctOperator(keySelector, flushes));
	}
	exports.distinct = distinct;
	var DistinctOperator = (function () {
	    function DistinctOperator(keySelector, flushes) {
	        this.keySelector = keySelector;
	        this.flushes = flushes;
	    }
	    DistinctOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
	    };
	    return DistinctOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DistinctSubscriber = (function (_super) {
	    __extends(DistinctSubscriber, _super);
	    function DistinctSubscriber(destination, keySelector, flushes) {
	        _super.call(this, destination);
	        this.keySelector = keySelector;
	        this.values = new Set_1.Set();
	        if (flushes) {
	            this.add(subscribeToResult_1.subscribeToResult(this, flushes));
	        }
	    }
	    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.values.clear();
	    };
	    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    DistinctSubscriber.prototype._next = function (value) {
	        if (this.keySelector) {
	            this._useKeySelector(value);
	        }
	        else {
	            this._finalizeNext(value, value);
	        }
	    };
	    DistinctSubscriber.prototype._useKeySelector = function (value) {
	        var key;
	        var destination = this.destination;
	        try {
	            key = this.keySelector(value);
	        }
	        catch (err) {
	            destination.error(err);
	            return;
	        }
	        this._finalizeNext(key, value);
	    };
	    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
	        var values = this.values;
	        if (!values.has(key)) {
	            values.add(key);
	            this.destination.next(value);
	        }
	    };
	    return DistinctSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.DistinctSubscriber = DistinctSubscriber;


/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var distinctUntilChanged_1 = __webpack_require__(45);
	/* tslint:enable:max-line-length */
	/**
	 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,
	 * using a property accessed by using the key provided to check if the two items are distinct.
	 *
	 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
	 *
	 * If a comparator function is not provided, an equality check is used by default.
	 *
	 * @example <caption>An example comparing the name of persons</caption>
	 *
	 *  interface Person {
	 *     age: number,
	 *     name: string
	 *  }
	 *
	 * Observable.of<Person>(
	 *     { age: 4, name: 'Foo'},
	 *     { age: 7, name: 'Bar'},
	 *     { age: 5, name: 'Foo'},
	 *     { age: 6, name: 'Foo'})
	 *     .distinctUntilKeyChanged('name')
	 *     .subscribe(x => console.log(x));
	 *
	 * // displays:
	 * // { age: 4, name: 'Foo' }
	 * // { age: 7, name: 'Bar' }
	 * // { age: 5, name: 'Foo' }
	 *
	 * @example <caption>An example comparing the first letters of the name</caption>
	 *
	 * interface Person {
	 *     age: number,
	 *     name: string
	 *  }
	 *
	 * Observable.of<Person>(
	 *     { age: 4, name: 'Foo1'},
	 *     { age: 7, name: 'Bar'},
	 *     { age: 5, name: 'Foo2'},
	 *     { age: 6, name: 'Foo3'})
	 *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))
	 *     .subscribe(x => console.log(x));
	 *
	 * // displays:
	 * // { age: 4, name: 'Foo1' }
	 * // { age: 7, name: 'Bar' }
	 * // { age: 5, name: 'Foo2' }
	 *
	 * @see {@link distinct}
	 * @see {@link distinctUntilChanged}
	 *
	 * @param {string} key String key for object property lookup on each item.
	 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
	 * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.
	 * @method distinctUntilKeyChanged
	 * @owner Observable
	 */
	function distinctUntilKeyChanged(key, compare) {
	    return distinctUntilChanged_1.distinctUntilChanged.call(this, function (x, y) {
	        if (compare) {
	            return compare(x[key], y[key]);
	        }
	        return x[key] === y[key];
	    });
	}
	exports.distinctUntilKeyChanged = distinctUntilKeyChanged;


/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/* tslint:enable:max-line-length */
	/**
	 * Perform a side effect for every emission on the source Observable, but return
	 * an Observable that is identical to the source.
	 *
	 * <span class="informal">Intercepts each emission on the source and runs a
	 * function, but returns an output which is identical to the source.</span>
	 *
	 * <img src="./img/do.png" width="100%">
	 *
	 * Returns a mirrored Observable of the source Observable, but modified so that
	 * the provided Observer is called to perform a side effect for every value,
	 * error, and completion emitted by the source. Any errors that are thrown in
	 * the aforementioned Observer or handlers are safely sent down the error path
	 * of the output Observable.
	 *
	 * This operator is useful for debugging your Observables for the correct values
	 * or performing other side effects.
	 *
	 * Note: this is different to a `subscribe` on the Observable. If the Observable
	 * returned by `do` is not subscribed, the side effects specified by the
	 * Observer will never happen. `do` therefore simply spies on existing
	 * execution, it does not trigger an execution to happen like `subscribe` does.
	 *
	 * @example <caption>Map every every click to the clientX position of that click, while also logging the click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var positions = clicks
	 *   .do(ev => console.log(ev))
	 *   .map(ev => ev.clientX);
	 * positions.subscribe(x => console.log(x));
	 *
	 * @see {@link map}
	 * @see {@link subscribe}
	 *
	 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
	 * callback for `next`.
	 * @param {function} [error] Callback for errors in the source.
	 * @param {function} [complete] Callback for the completion of the source.
	 * @return {Observable} An Observable identical to the source, but runs the
	 * specified Observer or callback(s) for each item.
	 * @method do
	 * @name do
	 * @owner Observable
	 */
	function _do(nextOrObserver, error, complete) {
	    return this.lift(new DoOperator(nextOrObserver, error, complete));
	}
	exports._do = _do;
	var DoOperator = (function () {
	    function DoOperator(nextOrObserver, error, complete) {
	        this.nextOrObserver = nextOrObserver;
	        this.error = error;
	        this.complete = complete;
	    }
	    DoOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new DoSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
	    };
	    return DoOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var DoSubscriber = (function (_super) {
	    __extends(DoSubscriber, _super);
	    function DoSubscriber(destination, nextOrObserver, error, complete) {
	        _super.call(this, destination);
	        var safeSubscriber = new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	        safeSubscriber.syncErrorThrowable = true;
	        this.add(safeSubscriber);
	        this.safeSubscriber = safeSubscriber;
	    }
	    DoSubscriber.prototype._next = function (value) {
	        var safeSubscriber = this.safeSubscriber;
	        safeSubscriber.next(value);
	        if (safeSubscriber.syncErrorThrown) {
	            this.destination.error(safeSubscriber.syncErrorValue);
	        }
	        else {
	            this.destination.next(value);
	        }
	    };
	    DoSubscriber.prototype._error = function (err) {
	        var safeSubscriber = this.safeSubscriber;
	        safeSubscriber.error(err);
	        if (safeSubscriber.syncErrorThrown) {
	            this.destination.error(safeSubscriber.syncErrorValue);
	        }
	        else {
	            this.destination.error(err);
	        }
	    };
	    DoSubscriber.prototype._complete = function () {
	        var safeSubscriber = this.safeSubscriber;
	        safeSubscriber.complete();
	        if (safeSubscriber.syncErrorThrown) {
	            this.destination.error(safeSubscriber.syncErrorValue);
	        }
	        else {
	            this.destination.complete();
	        }
	    };
	    return DoSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var ArgumentOutOfRangeError_1 = __webpack_require__(24);
	/**
	 * Emits the single value at the specified `index` in a sequence of emissions
	 * from the source Observable.
	 *
	 * <span class="informal">Emits only the i-th value, then completes.</span>
	 *
	 * <img src="./img/elementAt.png" width="100%">
	 *
	 * `elementAt` returns an Observable that emits the item at the specified
	 * `index` in the source Observable, or a default value if that `index` is out
	 * of range and the `default` argument is provided. If the `default` argument is
	 * not given and the `index` is out of range, the output Observable will emit an
	 * `ArgumentOutOfRangeError` error.
	 *
	 * @example <caption>Emit only the third click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.elementAt(2);
	 * result.subscribe(x => console.log(x));
	 *
	 * // Results in:
	 * // click 1 = nothing
	 * // click 2 = nothing
	 * // click 3 = MouseEvent object logged to console
	 *
	 * @see {@link first}
	 * @see {@link last}
	 * @see {@link skip}
	 * @see {@link single}
	 * @see {@link take}
	 *
	 * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an
	 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the
	 * Observable has completed before emitting the i-th `next` notification.
	 *
	 * @param {number} index Is the number `i` for the i-th source emission that has
	 * happened since the subscription, starting from the number `0`.
	 * @param {T} [defaultValue] The default value returned for missing indices.
	 * @return {Observable} An Observable that emits a single item, if it is found.
	 * Otherwise, will emit the default value if given. If not, then emits an error.
	 * @method elementAt
	 * @owner Observable
	 */
	function elementAt(index, defaultValue) {
	    return this.lift(new ElementAtOperator(index, defaultValue));
	}
	exports.elementAt = elementAt;
	var ElementAtOperator = (function () {
	    function ElementAtOperator(index, defaultValue) {
	        this.index = index;
	        this.defaultValue = defaultValue;
	        if (index < 0) {
	            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
	        }
	    }
	    ElementAtOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ElementAtSubscriber(subscriber, this.index, this.defaultValue));
	    };
	    return ElementAtOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ElementAtSubscriber = (function (_super) {
	    __extends(ElementAtSubscriber, _super);
	    function ElementAtSubscriber(destination, index, defaultValue) {
	        _super.call(this, destination);
	        this.index = index;
	        this.defaultValue = defaultValue;
	    }
	    ElementAtSubscriber.prototype._next = function (x) {
	        if (this.index-- === 0) {
	            this.destination.next(x);
	            this.destination.complete();
	        }
	    };
	    ElementAtSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        if (this.index >= 0) {
	            if (typeof this.defaultValue !== 'undefined') {
	                destination.next(this.defaultValue);
	            }
	            else {
	                destination.error(new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError);
	            }
	        }
	        destination.complete();
	    };
	    return ElementAtSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/**
	 * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.
	 *
	 * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>
	 *  Observable.of(1, 2, 3, 4, 5, 6)
	 *     .every(x => x < 5)
	 *     .subscribe(x => console.log(x)); // -> false
	 *
	 * @param {function} predicate A function for determining if an item meets a specified condition.
	 * @param {any} [thisArg] Optional object to use for `this` in the callback.
	 * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.
	 * @method every
	 * @owner Observable
	 */
	function every(predicate, thisArg) {
	    return this.lift(new EveryOperator(predicate, thisArg, this));
	}
	exports.every = every;
	var EveryOperator = (function () {
	    function EveryOperator(predicate, thisArg, source) {
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.source = source;
	    }
	    EveryOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
	    };
	    return EveryOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var EverySubscriber = (function (_super) {
	    __extends(EverySubscriber, _super);
	    function EverySubscriber(destination, predicate, thisArg, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.thisArg = thisArg;
	        this.source = source;
	        this.index = 0;
	        this.thisArg = thisArg || this;
	    }
	    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
	        this.destination.next(everyValueMatch);
	        this.destination.complete();
	    };
	    EverySubscriber.prototype._next = function (value) {
	        var result = false;
	        try {
	            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (!result) {
	            this.notifyComplete(false);
	        }
	    };
	    EverySubscriber.prototype._complete = function () {
	        this.notifyComplete(true);
	    };
	    return EverySubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/**
	 * Converts a higher-order Observable into a first-order Observable by dropping
	 * inner Observables while the previous inner Observable has not yet completed.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables by dropping the
	 * next inner Observables while the current inner is still executing.</span>
	 *
	 * <img src="./img/exhaust.png" width="100%">
	 *
	 * `exhaust` subscribes to an Observable that emits Observables, also known as a
	 * higher-order Observable. Each time it observes one of these emitted inner
	 * Observables, the output Observable begins emitting the items emitted by that
	 * inner Observable. So far, it behaves like {@link mergeAll}. However,
	 * `exhaust` ignores every new inner Observable if the previous Observable has
	 * not yet completed. Once that one completes, it will accept and flatten the
	 * next inner Observable and repeat this process.
	 *
	 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
	 * var result = higherOrder.exhaust();
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link combineAll}
	 * @see {@link concatAll}
	 * @see {@link switch}
	 * @see {@link mergeAll}
	 * @see {@link exhaustMap}
	 * @see {@link zipAll}
	 *
	 * @return {Observable} An Observable that takes a source of Observables and propagates the first observable
	 * exclusively until it completes before subscribing to the next.
	 * @method exhaust
	 * @owner Observable
	 */
	function exhaust() {
	    return this.lift(new SwitchFirstOperator());
	}
	exports.exhaust = exhaust;
	var SwitchFirstOperator = (function () {
	    function SwitchFirstOperator() {
	    }
	    SwitchFirstOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SwitchFirstSubscriber(subscriber));
	    };
	    return SwitchFirstOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchFirstSubscriber = (function (_super) {
	    __extends(SwitchFirstSubscriber, _super);
	    function SwitchFirstSubscriber(destination) {
	        _super.call(this, destination);
	        this.hasCompleted = false;
	        this.hasSubscription = false;
	    }
	    SwitchFirstSubscriber.prototype._next = function (value) {
	        if (!this.hasSubscription) {
	            this.hasSubscription = true;
	            this.add(subscribeToResult_1.subscribeToResult(this, value));
	        }
	    };
	    SwitchFirstSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (!this.hasSubscription) {
	            this.destination.complete();
	        }
	    };
	    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.remove(innerSub);
	        this.hasSubscription = false;
	        if (this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return SwitchFirstSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/* tslint:enable:max-line-length */
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable only if the previous projected Observable has completed.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link exhaust}.</span>
	 *
	 * <img src="./img/exhaustMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an (so-called "inner") Observable. When it projects a source value to
	 * an Observable, the output Observable begins emitting the items emitted by
	 * that projected Observable. However, `exhaustMap` ignores every new projected
	 * Observable if the previous projected Observable has not yet completed. Once
	 * that one completes, it will accept and flatten the next projected Observable
	 * and repeat this process.
	 *
	 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMap}
	 * @see {@link exhaust}
	 * @see {@link mergeMap}
	 * @see {@link switchMap}
	 *
	 * @param {function(value: T, ?index: number): ObservableInput} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An Observable containing projected Observables
	 * of each item of the source, ignoring projected Observables that start before
	 * their preceding Observable has completed.
	 * @method exhaustMap
	 * @owner Observable
	 */
	function exhaustMap(project, resultSelector) {
	    return this.lift(new SwitchFirstMapOperator(project, resultSelector));
	}
	exports.exhaustMap = exhaustMap;
	var SwitchFirstMapOperator = (function () {
	    function SwitchFirstMapOperator(project, resultSelector) {
	        this.project = project;
	        this.resultSelector = resultSelector;
	    }
	    SwitchFirstMapOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SwitchFirstMapSubscriber(subscriber, this.project, this.resultSelector));
	    };
	    return SwitchFirstMapOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchFirstMapSubscriber = (function (_super) {
	    __extends(SwitchFirstMapSubscriber, _super);
	    function SwitchFirstMapSubscriber(destination, project, resultSelector) {
	        _super.call(this, destination);
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.hasSubscription = false;
	        this.hasCompleted = false;
	        this.index = 0;
	    }
	    SwitchFirstMapSubscriber.prototype._next = function (value) {
	        if (!this.hasSubscription) {
	            this.tryNext(value);
	        }
	    };
	    SwitchFirstMapSubscriber.prototype.tryNext = function (value) {
	        var index = this.index++;
	        var destination = this.destination;
	        try {
	            var result = this.project(value, index);
	            this.hasSubscription = true;
	            this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
	        }
	        catch (err) {
	            destination.error(err);
	        }
	    };
	    SwitchFirstMapSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (!this.hasSubscription) {
	            this.destination.complete();
	        }
	    };
	    SwitchFirstMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        if (resultSelector) {
	            this.trySelectResult(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            destination.next(innerValue);
	        }
	    };
	    SwitchFirstMapSubscriber.prototype.trySelectResult = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        try {
	            var result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	            destination.next(result);
	        }
	        catch (err) {
	            destination.error(err);
	        }
	    };
	    SwitchFirstMapSubscriber.prototype.notifyError = function (err) {
	        this.destination.error(err);
	    };
	    SwitchFirstMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.remove(innerSub);
	        this.hasSubscription = false;
	        if (this.hasCompleted) {
	            this.destination.complete();
	        }
	    };
	    return SwitchFirstMapSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var tryCatch_1 = __webpack_require__(9);
	var errorObject_1 = __webpack_require__(7);
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/* tslint:enable:max-line-length */
	/**
	 * Recursively projects each source value to an Observable which is merged in
	 * the output Observable.
	 *
	 * <span class="informal">It's similar to {@link mergeMap}, but applies the
	 * projection function to every source value as well as every output value.
	 * It's recursive.</span>
	 *
	 * <img src="./img/expand.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an Observable, and then merging those resulting Observables and
	 * emitting the results of this merger. *Expand* will re-emit on the output
	 * Observable every source value. Then, each output value is given to the
	 * `project` function which returns an inner Observable to be merged on the
	 * output Observable. Those output values resulting from the projection are also
	 * given to the `project` function to produce new output values. This is how
	 * *expand* behaves recursively.
	 *
	 * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var powersOfTwo = clicks
	 *   .mapTo(1)
	 *   .expand(x => Rx.Observable.of(2 * x).delay(1000))
	 *   .take(10);
	 * powersOfTwo.subscribe(x => console.log(x));
	 *
	 * @see {@link mergeMap}
	 * @see {@link mergeScan}
	 *
	 * @param {function(value: T, index: number) => Observable} project A function
	 * that, when applied to an item emitted by the source or the output Observable,
	 * returns an Observable.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
	 * Observables being subscribed to concurrently.
	 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
	 * each projected inner Observable.
	 * @return {Observable} An Observable that emits the source values and also
	 * result of applying the projection function to each value emitted on the
	 * output Observable and and merging the results of the Observables obtained
	 * from this transformation.
	 * @method expand
	 * @owner Observable
	 */
	function expand(project, concurrent, scheduler) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    if (scheduler === void 0) { scheduler = undefined; }
	    concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
	    return this.lift(new ExpandOperator(project, concurrent, scheduler));
	}
	exports.expand = expand;
	var ExpandOperator = (function () {
	    function ExpandOperator(project, concurrent, scheduler) {
	        this.project = project;
	        this.concurrent = concurrent;
	        this.scheduler = scheduler;
	    }
	    ExpandOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
	    };
	    return ExpandOperator;
	}());
	exports.ExpandOperator = ExpandOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ExpandSubscriber = (function (_super) {
	    __extends(ExpandSubscriber, _super);
	    function ExpandSubscriber(destination, project, concurrent, scheduler) {
	        _super.call(this, destination);
	        this.project = project;
	        this.concurrent = concurrent;
	        this.scheduler = scheduler;
	        this.index = 0;
	        this.active = 0;
	        this.hasCompleted = false;
	        if (concurrent < Number.POSITIVE_INFINITY) {
	            this.buffer = [];
	        }
	    }
	    ExpandSubscriber.dispatch = function (arg) {
	        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
	        subscriber.subscribeToProjection(result, value, index);
	    };
	    ExpandSubscriber.prototype._next = function (value) {
	        var destination = this.destination;
	        if (destination.closed) {
	            this._complete();
	            return;
	        }
	        var index = this.index++;
	        if (this.active < this.concurrent) {
	            destination.next(value);
	            var result = tryCatch_1.tryCatch(this.project)(value, index);
	            if (result === errorObject_1.errorObject) {
	                destination.error(errorObject_1.errorObject.e);
	            }
	            else if (!this.scheduler) {
	                this.subscribeToProjection(result, value, index);
	            }
	            else {
	                var state = { subscriber: this, result: result, value: value, index: index };
	                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
	            }
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
	        this.active++;
	        this.add(subscribeToResult_1.subscribeToResult(this, result, value, index));
	    };
	    ExpandSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this._next(innerValue);
	    };
	    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer && buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    return ExpandSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.ExpandSubscriber = ExpandSubscriber;


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var Subscription_1 = __webpack_require__(5);
	/**
	 * Returns an Observable that mirrors the source Observable, but will call a specified function when
	 * the source terminates on complete or error.
	 * @param {function} callback Function to be called when source terminates.
	 * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
	 * @method finally
	 * @owner Observable
	 */
	function _finally(callback) {
	    return this.lift(new FinallyOperator(callback));
	}
	exports._finally = _finally;
	var FinallyOperator = (function () {
	    function FinallyOperator(callback) {
	        this.callback = callback;
	    }
	    FinallyOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
	    };
	    return FinallyOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FinallySubscriber = (function (_super) {
	    __extends(FinallySubscriber, _super);
	    function FinallySubscriber(destination, callback) {
	        _super.call(this, destination);
	        this.add(new Subscription_1.Subscription(callback));
	    }
	    return FinallySubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var find_1 = __webpack_require__(47);
	/**
	 * Emits only the index of the first value emitted by the source Observable that
	 * meets some condition.
	 *
	 * <span class="informal">It's like {@link find}, but emits the index of the
	 * found value, not the value itself.</span>
	 *
	 * <img src="./img/findIndex.png" width="100%">
	 *
	 * `findIndex` searches for the first item in the source Observable that matches
	 * the specified condition embodied by the `predicate`, and returns the
	 * (zero-based) index of the first occurrence in the source. Unlike
	 * {@link first}, the `predicate` is required in `findIndex`, and does not emit
	 * an error if a valid value is not found.
	 *
	 * @example <caption>Emit the index of first click that happens on a DIV element</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link filter}
	 * @see {@link find}
	 * @see {@link first}
	 * @see {@link take}
	 *
	 * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
	 * A function called with each item to test for condition matching.
	 * @param {any} [thisArg] An optional argument to determine the value of `this`
	 * in the `predicate` function.
	 * @return {Observable} An Observable of the index of the first item that
	 * matches the condition.
	 * @method find
	 * @owner Observable
	 */
	function findIndex(predicate, thisArg) {
	    return this.lift(new find_1.FindValueOperator(predicate, this, true, thisArg));
	}
	exports.findIndex = findIndex;


/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var EmptyError_1 = __webpack_require__(25);
	/**
	 * Emits only the first value (or the first value that meets some condition)
	 * emitted by the source Observable.
	 *
	 * <span class="informal">Emits only the first value. Or emits only the first
	 * value that passes some test.</span>
	 *
	 * <img src="./img/first.png" width="100%">
	 *
	 * If called with no arguments, `first` emits the first value of the source
	 * Observable, then completes. If called with a `predicate` function, `first`
	 * emits the first value of the source that matches the specified condition. It
	 * may also take a `resultSelector` function to produce the output value from
	 * the input value, and a `defaultValue` to emit in case the source completes
	 * before it is able to emit a valid value. Throws an error if `defaultValue`
	 * was not provided and a matching element is not found.
	 *
	 * @example <caption>Emit only the first click that happens on the DOM</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.first();
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Emits the first click that happens on a DIV</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.first(ev => ev.target.tagName === 'DIV');
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link filter}
	 * @see {@link find}
	 * @see {@link take}
	 *
	 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
	 * callback if the Observable completes before any `next` notification was sent.
	 *
	 * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]
	 * An optional function called with each item to test for condition matching.
	 * @param {function(value: T, index: number): R} [resultSelector] A function to
	 * produce the value on the output Observable based on the values
	 * and the indices of the source Observable. The arguments passed to this
	 * function are:
	 * - `value`: the value that was emitted on the source.
	 * - `index`: the "index" of the value from the source.
	 * @param {R} [defaultValue] The default value emitted in case no valid value
	 * was found on the source.
	 * @return {Observable<T|R>} An Observable of the first item that matches the
	 * condition.
	 * @method first
	 * @owner Observable
	 */
	function first(predicate, resultSelector, defaultValue) {
	    return this.lift(new FirstOperator(predicate, resultSelector, defaultValue, this));
	}
	exports.first = first;
	var FirstOperator = (function () {
	    function FirstOperator(predicate, resultSelector, defaultValue, source) {
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	    }
	    FirstOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new FirstSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
	    };
	    return FirstOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var FirstSubscriber = (function (_super) {
	    __extends(FirstSubscriber, _super);
	    function FirstSubscriber(destination, predicate, resultSelector, defaultValue, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	        this.index = 0;
	        this.hasCompleted = false;
	        this._emitted = false;
	    }
	    FirstSubscriber.prototype._next = function (value) {
	        var index = this.index++;
	        if (this.predicate) {
	            this._tryPredicate(value, index);
	        }
	        else {
	            this._emit(value, index);
	        }
	    };
	    FirstSubscriber.prototype._tryPredicate = function (value, index) {
	        var result;
	        try {
	            result = this.predicate(value, index, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            this._emit(value, index);
	        }
	    };
	    FirstSubscriber.prototype._emit = function (value, index) {
	        if (this.resultSelector) {
	            this._tryResultSelector(value, index);
	            return;
	        }
	        this._emitFinal(value);
	    };
	    FirstSubscriber.prototype._tryResultSelector = function (value, index) {
	        var result;
	        try {
	            result = this.resultSelector(value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this._emitFinal(result);
	    };
	    FirstSubscriber.prototype._emitFinal = function (value) {
	        var destination = this.destination;
	        if (!this._emitted) {
	            this._emitted = true;
	            destination.next(value);
	            destination.complete();
	            this.hasCompleted = true;
	        }
	    };
	    FirstSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        if (!this.hasCompleted && typeof this.defaultValue !== 'undefined') {
	            destination.next(this.defaultValue);
	            destination.complete();
	        }
	        else if (!this.hasCompleted) {
	            destination.error(new EmptyError_1.EmptyError);
	        }
	    };
	    return FirstSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var Subscription_1 = __webpack_require__(5);
	var Observable_1 = __webpack_require__(1);
	var Subject_1 = __webpack_require__(6);
	var Map_1 = __webpack_require__(339);
	var FastMap_1 = __webpack_require__(337);
	/* tslint:enable:max-line-length */
	/**
	 * Groups the items emitted by an Observable according to a specified criterion,
	 * and emits these grouped items as `GroupedObservables`, one
	 * {@link GroupedObservable} per group.
	 *
	 * <img src="./img/groupBy.png" width="100%">
	 *
	 * @example <caption>Group objects by id and return as array</caption>
	 * Observable.of<Obj>({id: 1, name: 'aze1'},
	 *                    {id: 2, name: 'sf2'},
	 *                    {id: 2, name: 'dg2'},
	 *                    {id: 1, name: 'erg1'},
	 *                    {id: 1, name: 'df1'},
	 *                    {id: 2, name: 'sfqfb2'},
	 *                    {id: 3, name: 'qfs3'},
	 *                    {id: 2, name: 'qsgqsfg2'}
	 *     )
	 *     .groupBy(p => p.id)
	 *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))
	 *     .subscribe(p => console.log(p));
	 *
	 * // displays:
	 * // [ { id: 1, name: 'aze1' },
	 * //   { id: 1, name: 'erg1' },
	 * //   { id: 1, name: 'df1' } ]
	 * //
	 * // [ { id: 2, name: 'sf2' },
	 * //   { id: 2, name: 'dg2' },
	 * //   { id: 2, name: 'sfqfb2' },
	 * //   { id: 2, name: 'qsgqsfg2' } ]
	 * //
	 * // [ { id: 3, name: 'qfs3' } ]
	 *
	 * @example <caption>Pivot data on the id field</caption>
	 * Observable.of<Obj>({id: 1, name: 'aze1'},
	 *                    {id: 2, name: 'sf2'},
	 *                    {id: 2, name: 'dg2'},
	 *                    {id: 1, name: 'erg1'},
	 *                    {id: 1, name: 'df1'},
	 *                    {id: 2, name: 'sfqfb2'},
	 *                    {id: 3, name: 'qfs1'},
	 *                    {id: 2, name: 'qsgqsfg2'}
	 *                   )
	 *     .groupBy(p => p.id, p => p.anme)
	 *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], ["" + group$.key]))
	 *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))
	 *     .subscribe(p => console.log(p));
	 *
	 * // displays:
	 * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }
	 * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }
	 * // { id: 3, values: [ 'qfs1' ] }
	 *
	 * @param {function(value: T): K} keySelector A function that extracts the key
	 * for each item.
	 * @param {function(value: T): R} [elementSelector] A function that extracts the
	 * return element for each item.
	 * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]
	 * A function that returns an Observable to determine how long each group should
	 * exist.
	 * @return {Observable<GroupedObservable<K,R>>} An Observable that emits
	 * GroupedObservables, each of which corresponds to a unique key value and each
	 * of which emits those items from the source Observable that share that key
	 * value.
	 * @method groupBy
	 * @owner Observable
	 */
	function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
	    return this.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
	}
	exports.groupBy = groupBy;
	var GroupByOperator = (function () {
	    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
	        this.keySelector = keySelector;
	        this.elementSelector = elementSelector;
	        this.durationSelector = durationSelector;
	        this.subjectSelector = subjectSelector;
	    }
	    GroupByOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
	    };
	    return GroupByOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var GroupBySubscriber = (function (_super) {
	    __extends(GroupBySubscriber, _super);
	    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
	        _super.call(this, destination);
	        this.keySelector = keySelector;
	        this.elementSelector = elementSelector;
	        this.durationSelector = durationSelector;
	        this.subjectSelector = subjectSelector;
	        this.groups = null;
	        this.attemptedToUnsubscribe = false;
	        this.count = 0;
	    }
	    GroupBySubscriber.prototype._next = function (value) {
	        var key;
	        try {
	            key = this.keySelector(value);
	        }
	        catch (err) {
	            this.error(err);
	            return;
	        }
	        this._group(value, key);
	    };
	    GroupBySubscriber.prototype._group = function (value, key) {
	        var groups = this.groups;
	        if (!groups) {
	            groups = this.groups = typeof key === 'string' ? new FastMap_1.FastMap() : new Map_1.Map();
	        }
	        var group = groups.get(key);
	        var element;
	        if (this.elementSelector) {
	            try {
	                element = this.elementSelector(value);
	            }
	            catch (err) {
	                this.error(err);
	            }
	        }
	        else {
	            element = value;
	        }
	        if (!group) {
	            group = this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject();
	            groups.set(key, group);
	            var groupedObservable = new GroupedObservable(key, group, this);
	            this.destination.next(groupedObservable);
	            if (this.durationSelector) {
	                var duration = void 0;
	                try {
	                    duration = this.durationSelector(new GroupedObservable(key, group));
	                }
	                catch (err) {
	                    this.error(err);
	                    return;
	                }
	                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
	            }
	        }
	        if (!group.closed) {
	            group.next(element);
	        }
	    };
	    GroupBySubscriber.prototype._error = function (err) {
	        var groups = this.groups;
	        if (groups) {
	            groups.forEach(function (group, key) {
	                group.error(err);
	            });
	            groups.clear();
	        }
	        this.destination.error(err);
	    };
	    GroupBySubscriber.prototype._complete = function () {
	        var groups = this.groups;
	        if (groups) {
	            groups.forEach(function (group, key) {
	                group.complete();
	            });
	            groups.clear();
	        }
	        this.destination.complete();
	    };
	    GroupBySubscriber.prototype.removeGroup = function (key) {
	        this.groups.delete(key);
	    };
	    GroupBySubscriber.prototype.unsubscribe = function () {
	        if (!this.closed) {
	            this.attemptedToUnsubscribe = true;
	            if (this.count === 0) {
	                _super.prototype.unsubscribe.call(this);
	            }
	        }
	    };
	    return GroupBySubscriber;
	}(Subscriber_1.Subscriber));
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var GroupDurationSubscriber = (function (_super) {
	    __extends(GroupDurationSubscriber, _super);
	    function GroupDurationSubscriber(key, group, parent) {
	        _super.call(this);
	        this.key = key;
	        this.group = group;
	        this.parent = parent;
	    }
	    GroupDurationSubscriber.prototype._next = function (value) {
	        this._complete();
	    };
	    GroupDurationSubscriber.prototype._error = function (err) {
	        var group = this.group;
	        if (!group.closed) {
	            group.error(err);
	        }
	        this.parent.removeGroup(this.key);
	    };
	    GroupDurationSubscriber.prototype._complete = function () {
	        var group = this.group;
	        if (!group.closed) {
	            group.complete();
	        }
	        this.parent.removeGroup(this.key);
	    };
	    return GroupDurationSubscriber;
	}(Subscriber_1.Subscriber));
	/**
	 * An Observable representing values belonging to the same group represented by
	 * a common key. The values emitted by a GroupedObservable come from the source
	 * Observable. The common key is available as the field `key` on a
	 * GroupedObservable instance.
	 *
	 * @class GroupedObservable<K, T>
	 */
	var GroupedObservable = (function (_super) {
	    __extends(GroupedObservable, _super);
	    function GroupedObservable(key, groupSubject, refCountSubscription) {
	        _super.call(this);
	        this.key = key;
	        this.groupSubject = groupSubject;
	        this.refCountSubscription = refCountSubscription;
	    }
	    GroupedObservable.prototype._subscribe = function (subscriber) {
	        var subscription = new Subscription_1.Subscription();
	        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
	        if (refCountSubscription && !refCountSubscription.closed) {
	            subscription.add(new InnerRefCountSubscription(refCountSubscription));
	        }
	        subscription.add(groupSubject.subscribe(subscriber));
	        return subscription;
	    };
	    return GroupedObservable;
	}(Observable_1.Observable));
	exports.GroupedObservable = GroupedObservable;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var InnerRefCountSubscription = (function (_super) {
	    __extends(InnerRefCountSubscription, _super);
	    function InnerRefCountSubscription(parent) {
	        _super.call(this);
	        this.parent = parent;
	        parent.count++;
	    }
	    InnerRefCountSubscription.prototype.unsubscribe = function () {
	        var parent = this.parent;
	        if (!parent.closed && !this.closed) {
	            _super.prototype.unsubscribe.call(this);
	            parent.count -= 1;
	            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
	                parent.unsubscribe();
	            }
	        }
	    };
	    return InnerRefCountSubscription;
	}(Subscription_1.Subscription));


/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var noop_1 = __webpack_require__(66);
	/**
	 * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
	 *
	 * <img src="./img/ignoreElements.png" width="100%">
	 *
	 * @return {Observable} An empty Observable that only calls `complete`
	 * or `error`, based on which one is called by the source Observable.
	 * @method ignoreElements
	 * @owner Observable
	 */
	function ignoreElements() {
	    return this.lift(new IgnoreElementsOperator());
	}
	exports.ignoreElements = ignoreElements;
	;
	var IgnoreElementsOperator = (function () {
	    function IgnoreElementsOperator() {
	    }
	    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
	    };
	    return IgnoreElementsOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var IgnoreElementsSubscriber = (function (_super) {
	    __extends(IgnoreElementsSubscriber, _super);
	    function IgnoreElementsSubscriber() {
	        _super.apply(this, arguments);
	    }
	    IgnoreElementsSubscriber.prototype._next = function (unused) {
	        noop_1.noop();
	    };
	    return IgnoreElementsSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/**
	 * If the source Observable is empty it returns an Observable that emits true, otherwise it emits false.
	 *
	 * <img src="./img/isEmpty.png" width="100%">
	 *
	 * @return {Observable} An Observable that emits a Boolean.
	 * @method isEmpty
	 * @owner Observable
	 */
	function isEmpty() {
	    return this.lift(new IsEmptyOperator());
	}
	exports.isEmpty = isEmpty;
	var IsEmptyOperator = (function () {
	    function IsEmptyOperator() {
	    }
	    IsEmptyOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new IsEmptySubscriber(observer));
	    };
	    return IsEmptyOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var IsEmptySubscriber = (function (_super) {
	    __extends(IsEmptySubscriber, _super);
	    function IsEmptySubscriber(destination) {
	        _super.call(this, destination);
	    }
	    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
	        var destination = this.destination;
	        destination.next(isEmpty);
	        destination.complete();
	    };
	    IsEmptySubscriber.prototype._next = function (value) {
	        this.notifyComplete(false);
	    };
	    IsEmptySubscriber.prototype._complete = function () {
	        this.notifyComplete(true);
	    };
	    return IsEmptySubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var EmptyError_1 = __webpack_require__(25);
	/* tslint:enable:max-line-length */
	/**
	 * Returns an Observable that emits only the last item emitted by the source Observable.
	 * It optionally takes a predicate function as a parameter, in which case, rather than emitting
	 * the last item from the source Observable, the resulting Observable will emit the last item
	 * from the source Observable that satisfies the predicate.
	 *
	 * <img src="./img/last.png" width="100%">
	 *
	 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
	 * callback if the Observable completes before any `next` notification was sent.
	 * @param {function} predicate - The condition any source emitted item has to satisfy.
	 * @return {Observable} An Observable that emits only the last item satisfying the given condition
	 * from the source, or an NoSuchElementException if no such items are emitted.
	 * @throws - Throws if no items that match the predicate are emitted by the source Observable.
	 * @method last
	 * @owner Observable
	 */
	function last(predicate, resultSelector, defaultValue) {
	    return this.lift(new LastOperator(predicate, resultSelector, defaultValue, this));
	}
	exports.last = last;
	var LastOperator = (function () {
	    function LastOperator(predicate, resultSelector, defaultValue, source) {
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	    }
	    LastOperator.prototype.call = function (observer, source) {
	        return source.subscribe(new LastSubscriber(observer, this.predicate, this.resultSelector, this.defaultValue, this.source));
	    };
	    return LastOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var LastSubscriber = (function (_super) {
	    __extends(LastSubscriber, _super);
	    function LastSubscriber(destination, predicate, resultSelector, defaultValue, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.resultSelector = resultSelector;
	        this.defaultValue = defaultValue;
	        this.source = source;
	        this.hasValue = false;
	        this.index = 0;
	        if (typeof defaultValue !== 'undefined') {
	            this.lastValue = defaultValue;
	            this.hasValue = true;
	        }
	    }
	    LastSubscriber.prototype._next = function (value) {
	        var index = this.index++;
	        if (this.predicate) {
	            this._tryPredicate(value, index);
	        }
	        else {
	            if (this.resultSelector) {
	                this._tryResultSelector(value, index);
	                return;
	            }
	            this.lastValue = value;
	            this.hasValue = true;
	        }
	    };
	    LastSubscriber.prototype._tryPredicate = function (value, index) {
	        var result;
	        try {
	            result = this.predicate(value, index, this.source);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        if (result) {
	            if (this.resultSelector) {
	                this._tryResultSelector(value, index);
	                return;
	            }
	            this.lastValue = value;
	            this.hasValue = true;
	        }
	    };
	    LastSubscriber.prototype._tryResultSelector = function (value, index) {
	        var result;
	        try {
	            result = this.resultSelector(value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.lastValue = result;
	        this.hasValue = true;
	    };
	    LastSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        if (this.hasValue) {
	            destination.next(this.lastValue);
	            destination.complete();
	        }
	        else {
	            destination.error(new EmptyError_1.EmptyError);
	        }
	    };
	    return LastSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 277 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @param func
	 * @return {Observable<R>}
	 * @method let
	 * @owner Observable
	 */
	function letProto(func) {
	    return func(this);
	}
	exports.letProto = letProto;


/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/**
	 * Emits the given constant value on the output Observable every time the source
	 * Observable emits a value.
	 *
	 * <span class="informal">Like {@link map}, but it maps every source value to
	 * the same output value every time.</span>
	 *
	 * <img src="./img/mapTo.png" width="100%">
	 *
	 * Takes a constant `value` as argument, and emits that whenever the source
	 * Observable emits a value. In other words, ignores the actual source value,
	 * and simply uses the emission moment to know when to emit the given `value`.
	 *
	 * @example <caption>Map every every click to the string 'Hi'</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var greetings = clicks.mapTo('Hi');
	 * greetings.subscribe(x => console.log(x));
	 *
	 * @see {@link map}
	 *
	 * @param {any} value The value to map each source value to.
	 * @return {Observable} An Observable that emits the given `value` every time
	 * the source Observable emits something.
	 * @method mapTo
	 * @owner Observable
	 */
	function mapTo(value) {
	    return this.lift(new MapToOperator(value));
	}
	exports.mapTo = mapTo;
	var MapToOperator = (function () {
	    function MapToOperator(value) {
	        this.value = value;
	    }
	    MapToOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new MapToSubscriber(subscriber, this.value));
	    };
	    return MapToOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MapToSubscriber = (function (_super) {
	    __extends(MapToSubscriber, _super);
	    function MapToSubscriber(destination, value) {
	        _super.call(this, destination);
	        this.value = value;
	    }
	    MapToSubscriber.prototype._next = function (x) {
	        this.destination.next(this.value);
	    };
	    return MapToSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var Notification_1 = __webpack_require__(16);
	/**
	 * Represents all of the notifications from the source Observable as `next`
	 * emissions marked with their original types within {@link Notification}
	 * objects.
	 *
	 * <span class="informal">Wraps `next`, `error` and `complete` emissions in
	 * {@link Notification} objects, emitted as `next` on the output Observable.
	 * </span>
	 *
	 * <img src="./img/materialize.png" width="100%">
	 *
	 * `materialize` returns an Observable that emits a `next` notification for each
	 * `next`, `error`, or `complete` emission of the source Observable. When the
	 * source Observable emits `complete`, the output Observable will emit `next` as
	 * a Notification of type "complete", and then it will emit `complete` as well.
	 * When the source Observable emits `error`, the output will emit `next` as a
	 * Notification of type "error", and then `complete`.
	 *
	 * This operator is useful for producing metadata of the source Observable, to
	 * be consumed as `next` emissions. Use it in conjunction with
	 * {@link dematerialize}.
	 *
	 * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>
	 * var letters = Rx.Observable.of('a', 'b', 13, 'd');
	 * var upperCase = letters.map(x => x.toUpperCase());
	 * var materialized = upperCase.materialize();
	 * materialized.subscribe(x => console.log(x));
	 *
	 * // Results in the following:
	 * // - Notification {kind: "N", value: "A", error: undefined, hasValue: true}
	 * // - Notification {kind: "N", value: "B", error: undefined, hasValue: true}
	 * // - Notification {kind: "E", value: undefined, error: TypeError:
	 * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x
	 * //   [as project] (http://1…, hasValue: false}
	 *
	 * @see {@link Notification}
	 * @see {@link dematerialize}
	 *
	 * @return {Observable<Notification<T>>} An Observable that emits
	 * {@link Notification} objects that wrap the original emissions from the source
	 * Observable with metadata.
	 * @method materialize
	 * @owner Observable
	 */
	function materialize() {
	    return this.lift(new MaterializeOperator());
	}
	exports.materialize = materialize;
	var MaterializeOperator = (function () {
	    function MaterializeOperator() {
	    }
	    MaterializeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new MaterializeSubscriber(subscriber));
	    };
	    return MaterializeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MaterializeSubscriber = (function (_super) {
	    __extends(MaterializeSubscriber, _super);
	    function MaterializeSubscriber(destination) {
	        _super.call(this, destination);
	    }
	    MaterializeSubscriber.prototype._next = function (value) {
	        this.destination.next(Notification_1.Notification.createNext(value));
	    };
	    MaterializeSubscriber.prototype._error = function (err) {
	        var destination = this.destination;
	        destination.next(Notification_1.Notification.createError(err));
	        destination.complete();
	    };
	    MaterializeSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        destination.next(Notification_1.Notification.createComplete());
	        destination.complete();
	    };
	    return MaterializeSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var reduce_1 = __webpack_require__(36);
	/**
	 * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
	 * and when source Observable completes it emits a single item: the item with the largest value.
	 *
	 * <img src="./img/max.png" width="100%">
	 *
	 * @example <caption>Get the maximal value of a series of numbers</caption>
	 * Rx.Observable.of(5, 4, 7, 2, 8)
	 *   .max()
	 *   .subscribe(x => console.log(x)); // -> 8
	 *
	 * @example <caption>Use a comparer function to get the maximal item</caption>
	 * interface Person {
	 *   age: number,
	 *   name: string
	 * }
	 * Observable.of<Person>({age: 7, name: 'Foo'},
	 *                       {age: 5, name: 'Bar'},
	 *                       {age: 9, name: 'Beer'})
	 *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)
	 *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'
	 * }
	 *
	 * @see {@link min}
	 *
	 * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the
	 * value of two items.
	 * @return {Observable} An Observable that emits item with the largest value.
	 * @method max
	 * @owner Observable
	 */
	function max(comparer) {
	    var max = (typeof comparer === 'function')
	        ? function (x, y) { return comparer(x, y) > 0 ? x : y; }
	        : function (x, y) { return x > y ? x : y; };
	    return this.lift(new reduce_1.ReduceOperator(max));
	}
	exports.max = max;


/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var tryCatch_1 = __webpack_require__(9);
	var errorObject_1 = __webpack_require__(7);
	var subscribeToResult_1 = __webpack_require__(4);
	var OuterSubscriber_1 = __webpack_require__(3);
	/**
	 * Applies an accumulator function over the source Observable where the
	 * accumulator function itself returns an Observable, then each intermediate
	 * Observable returned is merged into the output Observable.
	 *
	 * <span class="informal">It's like {@link scan}, but the Observables returned
	 * by the accumulator are merged into the outer Observable.</span>
	 *
	 * @example <caption>Count the number of click events</caption>
	 * const click$ = Rx.Observable.fromEvent(document, 'click');
	 * const one$ = click$.mapTo(1);
	 * const seed = 0;
	 * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);
	 * count$.subscribe(x => console.log(x));
	 *
	 * // Results:
	 * 1
	 * 2
	 * 3
	 * 4
	 * // ...and so on for each click
	 *
	 * @param {function(acc: R, value: T): Observable<R>} accumulator
	 * The accumulator function called on each source value.
	 * @param seed The initial accumulation value.
	 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of
	 * input Observables being subscribed to concurrently.
	 * @return {Observable<R>} An observable of the accumulated values.
	 * @method mergeScan
	 * @owner Observable
	 */
	function mergeScan(accumulator, seed, concurrent) {
	    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
	    return this.lift(new MergeScanOperator(accumulator, seed, concurrent));
	}
	exports.mergeScan = mergeScan;
	var MergeScanOperator = (function () {
	    function MergeScanOperator(accumulator, seed, concurrent) {
	        this.accumulator = accumulator;
	        this.seed = seed;
	        this.concurrent = concurrent;
	    }
	    MergeScanOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
	    };
	    return MergeScanOperator;
	}());
	exports.MergeScanOperator = MergeScanOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var MergeScanSubscriber = (function (_super) {
	    __extends(MergeScanSubscriber, _super);
	    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
	        _super.call(this, destination);
	        this.accumulator = accumulator;
	        this.acc = acc;
	        this.concurrent = concurrent;
	        this.hasValue = false;
	        this.hasCompleted = false;
	        this.buffer = [];
	        this.active = 0;
	        this.index = 0;
	    }
	    MergeScanSubscriber.prototype._next = function (value) {
	        if (this.active < this.concurrent) {
	            var index = this.index++;
	            var ish = tryCatch_1.tryCatch(this.accumulator)(this.acc, value);
	            var destination = this.destination;
	            if (ish === errorObject_1.errorObject) {
	                destination.error(errorObject_1.errorObject.e);
	            }
	            else {
	                this.active++;
	                this._innerSub(ish, value, index);
	            }
	        }
	        else {
	            this.buffer.push(value);
	        }
	    };
	    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
	        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
	    };
	    MergeScanSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0 && this.buffer.length === 0) {
	            if (this.hasValue === false) {
	                this.destination.next(this.acc);
	            }
	            this.destination.complete();
	        }
	    };
	    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var destination = this.destination;
	        this.acc = innerValue;
	        this.hasValue = true;
	        destination.next(innerValue);
	    };
	    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
	        var buffer = this.buffer;
	        this.remove(innerSub);
	        this.active--;
	        if (buffer.length > 0) {
	            this._next(buffer.shift());
	        }
	        else if (this.active === 0 && this.hasCompleted) {
	            if (this.hasValue === false) {
	                this.destination.next(this.acc);
	            }
	            this.destination.complete();
	        }
	    };
	    return MergeScanSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));
	exports.MergeScanSubscriber = MergeScanSubscriber;


/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var reduce_1 = __webpack_require__(36);
	/**
	 * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
	 * and when source Observable completes it emits a single item: the item with the smallest value.
	 *
	 * <img src="./img/min.png" width="100%">
	 *
	 * @example <caption>Get the minimal value of a series of numbers</caption>
	 * Rx.Observable.of(5, 4, 7, 2, 8)
	 *   .min()
	 *   .subscribe(x => console.log(x)); // -> 2
	 *
	 * @example <caption>Use a comparer function to get the minimal item</caption>
	 * interface Person {
	 *   age: number,
	 *   name: string
	 * }
	 * Observable.of<Person>({age: 7, name: 'Foo'},
	 *                       {age: 5, name: 'Bar'},
	 *                       {age: 9, name: 'Beer'})
	 *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)
	 *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'
	 * }
	 *
	 * @see {@link max}
	 *
	 * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the
	 * value of two items.
	 * @return {Observable<R>} An Observable that emits item with the smallest value.
	 * @method min
	 * @owner Observable
	 */
	function min(comparer) {
	    var min = (typeof comparer === 'function')
	        ? function (x, y) { return comparer(x, y) < 0 ? x : y; }
	        : function (x, y) { return x < y ? x : y; };
	    return this.lift(new reduce_1.ReduceOperator(min));
	}
	exports.min = min;


/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/**
	 * Groups pairs of consecutive emissions together and emits them as an array of
	 * two values.
	 *
	 * <span class="informal">Puts the current value and previous value together as
	 * an array, and emits that.</span>
	 *
	 * <img src="./img/pairwise.png" width="100%">
	 *
	 * The Nth emission from the source Observable will cause the output Observable
	 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
	 * pair. For this reason, `pairwise` emits on the second and subsequent
	 * emissions from the source Observable, but not on the first emission, because
	 * there is no previous value in that case.
	 *
	 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var pairs = clicks.pairwise();
	 * var distance = pairs.map(pair => {
	 *   var x0 = pair[0].clientX;
	 *   var y0 = pair[0].clientY;
	 *   var x1 = pair[1].clientX;
	 *   var y1 = pair[1].clientY;
	 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
	 * });
	 * distance.subscribe(x => console.log(x));
	 *
	 * @see {@link buffer}
	 * @see {@link bufferCount}
	 *
	 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
	 * consecutive values from the source Observable.
	 * @method pairwise
	 * @owner Observable
	 */
	function pairwise() {
	    return this.lift(new PairwiseOperator());
	}
	exports.pairwise = pairwise;
	var PairwiseOperator = (function () {
	    function PairwiseOperator() {
	    }
	    PairwiseOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new PairwiseSubscriber(subscriber));
	    };
	    return PairwiseOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var PairwiseSubscriber = (function (_super) {
	    __extends(PairwiseSubscriber, _super);
	    function PairwiseSubscriber(destination) {
	        _super.call(this, destination);
	        this.hasPrev = false;
	    }
	    PairwiseSubscriber.prototype._next = function (value) {
	        if (this.hasPrev) {
	            this.destination.next([this.prev, value]);
	        }
	        else {
	            this.hasPrev = true;
	        }
	        this.prev = value;
	    };
	    return PairwiseSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var not_1 = __webpack_require__(343);
	var filter_1 = __webpack_require__(46);
	/**
	 * Splits the source Observable into two, one with values that satisfy a
	 * predicate, and another with values that don't satisfy the predicate.
	 *
	 * <span class="informal">It's like {@link filter}, but returns two Observables:
	 * one like the output of {@link filter}, and the other with values that did not
	 * pass the condition.</span>
	 *
	 * <img src="./img/partition.png" width="100%">
	 *
	 * `partition` outputs an array with two Observables that partition the values
	 * from the source Observable through the given `predicate` function. The first
	 * Observable in that array emits source values for which the predicate argument
	 * returns true. The second Observable emits source values for which the
	 * predicate returns false. The first behaves like {@link filter} and the second
	 * behaves like {@link filter} with the predicate negated.
	 *
	 * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');
	 * var clicksOnDivs = parts[0];
	 * var clicksElsewhere = parts[1];
	 * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));
	 * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));
	 *
	 * @see {@link filter}
	 *
	 * @param {function(value: T, index: number): boolean} predicate A function that
	 * evaluates each value emitted by the source Observable. If it returns `true`,
	 * the value is emitted on the first Observable in the returned array, if
	 * `false` the value is emitted on the second Observable in the array. The
	 * `index` parameter is the number `i` for the i-th source emission that has
	 * happened since the subscription, starting from the number `0`.
	 * @param {any} [thisArg] An optional argument to determine the value of `this`
	 * in the `predicate` function.
	 * @return {[Observable<T>, Observable<T>]} An array with two Observables: one
	 * with values that passed the predicate, and another with values that did not
	 * pass the predicate.
	 * @method partition
	 * @owner Observable
	 */
	function partition(predicate, thisArg) {
	    return [
	        filter_1.filter.call(this, predicate, thisArg),
	        filter_1.filter.call(this, not_1.not(predicate, thisArg))
	    ];
	}
	exports.partition = partition;


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var map_1 = __webpack_require__(34);
	/**
	 * Maps each source value (an object) to its specified nested property.
	 *
	 * <span class="informal">Like {@link map}, but meant only for picking one of
	 * the nested properties of every emitted object.</span>
	 *
	 * <img src="./img/pluck.png" width="100%">
	 *
	 * Given a list of strings describing a path to an object property, retrieves
	 * the value of a specified nested property from all values in the source
	 * Observable. If a property can't be resolved, it will return `undefined` for
	 * that value.
	 *
	 * @example <caption>Map every every click to the tagName of the clicked target element</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var tagNames = clicks.pluck('target', 'tagName');
	 * tagNames.subscribe(x => console.log(x));
	 *
	 * @see {@link map}
	 *
	 * @param {...string} properties The nested properties to pluck from each source
	 * value (an object).
	 * @return {Observable} A new Observable of property values from the source values.
	 * @method pluck
	 * @owner Observable
	 */
	function pluck() {
	    var properties = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        properties[_i - 0] = arguments[_i];
	    }
	    var length = properties.length;
	    if (length === 0) {
	        throw new Error('list of properties cannot be empty.');
	    }
	    return map_1.map.call(this, plucker(properties, length));
	}
	exports.pluck = pluck;
	function plucker(props, length) {
	    var mapper = function (x) {
	        var currentProp = x;
	        for (var i = 0; i < length; i++) {
	            var p = currentProp[props[i]];
	            if (typeof p !== 'undefined') {
	                currentProp = p;
	            }
	            else {
	                return undefined;
	            }
	        }
	        return currentProp;
	    };
	    return mapper;
	}


/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Subject_1 = __webpack_require__(6);
	var multicast_1 = __webpack_require__(15);
	/* tslint:enable:max-line-length */
	/**
	 * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
	 * before it begins emitting items to those Observers that have subscribed to it.
	 *
	 * <img src="./img/publish.png" width="100%">
	 *
	 * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times
	 * as needed, without causing multiple subscriptions to the source sequence.
	 * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
	 * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
	 * @method publish
	 * @owner Observable
	 */
	function publish(selector) {
	    return selector ? multicast_1.multicast.call(this, function () { return new Subject_1.Subject(); }, selector) :
	        multicast_1.multicast.call(this, new Subject_1.Subject());
	}
	exports.publish = publish;


/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var BehaviorSubject_1 = __webpack_require__(38);
	var multicast_1 = __webpack_require__(15);
	/**
	 * @param value
	 * @return {ConnectableObservable<T>}
	 * @method publishBehavior
	 * @owner Observable
	 */
	function publishBehavior(value) {
	    return multicast_1.multicast.call(this, new BehaviorSubject_1.BehaviorSubject(value));
	}
	exports.publishBehavior = publishBehavior;


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AsyncSubject_1 = __webpack_require__(20);
	var multicast_1 = __webpack_require__(15);
	/**
	 * @return {ConnectableObservable<T>}
	 * @method publishLast
	 * @owner Observable
	 */
	function publishLast() {
	    return multicast_1.multicast.call(this, new AsyncSubject_1.AsyncSubject());
	}
	exports.publishLast = publishLast;


/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ReplaySubject_1 = __webpack_require__(30);
	var multicast_1 = __webpack_require__(15);
	/**
	 * @param bufferSize
	 * @param windowTime
	 * @param scheduler
	 * @return {ConnectableObservable<T>}
	 * @method publishReplay
	 * @owner Observable
	 */
	function publishReplay(bufferSize, windowTime, scheduler) {
	    if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
	    if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
	    return multicast_1.multicast.call(this, new ReplaySubject_1.ReplaySubject(bufferSize, windowTime, scheduler));
	}
	exports.publishReplay = publishReplay;


/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var EmptyObservable_1 = __webpack_require__(14);
	/**
	 * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.
	 *
	 * <img src="./img/repeat.png" width="100%">
	 *
	 * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield
	 * an empty Observable.
	 * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most
	 * count times.
	 * @method repeat
	 * @owner Observable
	 */
	function repeat(count) {
	    if (count === void 0) { count = -1; }
	    if (count === 0) {
	        return new EmptyObservable_1.EmptyObservable();
	    }
	    else if (count < 0) {
	        return this.lift(new RepeatOperator(-1, this));
	    }
	    else {
	        return this.lift(new RepeatOperator(count - 1, this));
	    }
	}
	exports.repeat = repeat;
	var RepeatOperator = (function () {
	    function RepeatOperator(count, source) {
	        this.count = count;
	        this.source = source;
	    }
	    RepeatOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
	    };
	    return RepeatOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var RepeatSubscriber = (function (_super) {
	    __extends(RepeatSubscriber, _super);
	    function RepeatSubscriber(destination, count, source) {
	        _super.call(this, destination);
	        this.count = count;
	        this.source = source;
	    }
	    RepeatSubscriber.prototype.complete = function () {
	        if (!this.isStopped) {
	            var _a = this, source = _a.source, count = _a.count;
	            if (count === 0) {
	                return _super.prototype.complete.call(this);
	            }
	            else if (count > -1) {
	                this.count = count - 1;
	            }
	            source.subscribe(this._unsubscribeAndRecycle());
	        }
	    };
	    return RepeatSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var tryCatch_1 = __webpack_require__(9);
	var errorObject_1 = __webpack_require__(7);
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/**
	 * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source
	 * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable
	 * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise
	 * this method will resubscribe to the source Observable.
	 *
	 * <img src="./img/repeatWhen.png" width="100%">
	 *
	 * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with
	 * which a user can `complete` or `error`, aborting the repetition.
	 * @return {Observable} The source Observable modified with repeat logic.
	 * @method repeatWhen
	 * @owner Observable
	 */
	function repeatWhen(notifier) {
	    return this.lift(new RepeatWhenOperator(notifier));
	}
	exports.repeatWhen = repeatWhen;
	var RepeatWhenOperator = (function () {
	    function RepeatWhenOperator(notifier) {
	        this.notifier = notifier;
	    }
	    RepeatWhenOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
	    };
	    return RepeatWhenOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var RepeatWhenSubscriber = (function (_super) {
	    __extends(RepeatWhenSubscriber, _super);
	    function RepeatWhenSubscriber(destination, notifier, source) {
	        _super.call(this, destination);
	        this.notifier = notifier;
	        this.source = source;
	        this.sourceIsBeingSubscribedTo = true;
	    }
	    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.sourceIsBeingSubscribedTo = true;
	        this.source.subscribe(this);
	    };
	    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
	        if (this.sourceIsBeingSubscribedTo === false) {
	            return _super.prototype.complete.call(this);
	        }
	    };
	    RepeatWhenSubscriber.prototype.complete = function () {
	        this.sourceIsBeingSubscribedTo = false;
	        if (!this.isStopped) {
	            if (!this.retries) {
	                this.subscribeToRetries();
	            }
	            else if (this.retriesSubscription.closed) {
	                return _super.prototype.complete.call(this);
	            }
	            this._unsubscribeAndRecycle();
	            this.notifications.next();
	        }
	    };
	    RepeatWhenSubscriber.prototype._unsubscribe = function () {
	        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
	        if (notifications) {
	            notifications.unsubscribe();
	            this.notifications = null;
	        }
	        if (retriesSubscription) {
	            retriesSubscription.unsubscribe();
	            this.retriesSubscription = null;
	        }
	        this.retries = null;
	    };
	    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
	        var _a = this, notifications = _a.notifications, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
	        this.notifications = null;
	        this.retries = null;
	        this.retriesSubscription = null;
	        _super.prototype._unsubscribeAndRecycle.call(this);
	        this.notifications = notifications;
	        this.retries = retries;
	        this.retriesSubscription = retriesSubscription;
	        return this;
	    };
	    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
	        this.notifications = new Subject_1.Subject();
	        var retries = tryCatch_1.tryCatch(this.notifier)(this.notifications);
	        if (retries === errorObject_1.errorObject) {
	            return _super.prototype.complete.call(this);
	        }
	        this.retries = retries;
	        this.retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
	    };
	    return RepeatWhenSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/**
	 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
	 * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given
	 * as a number parameter) rather than propagating the `error` call.
	 *
	 * <img src="./img/retry.png" width="100%">
	 *
	 * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted
	 * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second
	 * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications
	 * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].
	 * @param {number} count - Number of retry attempts before failing.
	 * @return {Observable} The source Observable modified with the retry logic.
	 * @method retry
	 * @owner Observable
	 */
	function retry(count) {
	    if (count === void 0) { count = -1; }
	    return this.lift(new RetryOperator(count, this));
	}
	exports.retry = retry;
	var RetryOperator = (function () {
	    function RetryOperator(count, source) {
	        this.count = count;
	        this.source = source;
	    }
	    RetryOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
	    };
	    return RetryOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var RetrySubscriber = (function (_super) {
	    __extends(RetrySubscriber, _super);
	    function RetrySubscriber(destination, count, source) {
	        _super.call(this, destination);
	        this.count = count;
	        this.source = source;
	    }
	    RetrySubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var _a = this, source = _a.source, count = _a.count;
	            if (count === 0) {
	                return _super.prototype.error.call(this, err);
	            }
	            else if (count > -1) {
	                this.count = count - 1;
	            }
	            source.subscribe(this._unsubscribeAndRecycle());
	        }
	    };
	    return RetrySubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var tryCatch_1 = __webpack_require__(9);
	var errorObject_1 = __webpack_require__(7);
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/**
	 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
	 * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.
	 * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child
	 * subscription. Otherwise this method will resubscribe to the source Observable.
	 *
	 * <img src="./img/retryWhen.png" width="100%">
	 *
	 * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a
	 * user can `complete` or `error`, aborting the retry.
	 * @return {Observable} The source Observable modified with retry logic.
	 * @method retryWhen
	 * @owner Observable
	 */
	function retryWhen(notifier) {
	    return this.lift(new RetryWhenOperator(notifier, this));
	}
	exports.retryWhen = retryWhen;
	var RetryWhenOperator = (function () {
	    function RetryWhenOperator(notifier, source) {
	        this.notifier = notifier;
	        this.source = source;
	    }
	    RetryWhenOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
	    };
	    return RetryWhenOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var RetryWhenSubscriber = (function (_super) {
	    __extends(RetryWhenSubscriber, _super);
	    function RetryWhenSubscriber(destination, notifier, source) {
	        _super.call(this, destination);
	        this.notifier = notifier;
	        this.source = source;
	    }
	    RetryWhenSubscriber.prototype.error = function (err) {
	        if (!this.isStopped) {
	            var errors = this.errors;
	            var retries = this.retries;
	            var retriesSubscription = this.retriesSubscription;
	            if (!retries) {
	                errors = new Subject_1.Subject();
	                retries = tryCatch_1.tryCatch(this.notifier)(errors);
	                if (retries === errorObject_1.errorObject) {
	                    return _super.prototype.error.call(this, errorObject_1.errorObject.e);
	                }
	                retriesSubscription = subscribeToResult_1.subscribeToResult(this, retries);
	            }
	            else {
	                this.errors = null;
	                this.retriesSubscription = null;
	            }
	            this._unsubscribeAndRecycle();
	            this.errors = errors;
	            this.retries = retries;
	            this.retriesSubscription = retriesSubscription;
	            errors.next(err);
	        }
	    };
	    RetryWhenSubscriber.prototype._unsubscribe = function () {
	        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
	        if (errors) {
	            errors.unsubscribe();
	            this.errors = null;
	        }
	        if (retriesSubscription) {
	            retriesSubscription.unsubscribe();
	            this.retriesSubscription = null;
	        }
	        this.retries = null;
	    };
	    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var _a = this, errors = _a.errors, retries = _a.retries, retriesSubscription = _a.retriesSubscription;
	        this.errors = null;
	        this.retries = null;
	        this.retriesSubscription = null;
	        this._unsubscribeAndRecycle();
	        this.errors = errors;
	        this.retries = retries;
	        this.retriesSubscription = retriesSubscription;
	        this.source.subscribe(this);
	    };
	    return RetryWhenSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/**
	 * Emits the most recently emitted value from the source Observable whenever
	 * another Observable, the `notifier`, emits.
	 *
	 * <span class="informal">It's like {@link sampleTime}, but samples whenever
	 * the `notifier` Observable emits something.</span>
	 *
	 * <img src="./img/sample.png" width="100%">
	 *
	 * Whenever the `notifier` Observable emits a value or completes, `sample`
	 * looks at the source Observable and emits whichever value it has most recently
	 * emitted since the previous sampling, unless the source has not emitted
	 * anything since the previous sampling. The `notifier` is subscribed to as soon
	 * as the output Observable is subscribed.
	 *
	 * @example <caption>On every click, sample the most recent "seconds" timer</caption>
	 * var seconds = Rx.Observable.interval(1000);
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = seconds.sample(clicks);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link audit}
	 * @see {@link debounce}
	 * @see {@link sampleTime}
	 * @see {@link throttle}
	 *
	 * @param {Observable<any>} notifier The Observable to use for sampling the
	 * source Observable.
	 * @return {Observable<T>} An Observable that emits the results of sampling the
	 * values emitted by the source Observable whenever the notifier Observable
	 * emits value or completes.
	 * @method sample
	 * @owner Observable
	 */
	function sample(notifier) {
	    return this.lift(new SampleOperator(notifier));
	}
	exports.sample = sample;
	var SampleOperator = (function () {
	    function SampleOperator(notifier) {
	        this.notifier = notifier;
	    }
	    SampleOperator.prototype.call = function (subscriber, source) {
	        var sampleSubscriber = new SampleSubscriber(subscriber);
	        var subscription = source.subscribe(sampleSubscriber);
	        subscription.add(subscribeToResult_1.subscribeToResult(sampleSubscriber, this.notifier));
	        return subscription;
	    };
	    return SampleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SampleSubscriber = (function (_super) {
	    __extends(SampleSubscriber, _super);
	    function SampleSubscriber() {
	        _super.apply(this, arguments);
	        this.hasValue = false;
	    }
	    SampleSubscriber.prototype._next = function (value) {
	        this.value = value;
	        this.hasValue = true;
	    };
	    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.emitValue();
	    };
	    SampleSubscriber.prototype.notifyComplete = function () {
	        this.emitValue();
	    };
	    SampleSubscriber.prototype.emitValue = function () {
	        if (this.hasValue) {
	            this.hasValue = false;
	            this.destination.next(this.value);
	        }
	    };
	    return SampleSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var async_1 = __webpack_require__(10);
	/**
	 * Emits the most recently emitted value from the source Observable within
	 * periodic time intervals.
	 *
	 * <span class="informal">Samples the source Observable at periodic time
	 * intervals, emitting what it samples.</span>
	 *
	 * <img src="./img/sampleTime.png" width="100%">
	 *
	 * `sampleTime` periodically looks at the source Observable and emits whichever
	 * value it has most recently emitted since the previous sampling, unless the
	 * source has not emitted anything since the previous sampling. The sampling
	 * happens periodically in time every `period` milliseconds (or the time unit
	 * defined by the optional `scheduler` argument). The sampling starts as soon as
	 * the output Observable is subscribed.
	 *
	 * @example <caption>Every second, emit the most recent click at most once</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.sampleTime(1000);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link auditTime}
	 * @see {@link debounceTime}
	 * @see {@link delay}
	 * @see {@link sample}
	 * @see {@link throttleTime}
	 *
	 * @param {number} period The sampling period expressed in milliseconds or the
	 * time unit determined internally by the optional `scheduler`.
	 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
	 * managing the timers that handle the sampling.
	 * @return {Observable<T>} An Observable that emits the results of sampling the
	 * values emitted by the source Observable at the specified time interval.
	 * @method sampleTime
	 * @owner Observable
	 */
	function sampleTime(period, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new SampleTimeOperator(period, scheduler));
	}
	exports.sampleTime = sampleTime;
	var SampleTimeOperator = (function () {
	    function SampleTimeOperator(period, scheduler) {
	        this.period = period;
	        this.scheduler = scheduler;
	    }
	    SampleTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
	    };
	    return SampleTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SampleTimeSubscriber = (function (_super) {
	    __extends(SampleTimeSubscriber, _super);
	    function SampleTimeSubscriber(destination, period, scheduler) {
	        _super.call(this, destination);
	        this.period = period;
	        this.scheduler = scheduler;
	        this.hasValue = false;
	        this.add(scheduler.schedule(dispatchNotification, period, { subscriber: this, period: period }));
	    }
	    SampleTimeSubscriber.prototype._next = function (value) {
	        this.lastValue = value;
	        this.hasValue = true;
	    };
	    SampleTimeSubscriber.prototype.notifyNext = function () {
	        if (this.hasValue) {
	            this.hasValue = false;
	            this.destination.next(this.lastValue);
	        }
	    };
	    return SampleTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchNotification(state) {
	    var subscriber = state.subscriber, period = state.period;
	    subscriber.notifyNext();
	    this.schedule(state, period);
	}


/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/* tslint:enable:max-line-length */
	/**
	 * Applies an accumulator function over the source Observable, and returns each
	 * intermediate result, with an optional seed value.
	 *
	 * <span class="informal">It's like {@link reduce}, but emits the current
	 * accumulation whenever the source emits a value.</span>
	 *
	 * <img src="./img/scan.png" width="100%">
	 *
	 * Combines together all values emitted on the source, using an accumulator
	 * function that knows how to join a new source value into the accumulation from
	 * the past. Is similar to {@link reduce}, but emits the intermediate
	 * accumulations.
	 *
	 * Returns an Observable that applies a specified `accumulator` function to each
	 * item emitted by the source Observable. If a `seed` value is specified, then
	 * that value will be used as the initial value for the accumulator. If no seed
	 * value is specified, the first item of the source is used as the seed.
	 *
	 * @example <caption>Count the number of click events</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var ones = clicks.mapTo(1);
	 * var seed = 0;
	 * var count = ones.scan((acc, one) => acc + one, seed);
	 * count.subscribe(x => console.log(x));
	 *
	 * @see {@link expand}
	 * @see {@link mergeScan}
	 * @see {@link reduce}
	 *
	 * @param {function(acc: R, value: T, index: number): R} accumulator
	 * The accumulator function called on each source value.
	 * @param {T|R} [seed] The initial accumulation value.
	 * @return {Observable<R>} An observable of the accumulated values.
	 * @method scan
	 * @owner Observable
	 */
	function scan(accumulator, seed) {
	    var hasSeed = false;
	    // providing a seed of `undefined` *should* be valid and trigger
	    // hasSeed! so don't use `seed !== undefined` checks!
	    // For this reason, we have to check it here at the original call site
	    // otherwise inside Operator/Subscriber we won't know if `undefined`
	    // means they didn't provide anything or if they literally provided `undefined`
	    if (arguments.length >= 2) {
	        hasSeed = true;
	    }
	    return this.lift(new ScanOperator(accumulator, seed, hasSeed));
	}
	exports.scan = scan;
	var ScanOperator = (function () {
	    function ScanOperator(accumulator, seed, hasSeed) {
	        if (hasSeed === void 0) { hasSeed = false; }
	        this.accumulator = accumulator;
	        this.seed = seed;
	        this.hasSeed = hasSeed;
	    }
	    ScanOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
	    };
	    return ScanOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ScanSubscriber = (function (_super) {
	    __extends(ScanSubscriber, _super);
	    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
	        _super.call(this, destination);
	        this.accumulator = accumulator;
	        this._seed = _seed;
	        this.hasSeed = hasSeed;
	        this.index = 0;
	    }
	    Object.defineProperty(ScanSubscriber.prototype, "seed", {
	        get: function () {
	            return this._seed;
	        },
	        set: function (value) {
	            this.hasSeed = true;
	            this._seed = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ScanSubscriber.prototype._next = function (value) {
	        if (!this.hasSeed) {
	            this.seed = value;
	            this.destination.next(value);
	        }
	        else {
	            return this._tryNext(value);
	        }
	    };
	    ScanSubscriber.prototype._tryNext = function (value) {
	        var index = this.index++;
	        var result;
	        try {
	            result = this.accumulator(this.seed, value, index);
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	        this.seed = result;
	        this.destination.next(result);
	    };
	    return ScanSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var tryCatch_1 = __webpack_require__(9);
	var errorObject_1 = __webpack_require__(7);
	/**
	 * Compares all values of two observables in sequence using an optional comparor function
	 * and returns an observable of a single boolean value representing whether or not the two sequences
	 * are equal.
	 *
	 * <span class="informal">Checks to see of all values emitted by both observables are equal, in order.</span>
	 *
	 * <img src="./img/sequenceEqual.png" width="100%">
	 *
	 * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either
	 * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom
	 * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the
	 * observables completes, the operator will wait for the other observable to complete; If the other
	 * observable emits before completing, the returned observable will emit `false` and complete. If one observable never
	 * completes or emits after the other complets, the returned observable will never complete.
	 *
	 * @example <caption>figure out if the Konami code matches</caption>
	 * var code = Rx.Observable.from([
	 *  "ArrowUp",
	 *  "ArrowUp",
	 *  "ArrowDown",
	 *  "ArrowDown",
	 *  "ArrowLeft",
	 *  "ArrowRight",
	 *  "ArrowLeft",
	 *  "ArrowRight",
	 *  "KeyB",
	 *  "KeyA",
	 *  "Enter" // no start key, clearly.
	 * ]);
	 *
	 * var keys = Rx.Observable.fromEvent(document, 'keyup')
	 *  .map(e => e.code);
	 * var matches = keys.bufferCount(11, 1)
	 *  .mergeMap(
	 *    last11 =>
	 *      Rx.Observable.from(last11)
	 *        .sequenceEqual(code)
	 *   );
	 * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));
	 *
	 * @see {@link combineLatest}
	 * @see {@link zip}
	 * @see {@link withLatestFrom}
	 *
	 * @param {Observable} compareTo The observable sequence to compare the source sequence to.
	 * @param {function} [comparor] An optional function to compare each value pair
	 * @return {Observable} An Observable of a single boolean value representing whether or not
	 * the values emitted by both observables were equal in sequence.
	 * @method sequenceEqual
	 * @owner Observable
	 */
	function sequenceEqual(compareTo, comparor) {
	    return this.lift(new SequenceEqualOperator(compareTo, comparor));
	}
	exports.sequenceEqual = sequenceEqual;
	var SequenceEqualOperator = (function () {
	    function SequenceEqualOperator(compareTo, comparor) {
	        this.compareTo = compareTo;
	        this.comparor = comparor;
	    }
	    SequenceEqualOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));
	    };
	    return SequenceEqualOperator;
	}());
	exports.SequenceEqualOperator = SequenceEqualOperator;
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SequenceEqualSubscriber = (function (_super) {
	    __extends(SequenceEqualSubscriber, _super);
	    function SequenceEqualSubscriber(destination, compareTo, comparor) {
	        _super.call(this, destination);
	        this.compareTo = compareTo;
	        this.comparor = comparor;
	        this._a = [];
	        this._b = [];
	        this._oneComplete = false;
	        this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));
	    }
	    SequenceEqualSubscriber.prototype._next = function (value) {
	        if (this._oneComplete && this._b.length === 0) {
	            this.emit(false);
	        }
	        else {
	            this._a.push(value);
	            this.checkValues();
	        }
	    };
	    SequenceEqualSubscriber.prototype._complete = function () {
	        if (this._oneComplete) {
	            this.emit(this._a.length === 0 && this._b.length === 0);
	        }
	        else {
	            this._oneComplete = true;
	        }
	    };
	    SequenceEqualSubscriber.prototype.checkValues = function () {
	        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;
	        while (_a.length > 0 && _b.length > 0) {
	            var a = _a.shift();
	            var b = _b.shift();
	            var areEqual = false;
	            if (comparor) {
	                areEqual = tryCatch_1.tryCatch(comparor)(a, b);
	                if (areEqual === errorObject_1.errorObject) {
	                    this.destination.error(errorObject_1.errorObject.e);
	                }
	            }
	            else {
	                areEqual = a === b;
	            }
	            if (!areEqual) {
	                this.emit(false);
	            }
	        }
	    };
	    SequenceEqualSubscriber.prototype.emit = function (value) {
	        var destination = this.destination;
	        destination.next(value);
	        destination.complete();
	    };
	    SequenceEqualSubscriber.prototype.nextB = function (value) {
	        if (this._oneComplete && this._a.length === 0) {
	            this.emit(false);
	        }
	        else {
	            this._b.push(value);
	            this.checkValues();
	        }
	    };
	    return SequenceEqualSubscriber;
	}(Subscriber_1.Subscriber));
	exports.SequenceEqualSubscriber = SequenceEqualSubscriber;
	var SequenceEqualCompareToSubscriber = (function (_super) {
	    __extends(SequenceEqualCompareToSubscriber, _super);
	    function SequenceEqualCompareToSubscriber(destination, parent) {
	        _super.call(this, destination);
	        this.parent = parent;
	    }
	    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
	        this.parent.nextB(value);
	    };
	    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
	        this.parent.error(err);
	    };
	    SequenceEqualCompareToSubscriber.prototype._complete = function () {
	        this.parent._complete();
	    };
	    return SequenceEqualCompareToSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var multicast_1 = __webpack_require__(15);
	var Subject_1 = __webpack_require__(6);
	function shareSubjectFactory() {
	    return new Subject_1.Subject();
	}
	/**
	 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
	 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
	 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
	 * This is an alias for .publish().refCount().
	 *
	 * <img src="./img/share.png" width="100%">
	 *
	 * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
	 * @method share
	 * @owner Observable
	 */
	function share() {
	    return multicast_1.multicast.call(this, shareSubjectFactory).refCount();
	}
	exports.share = share;
	;


/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var EmptyError_1 = __webpack_require__(25);
	/**
	 * Returns an Observable that emits the single item emitted by the source Observable that matches a specified
	 * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no
	 * such items, notify of an IllegalArgumentException or NoSuchElementException respectively.
	 *
	 * <img src="./img/single.png" width="100%">
	 *
	 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
	 * callback if the Observable completes before any `next` notification was sent.
	 * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.
	 * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches
	 * the predicate.
	 .
	 * @method single
	 * @owner Observable
	 */
	function single(predicate) {
	    return this.lift(new SingleOperator(predicate, this));
	}
	exports.single = single;
	var SingleOperator = (function () {
	    function SingleOperator(predicate, source) {
	        this.predicate = predicate;
	        this.source = source;
	    }
	    SingleOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
	    };
	    return SingleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SingleSubscriber = (function (_super) {
	    __extends(SingleSubscriber, _super);
	    function SingleSubscriber(destination, predicate, source) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.source = source;
	        this.seenValue = false;
	        this.index = 0;
	    }
	    SingleSubscriber.prototype.applySingleValue = function (value) {
	        if (this.seenValue) {
	            this.destination.error('Sequence contains more than one element');
	        }
	        else {
	            this.seenValue = true;
	            this.singleValue = value;
	        }
	    };
	    SingleSubscriber.prototype._next = function (value) {
	        var index = this.index++;
	        if (this.predicate) {
	            this.tryNext(value, index);
	        }
	        else {
	            this.applySingleValue(value);
	        }
	    };
	    SingleSubscriber.prototype.tryNext = function (value, index) {
	        try {
	            if (this.predicate(value, index, this.source)) {
	                this.applySingleValue(value);
	            }
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    SingleSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        if (this.index > 0) {
	            destination.next(this.seenValue ? this.singleValue : undefined);
	            destination.complete();
	        }
	        else {
	            destination.error(new EmptyError_1.EmptyError);
	        }
	    };
	    return SingleSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/**
	 * Returns an Observable that skips the first `count` items emitted by the source Observable.
	 *
	 * <img src="./img/skip.png" width="100%">
	 *
	 * @param {Number} count - The number of times, items emitted by source Observable should be skipped.
	 * @return {Observable} An Observable that skips values emitted by the source Observable.
	 *
	 * @method skip
	 * @owner Observable
	 */
	function skip(count) {
	    return this.lift(new SkipOperator(count));
	}
	exports.skip = skip;
	var SkipOperator = (function () {
	    function SkipOperator(total) {
	        this.total = total;
	    }
	    SkipOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SkipSubscriber(subscriber, this.total));
	    };
	    return SkipOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SkipSubscriber = (function (_super) {
	    __extends(SkipSubscriber, _super);
	    function SkipSubscriber(destination, total) {
	        _super.call(this, destination);
	        this.total = total;
	        this.count = 0;
	    }
	    SkipSubscriber.prototype._next = function (x) {
	        if (++this.count > this.total) {
	            this.destination.next(x);
	        }
	    };
	    return SkipSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/**
	 * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
	 *
	 * <img src="./img/skipUntil.png" width="100%">
	 *
	 * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to
	 * be mirrored by the resulting Observable.
	 * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits
	 * an item, then emits the remaining items.
	 * @method skipUntil
	 * @owner Observable
	 */
	function skipUntil(notifier) {
	    return this.lift(new SkipUntilOperator(notifier));
	}
	exports.skipUntil = skipUntil;
	var SkipUntilOperator = (function () {
	    function SkipUntilOperator(notifier) {
	        this.notifier = notifier;
	    }
	    SkipUntilOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SkipUntilSubscriber(subscriber, this.notifier));
	    };
	    return SkipUntilOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SkipUntilSubscriber = (function (_super) {
	    __extends(SkipUntilSubscriber, _super);
	    function SkipUntilSubscriber(destination, notifier) {
	        _super.call(this, destination);
	        this.hasValue = false;
	        this.isInnerStopped = false;
	        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
	    }
	    SkipUntilSubscriber.prototype._next = function (value) {
	        if (this.hasValue) {
	            _super.prototype._next.call(this, value);
	        }
	    };
	    SkipUntilSubscriber.prototype._complete = function () {
	        if (this.isInnerStopped) {
	            _super.prototype._complete.call(this);
	        }
	        else {
	            this.unsubscribe();
	        }
	    };
	    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.hasValue = true;
	    };
	    SkipUntilSubscriber.prototype.notifyComplete = function () {
	        this.isInnerStopped = true;
	        if (this.isStopped) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    return SkipUntilSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/**
	 * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds
	 * true, but emits all further source items as soon as the condition becomes false.
	 *
	 * <img src="./img/skipWhile.png" width="100%">
	 *
	 * @param {Function} predicate - A function to test each item emitted from the source Observable.
	 * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the
	 * specified predicate becomes false.
	 * @method skipWhile
	 * @owner Observable
	 */
	function skipWhile(predicate) {
	    return this.lift(new SkipWhileOperator(predicate));
	}
	exports.skipWhile = skipWhile;
	var SkipWhileOperator = (function () {
	    function SkipWhileOperator(predicate) {
	        this.predicate = predicate;
	    }
	    SkipWhileOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
	    };
	    return SkipWhileOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SkipWhileSubscriber = (function (_super) {
	    __extends(SkipWhileSubscriber, _super);
	    function SkipWhileSubscriber(destination, predicate) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.skipping = true;
	        this.index = 0;
	    }
	    SkipWhileSubscriber.prototype._next = function (value) {
	        var destination = this.destination;
	        if (this.skipping) {
	            this.tryCallPredicate(value);
	        }
	        if (!this.skipping) {
	            destination.next(value);
	        }
	    };
	    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
	        try {
	            var result = this.predicate(value, this.index++);
	            this.skipping = Boolean(result);
	        }
	        catch (err) {
	            this.destination.error(err);
	        }
	    };
	    return SkipWhileSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ArrayObservable_1 = __webpack_require__(11);
	var ScalarObservable_1 = __webpack_require__(31);
	var EmptyObservable_1 = __webpack_require__(14);
	var concat_1 = __webpack_require__(33);
	var isScheduler_1 = __webpack_require__(13);
	/* tslint:enable:max-line-length */
	/**
	 * Returns an Observable that emits the items you specify as arguments before it begins to emit
	 * items emitted by the source Observable.
	 *
	 * <img src="./img/startWith.png" width="100%">
	 *
	 * @param {...T} values - Items you want the modified Observable to emit first.
	 * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
	 * the emissions of the `next` notifications.
	 * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
	 * emitted by the source Observable.
	 * @method startWith
	 * @owner Observable
	 */
	function startWith() {
	    var array = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        array[_i - 0] = arguments[_i];
	    }
	    var scheduler = array[array.length - 1];
	    if (isScheduler_1.isScheduler(scheduler)) {
	        array.pop();
	    }
	    else {
	        scheduler = null;
	    }
	    var len = array.length;
	    if (len === 1) {
	        return concat_1.concatStatic(new ScalarObservable_1.ScalarObservable(array[0], scheduler), this);
	    }
	    else if (len > 1) {
	        return concat_1.concatStatic(new ArrayObservable_1.ArrayObservable(array, scheduler), this);
	    }
	    else {
	        return concat_1.concatStatic(new EmptyObservable_1.EmptyObservable(scheduler), this);
	    }
	}
	exports.startWith = startWith;


/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var SubscribeOnObservable_1 = __webpack_require__(215);
	/**
	 * Asynchronously subscribes Observers to this Observable on the specified IScheduler.
	 *
	 * <img src="./img/subscribeOn.png" width="100%">
	 *
	 * @param {Scheduler} scheduler - The IScheduler to perform subscription actions on.
	 * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified IScheduler.
	 .
	 * @method subscribeOn
	 * @owner Observable
	 */
	function subscribeOn(scheduler, delay) {
	    if (delay === void 0) { delay = 0; }
	    return this.lift(new SubscribeOnOperator(scheduler, delay));
	}
	exports.subscribeOn = subscribeOn;
	var SubscribeOnOperator = (function () {
	    function SubscribeOnOperator(scheduler, delay) {
	        this.scheduler = scheduler;
	        this.delay = delay;
	    }
	    SubscribeOnOperator.prototype.call = function (subscriber, source) {
	        return new SubscribeOnObservable_1.SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
	    };
	    return SubscribeOnOperator;
	}());


/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/**
	 * Converts a higher-order Observable into a first-order Observable by
	 * subscribing to only the most recently emitted of those inner Observables.
	 *
	 * <span class="informal">Flattens an Observable-of-Observables by dropping the
	 * previous inner Observable once a new one appears.</span>
	 *
	 * <img src="./img/switch.png" width="100%">
	 *
	 * `switch` subscribes to an Observable that emits Observables, also known as a
	 * higher-order Observable. Each time it observes one of these emitted inner
	 * Observables, the output Observable subscribes to the inner Observable and
	 * begins emitting the items emitted by that. So far, it behaves
	 * like {@link mergeAll}. However, when a new inner Observable is emitted,
	 * `switch` unsubscribes from the earlier-emitted inner Observable and
	 * subscribes to the new inner Observable and begins emitting items from it. It
	 * continues to behave like this for subsequent inner Observables.
	 *
	 * @example <caption>Rerun an interval Observable on every click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * // Each click event is mapped to an Observable that ticks every second
	 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
	 * var switched = higherOrder.switch();
	 * // The outcome is that `switched` is essentially a timer that restarts
	 * // on every click. The interval Observables from older clicks do not merge
	 * // with the current interval Observable.
	 * switched.subscribe(x => console.log(x));
	 *
	 * @see {@link combineAll}
	 * @see {@link concatAll}
	 * @see {@link exhaust}
	 * @see {@link mergeAll}
	 * @see {@link switchMap}
	 * @see {@link switchMapTo}
	 * @see {@link zipAll}
	 *
	 * @return {Observable<T>} An Observable that emits the items emitted by the
	 * Observable most recently emitted by the source Observable.
	 * @method switch
	 * @name switch
	 * @owner Observable
	 */
	function _switch() {
	    return this.lift(new SwitchOperator());
	}
	exports._switch = _switch;
	var SwitchOperator = (function () {
	    function SwitchOperator() {
	    }
	    SwitchOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SwitchSubscriber(subscriber));
	    };
	    return SwitchOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchSubscriber = (function (_super) {
	    __extends(SwitchSubscriber, _super);
	    function SwitchSubscriber(destination) {
	        _super.call(this, destination);
	        this.active = 0;
	        this.hasCompleted = false;
	    }
	    SwitchSubscriber.prototype._next = function (value) {
	        this.unsubscribeInner();
	        this.active++;
	        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, value));
	    };
	    SwitchSubscriber.prototype._complete = function () {
	        this.hasCompleted = true;
	        if (this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    SwitchSubscriber.prototype.unsubscribeInner = function () {
	        this.active = this.active > 0 ? this.active - 1 : 0;
	        var innerSubscription = this.innerSubscription;
	        if (innerSubscription) {
	            innerSubscription.unsubscribe();
	            this.remove(innerSubscription);
	        }
	    };
	    SwitchSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.destination.next(innerValue);
	    };
	    SwitchSubscriber.prototype.notifyError = function (err) {
	        this.destination.error(err);
	    };
	    SwitchSubscriber.prototype.notifyComplete = function () {
	        this.unsubscribeInner();
	        if (this.hasCompleted && this.active === 0) {
	            this.destination.complete();
	        }
	    };
	    return SwitchSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/* tslint:enable:max-line-length */
	/**
	 * Projects each source value to an Observable which is merged in the output
	 * Observable, emitting values only from the most recently projected Observable.
	 *
	 * <span class="informal">Maps each value to an Observable, then flattens all of
	 * these inner Observables using {@link switch}.</span>
	 *
	 * <img src="./img/switchMap.png" width="100%">
	 *
	 * Returns an Observable that emits items based on applying a function that you
	 * supply to each item emitted by the source Observable, where that function
	 * returns an (so-called "inner") Observable. Each time it observes one of these
	 * inner Observables, the output Observable begins emitting the items emitted by
	 * that inner Observable. When a new inner Observable is emitted, `switchMap`
	 * stops emitting items from the earlier-emitted inner Observable and begins
	 * emitting items from the new one. It continues to behave like this for
	 * subsequent inner Observables.
	 *
	 * @example <caption>Rerun an interval Observable on every click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMap}
	 * @see {@link exhaustMap}
	 * @see {@link mergeMap}
	 * @see {@link switch}
	 * @see {@link switchMapTo}
	 *
	 * @param {function(value: T, ?index: number): ObservableInput} project A function
	 * that, when applied to an item emitted by the source Observable, returns an
	 * Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An Observable that emits the result of applying the
	 * projection function (and the optional `resultSelector`) to each item emitted
	 * by the source Observable and taking only the values from the most recently
	 * projected inner Observable.
	 * @method switchMap
	 * @owner Observable
	 */
	function switchMap(project, resultSelector) {
	    return this.lift(new SwitchMapOperator(project, resultSelector));
	}
	exports.switchMap = switchMap;
	var SwitchMapOperator = (function () {
	    function SwitchMapOperator(project, resultSelector) {
	        this.project = project;
	        this.resultSelector = resultSelector;
	    }
	    SwitchMapOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project, this.resultSelector));
	    };
	    return SwitchMapOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchMapSubscriber = (function (_super) {
	    __extends(SwitchMapSubscriber, _super);
	    function SwitchMapSubscriber(destination, project, resultSelector) {
	        _super.call(this, destination);
	        this.project = project;
	        this.resultSelector = resultSelector;
	        this.index = 0;
	    }
	    SwitchMapSubscriber.prototype._next = function (value) {
	        var result;
	        var index = this.index++;
	        try {
	            result = this.project(value, index);
	        }
	        catch (error) {
	            this.destination.error(error);
	            return;
	        }
	        this._innerSub(result, value, index);
	    };
	    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
	        var innerSubscription = this.innerSubscription;
	        if (innerSubscription) {
	            innerSubscription.unsubscribe();
	        }
	        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, result, value, index));
	    };
	    SwitchMapSubscriber.prototype._complete = function () {
	        var innerSubscription = this.innerSubscription;
	        if (!innerSubscription || innerSubscription.closed) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapSubscriber.prototype._unsubscribe = function () {
	        this.innerSubscription = null;
	    };
	    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.remove(innerSub);
	        this.innerSubscription = null;
	        if (this.isStopped) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (this.resultSelector) {
	            this._tryNotifyNext(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            this.destination.next(innerValue);
	        }
	    };
	    SwitchMapSubscriber.prototype._tryNotifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var result;
	        try {
	            result = this.resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return SwitchMapSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/* tslint:enable:max-line-length */
	/**
	 * Projects each source value to the same Observable which is flattened multiple
	 * times with {@link switch} in the output Observable.
	 *
	 * <span class="informal">It's like {@link switchMap}, but maps each value
	 * always to the same inner Observable.</span>
	 *
	 * <img src="./img/switchMapTo.png" width="100%">
	 *
	 * Maps each source value to the given Observable `innerObservable` regardless
	 * of the source value, and then flattens those resulting Observables into one
	 * single Observable, which is the output Observable. The output Observables
	 * emits values only from the most recently emitted instance of
	 * `innerObservable`.
	 *
	 * @example <caption>Rerun an interval Observable on every click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link concatMapTo}
	 * @see {@link switch}
	 * @see {@link switchMap}
	 * @see {@link mergeMapTo}
	 *
	 * @param {ObservableInput} innerObservable An Observable to replace each value from
	 * the source Observable.
	 * @param {function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any} [resultSelector]
	 * A function to produce the value on the output Observable based on the values
	 * and the indices of the source (outer) emission and the inner Observable
	 * emission. The arguments passed to this function are:
	 * - `outerValue`: the value that came from the source
	 * - `innerValue`: the value that came from the projected Observable
	 * - `outerIndex`: the "index" of the value that came from the source
	 * - `innerIndex`: the "index" of the value from the projected Observable
	 * @return {Observable} An Observable that emits items from the given
	 * `innerObservable` (and optionally transformed through `resultSelector`) every
	 * time a value is emitted on the source Observable, and taking only the values
	 * from the most recently projected inner Observable.
	 * @method switchMapTo
	 * @owner Observable
	 */
	function switchMapTo(innerObservable, resultSelector) {
	    return this.lift(new SwitchMapToOperator(innerObservable, resultSelector));
	}
	exports.switchMapTo = switchMapTo;
	var SwitchMapToOperator = (function () {
	    function SwitchMapToOperator(observable, resultSelector) {
	        this.observable = observable;
	        this.resultSelector = resultSelector;
	    }
	    SwitchMapToOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new SwitchMapToSubscriber(subscriber, this.observable, this.resultSelector));
	    };
	    return SwitchMapToOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var SwitchMapToSubscriber = (function (_super) {
	    __extends(SwitchMapToSubscriber, _super);
	    function SwitchMapToSubscriber(destination, inner, resultSelector) {
	        _super.call(this, destination);
	        this.inner = inner;
	        this.resultSelector = resultSelector;
	        this.index = 0;
	    }
	    SwitchMapToSubscriber.prototype._next = function (value) {
	        var innerSubscription = this.innerSubscription;
	        if (innerSubscription) {
	            innerSubscription.unsubscribe();
	        }
	        this.add(this.innerSubscription = subscribeToResult_1.subscribeToResult(this, this.inner, value, this.index++));
	    };
	    SwitchMapToSubscriber.prototype._complete = function () {
	        var innerSubscription = this.innerSubscription;
	        if (!innerSubscription || innerSubscription.closed) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapToSubscriber.prototype._unsubscribe = function () {
	        this.innerSubscription = null;
	    };
	    SwitchMapToSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.remove(innerSub);
	        this.innerSubscription = null;
	        if (this.isStopped) {
	            _super.prototype._complete.call(this);
	        }
	    };
	    SwitchMapToSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        if (resultSelector) {
	            this.tryResultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        else {
	            destination.next(innerValue);
	        }
	    };
	    SwitchMapToSubscriber.prototype.tryResultSelector = function (outerValue, innerValue, outerIndex, innerIndex) {
	        var _a = this, resultSelector = _a.resultSelector, destination = _a.destination;
	        var result;
	        try {
	            result = resultSelector(outerValue, innerValue, outerIndex, innerIndex);
	        }
	        catch (err) {
	            destination.error(err);
	            return;
	        }
	        destination.next(result);
	    };
	    return SwitchMapToSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var ArgumentOutOfRangeError_1 = __webpack_require__(24);
	var EmptyObservable_1 = __webpack_require__(14);
	/**
	 * Emits only the first `count` values emitted by the source Observable.
	 *
	 * <span class="informal">Takes the first `count` values from the source, then
	 * completes.</span>
	 *
	 * <img src="./img/take.png" width="100%">
	 *
	 * `take` returns an Observable that emits only the first `count` values emitted
	 * by the source Observable. If the source emits fewer than `count` values then
	 * all of its values are emitted. After that, it completes, regardless if the
	 * source completes.
	 *
	 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
	 * var interval = Rx.Observable.interval(1000);
	 * var five = interval.take(5);
	 * five.subscribe(x => console.log(x));
	 *
	 * @see {@link takeLast}
	 * @see {@link takeUntil}
	 * @see {@link takeWhile}
	 * @see {@link skip}
	 *
	 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
	 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
	 *
	 * @param {number} count The maximum number of `next` values to emit.
	 * @return {Observable<T>} An Observable that emits only the first `count`
	 * values emitted by the source Observable, or all of the values from the source
	 * if the source emits fewer than `count` values.
	 * @method take
	 * @owner Observable
	 */
	function take(count) {
	    if (count === 0) {
	        return new EmptyObservable_1.EmptyObservable();
	    }
	    else {
	        return this.lift(new TakeOperator(count));
	    }
	}
	exports.take = take;
	var TakeOperator = (function () {
	    function TakeOperator(total) {
	        this.total = total;
	        if (this.total < 0) {
	            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
	        }
	    }
	    TakeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TakeSubscriber(subscriber, this.total));
	    };
	    return TakeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TakeSubscriber = (function (_super) {
	    __extends(TakeSubscriber, _super);
	    function TakeSubscriber(destination, total) {
	        _super.call(this, destination);
	        this.total = total;
	        this.count = 0;
	    }
	    TakeSubscriber.prototype._next = function (value) {
	        var total = this.total;
	        var count = ++this.count;
	        if (count <= total) {
	            this.destination.next(value);
	            if (count === total) {
	                this.destination.complete();
	                this.unsubscribe();
	            }
	        }
	    };
	    return TakeSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var ArgumentOutOfRangeError_1 = __webpack_require__(24);
	var EmptyObservable_1 = __webpack_require__(14);
	/**
	 * Emits only the last `count` values emitted by the source Observable.
	 *
	 * <span class="informal">Remembers the latest `count` values, then emits those
	 * only when the source completes.</span>
	 *
	 * <img src="./img/takeLast.png" width="100%">
	 *
	 * `takeLast` returns an Observable that emits at most the last `count` values
	 * emitted by the source Observable. If the source emits fewer than `count`
	 * values then all of its values are emitted. This operator must wait until the
	 * `complete` notification emission from the source in order to emit the `next`
	 * values on the output Observable, because otherwise it is impossible to know
	 * whether or not more values will be emitted on the source. For this reason,
	 * all values are emitted synchronously, followed by the complete notification.
	 *
	 * @example <caption>Take the last 3 values of an Observable with many values</caption>
	 * var many = Rx.Observable.range(1, 100);
	 * var lastThree = many.takeLast(3);
	 * lastThree.subscribe(x => console.log(x));
	 *
	 * @see {@link take}
	 * @see {@link takeUntil}
	 * @see {@link takeWhile}
	 * @see {@link skip}
	 *
	 * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an
	 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
	 *
	 * @param {number} count The maximum number of values to emit from the end of
	 * the sequence of values emitted by the source Observable.
	 * @return {Observable<T>} An Observable that emits at most the last count
	 * values emitted by the source Observable.
	 * @method takeLast
	 * @owner Observable
	 */
	function takeLast(count) {
	    if (count === 0) {
	        return new EmptyObservable_1.EmptyObservable();
	    }
	    else {
	        return this.lift(new TakeLastOperator(count));
	    }
	}
	exports.takeLast = takeLast;
	var TakeLastOperator = (function () {
	    function TakeLastOperator(total) {
	        this.total = total;
	        if (this.total < 0) {
	            throw new ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;
	        }
	    }
	    TakeLastOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
	    };
	    return TakeLastOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TakeLastSubscriber = (function (_super) {
	    __extends(TakeLastSubscriber, _super);
	    function TakeLastSubscriber(destination, total) {
	        _super.call(this, destination);
	        this.total = total;
	        this.ring = new Array();
	        this.count = 0;
	    }
	    TakeLastSubscriber.prototype._next = function (value) {
	        var ring = this.ring;
	        var total = this.total;
	        var count = this.count++;
	        if (ring.length < total) {
	            ring.push(value);
	        }
	        else {
	            var index = count % total;
	            ring[index] = value;
	        }
	    };
	    TakeLastSubscriber.prototype._complete = function () {
	        var destination = this.destination;
	        var count = this.count;
	        if (count > 0) {
	            var total = this.count >= this.total ? this.total : this.count;
	            var ring = this.ring;
	            for (var i = 0; i < total; i++) {
	                var idx = (count++) % total;
	                destination.next(ring[idx]);
	            }
	        }
	        destination.complete();
	    };
	    return TakeLastSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/**
	 * Emits the values emitted by the source Observable until a `notifier`
	 * Observable emits a value.
	 *
	 * <span class="informal">Lets values pass until a second Observable,
	 * `notifier`, emits something. Then, it completes.</span>
	 *
	 * <img src="./img/takeUntil.png" width="100%">
	 *
	 * `takeUntil` subscribes and begins mirroring the source Observable. It also
	 * monitors a second Observable, `notifier` that you provide. If the `notifier`
	 * emits a value or a complete notification, the output Observable stops
	 * mirroring the source Observable and completes.
	 *
	 * @example <caption>Tick every second until the first click happens</caption>
	 * var interval = Rx.Observable.interval(1000);
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = interval.takeUntil(clicks);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link take}
	 * @see {@link takeLast}
	 * @see {@link takeWhile}
	 * @see {@link skip}
	 *
	 * @param {Observable} notifier The Observable whose first emitted value will
	 * cause the output Observable of `takeUntil` to stop emitting values from the
	 * source Observable.
	 * @return {Observable<T>} An Observable that emits the values from the source
	 * Observable until such time as `notifier` emits its first value.
	 * @method takeUntil
	 * @owner Observable
	 */
	function takeUntil(notifier) {
	    return this.lift(new TakeUntilOperator(notifier));
	}
	exports.takeUntil = takeUntil;
	var TakeUntilOperator = (function () {
	    function TakeUntilOperator(notifier) {
	        this.notifier = notifier;
	    }
	    TakeUntilOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TakeUntilSubscriber(subscriber, this.notifier));
	    };
	    return TakeUntilOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TakeUntilSubscriber = (function (_super) {
	    __extends(TakeUntilSubscriber, _super);
	    function TakeUntilSubscriber(destination, notifier) {
	        _super.call(this, destination);
	        this.notifier = notifier;
	        this.add(subscribeToResult_1.subscribeToResult(this, notifier));
	    }
	    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.complete();
	    };
	    TakeUntilSubscriber.prototype.notifyComplete = function () {
	        // noop
	    };
	    return TakeUntilSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/**
	 * Emits values emitted by the source Observable so long as each value satisfies
	 * the given `predicate`, and then completes as soon as this `predicate` is not
	 * satisfied.
	 *
	 * <span class="informal">Takes values from the source only while they pass the
	 * condition given. When the first value does not satisfy, it completes.</span>
	 *
	 * <img src="./img/takeWhile.png" width="100%">
	 *
	 * `takeWhile` subscribes and begins mirroring the source Observable. Each value
	 * emitted on the source is given to the `predicate` function which returns a
	 * boolean, representing a condition to be satisfied by the source values. The
	 * output Observable emits the source values until such time as the `predicate`
	 * returns false, at which point `takeWhile` stops mirroring the source
	 * Observable and completes the output Observable.
	 *
	 * @example <caption>Emit click events only while the clientX property is greater than 200</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.takeWhile(ev => ev.clientX > 200);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link take}
	 * @see {@link takeLast}
	 * @see {@link takeUntil}
	 * @see {@link skip}
	 *
	 * @param {function(value: T, index: number): boolean} predicate A function that
	 * evaluates a value emitted by the source Observable and returns a boolean.
	 * Also takes the (zero-based) index as the second argument.
	 * @return {Observable<T>} An Observable that emits the values from the source
	 * Observable so long as each value satisfies the condition defined by the
	 * `predicate`, then completes.
	 * @method takeWhile
	 * @owner Observable
	 */
	function takeWhile(predicate) {
	    return this.lift(new TakeWhileOperator(predicate));
	}
	exports.takeWhile = takeWhile;
	var TakeWhileOperator = (function () {
	    function TakeWhileOperator(predicate) {
	        this.predicate = predicate;
	    }
	    TakeWhileOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));
	    };
	    return TakeWhileOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TakeWhileSubscriber = (function (_super) {
	    __extends(TakeWhileSubscriber, _super);
	    function TakeWhileSubscriber(destination, predicate) {
	        _super.call(this, destination);
	        this.predicate = predicate;
	        this.index = 0;
	    }
	    TakeWhileSubscriber.prototype._next = function (value) {
	        var destination = this.destination;
	        var result;
	        try {
	            result = this.predicate(value, this.index++);
	        }
	        catch (err) {
	            destination.error(err);
	            return;
	        }
	        this.nextOrComplete(value, result);
	    };
	    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
	        var destination = this.destination;
	        if (Boolean(predicateResult)) {
	            destination.next(value);
	        }
	        else {
	            destination.complete();
	        }
	    };
	    return TakeWhileSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/**
	 * Emits a value from the source Observable, then ignores subsequent source
	 * values for a duration determined by another Observable, then repeats this
	 * process.
	 *
	 * <span class="informal">It's like {@link throttleTime}, but the silencing
	 * duration is determined by a second Observable.</span>
	 *
	 * <img src="./img/throttle.png" width="100%">
	 *
	 * `throttle` emits the source Observable values on the output Observable
	 * when its internal timer is disabled, and ignores source values when the timer
	 * is enabled. Initially, the timer is disabled. As soon as the first source
	 * value arrives, it is forwarded to the output Observable, and then the timer
	 * is enabled by calling the `durationSelector` function with the source value,
	 * which returns the "duration" Observable. When the duration Observable emits a
	 * value or completes, the timer is disabled, and this process repeats for the
	 * next source value.
	 *
	 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.throttle(ev => Rx.Observable.interval(1000));
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link audit}
	 * @see {@link debounce}
	 * @see {@link delayWhen}
	 * @see {@link sample}
	 * @see {@link throttleTime}
	 *
	 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
	 * that receives a value from the source Observable, for computing the silencing
	 * duration for each source value, returned as an Observable or a Promise.
	 * @return {Observable<T>} An Observable that performs the throttle operation to
	 * limit the rate of emissions from the source.
	 * @method throttle
	 * @owner Observable
	 */
	function throttle(durationSelector) {
	    return this.lift(new ThrottleOperator(durationSelector));
	}
	exports.throttle = throttle;
	var ThrottleOperator = (function () {
	    function ThrottleOperator(durationSelector) {
	        this.durationSelector = durationSelector;
	    }
	    ThrottleOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector));
	    };
	    return ThrottleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ThrottleSubscriber = (function (_super) {
	    __extends(ThrottleSubscriber, _super);
	    function ThrottleSubscriber(destination, durationSelector) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.durationSelector = durationSelector;
	    }
	    ThrottleSubscriber.prototype._next = function (value) {
	        if (!this.throttled) {
	            this.tryDurationSelector(value);
	        }
	    };
	    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
	        var duration = null;
	        try {
	            duration = this.durationSelector(value);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.emitAndThrottle(value, duration);
	    };
	    ThrottleSubscriber.prototype.emitAndThrottle = function (value, duration) {
	        this.add(this.throttled = subscribeToResult_1.subscribeToResult(this, duration));
	        this.destination.next(value);
	    };
	    ThrottleSubscriber.prototype._unsubscribe = function () {
	        var throttled = this.throttled;
	        if (throttled) {
	            this.remove(throttled);
	            this.throttled = null;
	            throttled.unsubscribe();
	        }
	    };
	    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this._unsubscribe();
	    };
	    ThrottleSubscriber.prototype.notifyComplete = function () {
	        this._unsubscribe();
	    };
	    return ThrottleSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var async_1 = __webpack_require__(10);
	/**
	 * Emits a value from the source Observable, then ignores subsequent source
	 * values for `duration` milliseconds, then repeats this process.
	 *
	 * <span class="informal">Lets a value pass, then ignores source values for the
	 * next `duration` milliseconds.</span>
	 *
	 * <img src="./img/throttleTime.png" width="100%">
	 *
	 * `throttleTime` emits the source Observable values on the output Observable
	 * when its internal timer is disabled, and ignores source values when the timer
	 * is enabled. Initially, the timer is disabled. As soon as the first source
	 * value arrives, it is forwarded to the output Observable, and then the timer
	 * is enabled. After `duration` milliseconds (or the time unit determined
	 * internally by the optional `scheduler`) has passed, the timer is disabled,
	 * and this process repeats for the next source value. Optionally takes a
	 * {@link IScheduler} for managing timers.
	 *
	 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.throttleTime(1000);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link auditTime}
	 * @see {@link debounceTime}
	 * @see {@link delay}
	 * @see {@link sampleTime}
	 * @see {@link throttle}
	 *
	 * @param {number} duration Time to wait before emitting another value after
	 * emitting the last value, measured in milliseconds or the time unit determined
	 * internally by the optional `scheduler`.
	 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
	 * managing the timers that handle the sampling.
	 * @return {Observable<T>} An Observable that performs the throttle operation to
	 * limit the rate of emissions from the source.
	 * @method throttleTime
	 * @owner Observable
	 */
	function throttleTime(duration, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    return this.lift(new ThrottleTimeOperator(duration, scheduler));
	}
	exports.throttleTime = throttleTime;
	var ThrottleTimeOperator = (function () {
	    function ThrottleTimeOperator(duration, scheduler) {
	        this.duration = duration;
	        this.scheduler = scheduler;
	    }
	    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler));
	    };
	    return ThrottleTimeOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ThrottleTimeSubscriber = (function (_super) {
	    __extends(ThrottleTimeSubscriber, _super);
	    function ThrottleTimeSubscriber(destination, duration, scheduler) {
	        _super.call(this, destination);
	        this.duration = duration;
	        this.scheduler = scheduler;
	    }
	    ThrottleTimeSubscriber.prototype._next = function (value) {
	        if (!this.throttled) {
	            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
	            this.destination.next(value);
	        }
	    };
	    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
	        var throttled = this.throttled;
	        if (throttled) {
	            throttled.unsubscribe();
	            this.remove(throttled);
	            this.throttled = null;
	        }
	    };
	    return ThrottleTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchNext(arg) {
	    var subscriber = arg.subscriber;
	    subscriber.clearThrottle();
	}


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1 = __webpack_require__(10);
	var isDate_1 = __webpack_require__(27);
	var Subscriber_1 = __webpack_require__(2);
	var TimeoutError_1 = __webpack_require__(60);
	/**
	 * @param {number} due
	 * @param {Scheduler} [scheduler]
	 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
	 * @method timeout
	 * @owner Observable
	 */
	function timeout(due, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    var absoluteTimeout = isDate_1.isDate(due);
	    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
	    return this.lift(new TimeoutOperator(waitFor, absoluteTimeout, scheduler, new TimeoutError_1.TimeoutError()));
	}
	exports.timeout = timeout;
	var TimeoutOperator = (function () {
	    function TimeoutOperator(waitFor, absoluteTimeout, scheduler, errorInstance) {
	        this.waitFor = waitFor;
	        this.absoluteTimeout = absoluteTimeout;
	        this.scheduler = scheduler;
	        this.errorInstance = errorInstance;
	    }
	    TimeoutOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TimeoutSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.scheduler, this.errorInstance));
	    };
	    return TimeoutOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TimeoutSubscriber = (function (_super) {
	    __extends(TimeoutSubscriber, _super);
	    function TimeoutSubscriber(destination, absoluteTimeout, waitFor, scheduler, errorInstance) {
	        _super.call(this, destination);
	        this.absoluteTimeout = absoluteTimeout;
	        this.waitFor = waitFor;
	        this.scheduler = scheduler;
	        this.errorInstance = errorInstance;
	        this.action = null;
	        this.scheduleTimeout();
	    }
	    TimeoutSubscriber.dispatchTimeout = function (subscriber) {
	        subscriber.error(subscriber.errorInstance);
	    };
	    TimeoutSubscriber.prototype.scheduleTimeout = function () {
	        var action = this.action;
	        if (action) {
	            // Recycle the action if we've already scheduled one. All the production
	            // Scheduler Actions mutate their state/delay time and return themeselves.
	            // VirtualActions are immutable, so they create and return a clone. In this
	            // case, we need to set the action reference to the most recent VirtualAction,
	            // to ensure that's the one we clone from next time.
	            this.action = action.schedule(this, this.waitFor);
	        }
	        else {
	            this.add(this.action = this.scheduler.schedule(TimeoutSubscriber.dispatchTimeout, this.waitFor, this));
	        }
	    };
	    TimeoutSubscriber.prototype._next = function (value) {
	        if (!this.absoluteTimeout) {
	            this.scheduleTimeout();
	        }
	        _super.prototype._next.call(this, value);
	    };
	    TimeoutSubscriber.prototype._unsubscribe = function () {
	        this.action = null;
	        this.scheduler = null;
	        this.errorInstance = null;
	    };
	    return TimeoutSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var async_1 = __webpack_require__(10);
	var isDate_1 = __webpack_require__(27);
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/* tslint:enable:max-line-length */
	/**
	 * @param due
	 * @param withObservable
	 * @param scheduler
	 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
	 * @method timeoutWith
	 * @owner Observable
	 */
	function timeoutWith(due, withObservable, scheduler) {
	    if (scheduler === void 0) { scheduler = async_1.async; }
	    var absoluteTimeout = isDate_1.isDate(due);
	    var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
	    return this.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
	}
	exports.timeoutWith = timeoutWith;
	var TimeoutWithOperator = (function () {
	    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
	        this.waitFor = waitFor;
	        this.absoluteTimeout = absoluteTimeout;
	        this.withObservable = withObservable;
	        this.scheduler = scheduler;
	    }
	    TimeoutWithOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
	    };
	    return TimeoutWithOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var TimeoutWithSubscriber = (function (_super) {
	    __extends(TimeoutWithSubscriber, _super);
	    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
	        _super.call(this, destination);
	        this.absoluteTimeout = absoluteTimeout;
	        this.waitFor = waitFor;
	        this.withObservable = withObservable;
	        this.scheduler = scheduler;
	        this.action = null;
	        this.scheduleTimeout();
	    }
	    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
	        var withObservable = subscriber.withObservable;
	        subscriber._unsubscribeAndRecycle();
	        subscriber.add(subscribeToResult_1.subscribeToResult(subscriber, withObservable));
	    };
	    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
	        var action = this.action;
	        if (action) {
	            // Recycle the action if we've already scheduled one. All the production
	            // Scheduler Actions mutate their state/delay time and return themeselves.
	            // VirtualActions are immutable, so they create and return a clone. In this
	            // case, we need to set the action reference to the most recent VirtualAction,
	            // to ensure that's the one we clone from next time.
	            this.action = action.schedule(this, this.waitFor);
	        }
	        else {
	            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
	        }
	    };
	    TimeoutWithSubscriber.prototype._next = function (value) {
	        if (!this.absoluteTimeout) {
	            this.scheduleTimeout();
	        }
	        _super.prototype._next.call(this, value);
	    };
	    TimeoutWithSubscriber.prototype._unsubscribe = function () {
	        this.action = null;
	        this.scheduler = null;
	        this.withObservable = null;
	    };
	    return TimeoutWithSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	/**
	 * @return {Observable<any[]>|WebSocketSubject<T>|Observable<T>}
	 * @method toArray
	 * @owner Observable
	 */
	function toArray() {
	    return this.lift(new ToArrayOperator());
	}
	exports.toArray = toArray;
	var ToArrayOperator = (function () {
	    function ToArrayOperator() {
	    }
	    ToArrayOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new ToArraySubscriber(subscriber));
	    };
	    return ToArrayOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ToArraySubscriber = (function (_super) {
	    __extends(ToArraySubscriber, _super);
	    function ToArraySubscriber(destination) {
	        _super.call(this, destination);
	        this.array = [];
	    }
	    ToArraySubscriber.prototype._next = function (x) {
	        this.array.push(x);
	    };
	    ToArraySubscriber.prototype._complete = function () {
	        this.destination.next(this.array);
	        this.destination.complete();
	    };
	    return ToArraySubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(8);
	/* tslint:enable:max-line-length */
	/**
	 * Converts an Observable sequence to a ES2015 compliant promise.
	 *
	 * @example
	 * // Using normal ES2015
	 * let source = Rx.Observable
	 *   .just(42)
	 *   .toPromise();
	 *
	 * source.then((value) => console.log('Value: %s', value));
	 * // => Value: 42
	 *
	 * // Rejected Promise
	 * // Using normal ES2015
	 * let source = Rx.Observable
	 *   .throw(new Error('woops'))
	 *   .toPromise();
	 *
	 * source
	 *   .then((value) => console.log('Value: %s', value))
	 *   .catch((err) => console.log('Error: %s', err));
	 * // => Error: Error: woops
	 *
	 * // Setting via the config
	 * Rx.config.Promise = RSVP.Promise;
	 *
	 * let source = Rx.Observable
	 *   .of(42)
	 *   .toPromise();
	 *
	 * source.then((value) => console.log('Value: %s', value));
	 * // => Value: 42
	 *
	 * // Setting via the method
	 * let source = Rx.Observable
	 *   .just(42)
	 *   .toPromise(RSVP.Promise);
	 *
	 * source.then((value) => console.log('Value: %s', value));
	 * // => Value: 42
	 *
	 * @param PromiseCtor promise The constructor of the promise. If not provided,
	 * it will look for a constructor first in Rx.config.Promise then fall back to
	 * the native Promise constructor if available.
	 * @return {Promise<T>} An ES2015 compatible promise with the last value from
	 * the observable sequence.
	 * @method toPromise
	 * @owner Observable
	 */
	function toPromise(PromiseCtor) {
	    var _this = this;
	    if (!PromiseCtor) {
	        if (root_1.root.Rx && root_1.root.Rx.config && root_1.root.Rx.config.Promise) {
	            PromiseCtor = root_1.root.Rx.config.Promise;
	        }
	        else if (root_1.root.Promise) {
	            PromiseCtor = root_1.root.Promise;
	        }
	    }
	    if (!PromiseCtor) {
	        throw new Error('no Promise impl found');
	    }
	    return new PromiseCtor(function (resolve, reject) {
	        var value;
	        _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
	    });
	}
	exports.toPromise = toPromise;


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/**
	 * Branch out the source Observable values as a nested Observable whenever
	 * `windowBoundaries` emits.
	 *
	 * <span class="informal">It's like {@link buffer}, but emits a nested Observable
	 * instead of an array.</span>
	 *
	 * <img src="./img/window.png" width="100%">
	 *
	 * Returns an Observable that emits windows of items it collects from the source
	 * Observable. The output Observable emits connected, non-overlapping
	 * windows. It emits the current window and opens a new one whenever the
	 * Observable `windowBoundaries` emits an item. Because each window is an
	 * Observable, the output is a higher-order Observable.
	 *
	 * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var interval = Rx.Observable.interval(1000);
	 * var result = clicks.window(interval)
	 *   .map(win => win.take(2)) // each window has at most 2 emissions
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link windowCount}
	 * @see {@link windowTime}
	 * @see {@link windowToggle}
	 * @see {@link windowWhen}
	 * @see {@link buffer}
	 *
	 * @param {Observable<any>} windowBoundaries An Observable that completes the
	 * previous window and starts a new window.
	 * @return {Observable<Observable<T>>} An Observable of windows, which are
	 * Observables emitting values of the source Observable.
	 * @method window
	 * @owner Observable
	 */
	function window(windowBoundaries) {
	    return this.lift(new WindowOperator(windowBoundaries));
	}
	exports.window = window;
	var WindowOperator = (function () {
	    function WindowOperator(windowBoundaries) {
	        this.windowBoundaries = windowBoundaries;
	    }
	    WindowOperator.prototype.call = function (subscriber, source) {
	        var windowSubscriber = new WindowSubscriber(subscriber);
	        var sourceSubscription = source.subscribe(windowSubscriber);
	        if (!sourceSubscription.closed) {
	            windowSubscriber.add(subscribeToResult_1.subscribeToResult(windowSubscriber, this.windowBoundaries));
	        }
	        return sourceSubscription;
	    };
	    return WindowOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowSubscriber = (function (_super) {
	    __extends(WindowSubscriber, _super);
	    function WindowSubscriber(destination) {
	        _super.call(this, destination);
	        this.window = new Subject_1.Subject();
	        destination.next(this.window);
	    }
	    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.openWindow();
	    };
	    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
	        this._complete();
	    };
	    WindowSubscriber.prototype._next = function (value) {
	        this.window.next(value);
	    };
	    WindowSubscriber.prototype._error = function (err) {
	        this.window.error(err);
	        this.destination.error(err);
	    };
	    WindowSubscriber.prototype._complete = function () {
	        this.window.complete();
	        this.destination.complete();
	    };
	    WindowSubscriber.prototype._unsubscribe = function () {
	        this.window = null;
	    };
	    WindowSubscriber.prototype.openWindow = function () {
	        var prevWindow = this.window;
	        if (prevWindow) {
	            prevWindow.complete();
	        }
	        var destination = this.destination;
	        var newWindow = this.window = new Subject_1.Subject();
	        destination.next(newWindow);
	    };
	    return WindowSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscriber_1 = __webpack_require__(2);
	var Subject_1 = __webpack_require__(6);
	/**
	 * Branch out the source Observable values as a nested Observable with each
	 * nested Observable emitting at most `windowSize` values.
	 *
	 * <span class="informal">It's like {@link bufferCount}, but emits a nested
	 * Observable instead of an array.</span>
	 *
	 * <img src="./img/windowCount.png" width="100%">
	 *
	 * Returns an Observable that emits windows of items it collects from the source
	 * Observable. The output Observable emits windows every `startWindowEvery`
	 * items, each containing no more than `windowSize` items. When the source
	 * Observable completes or encounters an error, the output Observable emits
	 * the current window and propagates the notification from the source
	 * Observable. If `startWindowEvery` is not provided, then new windows are
	 * started immediately at the start of the source and when each window completes
	 * with size `windowSize`.
	 *
	 * @example <caption>Ignore every 3rd click event, starting from the first one</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.windowCount(3)
	 *   .map(win => win.skip(1)) // skip first of every 3 clicks
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @example <caption>Ignore every 3rd click event, starting from the third one</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks.windowCount(2, 3)
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link window}
	 * @see {@link windowTime}
	 * @see {@link windowToggle}
	 * @see {@link windowWhen}
	 * @see {@link bufferCount}
	 *
	 * @param {number} windowSize The maximum number of values emitted by each
	 * window.
	 * @param {number} [startWindowEvery] Interval at which to start a new window.
	 * For example if `startWindowEvery` is `2`, then a new window will be started
	 * on every other value from the source. A new window is started at the
	 * beginning of the source by default.
	 * @return {Observable<Observable<T>>} An Observable of windows, which in turn
	 * are Observable of values.
	 * @method windowCount
	 * @owner Observable
	 */
	function windowCount(windowSize, startWindowEvery) {
	    if (startWindowEvery === void 0) { startWindowEvery = 0; }
	    return this.lift(new WindowCountOperator(windowSize, startWindowEvery));
	}
	exports.windowCount = windowCount;
	var WindowCountOperator = (function () {
	    function WindowCountOperator(windowSize, startWindowEvery) {
	        this.windowSize = windowSize;
	        this.startWindowEvery = startWindowEvery;
	    }
	    WindowCountOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
	    };
	    return WindowCountOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowCountSubscriber = (function (_super) {
	    __extends(WindowCountSubscriber, _super);
	    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.windowSize = windowSize;
	        this.startWindowEvery = startWindowEvery;
	        this.windows = [new Subject_1.Subject()];
	        this.count = 0;
	        destination.next(this.windows[0]);
	    }
	    WindowCountSubscriber.prototype._next = function (value) {
	        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
	        var destination = this.destination;
	        var windowSize = this.windowSize;
	        var windows = this.windows;
	        var len = windows.length;
	        for (var i = 0; i < len && !this.closed; i++) {
	            windows[i].next(value);
	        }
	        var c = this.count - windowSize + 1;
	        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
	            windows.shift().complete();
	        }
	        if (++this.count % startWindowEvery === 0 && !this.closed) {
	            var window_1 = new Subject_1.Subject();
	            windows.push(window_1);
	            destination.next(window_1);
	        }
	    };
	    WindowCountSubscriber.prototype._error = function (err) {
	        var windows = this.windows;
	        if (windows) {
	            while (windows.length > 0 && !this.closed) {
	                windows.shift().error(err);
	            }
	        }
	        this.destination.error(err);
	    };
	    WindowCountSubscriber.prototype._complete = function () {
	        var windows = this.windows;
	        if (windows) {
	            while (windows.length > 0 && !this.closed) {
	                windows.shift().complete();
	            }
	        }
	        this.destination.complete();
	    };
	    WindowCountSubscriber.prototype._unsubscribe = function () {
	        this.count = 0;
	        this.windows = null;
	    };
	    return WindowCountSubscriber;
	}(Subscriber_1.Subscriber));


/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var async_1 = __webpack_require__(10);
	var Subscriber_1 = __webpack_require__(2);
	var isNumeric_1 = __webpack_require__(29);
	var isScheduler_1 = __webpack_require__(13);
	function windowTime(windowTimeSpan) {
	    var scheduler = async_1.async;
	    var windowCreationInterval = null;
	    var maxWindowSize = Number.POSITIVE_INFINITY;
	    if (isScheduler_1.isScheduler(arguments[3])) {
	        scheduler = arguments[3];
	    }
	    if (isScheduler_1.isScheduler(arguments[2])) {
	        scheduler = arguments[2];
	    }
	    else if (isNumeric_1.isNumeric(arguments[2])) {
	        maxWindowSize = arguments[2];
	    }
	    if (isScheduler_1.isScheduler(arguments[1])) {
	        scheduler = arguments[1];
	    }
	    else if (isNumeric_1.isNumeric(arguments[1])) {
	        windowCreationInterval = arguments[1];
	    }
	    return this.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
	}
	exports.windowTime = windowTime;
	var WindowTimeOperator = (function () {
	    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
	        this.windowTimeSpan = windowTimeSpan;
	        this.windowCreationInterval = windowCreationInterval;
	        this.maxWindowSize = maxWindowSize;
	        this.scheduler = scheduler;
	    }
	    WindowTimeOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
	    };
	    return WindowTimeOperator;
	}());
	var CountedSubject = (function (_super) {
	    __extends(CountedSubject, _super);
	    function CountedSubject() {
	        _super.apply(this, arguments);
	        this._numberOfNextedValues = 0;
	    }
	    CountedSubject.prototype.next = function (value) {
	        this._numberOfNextedValues++;
	        _super.prototype.next.call(this, value);
	    };
	    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
	        get: function () {
	            return this._numberOfNextedValues;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return CountedSubject;
	}(Subject_1.Subject));
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowTimeSubscriber = (function (_super) {
	    __extends(WindowTimeSubscriber, _super);
	    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.windowTimeSpan = windowTimeSpan;
	        this.windowCreationInterval = windowCreationInterval;
	        this.maxWindowSize = maxWindowSize;
	        this.scheduler = scheduler;
	        this.windows = [];
	        var window = this.openWindow();
	        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
	            var closeState = { subscriber: this, window: window, context: null };
	            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: this, scheduler: scheduler };
	            this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
	            this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
	        }
	        else {
	            var timeSpanOnlyState = { subscriber: this, window: window, windowTimeSpan: windowTimeSpan };
	            this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
	        }
	    }
	    WindowTimeSubscriber.prototype._next = function (value) {
	        var windows = this.windows;
	        var len = windows.length;
	        for (var i = 0; i < len; i++) {
	            var window_1 = windows[i];
	            if (!window_1.closed) {
	                window_1.next(value);
	                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
	                    this.closeWindow(window_1);
	                }
	            }
	        }
	    };
	    WindowTimeSubscriber.prototype._error = function (err) {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            windows.shift().error(err);
	        }
	        this.destination.error(err);
	    };
	    WindowTimeSubscriber.prototype._complete = function () {
	        var windows = this.windows;
	        while (windows.length > 0) {
	            var window_2 = windows.shift();
	            if (!window_2.closed) {
	                window_2.complete();
	            }
	        }
	        this.destination.complete();
	    };
	    WindowTimeSubscriber.prototype.openWindow = function () {
	        var window = new CountedSubject();
	        this.windows.push(window);
	        var destination = this.destination;
	        destination.next(window);
	        return window;
	    };
	    WindowTimeSubscriber.prototype.closeWindow = function (window) {
	        window.complete();
	        var windows = this.windows;
	        windows.splice(windows.indexOf(window), 1);
	    };
	    return WindowTimeSubscriber;
	}(Subscriber_1.Subscriber));
	function dispatchWindowTimeSpanOnly(state) {
	    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
	    if (window) {
	        subscriber.closeWindow(window);
	    }
	    state.window = subscriber.openWindow();
	    this.schedule(state, windowTimeSpan);
	}
	function dispatchWindowCreation(state) {
	    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
	    var window = subscriber.openWindow();
	    var action = this;
	    var context = { action: action, subscription: null };
	    var timeSpanState = { subscriber: subscriber, window: window, context: context };
	    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
	    action.add(context.subscription);
	    action.schedule(state, windowCreationInterval);
	}
	function dispatchWindowClose(state) {
	    var subscriber = state.subscriber, window = state.window, context = state.context;
	    if (context && context.action && context.subscription) {
	        context.action.remove(context.subscription);
	    }
	    subscriber.closeWindow(window);
	}


/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var Subscription_1 = __webpack_require__(5);
	var tryCatch_1 = __webpack_require__(9);
	var errorObject_1 = __webpack_require__(7);
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/**
	 * Branch out the source Observable values as a nested Observable starting from
	 * an emission from `openings` and ending when the output of `closingSelector`
	 * emits.
	 *
	 * <span class="informal">It's like {@link bufferToggle}, but emits a nested
	 * Observable instead of an array.</span>
	 *
	 * <img src="./img/windowToggle.png" width="100%">
	 *
	 * Returns an Observable that emits windows of items it collects from the source
	 * Observable. The output Observable emits windows that contain those items
	 * emitted by the source Observable between the time when the `openings`
	 * Observable emits an item and when the Observable returned by
	 * `closingSelector` emits an item.
	 *
	 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var openings = Rx.Observable.interval(1000);
	 * var result = clicks.windowToggle(openings, i =>
	 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
	 * ).mergeAll();
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link window}
	 * @see {@link windowCount}
	 * @see {@link windowTime}
	 * @see {@link windowWhen}
	 * @see {@link bufferToggle}
	 *
	 * @param {Observable<O>} openings An observable of notifications to start new
	 * windows.
	 * @param {function(value: O): Observable} closingSelector A function that takes
	 * the value emitted by the `openings` observable and returns an Observable,
	 * which, when it emits (either `next` or `complete`), signals that the
	 * associated window should complete.
	 * @return {Observable<Observable<T>>} An observable of windows, which in turn
	 * are Observables.
	 * @method windowToggle
	 * @owner Observable
	 */
	function windowToggle(openings, closingSelector) {
	    return this.lift(new WindowToggleOperator(openings, closingSelector));
	}
	exports.windowToggle = windowToggle;
	var WindowToggleOperator = (function () {
	    function WindowToggleOperator(openings, closingSelector) {
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	    }
	    WindowToggleOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
	    };
	    return WindowToggleOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowToggleSubscriber = (function (_super) {
	    __extends(WindowToggleSubscriber, _super);
	    function WindowToggleSubscriber(destination, openings, closingSelector) {
	        _super.call(this, destination);
	        this.openings = openings;
	        this.closingSelector = closingSelector;
	        this.contexts = [];
	        this.add(this.openSubscription = subscribeToResult_1.subscribeToResult(this, openings, openings));
	    }
	    WindowToggleSubscriber.prototype._next = function (value) {
	        var contexts = this.contexts;
	        if (contexts) {
	            var len = contexts.length;
	            for (var i = 0; i < len; i++) {
	                contexts[i].window.next(value);
	            }
	        }
	    };
	    WindowToggleSubscriber.prototype._error = function (err) {
	        var contexts = this.contexts;
	        this.contexts = null;
	        if (contexts) {
	            var len = contexts.length;
	            var index = -1;
	            while (++index < len) {
	                var context = contexts[index];
	                context.window.error(err);
	                context.subscription.unsubscribe();
	            }
	        }
	        _super.prototype._error.call(this, err);
	    };
	    WindowToggleSubscriber.prototype._complete = function () {
	        var contexts = this.contexts;
	        this.contexts = null;
	        if (contexts) {
	            var len = contexts.length;
	            var index = -1;
	            while (++index < len) {
	                var context = contexts[index];
	                context.window.complete();
	                context.subscription.unsubscribe();
	            }
	        }
	        _super.prototype._complete.call(this);
	    };
	    WindowToggleSubscriber.prototype._unsubscribe = function () {
	        var contexts = this.contexts;
	        this.contexts = null;
	        if (contexts) {
	            var len = contexts.length;
	            var index = -1;
	            while (++index < len) {
	                var context = contexts[index];
	                context.window.unsubscribe();
	                context.subscription.unsubscribe();
	            }
	        }
	    };
	    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        if (outerValue === this.openings) {
	            var closingSelector = this.closingSelector;
	            var closingNotifier = tryCatch_1.tryCatch(closingSelector)(innerValue);
	            if (closingNotifier === errorObject_1.errorObject) {
	                return this.error(errorObject_1.errorObject.e);
	            }
	            else {
	                var window_1 = new Subject_1.Subject();
	                var subscription = new Subscription_1.Subscription();
	                var context = { window: window_1, subscription: subscription };
	                this.contexts.push(context);
	                var innerSubscription = subscribeToResult_1.subscribeToResult(this, closingNotifier, context);
	                if (innerSubscription.closed) {
	                    this.closeWindow(this.contexts.length - 1);
	                }
	                else {
	                    innerSubscription.context = context;
	                    subscription.add(innerSubscription);
	                }
	                this.destination.next(window_1);
	            }
	        }
	        else {
	            this.closeWindow(this.contexts.indexOf(outerValue));
	        }
	    };
	    WindowToggleSubscriber.prototype.notifyError = function (err) {
	        this.error(err);
	    };
	    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
	        if (inner !== this.openSubscription) {
	            this.closeWindow(this.contexts.indexOf(inner.context));
	        }
	    };
	    WindowToggleSubscriber.prototype.closeWindow = function (index) {
	        if (index === -1) {
	            return;
	        }
	        var contexts = this.contexts;
	        var context = contexts[index];
	        var window = context.window, subscription = context.subscription;
	        contexts.splice(index, 1);
	        window.complete();
	        subscription.unsubscribe();
	    };
	    return WindowToggleSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var tryCatch_1 = __webpack_require__(9);
	var errorObject_1 = __webpack_require__(7);
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/**
	 * Branch out the source Observable values as a nested Observable using a
	 * factory function of closing Observables to determine when to start a new
	 * window.
	 *
	 * <span class="informal">It's like {@link bufferWhen}, but emits a nested
	 * Observable instead of an array.</span>
	 *
	 * <img src="./img/windowWhen.png" width="100%">
	 *
	 * Returns an Observable that emits windows of items it collects from the source
	 * Observable. The output Observable emits connected, non-overlapping windows.
	 * It emits the current window and opens a new one whenever the Observable
	 * produced by the specified `closingSelector` function emits an item. The first
	 * window is opened immediately when subscribing to the output Observable.
	 *
	 * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var result = clicks
	 *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))
	 *   .map(win => win.take(2)) // each window has at most 2 emissions
	 *   .mergeAll(); // flatten the Observable-of-Observables
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link window}
	 * @see {@link windowCount}
	 * @see {@link windowTime}
	 * @see {@link windowToggle}
	 * @see {@link bufferWhen}
	 *
	 * @param {function(): Observable} closingSelector A function that takes no
	 * arguments and returns an Observable that signals (on either `next` or
	 * `complete`) when to close the previous window and start a new one.
	 * @return {Observable<Observable<T>>} An observable of windows, which in turn
	 * are Observables.
	 * @method windowWhen
	 * @owner Observable
	 */
	function windowWhen(closingSelector) {
	    return this.lift(new WindowOperator(closingSelector));
	}
	exports.windowWhen = windowWhen;
	var WindowOperator = (function () {
	    function WindowOperator(closingSelector) {
	        this.closingSelector = closingSelector;
	    }
	    WindowOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
	    };
	    return WindowOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WindowSubscriber = (function (_super) {
	    __extends(WindowSubscriber, _super);
	    function WindowSubscriber(destination, closingSelector) {
	        _super.call(this, destination);
	        this.destination = destination;
	        this.closingSelector = closingSelector;
	        this.openWindow();
	    }
	    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.openWindow(innerSub);
	    };
	    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
	        this._error(error);
	    };
	    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
	        this.openWindow(innerSub);
	    };
	    WindowSubscriber.prototype._next = function (value) {
	        this.window.next(value);
	    };
	    WindowSubscriber.prototype._error = function (err) {
	        this.window.error(err);
	        this.destination.error(err);
	        this.unsubscribeClosingNotification();
	    };
	    WindowSubscriber.prototype._complete = function () {
	        this.window.complete();
	        this.destination.complete();
	        this.unsubscribeClosingNotification();
	    };
	    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
	        if (this.closingNotification) {
	            this.closingNotification.unsubscribe();
	        }
	    };
	    WindowSubscriber.prototype.openWindow = function (innerSub) {
	        if (innerSub === void 0) { innerSub = null; }
	        if (innerSub) {
	            this.remove(innerSub);
	            innerSub.unsubscribe();
	        }
	        var prevWindow = this.window;
	        if (prevWindow) {
	            prevWindow.complete();
	        }
	        var window = this.window = new Subject_1.Subject();
	        this.destination.next(window);
	        var closingNotifier = tryCatch_1.tryCatch(this.closingSelector)();
	        if (closingNotifier === errorObject_1.errorObject) {
	            var err = errorObject_1.errorObject.e;
	            this.destination.error(err);
	            this.window.error(err);
	        }
	        else {
	            this.add(this.closingNotification = subscribeToResult_1.subscribeToResult(this, closingNotifier));
	        }
	    };
	    return WindowSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OuterSubscriber_1 = __webpack_require__(3);
	var subscribeToResult_1 = __webpack_require__(4);
	/* tslint:enable:max-line-length */
	/**
	 * Combines the source Observable with other Observables to create an Observable
	 * whose values are calculated from the latest values of each, only when the
	 * source emits.
	 *
	 * <span class="informal">Whenever the source Observable emits a value, it
	 * computes a formula using that value plus the latest values from other input
	 * Observables, then emits the output of that formula.</span>
	 *
	 * <img src="./img/withLatestFrom.png" width="100%">
	 *
	 * `withLatestFrom` combines each value from the source Observable (the
	 * instance) with the latest values from the other input Observables only when
	 * the source emits a value, optionally using a `project` function to determine
	 * the value to be emitted on the output Observable. All input Observables must
	 * emit at least one value before the output Observable will emit a value.
	 *
	 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
	 * var clicks = Rx.Observable.fromEvent(document, 'click');
	 * var timer = Rx.Observable.interval(1000);
	 * var result = clicks.withLatestFrom(timer);
	 * result.subscribe(x => console.log(x));
	 *
	 * @see {@link combineLatest}
	 *
	 * @param {ObservableInput} other An input Observable to combine with the source
	 * Observable. More than one input Observables may be given as argument.
	 * @param {Function} [project] Projection function for combining values
	 * together. Receives all values in order of the Observables passed, where the
	 * first parameter is a value from the source Observable. (e.g.
	 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
	 * passed, arrays will be emitted on the output Observable.
	 * @return {Observable} An Observable of projected values from the most recent
	 * values from each input Observable, or an array of the most recent values from
	 * each input Observable.
	 * @method withLatestFrom
	 * @owner Observable
	 */
	function withLatestFrom() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i - 0] = arguments[_i];
	    }
	    var project;
	    if (typeof args[args.length - 1] === 'function') {
	        project = args.pop();
	    }
	    var observables = args;
	    return this.lift(new WithLatestFromOperator(observables, project));
	}
	exports.withLatestFrom = withLatestFrom;
	var WithLatestFromOperator = (function () {
	    function WithLatestFromOperator(observables, project) {
	        this.observables = observables;
	        this.project = project;
	    }
	    WithLatestFromOperator.prototype.call = function (subscriber, source) {
	        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
	    };
	    return WithLatestFromOperator;
	}());
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var WithLatestFromSubscriber = (function (_super) {
	    __extends(WithLatestFromSubscriber, _super);
	    function WithLatestFromSubscriber(destination, observables, project) {
	        _super.call(this, destination);
	        this.observables = observables;
	        this.project = project;
	        this.toRespond = [];
	        var len = observables.length;
	        this.values = new Array(len);
	        for (var i = 0; i < len; i++) {
	            this.toRespond.push(i);
	        }
	        for (var i = 0; i < len; i++) {
	            var observable = observables[i];
	            this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
	        }
	    }
	    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
	        this.values[outerIndex] = innerValue;
	        var toRespond = this.toRespond;
	        if (toRespond.length > 0) {
	            var found = toRespond.indexOf(outerIndex);
	            if (found !== -1) {
	                toRespond.splice(found, 1);
	            }
	        }
	    };
	    WithLatestFromSubscriber.prototype.notifyComplete = function () {
	        // noop
	    };
	    WithLatestFromSubscriber.prototype._next = function (value) {
	        if (this.toRespond.length === 0) {
	            var args = [value].concat(this.values);
	            if (this.project) {
	                this._tryProject(args);
	            }
	            else {
	                this.destination.next(args);
	            }
	        }
	    };
	    WithLatestFromSubscriber.prototype._tryProject = function (args) {
	        var result;
	        try {
	            result = this.project.apply(this, args);
	        }
	        catch (err) {
	            this.destination.error(err);
	            return;
	        }
	        this.destination.next(result);
	    };
	    return WithLatestFromSubscriber;
	}(OuterSubscriber_1.OuterSubscriber));


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var zip_1 = __webpack_require__(37);
	/**
	 * @param project
	 * @return {Observable<R>|WebSocketSubject<T>|Observable<T>}
	 * @method zipAll
	 * @owner Observable
	 */
	function zipAll(project) {
	    return this.lift(new zip_1.ZipOperator(project));
	}
	exports.zipAll = zipAll;


/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subscription_1 = __webpack_require__(5);
	/**
	 * A unit of work to be executed in a {@link Scheduler}. An action is typically
	 * created from within a Scheduler and an RxJS user does not need to concern
	 * themselves about creating and manipulating an Action.
	 *
	 * ```ts
	 * class Action<T> extends Subscription {
	 *   new (scheduler: Scheduler, work: (state?: T) => void);
	 *   schedule(state?: T, delay: number = 0): Subscription;
	 * }
	 * ```
	 *
	 * @class Action<T>
	 */
	var Action = (function (_super) {
	    __extends(Action, _super);
	    function Action(scheduler, work) {
	        _super.call(this);
	    }
	    /**
	     * Schedules this action on its parent Scheduler for execution. May be passed
	     * some context object, `state`. May happen at some point in the future,
	     * according to the `delay` parameter, if specified.
	     * @param {T} [state] Some contextual data that the `work` function uses when
	     * called by the Scheduler.
	     * @param {number} [delay] Time to wait before executing the work, where the
	     * time unit is implicit and defined by the Scheduler.
	     * @return {void}
	     */
	    Action.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        return this;
	    };
	    return Action;
	}(Subscription_1.Subscription));
	exports.Action = Action;


/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsyncAction_1 = __webpack_require__(17);
	var AnimationFrame_1 = __webpack_require__(336);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AnimationFrameAction = (function (_super) {
	    __extends(AnimationFrameAction, _super);
	    function AnimationFrameAction(scheduler, work) {
	        _super.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	    }
	    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If delay is greater than 0, request as an async action.
	        if (delay !== null && delay > 0) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        // Push the action to the end of the scheduler queue.
	        scheduler.actions.push(this);
	        // If an animation frame has already been requested, don't request another
	        // one. If an animation frame hasn't been requested yet, request one. Return
	        // the current animation frame request id.
	        return scheduler.scheduled || (scheduler.scheduled = AnimationFrame_1.AnimationFrame.requestAnimationFrame(scheduler.flush.bind(scheduler, null)));
	    };
	    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If delay exists and is greater than 0, or if the delay is null (the
	        // action wasn't rescheduled) but was originally scheduled as an async
	        // action, then recycle as an async action.
	        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
	            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
	        }
	        // If the scheduler queue is empty, cancel the requested animation frame and
	        // set the scheduled flag to undefined so the next AnimationFrameAction will
	        // request its own.
	        if (scheduler.actions.length === 0) {
	            AnimationFrame_1.AnimationFrame.cancelAnimationFrame(id);
	            scheduler.scheduled = undefined;
	        }
	        // Return undefined so the action knows to request a new async id if it's rescheduled.
	        return undefined;
	    };
	    return AnimationFrameAction;
	}(AsyncAction_1.AsyncAction));
	exports.AnimationFrameAction = AnimationFrameAction;


/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsyncScheduler_1 = __webpack_require__(18);
	var AnimationFrameScheduler = (function (_super) {
	    __extends(AnimationFrameScheduler, _super);
	    function AnimationFrameScheduler() {
	        _super.apply(this, arguments);
	    }
	    AnimationFrameScheduler.prototype.flush = function (action) {
	        this.active = true;
	        this.scheduled = undefined;
	        var actions = this.actions;
	        var error;
	        var index = -1;
	        var count = actions.length;
	        action = action || actions.shift();
	        do {
	            if (error = action.execute(action.state, action.delay)) {
	                break;
	            }
	        } while (++index < count && (action = actions.shift()));
	        this.active = false;
	        if (error) {
	            while (++index < count && (action = actions.shift())) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AnimationFrameScheduler;
	}(AsyncScheduler_1.AsyncScheduler));
	exports.AnimationFrameScheduler = AnimationFrameScheduler;


/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Immediate_1 = __webpack_require__(338);
	var AsyncAction_1 = __webpack_require__(17);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var AsapAction = (function (_super) {
	    __extends(AsapAction, _super);
	    function AsapAction(scheduler, work) {
	        _super.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	    }
	    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If delay is greater than 0, request as an async action.
	        if (delay !== null && delay > 0) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        // Push the action to the end of the scheduler queue.
	        scheduler.actions.push(this);
	        // If a microtask has already been scheduled, don't schedule another
	        // one. If a microtask hasn't been scheduled yet, schedule one now. Return
	        // the current scheduled microtask id.
	        return scheduler.scheduled || (scheduler.scheduled = Immediate_1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
	    };
	    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If delay exists and is greater than 0, or if the delay is null (the
	        // action wasn't rescheduled) but was originally scheduled as an async
	        // action, then recycle as an async action.
	        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
	            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
	        }
	        // If the scheduler queue is empty, cancel the requested microtask and
	        // set the scheduled flag to undefined so the next AsapAction will schedule
	        // its own.
	        if (scheduler.actions.length === 0) {
	            Immediate_1.Immediate.clearImmediate(id);
	            scheduler.scheduled = undefined;
	        }
	        // Return undefined so the action knows to request a new async id if it's rescheduled.
	        return undefined;
	    };
	    return AsapAction;
	}(AsyncAction_1.AsyncAction));
	exports.AsapAction = AsapAction;


/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsyncScheduler_1 = __webpack_require__(18);
	var AsapScheduler = (function (_super) {
	    __extends(AsapScheduler, _super);
	    function AsapScheduler() {
	        _super.apply(this, arguments);
	    }
	    AsapScheduler.prototype.flush = function (action) {
	        this.active = true;
	        this.scheduled = undefined;
	        var actions = this.actions;
	        var error;
	        var index = -1;
	        var count = actions.length;
	        action = action || actions.shift();
	        do {
	            if (error = action.execute(action.state, action.delay)) {
	                break;
	            }
	        } while (++index < count && (action = actions.shift()));
	        this.active = false;
	        if (error) {
	            while (++index < count && (action = actions.shift())) {
	                action.unsubscribe();
	            }
	            throw error;
	        }
	    };
	    return AsapScheduler;
	}(AsyncScheduler_1.AsyncScheduler));
	exports.AsapScheduler = AsapScheduler;


/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsyncAction_1 = __webpack_require__(17);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var QueueAction = (function (_super) {
	    __extends(QueueAction, _super);
	    function QueueAction(scheduler, work) {
	        _super.call(this, scheduler, work);
	        this.scheduler = scheduler;
	        this.work = work;
	    }
	    QueueAction.prototype.schedule = function (state, delay) {
	        if (delay === void 0) { delay = 0; }
	        if (delay > 0) {
	            return _super.prototype.schedule.call(this, state, delay);
	        }
	        this.delay = delay;
	        this.state = state;
	        this.scheduler.flush(this);
	        return this;
	    };
	    QueueAction.prototype.execute = function (state, delay) {
	        return (delay > 0 || this.closed) ?
	            _super.prototype.execute.call(this, state, delay) :
	            this._execute(state, delay);
	    };
	    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
	        if (delay === void 0) { delay = 0; }
	        // If delay exists and is greater than 0, or if the delay is null (the
	        // action wasn't rescheduled) but was originally scheduled as an async
	        // action, then recycle as an async action.
	        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
	            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
	        }
	        // Otherwise flush the scheduler starting with this action.
	        return scheduler.flush(this);
	    };
	    return QueueAction;
	}(AsyncAction_1.AsyncAction));
	exports.QueueAction = QueueAction;


/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AsyncScheduler_1 = __webpack_require__(18);
	var QueueScheduler = (function (_super) {
	    __extends(QueueScheduler, _super);
	    function QueueScheduler() {
	        _super.apply(this, arguments);
	    }
	    return QueueScheduler;
	}(AsyncScheduler_1.AsyncScheduler));
	exports.QueueScheduler = QueueScheduler;


/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AnimationFrameAction_1 = __webpack_require__(326);
	var AnimationFrameScheduler_1 = __webpack_require__(327);
	/**
	 *
	 * Animation Frame Scheduler
	 *
	 * <span class="informal">Perform task when `window.requestAnimationFrame` would fire</span>
	 *
	 * When `animationFrame` scheduler is used with delay, it will fall back to {@link async} scheduler
	 * behaviour.
	 *
	 * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.
	 * It makes sure scheduled task will happen just before next browser content repaint,
	 * thus performing animations as efficiently as possible.
	 *
	 * @example <caption>Schedule div height animation</caption>
	 * const div = document.querySelector('.some-div');
	 *
	 * Rx.Scheduler.schedule(function(height) {
	 *   div.style.height = height + "px";
	 *
	 *   this.schedule(height + 1);  // `this` references currently executing Action,
	 *                               // which we reschedule with new state
	 * }, 0, 0);
	 *
	 * // You will see .some-div element growing in height
	 *
	 *
	 * @static true
	 * @name animationFrame
	 * @owner Scheduler
	 */
	exports.animationFrame = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);


/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	var Subscription_1 = __webpack_require__(5);
	var SubscriptionLoggable_1 = __webpack_require__(59);
	var applyMixins_1 = __webpack_require__(62);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var ColdObservable = (function (_super) {
	    __extends(ColdObservable, _super);
	    function ColdObservable(messages, scheduler) {
	        _super.call(this, function (subscriber) {
	            var observable = this;
	            var index = observable.logSubscribedFrame();
	            subscriber.add(new Subscription_1.Subscription(function () {
	                observable.logUnsubscribedFrame(index);
	            }));
	            observable.scheduleMessages(subscriber);
	            return subscriber;
	        });
	        this.messages = messages;
	        this.subscriptions = [];
	        this.scheduler = scheduler;
	    }
	    ColdObservable.prototype.scheduleMessages = function (subscriber) {
	        var messagesLength = this.messages.length;
	        for (var i = 0; i < messagesLength; i++) {
	            var message = this.messages[i];
	            subscriber.add(this.scheduler.schedule(function (_a) {
	                var message = _a.message, subscriber = _a.subscriber;
	                message.notification.observe(subscriber);
	            }, message.frame, { message: message, subscriber: subscriber }));
	        }
	    };
	    return ColdObservable;
	}(Observable_1.Observable));
	exports.ColdObservable = ColdObservable;
	applyMixins_1.applyMixins(ColdObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);


/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Subject_1 = __webpack_require__(6);
	var Subscription_1 = __webpack_require__(5);
	var SubscriptionLoggable_1 = __webpack_require__(59);
	var applyMixins_1 = __webpack_require__(62);
	/**
	 * We need this JSDoc comment for affecting ESDoc.
	 * @ignore
	 * @extends {Ignored}
	 */
	var HotObservable = (function (_super) {
	    __extends(HotObservable, _super);
	    function HotObservable(messages, scheduler) {
	        _super.call(this);
	        this.messages = messages;
	        this.subscriptions = [];
	        this.scheduler = scheduler;
	    }
	    HotObservable.prototype._subscribe = function (subscriber) {
	        var subject = this;
	        var index = subject.logSubscribedFrame();
	        subscriber.add(new Subscription_1.Subscription(function () {
	            subject.logUnsubscribedFrame(index);
	        }));
	        return _super.prototype._subscribe.call(this, subscriber);
	    };
	    HotObservable.prototype.setup = function () {
	        var subject = this;
	        var messagesLength = subject.messages.length;
	        /* tslint:disable:no-var-keyword */
	        for (var i = 0; i < messagesLength; i++) {
	            (function () {
	                var message = subject.messages[i];
	                /* tslint:enable */
	                subject.scheduler.schedule(function () { message.notification.observe(subject); }, message.frame);
	            })();
	        }
	    };
	    return HotObservable;
	}(Subject_1.Subject));
	exports.HotObservable = HotObservable;
	applyMixins_1.applyMixins(HotObservable, [SubscriptionLoggable_1.SubscriptionLoggable]);


/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Observable_1 = __webpack_require__(1);
	var Notification_1 = __webpack_require__(16);
	var ColdObservable_1 = __webpack_require__(333);
	var HotObservable_1 = __webpack_require__(334);
	var SubscriptionLog_1 = __webpack_require__(58);
	var VirtualTimeScheduler_1 = __webpack_require__(55);
	var defaultMaxFrame = 750;
	var TestScheduler = (function (_super) {
	    __extends(TestScheduler, _super);
	    function TestScheduler(assertDeepEqual) {
	        _super.call(this, VirtualTimeScheduler_1.VirtualAction, defaultMaxFrame);
	        this.assertDeepEqual = assertDeepEqual;
	        this.hotObservables = [];
	        this.coldObservables = [];
	        this.flushTests = [];
	    }
	    TestScheduler.prototype.createTime = function (marbles) {
	        var indexOf = marbles.indexOf('|');
	        if (indexOf === -1) {
	            throw new Error('marble diagram for time should have a completion marker "|"');
	        }
	        return indexOf * TestScheduler.frameTimeFactor;
	    };
	    TestScheduler.prototype.createColdObservable = function (marbles, values, error) {
	        if (marbles.indexOf('^') !== -1) {
	            throw new Error('cold observable cannot have subscription offset "^"');
	        }
	        if (marbles.indexOf('!') !== -1) {
	            throw new Error('cold observable cannot have unsubscription marker "!"');
	        }
	        var messages = TestScheduler.parseMarbles(marbles, values, error);
	        var cold = new ColdObservable_1.ColdObservable(messages, this);
	        this.coldObservables.push(cold);
	        return cold;
	    };
	    TestScheduler.prototype.createHotObservable = function (marbles, values, error) {
	        if (marbles.indexOf('!') !== -1) {
	            throw new Error('hot observable cannot have unsubscription marker "!"');
	        }
	        var messages = TestScheduler.parseMarbles(marbles, values, error);
	        var subject = new HotObservable_1.HotObservable(messages, this);
	        this.hotObservables.push(subject);
	        return subject;
	    };
	    TestScheduler.prototype.materializeInnerObservable = function (observable, outerFrame) {
	        var _this = this;
	        var messages = [];
	        observable.subscribe(function (value) {
	            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createNext(value) });
	        }, function (err) {
	            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createError(err) });
	        }, function () {
	            messages.push({ frame: _this.frame - outerFrame, notification: Notification_1.Notification.createComplete() });
	        });
	        return messages;
	    };
	    TestScheduler.prototype.expectObservable = function (observable, unsubscriptionMarbles) {
	        var _this = this;
	        if (unsubscriptionMarbles === void 0) { unsubscriptionMarbles = null; }
	        var actual = [];
	        var flushTest = { actual: actual, ready: false };
	        var unsubscriptionFrame = TestScheduler
	            .parseMarblesAsSubscriptions(unsubscriptionMarbles).unsubscribedFrame;
	        var subscription;
	        this.schedule(function () {
	            subscription = observable.subscribe(function (x) {
	                var value = x;
	                // Support Observable-of-Observables
	                if (x instanceof Observable_1.Observable) {
	                    value = _this.materializeInnerObservable(value, _this.frame);
	                }
	                actual.push({ frame: _this.frame, notification: Notification_1.Notification.createNext(value) });
	            }, function (err) {
	                actual.push({ frame: _this.frame, notification: Notification_1.Notification.createError(err) });
	            }, function () {
	                actual.push({ frame: _this.frame, notification: Notification_1.Notification.createComplete() });
	            });
	        }, 0);
	        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
	            this.schedule(function () { return subscription.unsubscribe(); }, unsubscriptionFrame);
	        }
	        this.flushTests.push(flushTest);
	        return {
	            toBe: function (marbles, values, errorValue) {
	                flushTest.ready = true;
	                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true);
	            }
	        };
	    };
	    TestScheduler.prototype.expectSubscriptions = function (actualSubscriptionLogs) {
	        var flushTest = { actual: actualSubscriptionLogs, ready: false };
	        this.flushTests.push(flushTest);
	        return {
	            toBe: function (marbles) {
	                var marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;
	                flushTest.ready = true;
	                flushTest.expected = marblesArray.map(function (marbles) {
	                    return TestScheduler.parseMarblesAsSubscriptions(marbles);
	                });
	            }
	        };
	    };
	    TestScheduler.prototype.flush = function () {
	        var hotObservables = this.hotObservables;
	        while (hotObservables.length > 0) {
	            hotObservables.shift().setup();
	        }
	        _super.prototype.flush.call(this);
	        var readyFlushTests = this.flushTests.filter(function (test) { return test.ready; });
	        while (readyFlushTests.length > 0) {
	            var test = readyFlushTests.shift();
	            this.assertDeepEqual(test.actual, test.expected);
	        }
	    };
	    TestScheduler.parseMarblesAsSubscriptions = function (marbles) {
	        if (typeof marbles !== 'string') {
	            return new SubscriptionLog_1.SubscriptionLog(Number.POSITIVE_INFINITY);
	        }
	        var len = marbles.length;
	        var groupStart = -1;
	        var subscriptionFrame = Number.POSITIVE_INFINITY;
	        var unsubscriptionFrame = Number.POSITIVE_INFINITY;
	        for (var i = 0; i < len; i++) {
	            var frame = i * this.frameTimeFactor;
	            var c = marbles[i];
	            switch (c) {
	                case '-':
	                case ' ':
	                    break;
	                case '(':
	                    groupStart = frame;
	                    break;
	                case ')':
	                    groupStart = -1;
	                    break;
	                case '^':
	                    if (subscriptionFrame !== Number.POSITIVE_INFINITY) {
	                        throw new Error('found a second subscription point \'^\' in a ' +
	                            'subscription marble diagram. There can only be one.');
	                    }
	                    subscriptionFrame = groupStart > -1 ? groupStart : frame;
	                    break;
	                case '!':
	                    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {
	                        throw new Error('found a second subscription point \'^\' in a ' +
	                            'subscription marble diagram. There can only be one.');
	                    }
	                    unsubscriptionFrame = groupStart > -1 ? groupStart : frame;
	                    break;
	                default:
	                    throw new Error('there can only be \'^\' and \'!\' markers in a ' +
	                        'subscription marble diagram. Found instead \'' + c + '\'.');
	            }
	        }
	        if (unsubscriptionFrame < 0) {
	            return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame);
	        }
	        else {
	            return new SubscriptionLog_1.SubscriptionLog(subscriptionFrame, unsubscriptionFrame);
	        }
	    };
	    TestScheduler.parseMarbles = function (marbles, values, errorValue, materializeInnerObservables) {
	        if (materializeInnerObservables === void 0) { materializeInnerObservables = false; }
	        if (marbles.indexOf('!') !== -1) {
	            throw new Error('conventional marble diagrams cannot have the ' +
	                'unsubscription marker "!"');
	        }
	        var len = marbles.length;
	        var testMessages = [];
	        var subIndex = marbles.indexOf('^');
	        var frameOffset = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);
	        var getValue = typeof values !== 'object' ?
	            function (x) { return x; } :
	            function (x) {
	                // Support Observable-of-Observables
	                if (materializeInnerObservables && values[x] instanceof ColdObservable_1.ColdObservable) {
	                    return values[x].messages;
	                }
	                return values[x];
	            };
	        var groupStart = -1;
	        for (var i = 0; i < len; i++) {
	            var frame = i * this.frameTimeFactor + frameOffset;
	            var notification = void 0;
	            var c = marbles[i];
	            switch (c) {
	                case '-':
	                case ' ':
	                    break;
	                case '(':
	                    groupStart = frame;
	                    break;
	                case ')':
	                    groupStart = -1;
	                    break;
	                case '|':
	                    notification = Notification_1.Notification.createComplete();
	                    break;
	                case '^':
	                    break;
	                case '#':
	                    notification = Notification_1.Notification.createError(errorValue || 'error');
	                    break;
	                default:
	                    notification = Notification_1.Notification.createNext(getValue(c));
	                    break;
	            }
	            if (notification) {
	                testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification: notification });
	            }
	        }
	        return testMessages;
	    };
	    return TestScheduler;
	}(VirtualTimeScheduler_1.VirtualTimeScheduler));
	exports.TestScheduler = TestScheduler;


/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(8);
	var RequestAnimationFrameDefinition = (function () {
	    function RequestAnimationFrameDefinition(root) {
	        if (root.requestAnimationFrame) {
	            this.cancelAnimationFrame = root.cancelAnimationFrame.bind(root);
	            this.requestAnimationFrame = root.requestAnimationFrame.bind(root);
	        }
	        else if (root.mozRequestAnimationFrame) {
	            this.cancelAnimationFrame = root.mozCancelAnimationFrame.bind(root);
	            this.requestAnimationFrame = root.mozRequestAnimationFrame.bind(root);
	        }
	        else if (root.webkitRequestAnimationFrame) {
	            this.cancelAnimationFrame = root.webkitCancelAnimationFrame.bind(root);
	            this.requestAnimationFrame = root.webkitRequestAnimationFrame.bind(root);
	        }
	        else if (root.msRequestAnimationFrame) {
	            this.cancelAnimationFrame = root.msCancelAnimationFrame.bind(root);
	            this.requestAnimationFrame = root.msRequestAnimationFrame.bind(root);
	        }
	        else if (root.oRequestAnimationFrame) {
	            this.cancelAnimationFrame = root.oCancelAnimationFrame.bind(root);
	            this.requestAnimationFrame = root.oRequestAnimationFrame.bind(root);
	        }
	        else {
	            this.cancelAnimationFrame = root.clearTimeout.bind(root);
	            this.requestAnimationFrame = function (cb) { return root.setTimeout(cb, 1000 / 60); };
	        }
	    }
	    return RequestAnimationFrameDefinition;
	}());
	exports.RequestAnimationFrameDefinition = RequestAnimationFrameDefinition;
	exports.AnimationFrame = new RequestAnimationFrameDefinition(root_1.root);


/***/ },
/* 337 */
/***/ function(module, exports) {

	"use strict";
	var FastMap = (function () {
	    function FastMap() {
	        this.values = {};
	    }
	    FastMap.prototype.delete = function (key) {
	        this.values[key] = null;
	        return true;
	    };
	    FastMap.prototype.set = function (key, value) {
	        this.values[key] = value;
	        return this;
	    };
	    FastMap.prototype.get = function (key) {
	        return this.values[key];
	    };
	    FastMap.prototype.forEach = function (cb, thisArg) {
	        var values = this.values;
	        for (var key in values) {
	            if (values.hasOwnProperty(key) && values[key] !== null) {
	                cb.call(thisArg, values[key], key);
	            }
	        }
	    };
	    FastMap.prototype.clear = function () {
	        this.values = {};
	    };
	    return FastMap;
	}());
	exports.FastMap = FastMap;


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(clearImmediate, setImmediate) {/**
	Some credit for this helper goes to http://github.com/YuzuJS/setImmediate
	*/
	"use strict";
	var root_1 = __webpack_require__(8);
	var ImmediateDefinition = (function () {
	    function ImmediateDefinition(root) {
	        this.root = root;
	        if (root.setImmediate && typeof root.setImmediate === 'function') {
	            this.setImmediate = root.setImmediate.bind(root);
	            this.clearImmediate = root.clearImmediate.bind(root);
	        }
	        else {
	            this.nextHandle = 1;
	            this.tasksByHandle = {};
	            this.currentlyRunningATask = false;
	            // Don't get fooled by e.g. browserify environments.
	            if (this.canUseProcessNextTick()) {
	                // For Node.js before 0.9
	                this.setImmediate = this.createProcessNextTickSetImmediate();
	            }
	            else if (this.canUsePostMessage()) {
	                // For non-IE10 modern browsers
	                this.setImmediate = this.createPostMessageSetImmediate();
	            }
	            else if (this.canUseMessageChannel()) {
	                // For web workers, where supported
	                this.setImmediate = this.createMessageChannelSetImmediate();
	            }
	            else if (this.canUseReadyStateChange()) {
	                // For IE 6–8
	                this.setImmediate = this.createReadyStateChangeSetImmediate();
	            }
	            else {
	                // For older browsers
	                this.setImmediate = this.createSetTimeoutSetImmediate();
	            }
	            var ci = function clearImmediate(handle) {
	                delete clearImmediate.instance.tasksByHandle[handle];
	            };
	            ci.instance = this;
	            this.clearImmediate = ci;
	        }
	    }
	    ImmediateDefinition.prototype.identify = function (o) {
	        return this.root.Object.prototype.toString.call(o);
	    };
	    ImmediateDefinition.prototype.canUseProcessNextTick = function () {
	        return this.identify(this.root.process) === '[object process]';
	    };
	    ImmediateDefinition.prototype.canUseMessageChannel = function () {
	        return Boolean(this.root.MessageChannel);
	    };
	    ImmediateDefinition.prototype.canUseReadyStateChange = function () {
	        var document = this.root.document;
	        return Boolean(document && 'onreadystatechange' in document.createElement('script'));
	    };
	    ImmediateDefinition.prototype.canUsePostMessage = function () {
	        var root = this.root;
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `root.postMessage` means something completely different and can't be used for this purpose.
	        if (root.postMessage && !root.importScripts) {
	            var postMessageIsAsynchronous_1 = true;
	            var oldOnMessage = root.onmessage;
	            root.onmessage = function () {
	                postMessageIsAsynchronous_1 = false;
	            };
	            root.postMessage('', '*');
	            root.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous_1;
	        }
	        return false;
	    };
	    // This function accepts the same arguments as setImmediate, but
	    // returns a function that requires no arguments.
	    ImmediateDefinition.prototype.partiallyApplied = function (handler) {
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        var fn = function result() {
	            var _a = result, handler = _a.handler, args = _a.args;
	            if (typeof handler === 'function') {
	                handler.apply(undefined, args);
	            }
	            else {
	                (new Function('' + handler))();
	            }
	        };
	        fn.handler = handler;
	        fn.args = args;
	        return fn;
	    };
	    ImmediateDefinition.prototype.addFromSetImmediateArguments = function (args) {
	        this.tasksByHandle[this.nextHandle] = this.partiallyApplied.apply(undefined, args);
	        return this.nextHandle++;
	    };
	    ImmediateDefinition.prototype.createProcessNextTickSetImmediate = function () {
	        var fn = function setImmediate() {
	            var instance = setImmediate.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            instance.root.process.nextTick(instance.partiallyApplied(instance.runIfPresent, handle));
	            return handle;
	        };
	        fn.instance = this;
	        return fn;
	    };
	    ImmediateDefinition.prototype.createPostMessageSetImmediate = function () {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	        var root = this.root;
	        var messagePrefix = 'setImmediate$' + root.Math.random() + '$';
	        var onGlobalMessage = function globalMessageHandler(event) {
	            var instance = globalMessageHandler.instance;
	            if (event.source === root &&
	                typeof event.data === 'string' &&
	                event.data.indexOf(messagePrefix) === 0) {
	                instance.runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	        onGlobalMessage.instance = this;
	        root.addEventListener('message', onGlobalMessage, false);
	        var fn = function setImmediate() {
	            var _a = setImmediate, messagePrefix = _a.messagePrefix, instance = _a.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            instance.root.postMessage(messagePrefix + handle, '*');
	            return handle;
	        };
	        fn.instance = this;
	        fn.messagePrefix = messagePrefix;
	        return fn;
	    };
	    ImmediateDefinition.prototype.runIfPresent = function (handle) {
	        // From the spec: 'Wait until any invocations of this algorithm started before this one have completed.'
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (this.currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // 'too much recursion' error.
	            this.root.setTimeout(this.partiallyApplied(this.runIfPresent, handle), 0);
	        }
	        else {
	            var task = this.tasksByHandle[handle];
	            if (task) {
	                this.currentlyRunningATask = true;
	                try {
	                    task();
	                }
	                finally {
	                    this.clearImmediate(handle);
	                    this.currentlyRunningATask = false;
	                }
	            }
	        }
	    };
	    ImmediateDefinition.prototype.createMessageChannelSetImmediate = function () {
	        var _this = this;
	        var channel = new this.root.MessageChannel();
	        channel.port1.onmessage = function (event) {
	            var handle = event.data;
	            _this.runIfPresent(handle);
	        };
	        var fn = function setImmediate() {
	            var _a = setImmediate, channel = _a.channel, instance = _a.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            channel.port2.postMessage(handle);
	            return handle;
	        };
	        fn.channel = channel;
	        fn.instance = this;
	        return fn;
	    };
	    ImmediateDefinition.prototype.createReadyStateChangeSetImmediate = function () {
	        var fn = function setImmediate() {
	            var instance = setImmediate.instance;
	            var root = instance.root;
	            var doc = root.document;
	            var html = doc.documentElement;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement('script');
	            script.onreadystatechange = function () {
	                instance.runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	            return handle;
	        };
	        fn.instance = this;
	        return fn;
	    };
	    ImmediateDefinition.prototype.createSetTimeoutSetImmediate = function () {
	        var fn = function setImmediate() {
	            var instance = setImmediate.instance;
	            var handle = instance.addFromSetImmediateArguments(arguments);
	            instance.root.setTimeout(instance.partiallyApplied(instance.runIfPresent, handle), 0);
	            return handle;
	        };
	        fn.instance = this;
	        return fn;
	    };
	    return ImmediateDefinition;
	}());
	exports.ImmediateDefinition = ImmediateDefinition;
	exports.Immediate = new ImmediateDefinition(root_1.root);
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(67).clearImmediate, __webpack_require__(67).setImmediate))

/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(8);
	var MapPolyfill_1 = __webpack_require__(340);
	exports.Map = root_1.root.Map || (function () { return MapPolyfill_1.MapPolyfill; })();


/***/ },
/* 340 */
/***/ function(module, exports) {

	"use strict";
	var MapPolyfill = (function () {
	    function MapPolyfill() {
	        this.size = 0;
	        this._values = [];
	        this._keys = [];
	    }
	    MapPolyfill.prototype.get = function (key) {
	        var i = this._keys.indexOf(key);
	        return i === -1 ? undefined : this._values[i];
	    };
	    MapPolyfill.prototype.set = function (key, value) {
	        var i = this._keys.indexOf(key);
	        if (i === -1) {
	            this._keys.push(key);
	            this._values.push(value);
	            this.size++;
	        }
	        else {
	            this._values[i] = value;
	        }
	        return this;
	    };
	    MapPolyfill.prototype.delete = function (key) {
	        var i = this._keys.indexOf(key);
	        if (i === -1) {
	            return false;
	        }
	        this._values.splice(i, 1);
	        this._keys.splice(i, 1);
	        this.size--;
	        return true;
	    };
	    MapPolyfill.prototype.clear = function () {
	        this._keys.length = 0;
	        this._values.length = 0;
	        this.size = 0;
	    };
	    MapPolyfill.prototype.forEach = function (cb, thisArg) {
	        for (var i = 0; i < this.size; i++) {
	            cb.call(thisArg, this._values[i], this._keys[i]);
	        }
	    };
	    return MapPolyfill;
	}());
	exports.MapPolyfill = MapPolyfill;


/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(8);
	function minimalSetImpl() {
	    // THIS IS NOT a full impl of Set, this is just the minimum
	    // bits of functionality we need for this library.
	    return (function () {
	        function MinimalSet() {
	            this._values = [];
	        }
	        MinimalSet.prototype.add = function (value) {
	            if (!this.has(value)) {
	                this._values.push(value);
	            }
	        };
	        MinimalSet.prototype.has = function (value) {
	            return this._values.indexOf(value) !== -1;
	        };
	        Object.defineProperty(MinimalSet.prototype, "size", {
	            get: function () {
	                return this._values.length;
	            },
	            enumerable: true,
	            configurable: true
	        });
	        MinimalSet.prototype.clear = function () {
	            this._values.length = 0;
	        };
	        return MinimalSet;
	    }());
	}
	exports.minimalSetImpl = minimalSetImpl;
	exports.Set = root_1.root.Set || minimalSetImpl();


/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var root_1 = __webpack_require__(8);
	function assignImpl(target) {
	    var sources = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        sources[_i - 1] = arguments[_i];
	    }
	    var len = sources.length;
	    for (var i = 0; i < len; i++) {
	        var source = sources[i];
	        for (var k in source) {
	            if (source.hasOwnProperty(k)) {
	                target[k] = source[k];
	            }
	        }
	    }
	    return target;
	}
	exports.assignImpl = assignImpl;
	;
	function getAssign(root) {
	    return root.Object.assign || assignImpl;
	}
	exports.getAssign = getAssign;
	exports.assign = getAssign(root_1.root);


/***/ },
/* 343 */
/***/ function(module, exports) {

	"use strict";
	function not(pred, thisArg) {
	    function notPred() {
	        return !(notPred.pred.apply(notPred.thisArg, arguments));
	    }
	    notPred.pred = pred;
	    notPred.thisArg = thisArg;
	    return notPred;
	}
	exports.not = not;


/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Subscriber_1 = __webpack_require__(2);
	var rxSubscriber_1 = __webpack_require__(23);
	var Observer_1 = __webpack_require__(39);
	function toSubscriber(nextOrObserver, error, complete) {
	    if (nextOrObserver) {
	        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
	            return nextOrObserver;
	        }
	        if (nextOrObserver[rxSubscriber_1.rxSubscriber]) {
	            return nextOrObserver[rxSubscriber_1.rxSubscriber]();
	        }
	    }
	    if (!nextOrObserver && !error && !complete) {
	        return new Subscriber_1.Subscriber(Observer_1.empty);
	    }
	    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
	}
	exports.toSubscriber = toSubscriber;


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
	    "use strict";
	
	    if (global.setImmediate) {
	        return;
	    }
	
	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var registerImmediate;
	
	    function setImmediate(callback) {
	      // Callback can either be a function or a string
	      if (typeof callback !== "function") {
	        callback = new Function("" + callback);
	      }
	      // Copy function arguments
	      var args = new Array(arguments.length - 1);
	      for (var i = 0; i < args.length; i++) {
	          args[i] = arguments[i + 1];
	      }
	      // Store and register the task
	      var task = { callback: callback, args: args };
	      tasksByHandle[nextHandle] = task;
	      registerImmediate(nextHandle);
	      return nextHandle++;
	    }
	
	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }
	
	    function run(task) {
	        var callback = task.callback;
	        var args = task.args;
	        switch (args.length) {
	        case 0:
	            callback();
	            break;
	        case 1:
	            callback(args[0]);
	            break;
	        case 2:
	            callback(args[0], args[1]);
	            break;
	        case 3:
	            callback(args[0], args[1], args[2]);
	            break;
	        default:
	            callback.apply(undefined, args);
	            break;
	        }
	    }
	
	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(runIfPresent, 0, handle);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    run(task);
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }
	
	    function installNextTickImplementation() {
	        registerImmediate = function(handle) {
	            process.nextTick(function () { runIfPresent(handle); });
	        };
	    }
	
	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function() {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }
	
	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	
	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function(event) {
	            if (event.source === global &&
	                typeof event.data === "string" &&
	                event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };
	
	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }
	
	        registerImmediate = function(handle) {
	            global.postMessage(messagePrefix + handle, "*");
	        };
	    }
	
	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function(event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };
	
	        registerImmediate = function(handle) {
	            channel.port2.postMessage(handle);
	        };
	    }
	
	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        registerImmediate = function(handle) {
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	        };
	    }
	
	    function installSetTimeoutImplementation() {
	        registerImmediate = function(handle) {
	            setTimeout(runIfPresent, 0, handle);
	        };
	    }
	
	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
	
	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();
	
	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();
	
	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();
	
	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 6–8
	        installReadyStateChangeImplementation();
	
	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }
	
	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(69)))

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNDc4ZmM2MzQ0OGQwYzA5OWZkNDAiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9PYnNlcnZhYmxlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvU3Vic2NyaWJlci50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL091dGVyU3Vic2NyaWJlci50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9TdWJzY3JpcHRpb24udHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9TdWJqZWN0LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvdXRpbC9lcnJvck9iamVjdC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3V0aWwvcm9vdC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3V0aWwvdHJ5Q2F0Y2gudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9zY2hlZHVsZXIvYXN5bmMudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL0FycmF5T2JzZXJ2YWJsZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3V0aWwvaXNBcnJheS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3V0aWwvaXNTY2hlZHVsZXIudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL0VtcHR5T2JzZXJ2YWJsZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL211bHRpY2FzdC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL05vdGlmaWNhdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3NjaGVkdWxlci9Bc3luY0FjdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3NjaGVkdWxlci9Bc3luY1NjaGVkdWxlci50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3N5bWJvbC9pdGVyYXRvci50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL0FzeW5jU3ViamVjdC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL21lcmdlQWxsLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvc3ltYm9sL29ic2VydmFibGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9zeW1ib2wvcnhTdWJzY3JpYmVyLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvci50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3V0aWwvRW1wdHlFcnJvci50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy91dGlsL2lzRGF0ZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3V0aWwvaXNGdW5jdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3V0aWwvaXNOdW1lcmljLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvUmVwbGF5U3ViamVjdC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29ic2VydmFibGUvU2NhbGFyT2JzZXJ2YWJsZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL2NvbWJpbmVMYXRlc3QudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9jb25jYXQudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9tYXAudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9vYnNlcnZlT24udHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9yZWR1Y2UudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci96aXAudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9CZWhhdmlvclN1YmplY3QudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9PYnNlcnZlci50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL1N1YmplY3RTdWJzY3JpcHRpb24udHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29ic2VydmFibGUvRnJvbU9ic2VydmFibGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL1Byb21pc2VPYnNlcnZhYmxlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9kb20vQWpheE9ic2VydmFibGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9kaXN0aW5jdFVudGlsQ2hhbmdlZC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL2ZpbHRlci50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL2ZpbmQudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9tZXJnZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL21lcmdlTWFwLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3IvbWVyZ2VNYXBUby50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL29uRXJyb3JSZXN1bWVOZXh0LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3IvcmFjZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3RpbWVJbnRlcnZhbC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3RpbWVzdGFtcC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3NjaGVkdWxlci9WaXJ0dWFsVGltZVNjaGVkdWxlci50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3NjaGVkdWxlci9hc2FwLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvc2NoZWR1bGVyL3F1ZXVlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvdGVzdGluZy9TdWJzY3JpcHRpb25Mb2cudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy90ZXN0aW5nL1N1YnNjcmlwdGlvbkxvZ2dhYmxlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvdXRpbC9UaW1lb3V0RXJyb3IudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy91dGlsL1Vuc3Vic2NyaXB0aW9uRXJyb3IudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy91dGlsL2FwcGx5TWl4aW5zLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvdXRpbC9pc0FycmF5TGlrZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3V0aWwvaXNPYmplY3QudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy91dGlsL2lzUHJvbWlzZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3V0aWwvbm9vcC50cyIsIndlYnBhY2s6Ly8vLi9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vY2xpZW50L2xvdHRlcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9Jbm5lclN1YnNjcmliZXIudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9SeC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL1NjaGVkdWxlci50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL2JpbmRDYWxsYmFjay50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL2JpbmROb2RlQ2FsbGJhY2sudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29ic2VydmFibGUvY29uY2F0LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29ic2VydmFibGUvZGVmZXIudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb2JzZXJ2YWJsZS9kb20vYWpheC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL2RvbS93ZWJTb2NrZXQudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb2JzZXJ2YWJsZS9lbXB0eS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL2ZvcmtKb2luLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29ic2VydmFibGUvZnJvbS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL2Zyb21FdmVudC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL2Zyb21FdmVudFBhdHRlcm4udHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb2JzZXJ2YWJsZS9mcm9tUHJvbWlzZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL2dlbmVyYXRlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29ic2VydmFibGUvaWYudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb2JzZXJ2YWJsZS9pbnRlcnZhbC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL21lcmdlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29ic2VydmFibGUvbmV2ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb2JzZXJ2YWJsZS9vZi50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL29uRXJyb3JSZXN1bWVOZXh0LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29ic2VydmFibGUvcGFpcnMudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb2JzZXJ2YWJsZS9yYWNlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29ic2VydmFibGUvcmFuZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb2JzZXJ2YWJsZS90aHJvdy50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL3RpbWVyLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29ic2VydmFibGUvdXNpbmcudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb2JzZXJ2YWJsZS96aXAudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvYXVkaXQudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvYXVkaXRUaW1lLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2J1ZmZlci50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9idWZmZXJDb3VudC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9idWZmZXJUaW1lLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2J1ZmZlclRvZ2dsZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9idWZmZXJXaGVuLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2NhdGNoLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2NvbWJpbmVBbGwudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvY29tYmluZUxhdGVzdC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9jb25jYXQudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvY29uY2F0QWxsLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2NvbmNhdE1hcC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9jb25jYXRNYXBUby50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9jb3VudC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9kZWJvdW5jZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9kZWJvdW5jZVRpbWUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZGVmYXVsdElmRW1wdHkudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZGVsYXkudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZGVsYXlXaGVuLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2RlbWF0ZXJpYWxpemUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZGlzdGluY3QudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZGlzdGluY3RVbnRpbENoYW5nZWQudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZGlzdGluY3RVbnRpbEtleUNoYW5nZWQudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZG8udHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZWxlbWVudEF0LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2V2ZXJ5LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2V4aGF1c3QudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZXhoYXVzdE1hcC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9leHBhbmQudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZmlsdGVyLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2ZpbmFsbHkudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZmluZC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9maW5kSW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZmlyc3QudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZ3JvdXBCeS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9pZ25vcmVFbGVtZW50cy50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9pc0VtcHR5LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2xhc3QudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvbGV0LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL21hcC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9tYXBUby50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9tYXRlcmlhbGl6ZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9tYXgudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvbWVyZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvbWVyZ2VBbGwudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvbWVyZ2VNYXAudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvbWVyZ2VNYXBUby50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9tZXJnZVNjYW4udHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvbWluLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL211bHRpY2FzdC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9vYnNlcnZlT24udHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3Ivb25FcnJvclJlc3VtZU5leHQudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvcGFpcndpc2UudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvcGFydGl0aW9uLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3BsdWNrLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3B1Ymxpc2gudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvcHVibGlzaEJlaGF2aW9yLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3B1Ymxpc2hMYXN0LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3B1Ymxpc2hSZXBsYXkudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvcmFjZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9yZWR1Y2UudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvcmVwZWF0LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3JlcGVhdFdoZW4udHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvcmV0cnkudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvcmV0cnlXaGVuLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3NhbXBsZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9zYW1wbGVUaW1lLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3NjYW4udHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3Ivc2VxdWVuY2VFcXVhbC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9zaGFyZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9zaW5nbGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3Ivc2tpcC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9za2lwVW50aWwudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3Ivc2tpcFdoaWxlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3N0YXJ0V2l0aC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9zdWJzY3JpYmVPbi50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9zd2l0Y2gudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3Ivc3dpdGNoTWFwLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3N3aXRjaE1hcFRvLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3Rha2UudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvdGFrZUxhc3QudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvdGFrZVVudGlsLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3Rha2VXaGlsZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci90aHJvdHRsZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci90aHJvdHRsZVRpbWUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvdGltZUludGVydmFsLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3RpbWVvdXQudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvdGltZW91dFdpdGgudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvdGltZXN0YW1wLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3RvQXJyYXkudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvdG9Qcm9taXNlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3dpbmRvdy50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci93aW5kb3dDb3VudC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci93aW5kb3dUaW1lLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3dpbmRvd1RvZ2dsZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci93aW5kb3dXaGVuLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3dpdGhMYXRlc3RGcm9tLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3ppcC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci96aXBBbGwudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL0FycmF5TGlrZU9ic2VydmFibGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL0JvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9Cb3VuZE5vZGVDYWxsYmFja09ic2VydmFibGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL0RlZmVyT2JzZXJ2YWJsZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29ic2VydmFibGUvRXJyb3JPYnNlcnZhYmxlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9Gb3JrSm9pbk9ic2VydmFibGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL0Zyb21FdmVudE9ic2VydmFibGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL0Zyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9HZW5lcmF0ZU9ic2VydmFibGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL0lmT2JzZXJ2YWJsZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29ic2VydmFibGUvSW50ZXJ2YWxPYnNlcnZhYmxlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9JdGVyYXRvck9ic2VydmFibGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL05ldmVyT2JzZXJ2YWJsZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29ic2VydmFibGUvUGFpcnNPYnNlcnZhYmxlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9SYW5nZU9ic2VydmFibGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL1N1YnNjcmliZU9uT2JzZXJ2YWJsZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29ic2VydmFibGUvVGltZXJPYnNlcnZhYmxlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9Vc2luZ09ic2VydmFibGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL2JpbmRDYWxsYmFjay50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29ic2VydmFibGUvYmluZE5vZGVDYWxsYmFjay50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29ic2VydmFibGUvY29tYmluZUxhdGVzdC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29ic2VydmFibGUvY29uY2F0LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9kZWZlci50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29ic2VydmFibGUvZG9tL1dlYlNvY2tldFN1YmplY3QudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL2RvbS9hamF4LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9kb20vd2ViU29ja2V0LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9lbXB0eS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29ic2VydmFibGUvZm9ya0pvaW4udHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL2Zyb20udHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL2Zyb21FdmVudC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29ic2VydmFibGUvZnJvbUV2ZW50UGF0dGVybi50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29ic2VydmFibGUvZnJvbVByb21pc2UudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL2lmLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9pbnRlcnZhbC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29ic2VydmFibGUvbWVyZ2UudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL25ldmVyLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9vZi50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29ic2VydmFibGUvcGFpcnMudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL3JhbmdlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS90aHJvdy50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29ic2VydmFibGUvdGltZXIudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL3VzaW5nLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS96aXAudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9hdWRpdC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL2F1ZGl0VGltZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL2J1ZmZlci50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL2J1ZmZlckNvdW50LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3IvYnVmZmVyVGltZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL2J1ZmZlclRvZ2dsZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL2J1ZmZlcldoZW4udHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9jYXRjaC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL2NvbWJpbmVBbGwudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9jb25jYXRBbGwudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9jb25jYXRNYXAudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9jb25jYXRNYXBUby50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL2NvdW50LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3IvZGVib3VuY2UudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9kZWJvdW5jZVRpbWUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9kZWZhdWx0SWZFbXB0eS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL2RlbGF5LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3IvZGVsYXlXaGVuLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3IvZGVtYXRlcmlhbGl6ZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL2Rpc3RpbmN0LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3IvZGlzdGluY3RVbnRpbEtleUNoYW5nZWQudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9kby50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL2VsZW1lbnRBdC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL2V2ZXJ5LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3IvZXhoYXVzdC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL2V4aGF1c3RNYXAudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9leHBhbmQudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9maW5hbGx5LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3IvZmluZEluZGV4LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3IvZmlyc3QudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9ncm91cEJ5LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3IvaWdub3JlRWxlbWVudHMudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9pc0VtcHR5LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3IvbGFzdC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL2xldC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL21hcFRvLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3IvbWF0ZXJpYWxpemUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9tYXgudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9tZXJnZVNjYW4udHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9taW4udHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9wYWlyd2lzZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3BhcnRpdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3BsdWNrLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3IvcHVibGlzaC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3B1Ymxpc2hCZWhhdmlvci50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3B1Ymxpc2hMYXN0LnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3IvcHVibGlzaFJlcGxheS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3JlcGVhdC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3JlcGVhdFdoZW4udHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9yZXRyeS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3JldHJ5V2hlbi50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3NhbXBsZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3NhbXBsZVRpbWUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci9zY2FuLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3Ivc2VxdWVuY2VFcXVhbC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3NoYXJlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3Ivc2luZ2xlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3Ivc2tpcC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3NraXBVbnRpbC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3NraXBXaGlsZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3N0YXJ0V2l0aC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3N1YnNjcmliZU9uLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3Ivc3dpdGNoLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3Ivc3dpdGNoTWFwLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3Ivc3dpdGNoTWFwVG8udHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci90YWtlLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3IvdGFrZUxhc3QudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci90YWtlVW50aWwudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci90YWtlV2hpbGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci90aHJvdHRsZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3Rocm90dGxlVGltZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3RpbWVvdXQudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci90aW1lb3V0V2l0aC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3RvQXJyYXkudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci90b1Byb21pc2UudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci93aW5kb3cudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci93aW5kb3dDb3VudC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL29wZXJhdG9yL3dpbmRvd1RpbWUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci93aW5kb3dUb2dnbGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci93aW5kb3dXaGVuLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvb3BlcmF0b3Ivd2l0aExhdGVzdEZyb20udHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9vcGVyYXRvci96aXBBbGwudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9zY2hlZHVsZXIvQWN0aW9uLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvc2NoZWR1bGVyL0FuaW1hdGlvbkZyYW1lQWN0aW9uLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvc2NoZWR1bGVyL0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvc2NoZWR1bGVyL0FzYXBBY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy9zY2hlZHVsZXIvQXNhcFNjaGVkdWxlci50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3NjaGVkdWxlci9RdWV1ZUFjdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3NjaGVkdWxlci9RdWV1ZVNjaGVkdWxlci50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3NjaGVkdWxlci9hbmltYXRpb25GcmFtZS50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3Rlc3RpbmcvQ29sZE9ic2VydmFibGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy90ZXN0aW5nL0hvdE9ic2VydmFibGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy90ZXN0aW5nL1Rlc3RTY2hlZHVsZXIudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy91dGlsL0FuaW1hdGlvbkZyYW1lLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvdXRpbC9GYXN0TWFwLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvdXRpbC9JbW1lZGlhdGUudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy91dGlsL01hcC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3V0aWwvTWFwUG9seWZpbGwudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy91dGlsL1NldC50cyIsIndlYnBhY2s6Ly8vLi9+L3J4anMvc3JjL3V0aWwvYXNzaWduLnRzIiwid2VicGFjazovLy8uL34vcnhqcy9zcmMvdXRpbC9ub3QudHMiLCJ3ZWJwYWNrOi8vLy4vfi9yeGpzL3NyYy91dGlsL3RvU3Vic2NyaWJlci50cyIsIndlYnBhY2s6Ly8vLi9+L3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiXSwibmFtZXMiOlsiY29sb3JzIiwibmFtZSIsIm5hbWVMaXN0Iiwic3JjIiwic3RhcnQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwic3RvcCIsInN0YXJ0Q2xpY2siLCJPYnNlcnZhYmxlIiwiZnJvbUV2ZW50Iiwic3RvcENsaWNrIiwidGltZXIiLCJzcGVlZCIsInNvdXJjZSIsImludGVydmFsIiwidGFrZSIsIlJhbmRvbU51bWJlcnMiLCJtYXAiLCJlIiwiY29uY2F0QWxsIiwidGFrZVVudGlsIiwiZG8iLCJuZXh0IiwidG9wIiwiJCIsImxlbmd0aCIsImltZ0VsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3MiLCJhcHBlbmRDaGlsZCIsIlR3ZWVuTGl0ZSIsInRvIiwiZWFzZSIsIkJvdW5jZSIsImVhc2VPdXQiLCJ5IiwicmVtb3ZlQ2xhc3MiLCJhZGRDbGFzcyIsImNvbXBsZXRlIiwic2V0VGltZW91dCIsImFsZXJ0IiwiZGlzYWJsZWQiLCJQb3dlcjAiLCJlYXNlTm9uZSIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImRlbGF5Iiwic3Vic2NyaWJlIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBLG1FQUEyRDtBQUMzRDtBQUNBO0FBQ0E7O0FBRUEsb0RBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtEQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0Q7QUFQUSxFQVhiLEU7Ozs7OztBQ2hFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVU7QUFDVjtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUMiLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0dmFyIHBhcmVudEhvdFVwZGF0ZUNhbGxiYWNrID0gdGhpc1tcIndlYnBhY2tIb3RVcGRhdGVcIl07XG4gXHR0aGlzW1wid2VicGFja0hvdFVwZGF0ZVwiXSA9IFxyXG4gXHRmdW5jdGlvbiB3ZWJwYWNrSG90VXBkYXRlQ2FsbGJhY2soY2h1bmtJZCwgbW9yZU1vZHVsZXMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rSWQsIG1vcmVNb2R1bGVzKTtcclxuIFx0XHRpZihwYXJlbnRIb3RVcGRhdGVDYWxsYmFjaykgcGFyZW50SG90VXBkYXRlQ2FsbGJhY2soY2h1bmtJZCwgbW9yZU1vZHVsZXMpO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3REb3dubG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xyXG4gXHRcdHZhciBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdO1xyXG4gXHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xyXG4gXHRcdHNjcmlwdC50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcclxuIFx0XHRzY3JpcHQuY2hhcnNldCA9IFwidXRmLThcIjtcclxuIFx0XHRzY3JpcHQuc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXCJcIiArIGNodW5rSWQgKyBcIi5cIiArIGhvdEN1cnJlbnRIYXNoICsgXCIuaG90LXVwZGF0ZS5qc1wiO1xyXG4gXHRcdGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90RG93bmxvYWRNYW5pZmVzdChjYWxsYmFjaykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFx0aWYodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ID09PSBcInVuZGVmaW5lZFwiKVxyXG4gXHRcdFx0cmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcIk5vIGJyb3dzZXIgc3VwcG9ydFwiKSk7XHJcbiBcdFx0dHJ5IHtcclxuIFx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiBcdFx0XHR2YXIgcmVxdWVzdFBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBcIlwiICsgaG90Q3VycmVudEhhc2ggKyBcIi5ob3QtdXBkYXRlLmpzb25cIjtcclxuIFx0XHRcdHJlcXVlc3Qub3BlbihcIkdFVFwiLCByZXF1ZXN0UGF0aCwgdHJ1ZSk7XHJcbiBcdFx0XHRyZXF1ZXN0LnRpbWVvdXQgPSAxMDAwMDtcclxuIFx0XHRcdHJlcXVlc3Quc2VuZChudWxsKTtcclxuIFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0cmV0dXJuIGNhbGxiYWNrKGVycik7XHJcbiBcdFx0fVxyXG4gXHRcdHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XHJcbiBcdFx0XHRpZihyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHJldHVybjtcclxuIFx0XHRcdGlmKHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XHJcbiBcdFx0XHRcdC8vIHRpbWVvdXRcclxuIFx0XHRcdFx0Y2FsbGJhY2sobmV3IEVycm9yKFwiTWFuaWZlc3QgcmVxdWVzdCB0byBcIiArIHJlcXVlc3RQYXRoICsgXCIgdGltZWQgb3V0LlwiKSk7XHJcbiBcdFx0XHR9IGVsc2UgaWYocmVxdWVzdC5zdGF0dXMgPT09IDQwNCkge1xyXG4gXHRcdFx0XHQvLyBubyB1cGRhdGUgYXZhaWxhYmxlXHJcbiBcdFx0XHRcdGNhbGxiYWNrKCk7XHJcbiBcdFx0XHR9IGVsc2UgaWYocmVxdWVzdC5zdGF0dXMgIT09IDIwMCAmJiByZXF1ZXN0LnN0YXR1cyAhPT0gMzA0KSB7XHJcbiBcdFx0XHRcdC8vIG90aGVyIGZhaWx1cmVcclxuIFx0XHRcdFx0Y2FsbGJhY2sobmV3IEVycm9yKFwiTWFuaWZlc3QgcmVxdWVzdCB0byBcIiArIHJlcXVlc3RQYXRoICsgXCIgZmFpbGVkLlwiKSk7XHJcbiBcdFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0XHQvLyBzdWNjZXNzXHJcbiBcdFx0XHRcdHRyeSB7XHJcbiBcdFx0XHRcdFx0dmFyIHVwZGF0ZSA9IEpTT04ucGFyc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xyXG4gXHRcdFx0XHR9IGNhdGNoKGUpIHtcclxuIFx0XHRcdFx0XHRjYWxsYmFjayhlKTtcclxuIFx0XHRcdFx0XHRyZXR1cm47XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgdXBkYXRlKTtcclxuIFx0XHRcdH1cclxuIFx0XHR9O1xyXG4gXHR9XHJcblxuIFx0XHJcbiBcdFxyXG4gXHQvLyBDb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iZWY0NWIwL3NyYy9zaGFyZWQvdXRpbHMvY2FuRGVmaW5lUHJvcGVydHkuanNcclxuIFx0dmFyIGNhbkRlZmluZVByb3BlcnR5ID0gZmFsc2U7XHJcbiBcdHRyeSB7XHJcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInhcIiwge1xyXG4gXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHt9XHJcbiBcdFx0fSk7XHJcbiBcdFx0Y2FuRGVmaW5lUHJvcGVydHkgPSB0cnVlO1xyXG4gXHR9IGNhdGNoKHgpIHtcclxuIFx0XHQvLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHlcclxuIFx0fVxyXG4gXHRcclxuIFx0dmFyIGhvdEFwcGx5T25VcGRhdGUgPSB0cnVlO1xyXG4gXHR2YXIgaG90Q3VycmVudEhhc2ggPSBcIjQ3OGZjNjM0NDhkMGMwOTlmZDQwXCI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0dmFyIGhvdEN1cnJlbnRNb2R1bGVEYXRhID0ge307XHJcbiBcdHZhciBob3RDdXJyZW50UGFyZW50cyA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RDcmVhdGVSZXF1aXJlKG1vZHVsZUlkKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHR2YXIgbWUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRpZighbWUpIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fO1xyXG4gXHRcdHZhciBmbiA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcclxuIFx0XHRcdGlmKG1lLmhvdC5hY3RpdmUpIHtcclxuIFx0XHRcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XSkge1xyXG4gXHRcdFx0XHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cy5pbmRleE9mKG1vZHVsZUlkKSA8IDApXHJcbiBcdFx0XHRcdFx0XHRpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdLnBhcmVudHMucHVzaChtb2R1bGVJZCk7XHJcbiBcdFx0XHRcdFx0aWYobWUuY2hpbGRyZW4uaW5kZXhPZihyZXF1ZXN0KSA8IDApXHJcbiBcdFx0XHRcdFx0XHRtZS5jaGlsZHJlbi5wdXNoKHJlcXVlc3QpO1xyXG4gXHRcdFx0XHR9IGVsc2UgaG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xyXG4gXHRcdFx0fSBlbHNlIHtcclxuIFx0XHRcdFx0Y29uc29sZS53YXJuKFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICsgcmVxdWVzdCArIFwiKSBmcm9tIGRpc3Bvc2VkIG1vZHVsZSBcIiArIG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbXTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHJlcXVlc3QpO1xyXG4gXHRcdH07XHJcbiBcdFx0Zm9yKHZhciBuYW1lIGluIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfX3dlYnBhY2tfcmVxdWlyZV9fLCBuYW1lKSkge1xyXG4gXHRcdFx0XHRpZihjYW5EZWZpbmVQcm9wZXJ0eSkge1xyXG4gXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgbmFtZSwgKGZ1bmN0aW9uKG5hbWUpIHtcclxuIFx0XHRcdFx0XHRcdHJldHVybiB7XHJcbiBcdFx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuIFx0XHRcdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuIFx0XHRcdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuIFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfX1tuYW1lXTtcclxuIFx0XHRcdFx0XHRcdFx0fSxcclxuIFx0XHRcdFx0XHRcdFx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gXHRcdFx0XHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX19bbmFtZV0gPSB2YWx1ZTtcclxuIFx0XHRcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdFx0fTtcclxuIFx0XHRcdFx0XHR9KG5hbWUpKSk7XHJcbiBcdFx0XHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRcdFx0Zm5bbmFtZV0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fW25hbWVdO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHRmdW5jdGlvbiBlbnN1cmUoY2h1bmtJZCwgY2FsbGJhY2spIHtcclxuIFx0XHRcdGlmKGhvdFN0YXR1cyA9PT0gXCJyZWFkeVwiKVxyXG4gXHRcdFx0XHRob3RTZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xyXG4gXHRcdFx0aG90Q2h1bmtzTG9hZGluZysrO1xyXG4gXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5lKGNodW5rSWQsIGZ1bmN0aW9uKCkge1xyXG4gXHRcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwobnVsbCwgZm4pO1xyXG4gXHRcdFx0XHR9IGZpbmFsbHkge1xyXG4gXHRcdFx0XHRcdGZpbmlzaENodW5rTG9hZGluZygpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFxyXG4gXHRcdFx0XHRmdW5jdGlvbiBmaW5pc2hDaHVua0xvYWRpbmcoKSB7XHJcbiBcdFx0XHRcdFx0aG90Q2h1bmtzTG9hZGluZy0tO1xyXG4gXHRcdFx0XHRcdGlmKGhvdFN0YXR1cyA9PT0gXCJwcmVwYXJlXCIpIHtcclxuIFx0XHRcdFx0XHRcdGlmKCFob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0pIHtcclxuIFx0XHRcdFx0XHRcdFx0aG90RW5zdXJlVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0XHRpZihob3RDaHVua3NMb2FkaW5nID09PSAwICYmIGhvdFdhaXRpbmdGaWxlcyA9PT0gMCkge1xyXG4gXHRcdFx0XHRcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XHJcbiBcdFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9KTtcclxuIFx0XHR9XHJcbiBcdFx0aWYoY2FuRGVmaW5lUHJvcGVydHkpIHtcclxuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgXCJlXCIsIHtcclxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcclxuIFx0XHRcdFx0dmFsdWU6IGVuc3VyZVxyXG4gXHRcdFx0fSk7XHJcbiBcdFx0fSBlbHNlIHtcclxuIFx0XHRcdGZuLmUgPSBlbnN1cmU7XHJcbiBcdFx0fVxyXG4gXHRcdHJldHVybiBmbjtcclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90Q3JlYXRlTW9kdWxlKG1vZHVsZUlkKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcclxuIFx0XHR2YXIgaG90ID0ge1xyXG4gXHRcdFx0Ly8gcHJpdmF0ZSBzdHVmZlxyXG4gXHRcdFx0X2FjY2VwdGVkRGVwZW5kZW5jaWVzOiB7fSxcclxuIFx0XHRcdF9kZWNsaW5lZERlcGVuZGVuY2llczoge30sXHJcbiBcdFx0XHRfc2VsZkFjY2VwdGVkOiBmYWxzZSxcclxuIFx0XHRcdF9zZWxmRGVjbGluZWQ6IGZhbHNlLFxyXG4gXHRcdFx0X2Rpc3Bvc2VIYW5kbGVyczogW10sXHJcbiBcdFxyXG4gXHRcdFx0Ly8gTW9kdWxlIEFQSVxyXG4gXHRcdFx0YWN0aXZlOiB0cnVlLFxyXG4gXHRcdFx0YWNjZXB0OiBmdW5jdGlvbihkZXAsIGNhbGxiYWNrKSB7XHJcbiBcdFx0XHRcdGlmKHR5cGVvZiBkZXAgPT09IFwidW5kZWZpbmVkXCIpXHJcbiBcdFx0XHRcdFx0aG90Ll9zZWxmQWNjZXB0ZWQgPSB0cnVlO1xyXG4gXHRcdFx0XHRlbHNlIGlmKHR5cGVvZiBkZXAgPT09IFwiZnVuY3Rpb25cIilcclxuIFx0XHRcdFx0XHRob3QuX3NlbGZBY2NlcHRlZCA9IGRlcDtcclxuIFx0XHRcdFx0ZWxzZSBpZih0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiKVxyXG4gXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXHJcbiBcdFx0XHRcdFx0XHRob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW2RlcFtpXV0gPSBjYWxsYmFjaztcclxuIFx0XHRcdFx0ZWxzZVxyXG4gXHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwXSA9IGNhbGxiYWNrO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGRlY2xpbmU6IGZ1bmN0aW9uKGRlcCkge1xyXG4gXHRcdFx0XHRpZih0eXBlb2YgZGVwID09PSBcInVuZGVmaW5lZFwiKVxyXG4gXHRcdFx0XHRcdGhvdC5fc2VsZkRlY2xpbmVkID0gdHJ1ZTtcclxuIFx0XHRcdFx0ZWxzZSBpZih0eXBlb2YgZGVwID09PSBcIm51bWJlclwiKVxyXG4gXHRcdFx0XHRcdGhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbZGVwXSA9IHRydWU7XHJcbiBcdFx0XHRcdGVsc2VcclxuIFx0XHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKVxyXG4gXHRcdFx0XHRcdFx0aG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBbaV1dID0gdHJ1ZTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRkaXNwb3NlOiBmdW5jdGlvbihjYWxsYmFjaykge1xyXG4gXHRcdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRhZGREaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuIFx0XHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcdFx0cmVtb3ZlRGlzcG9zZUhhbmRsZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiBcdFx0XHRcdHZhciBpZHggPSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5pbmRleE9mKGNhbGxiYWNrKTtcclxuIFx0XHRcdFx0aWYoaWR4ID49IDApIGhvdC5fZGlzcG9zZUhhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0fSxcclxuIFx0XHJcbiBcdFx0XHQvLyBNYW5hZ2VtZW50IEFQSVxyXG4gXHRcdFx0Y2hlY2s6IGhvdENoZWNrLFxyXG4gXHRcdFx0YXBwbHk6IGhvdEFwcGx5LFxyXG4gXHRcdFx0c3RhdHVzOiBmdW5jdGlvbihsKSB7XHJcbiBcdFx0XHRcdGlmKCFsKSByZXR1cm4gaG90U3RhdHVzO1xyXG4gXHRcdFx0XHRob3RTdGF0dXNIYW5kbGVycy5wdXNoKGwpO1xyXG4gXHRcdFx0fSxcclxuIFx0XHRcdGFkZFN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uKGwpIHtcclxuIFx0XHRcdFx0aG90U3RhdHVzSGFuZGxlcnMucHVzaChsKTtcclxuIFx0XHRcdH0sXHJcbiBcdFx0XHRyZW1vdmVTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbihsKSB7XHJcbiBcdFx0XHRcdHZhciBpZHggPSBob3RTdGF0dXNIYW5kbGVycy5pbmRleE9mKGwpO1xyXG4gXHRcdFx0XHRpZihpZHggPj0gMCkgaG90U3RhdHVzSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XHJcbiBcdFx0XHR9LFxyXG4gXHRcclxuIFx0XHRcdC8vaW5oZXJpdCBmcm9tIHByZXZpb3VzIGRpc3Bvc2UgY2FsbFxyXG4gXHRcdFx0ZGF0YTogaG90Q3VycmVudE1vZHVsZURhdGFbbW9kdWxlSWRdXHJcbiBcdFx0fTtcclxuIFx0XHRyZXR1cm4gaG90O1xyXG4gXHR9XHJcbiBcdFxyXG4gXHR2YXIgaG90U3RhdHVzSGFuZGxlcnMgPSBbXTtcclxuIFx0dmFyIGhvdFN0YXR1cyA9IFwiaWRsZVwiO1xyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90U2V0U3RhdHVzKG5ld1N0YXR1cykge1xyXG4gXHRcdGhvdFN0YXR1cyA9IG5ld1N0YXR1cztcclxuIFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgaG90U3RhdHVzSGFuZGxlcnMubGVuZ3RoOyBpKyspXHJcbiBcdFx0XHRob3RTdGF0dXNIYW5kbGVyc1tpXS5jYWxsKG51bGwsIG5ld1N0YXR1cyk7XHJcbiBcdH1cclxuIFx0XHJcbiBcdC8vIHdoaWxlIGRvd25sb2FkaW5nXHJcbiBcdHZhciBob3RXYWl0aW5nRmlsZXMgPSAwO1xyXG4gXHR2YXIgaG90Q2h1bmtzTG9hZGluZyA9IDA7XHJcbiBcdHZhciBob3RXYWl0aW5nRmlsZXNNYXAgPSB7fTtcclxuIFx0dmFyIGhvdFJlcXVlc3RlZEZpbGVzTWFwID0ge307XHJcbiBcdHZhciBob3RBdmFpbGlibGVGaWxlc01hcCA9IHt9O1xyXG4gXHR2YXIgaG90Q2FsbGJhY2s7XHJcbiBcdFxyXG4gXHQvLyBUaGUgdXBkYXRlIGluZm9cclxuIFx0dmFyIGhvdFVwZGF0ZSwgaG90VXBkYXRlTmV3SGFzaDtcclxuIFx0XHJcbiBcdGZ1bmN0aW9uIHRvTW9kdWxlSWQoaWQpIHtcclxuIFx0XHR2YXIgaXNOdW1iZXIgPSAoK2lkKSArIFwiXCIgPT09IGlkO1xyXG4gXHRcdHJldHVybiBpc051bWJlciA/ICtpZCA6IGlkO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RDaGVjayhhcHBseSwgY2FsbGJhY2spIHtcclxuIFx0XHRpZihob3RTdGF0dXMgIT09IFwiaWRsZVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJjaGVjaygpIGlzIG9ubHkgYWxsb3dlZCBpbiBpZGxlIHN0YXR1c1wiKTtcclxuIFx0XHRpZih0eXBlb2YgYXBwbHkgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gXHRcdFx0aG90QXBwbHlPblVwZGF0ZSA9IGZhbHNlO1xyXG4gXHRcdFx0Y2FsbGJhY2sgPSBhcHBseTtcclxuIFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0aG90QXBwbHlPblVwZGF0ZSA9IGFwcGx5O1xyXG4gXHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbihlcnIpIHtcclxuIFx0XHRcdFx0aWYoZXJyKSB0aHJvdyBlcnI7XHJcbiBcdFx0XHR9O1xyXG4gXHRcdH1cclxuIFx0XHRob3RTZXRTdGF0dXMoXCJjaGVja1wiKTtcclxuIFx0XHRob3REb3dubG9hZE1hbmlmZXN0KGZ1bmN0aW9uKGVyciwgdXBkYXRlKSB7XHJcbiBcdFx0XHRpZihlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpO1xyXG4gXHRcdFx0aWYoIXVwZGF0ZSkge1xyXG4gXHRcdFx0XHRob3RTZXRTdGF0dXMoXCJpZGxlXCIpO1xyXG4gXHRcdFx0XHRjYWxsYmFjayhudWxsLCBudWxsKTtcclxuIFx0XHRcdFx0cmV0dXJuO1xyXG4gXHRcdFx0fVxyXG4gXHRcclxuIFx0XHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwID0ge307XHJcbiBcdFx0XHRob3RBdmFpbGlibGVGaWxlc01hcCA9IHt9O1xyXG4gXHRcdFx0aG90V2FpdGluZ0ZpbGVzTWFwID0ge307XHJcbiBcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdXBkYXRlLmMubGVuZ3RoOyBpKyspXHJcbiBcdFx0XHRcdGhvdEF2YWlsaWJsZUZpbGVzTWFwW3VwZGF0ZS5jW2ldXSA9IHRydWU7XHJcbiBcdFx0XHRob3RVcGRhdGVOZXdIYXNoID0gdXBkYXRlLmg7XHJcbiBcdFxyXG4gXHRcdFx0aG90U2V0U3RhdHVzKFwicHJlcGFyZVwiKTtcclxuIFx0XHRcdGhvdENhbGxiYWNrID0gY2FsbGJhY2s7XHJcbiBcdFx0XHRob3RVcGRhdGUgPSB7fTtcclxuIFx0XHRcdHZhciBjaHVua0lkID0gMDtcclxuIFx0XHRcdHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1sb25lLWJsb2Nrc1xyXG4gXHRcdFx0XHQvKmdsb2JhbHMgY2h1bmtJZCAqL1xyXG4gXHRcdFx0XHRob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdGlmKGhvdFN0YXR1cyA9PT0gXCJwcmVwYXJlXCIgJiYgaG90Q2h1bmtzTG9hZGluZyA9PT0gMCAmJiBob3RXYWl0aW5nRmlsZXMgPT09IDApIHtcclxuIFx0XHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH0pO1xyXG4gXHR9XHJcbiBcdFxyXG4gXHRmdW5jdGlvbiBob3RBZGRVcGRhdGVDaHVuayhjaHVua0lkLCBtb3JlTW9kdWxlcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXHJcbiBcdFx0aWYoIWhvdEF2YWlsaWJsZUZpbGVzTWFwW2NodW5rSWRdIHx8ICFob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSlcclxuIFx0XHRcdHJldHVybjtcclxuIFx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSA9IGZhbHNlO1xyXG4gXHRcdGZvcih2YXIgbW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdGhvdFVwZGF0ZVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcdGlmKC0taG90V2FpdGluZ0ZpbGVzID09PSAwICYmIGhvdENodW5rc0xvYWRpbmcgPT09IDApIHtcclxuIFx0XHRcdGhvdFVwZGF0ZURvd25sb2FkZWQoKTtcclxuIFx0XHR9XHJcbiBcdH1cclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdEVuc3VyZVVwZGF0ZUNodW5rKGNodW5rSWQpIHtcclxuIFx0XHRpZighaG90QXZhaWxpYmxlRmlsZXNNYXBbY2h1bmtJZF0pIHtcclxuIFx0XHRcdGhvdFdhaXRpbmdGaWxlc01hcFtjaHVua0lkXSA9IHRydWU7XHJcbiBcdFx0fSBlbHNlIHtcclxuIFx0XHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdID0gdHJ1ZTtcclxuIFx0XHRcdGhvdFdhaXRpbmdGaWxlcysrO1xyXG4gXHRcdFx0aG90RG93bmxvYWRVcGRhdGVDaHVuayhjaHVua0lkKTtcclxuIFx0XHR9XHJcbiBcdH1cclxuIFx0XHJcbiBcdGZ1bmN0aW9uIGhvdFVwZGF0ZURvd25sb2FkZWQoKSB7XHJcbiBcdFx0aG90U2V0U3RhdHVzKFwicmVhZHlcIik7XHJcbiBcdFx0dmFyIGNhbGxiYWNrID0gaG90Q2FsbGJhY2s7XHJcbiBcdFx0aG90Q2FsbGJhY2sgPSBudWxsO1xyXG4gXHRcdGlmKCFjYWxsYmFjaykgcmV0dXJuO1xyXG4gXHRcdGlmKGhvdEFwcGx5T25VcGRhdGUpIHtcclxuIFx0XHRcdGhvdEFwcGx5KGhvdEFwcGx5T25VcGRhdGUsIGNhbGxiYWNrKTtcclxuIFx0XHR9IGVsc2Uge1xyXG4gXHRcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xyXG4gXHRcdFx0Zm9yKHZhciBpZCBpbiBob3RVcGRhdGUpIHtcclxuIFx0XHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhvdFVwZGF0ZSwgaWQpKSB7XHJcbiBcdFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLnB1c2godG9Nb2R1bGVJZChpZCkpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0XHRjYWxsYmFjayhudWxsLCBvdXRkYXRlZE1vZHVsZXMpO1xyXG4gXHRcdH1cclxuIFx0fVxyXG4gXHRcclxuIFx0ZnVuY3Rpb24gaG90QXBwbHkob3B0aW9ucywgY2FsbGJhY2spIHtcclxuIFx0XHRpZihob3RTdGF0dXMgIT09IFwicmVhZHlcIikgdGhyb3cgbmV3IEVycm9yKFwiYXBwbHkoKSBpcyBvbmx5IGFsbG93ZWQgaW4gcmVhZHkgc3RhdHVzXCIpO1xyXG4gXHRcdGlmKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcclxuIFx0XHRcdGNhbGxiYWNrID0gb3B0aW9ucztcclxuIFx0XHRcdG9wdGlvbnMgPSB7fTtcclxuIFx0XHR9IGVsc2UgaWYob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gXCJvYmplY3RcIikge1xyXG4gXHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbihlcnIpIHtcclxuIFx0XHRcdFx0aWYoZXJyKSB0aHJvdyBlcnI7XHJcbiBcdFx0XHR9O1xyXG4gXHRcdH0gZWxzZSB7XHJcbiBcdFx0XHRvcHRpb25zID0ge307XHJcbiBcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKGVycikge1xyXG4gXHRcdFx0XHRpZihlcnIpIHRocm93IGVycjtcclxuIFx0XHRcdH07XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHRmdW5jdGlvbiBnZXRBZmZlY3RlZFN0dWZmKG1vZHVsZSkge1xyXG4gXHRcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFttb2R1bGVdO1xyXG4gXHRcdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XHJcbiBcdFxyXG4gXHRcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLnNsaWNlKCk7XHJcbiBcdFx0XHR3aGlsZShxdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiBcdFx0XHRcdHZhciBtb2R1bGVJZCA9IHF1ZXVlLnBvcCgpO1xyXG4gXHRcdFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdGlmKCFtb2R1bGUgfHwgbW9kdWxlLmhvdC5fc2VsZkFjY2VwdGVkKVxyXG4gXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRpZihtb2R1bGUuaG90Ll9zZWxmRGVjbGluZWQpIHtcclxuIFx0XHRcdFx0XHRyZXR1cm4gbmV3IEVycm9yKFwiQWJvcnRlZCBiZWNhdXNlIG9mIHNlbGYgZGVjbGluZTogXCIgKyBtb2R1bGVJZCk7XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0aWYobW9kdWxlSWQgPT09IDApIHtcclxuIFx0XHRcdFx0XHRyZXR1cm47XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1vZHVsZS5wYXJlbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRcdFx0dmFyIHBhcmVudElkID0gbW9kdWxlLnBhcmVudHNbaV07XHJcbiBcdFx0XHRcdFx0dmFyIHBhcmVudCA9IGluc3RhbGxlZE1vZHVsZXNbcGFyZW50SWRdO1xyXG4gXHRcdFx0XHRcdGlmKHBhcmVudC5ob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSkge1xyXG4gXHRcdFx0XHRcdFx0cmV0dXJuIG5ldyBFcnJvcihcIkFib3J0ZWQgYmVjYXVzZSBvZiBkZWNsaW5lZCBkZXBlbmRlbmN5OiBcIiArIG1vZHVsZUlkICsgXCIgaW4gXCIgKyBwYXJlbnRJZCk7XHJcbiBcdFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRcdGlmKG91dGRhdGVkTW9kdWxlcy5pbmRleE9mKHBhcmVudElkKSA+PSAwKSBjb250aW51ZTtcclxuIFx0XHRcdFx0XHRpZihwYXJlbnQuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcclxuIFx0XHRcdFx0XHRcdGlmKCFvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0pXHJcbiBcdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW3BhcmVudElkXSA9IFtdO1xyXG4gXHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdLCBbbW9kdWxlSWRdKTtcclxuIFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0XHRkZWxldGUgb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdO1xyXG4gXHRcdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHBhcmVudElkKTtcclxuIFx0XHRcdFx0XHRxdWV1ZS5wdXNoKHBhcmVudElkKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcclxuIFx0XHRcdHJldHVybiBbb3V0ZGF0ZWRNb2R1bGVzLCBvdXRkYXRlZERlcGVuZGVuY2llc107XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHRmdW5jdGlvbiBhZGRBbGxUb1NldChhLCBiKSB7XHJcbiBcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0XHR2YXIgaXRlbSA9IGJbaV07XHJcbiBcdFx0XHRcdGlmKGEuaW5kZXhPZihpdGVtKSA8IDApXHJcbiBcdFx0XHRcdFx0YS5wdXNoKGl0ZW0pO1xyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gYXQgYmVnaW4gYWxsIHVwZGF0ZXMgbW9kdWxlcyBhcmUgb3V0ZGF0ZWRcclxuIFx0XHQvLyB0aGUgXCJvdXRkYXRlZFwiIHN0YXR1cyBjYW4gcHJvcGFnYXRlIHRvIHBhcmVudHMgaWYgdGhleSBkb24ndCBhY2NlcHQgdGhlIGNoaWxkcmVuXHJcbiBcdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XHJcbiBcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xyXG4gXHRcdHZhciBhcHBsaWVkVXBkYXRlID0ge307XHJcbiBcdFx0Zm9yKHZhciBpZCBpbiBob3RVcGRhdGUpIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChob3RVcGRhdGUsIGlkKSkge1xyXG4gXHRcdFx0XHR2YXIgbW9kdWxlSWQgPSB0b01vZHVsZUlkKGlkKTtcclxuIFx0XHRcdFx0dmFyIHJlc3VsdCA9IGdldEFmZmVjdGVkU3R1ZmYobW9kdWxlSWQpO1xyXG4gXHRcdFx0XHRpZighcmVzdWx0KSB7XHJcbiBcdFx0XHRcdFx0aWYob3B0aW9ucy5pZ25vcmVVbmFjY2VwdGVkKVxyXG4gXHRcdFx0XHRcdFx0Y29udGludWU7XHJcbiBcdFx0XHRcdFx0aG90U2V0U3RhdHVzKFwiYWJvcnRcIik7XHJcbiBcdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcihcIkFib3J0ZWQgYmVjYXVzZSBcIiArIG1vZHVsZUlkICsgXCIgaXMgbm90IGFjY2VwdGVkXCIpKTtcclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0XHRpZihyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gXHRcdFx0XHRcdGhvdFNldFN0YXR1cyhcImFib3J0XCIpO1xyXG4gXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjayhyZXN1bHQpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdID0gaG90VXBkYXRlW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCByZXN1bHRbMF0pO1xyXG4gXHRcdFx0XHRmb3IodmFyIG1vZHVsZUlkIGluIHJlc3VsdFsxXSkge1xyXG4gXHRcdFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHRbMV0sIG1vZHVsZUlkKSkge1xyXG4gXHRcdFx0XHRcdFx0aWYoIW91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSlcclxuIFx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdID0gW107XHJcbiBcdFx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0sIHJlc3VsdFsxXVttb2R1bGVJZF0pO1xyXG4gXHRcdFx0XHRcdH1cclxuIFx0XHRcdFx0fVxyXG4gXHRcdFx0fVxyXG4gXHRcdH1cclxuIFx0XHJcbiBcdFx0Ly8gU3RvcmUgc2VsZiBhY2NlcHRlZCBvdXRkYXRlZCBtb2R1bGVzIHRvIHJlcXVpcmUgdGhlbSBsYXRlciBieSB0aGUgbW9kdWxlIHN5c3RlbVxyXG4gXHRcdHZhciBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMgPSBbXTtcclxuIFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgb3V0ZGF0ZWRNb2R1bGVzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHR2YXIgbW9kdWxlSWQgPSBvdXRkYXRlZE1vZHVsZXNbaV07XHJcbiBcdFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSAmJiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5ob3QuX3NlbGZBY2NlcHRlZClcclxuIFx0XHRcdFx0b3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzLnB1c2goe1xyXG4gXHRcdFx0XHRcdG1vZHVsZTogbW9kdWxlSWQsXHJcbiBcdFx0XHRcdFx0ZXJyb3JIYW5kbGVyOiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5ob3QuX3NlbGZBY2NlcHRlZFxyXG4gXHRcdFx0XHR9KTtcclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIE5vdyBpbiBcImRpc3Bvc2VcIiBwaGFzZVxyXG4gXHRcdGhvdFNldFN0YXR1cyhcImRpc3Bvc2VcIik7XHJcbiBcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLnNsaWNlKCk7XHJcbiBcdFx0d2hpbGUocXVldWUubGVuZ3RoID4gMCkge1xyXG4gXHRcdFx0dmFyIG1vZHVsZUlkID0gcXVldWUucG9wKCk7XHJcbiBcdFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRpZighbW9kdWxlKSBjb250aW51ZTtcclxuIFx0XHJcbiBcdFx0XHR2YXIgZGF0YSA9IHt9O1xyXG4gXHRcclxuIFx0XHRcdC8vIENhbGwgZGlzcG9zZSBoYW5kbGVyc1xyXG4gXHRcdFx0dmFyIGRpc3Bvc2VIYW5kbGVycyA9IG1vZHVsZS5ob3QuX2Rpc3Bvc2VIYW5kbGVycztcclxuIFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkaXNwb3NlSGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcclxuIFx0XHRcdFx0dmFyIGNiID0gZGlzcG9zZUhhbmRsZXJzW2pdO1xyXG4gXHRcdFx0XHRjYihkYXRhKTtcclxuIFx0XHRcdH1cclxuIFx0XHRcdGhvdEN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXSA9IGRhdGE7XHJcbiBcdFxyXG4gXHRcdFx0Ly8gZGlzYWJsZSBtb2R1bGUgKHRoaXMgZGlzYWJsZXMgcmVxdWlyZXMgZnJvbSB0aGlzIG1vZHVsZSlcclxuIFx0XHRcdG1vZHVsZS5ob3QuYWN0aXZlID0gZmFsc2U7XHJcbiBcdFxyXG4gXHRcdFx0Ly8gcmVtb3ZlIG1vZHVsZSBmcm9tIGNhY2hlXHJcbiBcdFx0XHRkZWxldGUgaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XHJcbiBcdFxyXG4gXHRcdFx0Ly8gcmVtb3ZlIFwicGFyZW50c1wiIHJlZmVyZW5jZXMgZnJvbSBhbGwgY2hpbGRyZW5cclxuIFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBtb2R1bGUuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcclxuIFx0XHRcdFx0dmFyIGNoaWxkID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGUuY2hpbGRyZW5bal1dO1xyXG4gXHRcdFx0XHRpZighY2hpbGQpIGNvbnRpbnVlO1xyXG4gXHRcdFx0XHR2YXIgaWR4ID0gY2hpbGQucGFyZW50cy5pbmRleE9mKG1vZHVsZUlkKTtcclxuIFx0XHRcdFx0aWYoaWR4ID49IDApIHtcclxuIFx0XHRcdFx0XHRjaGlsZC5wYXJlbnRzLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyByZW1vdmUgb3V0ZGF0ZWQgZGVwZW5kZW5jeSBmcm9tIG1vZHVsZSBjaGlsZHJlblxyXG4gXHRcdGZvcih2YXIgbW9kdWxlSWQgaW4gb3V0ZGF0ZWREZXBlbmRlbmNpZXMpIHtcclxuIFx0XHRcdGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcclxuIFx0XHRcdFx0dmFyIG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzID0gb3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBqKyspIHtcclxuIFx0XHRcdFx0XHR2YXIgZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2pdO1xyXG4gXHRcdFx0XHRcdHZhciBpZHggPSBtb2R1bGUuY2hpbGRyZW4uaW5kZXhPZihkZXBlbmRlbmN5KTtcclxuIFx0XHRcdFx0XHRpZihpZHggPj0gMCkgbW9kdWxlLmNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBOb3QgaW4gXCJhcHBseVwiIHBoYXNlXHJcbiBcdFx0aG90U2V0U3RhdHVzKFwiYXBwbHlcIik7XHJcbiBcdFxyXG4gXHRcdGhvdEN1cnJlbnRIYXNoID0gaG90VXBkYXRlTmV3SGFzaDtcclxuIFx0XHJcbiBcdFx0Ly8gaW5zZXJ0IG5ldyBjb2RlXHJcbiBcdFx0Zm9yKHZhciBtb2R1bGVJZCBpbiBhcHBsaWVkVXBkYXRlKSB7XHJcbiBcdFx0XHRpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXBwbGllZFVwZGF0ZSwgbW9kdWxlSWQpKSB7XHJcbiBcdFx0XHRcdG1vZHVsZXNbbW9kdWxlSWRdID0gYXBwbGllZFVwZGF0ZVttb2R1bGVJZF07XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBjYWxsIGFjY2VwdCBoYW5kbGVyc1xyXG4gXHRcdHZhciBlcnJvciA9IG51bGw7XHJcbiBcdFx0Zm9yKHZhciBtb2R1bGVJZCBpbiBvdXRkYXRlZERlcGVuZGVuY2llcykge1xyXG4gXHRcdFx0aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZCkpIHtcclxuIFx0XHRcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xyXG4gXHRcdFx0XHR2YXIgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XHJcbiBcdFx0XHRcdHZhciBjYWxsYmFja3MgPSBbXTtcclxuIFx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiBcdFx0XHRcdFx0dmFyIGRlcGVuZGVuY3kgPSBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tpXTtcclxuIFx0XHRcdFx0XHR2YXIgY2IgPSBtb2R1bGUuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBlbmRlbmN5XTtcclxuIFx0XHRcdFx0XHRpZihjYWxsYmFja3MuaW5kZXhPZihjYikgPj0gMCkgY29udGludWU7XHJcbiBcdFx0XHRcdFx0Y2FsbGJhY2tzLnB1c2goY2IpO1xyXG4gXHRcdFx0XHR9XHJcbiBcdFx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuIFx0XHRcdFx0XHR2YXIgY2IgPSBjYWxsYmFja3NbaV07XHJcbiBcdFx0XHRcdFx0dHJ5IHtcclxuIFx0XHRcdFx0XHRcdGNiKG91dGRhdGVkRGVwZW5kZW5jaWVzKTtcclxuIFx0XHRcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRcdFx0aWYoIWVycm9yKVxyXG4gXHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH1cclxuIFx0XHRcdH1cclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdC8vIExvYWQgc2VsZiBhY2NlcHRlZCBtb2R1bGVzXHJcbiBcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG4gXHRcdFx0dmFyIGl0ZW0gPSBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXNbaV07XHJcbiBcdFx0XHR2YXIgbW9kdWxlSWQgPSBpdGVtLm1vZHVsZTtcclxuIFx0XHRcdGhvdEN1cnJlbnRQYXJlbnRzID0gW21vZHVsZUlkXTtcclxuIFx0XHRcdHRyeSB7XHJcbiBcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpO1xyXG4gXHRcdFx0fSBjYXRjaChlcnIpIHtcclxuIFx0XHRcdFx0aWYodHlwZW9mIGl0ZW0uZXJyb3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcclxuIFx0XHRcdFx0XHR0cnkge1xyXG4gXHRcdFx0XHRcdFx0aXRlbS5lcnJvckhhbmRsZXIoZXJyKTtcclxuIFx0XHRcdFx0XHR9IGNhdGNoKGVycikge1xyXG4gXHRcdFx0XHRcdFx0aWYoIWVycm9yKVxyXG4gXHRcdFx0XHRcdFx0XHRlcnJvciA9IGVycjtcclxuIFx0XHRcdFx0XHR9XHJcbiBcdFx0XHRcdH0gZWxzZSBpZighZXJyb3IpXHJcbiBcdFx0XHRcdFx0ZXJyb3IgPSBlcnI7XHJcbiBcdFx0XHR9XHJcbiBcdFx0fVxyXG4gXHRcclxuIFx0XHQvLyBoYW5kbGUgZXJyb3JzIGluIGFjY2VwdCBoYW5kbGVycyBhbmQgc2VsZiBhY2NlcHRlZCBtb2R1bGUgbG9hZFxyXG4gXHRcdGlmKGVycm9yKSB7XHJcbiBcdFx0XHRob3RTZXRTdGF0dXMoXCJmYWlsXCIpO1xyXG4gXHRcdFx0cmV0dXJuIGNhbGxiYWNrKGVycm9yKTtcclxuIFx0XHR9XHJcbiBcdFxyXG4gXHRcdGhvdFNldFN0YXR1cyhcImlkbGVcIik7XHJcbiBcdFx0Y2FsbGJhY2sobnVsbCwgb3V0ZGF0ZWRNb2R1bGVzKTtcclxuIFx0fVxyXG5cbiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZSxcbiBcdFx0XHRob3Q6IGhvdENyZWF0ZU1vZHVsZShtb2R1bGVJZCksXG4gXHRcdFx0cGFyZW50czogaG90Q3VycmVudFBhcmVudHMsXG4gXHRcdFx0Y2hpbGRyZW46IFtdXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuIFx0Ly8gX193ZWJwYWNrX2hhc2hfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5oID0gZnVuY3Rpb24oKSB7IHJldHVybiBob3RDdXJyZW50SGFzaDsgfTtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gaG90Q3JlYXRlUmVxdWlyZSgwKSgwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA0NzhmYzYzNDQ4ZDBjMDk5ZmQ0MCIsImltcG9ydCB7IFBhcnRpYWxPYnNlcnZlciB9IGZyb20gJy4vT2JzZXJ2ZXInO1xuaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuL09wZXJhdG9yJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBBbm9ueW1vdXNTdWJzY3JpcHRpb24sIFRlYXJkb3duTG9naWMgfSBmcm9tICcuL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyByb290IH0gZnJvbSAnLi91dGlsL3Jvb3QnO1xuaW1wb3J0IHsgdG9TdWJzY3JpYmVyIH0gZnJvbSAnLi91dGlsL3RvU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBJZk9ic2VydmFibGUgfSBmcm9tICcuL29ic2VydmFibGUvSWZPYnNlcnZhYmxlJztcbmltcG9ydCB7IEVycm9yT2JzZXJ2YWJsZSB9IGZyb20gJy4vb2JzZXJ2YWJsZS9FcnJvck9ic2VydmFibGUnO1xuaW1wb3J0IHsgb2JzZXJ2YWJsZSBhcyBTeW1ib2xfb2JzZXJ2YWJsZSB9IGZyb20gJy4vc3ltYm9sL29ic2VydmFibGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFN1YnNjcmliYWJsZTxUPiB7XG4gIHN1YnNjcmliZShvYnNlcnZlck9yTmV4dD86IFBhcnRpYWxPYnNlcnZlcjxUPiB8ICgodmFsdWU6IFQpID0+IHZvaWQpLFxuICAgICAgICAgICAgZXJyb3I/OiAoZXJyb3I6IGFueSkgPT4gdm9pZCxcbiAgICAgICAgICAgIGNvbXBsZXRlPzogKCkgPT4gdm9pZCk6IEFub255bW91c1N1YnNjcmlwdGlvbjtcbn1cblxuZXhwb3J0IHR5cGUgU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQ+ID0gU3Vic2NyaWJhYmxlPFQ+IHwgUHJvbWlzZUxpa2U8VD47XG5leHBvcnQgdHlwZSBPYnNlcnZhYmxlSW5wdXQ8VD4gPSBTdWJzY3JpYmFibGVPclByb21pc2U8VD4gfCBBcnJheUxpa2U8VD47XG5cbi8qKlxuICogQSByZXByZXNlbnRhdGlvbiBvZiBhbnkgc2V0IG9mIHZhbHVlcyBvdmVyIGFueSBhbW91bnQgb2YgdGltZS4gVGhpcyB0aGUgbW9zdCBiYXNpYyBidWlsZGluZyBibG9ja1xuICogb2YgUnhKUy5cbiAqXG4gKiBAY2xhc3MgT2JzZXJ2YWJsZTxUPlxuICovXG5leHBvcnQgY2xhc3MgT2JzZXJ2YWJsZTxUPiBpbXBsZW1lbnRzIFN1YnNjcmliYWJsZTxUPiB7XG5cbiAgcHVibGljIF9pc1NjYWxhcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHByb3RlY3RlZCBzb3VyY2U6IE9ic2VydmFibGU8YW55PjtcbiAgcHJvdGVjdGVkIG9wZXJhdG9yOiBPcGVyYXRvcjxhbnksIFQ+O1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3Vic2NyaWJlIHRoZSBmdW5jdGlvbiB0aGF0IGlzICBjYWxsZWQgd2hlbiB0aGUgT2JzZXJ2YWJsZSBpc1xuICAgKiBpbml0aWFsbHkgc3Vic2NyaWJlZCB0by4gVGhpcyBmdW5jdGlvbiBpcyBnaXZlbiBhIFN1YnNjcmliZXIsIHRvIHdoaWNoIG5ldyB2YWx1ZXNcbiAgICogY2FuIGJlIGBuZXh0YGVkLCBvciBhbiBgZXJyb3JgIG1ldGhvZCBjYW4gYmUgY2FsbGVkIHRvIHJhaXNlIGFuIGVycm9yLCBvclxuICAgKiBgY29tcGxldGVgIGNhbiBiZSBjYWxsZWQgdG8gbm90aWZ5IG9mIGEgc3VjY2Vzc2Z1bCBjb21wbGV0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3Vic2NyaWJlPzogKHRoaXM6IE9ic2VydmFibGU8VD4sIHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4pID0+IFRlYXJkb3duTG9naWMpIHtcbiAgICBpZiAoc3Vic2NyaWJlKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgfVxuICB9XG5cbiAgLy8gSEFDSzogU2luY2UgVHlwZVNjcmlwdCBpbmhlcml0cyBzdGF0aWMgcHJvcGVydGllcyB0b28sIHdlIGhhdmUgdG9cbiAgLy8gZmlnaHQgYWdhaW5zdCBUeXBlU2NyaXB0IGhlcmUgc28gU3ViamVjdCBjYW4gaGF2ZSBhIGRpZmZlcmVudCBzdGF0aWMgY3JlYXRlIHNpZ25hdHVyZVxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBjb2xkIE9ic2VydmFibGUgYnkgY2FsbGluZyB0aGUgT2JzZXJ2YWJsZSBjb25zdHJ1Y3RvclxuICAgKiBAc3RhdGljIHRydWVcbiAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICogQG1ldGhvZCBjcmVhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3Vic2NyaWJlPyB0aGUgc3Vic2NyaWJlciBmdW5jdGlvbiB0byBiZSBwYXNzZWQgdG8gdGhlIE9ic2VydmFibGUgY29uc3RydWN0b3JcbiAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYSBuZXcgY29sZCBvYnNlcnZhYmxlXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlOiBGdW5jdGlvbiA9IDxUPihzdWJzY3JpYmU/OiAoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPikgPT4gVGVhcmRvd25Mb2dpYykgPT4ge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZTxUPihzdWJzY3JpYmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgT2JzZXJ2YWJsZSwgd2l0aCB0aGlzIE9ic2VydmFibGUgYXMgdGhlIHNvdXJjZSwgYW5kIHRoZSBwYXNzZWRcbiAgICogb3BlcmF0b3IgZGVmaW5lZCBhcyB0aGUgbmV3IG9ic2VydmFibGUncyBvcGVyYXRvci5cbiAgICogQG1ldGhvZCBsaWZ0XG4gICAqIEBwYXJhbSB7T3BlcmF0b3J9IG9wZXJhdG9yIHRoZSBvcGVyYXRvciBkZWZpbmluZyB0aGUgb3BlcmF0aW9uIHRvIHRha2Ugb24gdGhlIG9ic2VydmFibGVcbiAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gYSBuZXcgb2JzZXJ2YWJsZSB3aXRoIHRoZSBPcGVyYXRvciBhcHBsaWVkXG4gICAqL1xuICBsaWZ0PFI+KG9wZXJhdG9yOiBPcGVyYXRvcjxULCBSPik6IE9ic2VydmFibGU8Uj4ge1xuICAgIGNvbnN0IG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZTxSPigpO1xuICAgIG9ic2VydmFibGUuc291cmNlID0gdGhpcztcbiAgICBvYnNlcnZhYmxlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gICAgcmV0dXJuIG9ic2VydmFibGU7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGhhbmRsZXJzIGZvciBoYW5kbGluZyBlbWl0dGVkIHZhbHVlcywgZXJyb3IgYW5kIGNvbXBsZXRpb25zIGZyb20gdGhlIG9ic2VydmFibGUsIGFuZFxuICAgKiAgZXhlY3V0ZXMgdGhlIG9ic2VydmFibGUncyBzdWJzY3JpYmVyIGZ1bmN0aW9uLCB3aGljaCB3aWxsIHRha2UgYWN0aW9uIHRvIHNldCB1cCB0aGUgdW5kZXJseWluZyBkYXRhIHN0cmVhbVxuICAgKiBAbWV0aG9kIHN1YnNjcmliZVxuICAgKiBAcGFyYW0ge1BhcnRpYWxPYnNlcnZlcnxGdW5jdGlvbn0gb2JzZXJ2ZXJPck5leHQgKG9wdGlvbmFsKSBlaXRoZXIgYW4gb2JzZXJ2ZXIgZGVmaW5pbmcgYWxsIGZ1bmN0aW9ucyB0byBiZSBjYWxsZWQsXG4gICAqICBvciB0aGUgZmlyc3Qgb2YgdGhyZWUgcG9zc2libGUgaGFuZGxlcnMsIHdoaWNoIGlzIHRoZSBoYW5kbGVyIGZvciBlYWNoIHZhbHVlIGVtaXR0ZWQgZnJvbSB0aGUgb2JzZXJ2YWJsZS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXJyb3IgKG9wdGlvbmFsKSBhIGhhbmRsZXIgZm9yIGEgdGVybWluYWwgZXZlbnQgcmVzdWx0aW5nIGZyb20gYW4gZXJyb3IuIElmIG5vIGVycm9yIGhhbmRsZXIgaXMgcHJvdmlkZWQsXG4gICAqICB0aGUgZXJyb3Igd2lsbCBiZSB0aHJvd24gYXMgdW5oYW5kbGVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBsZXRlIChvcHRpb25hbCkgYSBoYW5kbGVyIGZvciBhIHRlcm1pbmFsIGV2ZW50IHJlc3VsdGluZyBmcm9tIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi5cbiAgICogQHJldHVybiB7SVN1YnNjcmlwdGlvbn0gYSBzdWJzY3JpcHRpb24gcmVmZXJlbmNlIHRvIHRoZSByZWdpc3RlcmVkIGhhbmRsZXJzXG4gICAqL1xuICBzdWJzY3JpYmUoKTogU3Vic2NyaXB0aW9uO1xuICBzdWJzY3JpYmUob2JzZXJ2ZXI6IFBhcnRpYWxPYnNlcnZlcjxUPik6IFN1YnNjcmlwdGlvbjtcbiAgc3Vic2NyaWJlKG5leHQ/OiAodmFsdWU6IFQpID0+IHZvaWQsIGVycm9yPzogKGVycm9yOiBhbnkpID0+IHZvaWQsIGNvbXBsZXRlPzogKCkgPT4gdm9pZCk6IFN1YnNjcmlwdGlvbjtcbiAgc3Vic2NyaWJlKG9ic2VydmVyT3JOZXh0PzogUGFydGlhbE9ic2VydmVyPFQ+IHwgKCh2YWx1ZTogVCkgPT4gdm9pZCksXG4gICAgICAgICAgICBlcnJvcj86IChlcnJvcjogYW55KSA9PiB2b2lkLFxuICAgICAgICAgICAgY29tcGxldGU/OiAoKSA9PiB2b2lkKTogU3Vic2NyaXB0aW9uIHtcblxuICAgIGNvbnN0IHsgb3BlcmF0b3IgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2luayA9IHRvU3Vic2NyaWJlcihvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcblxuICAgIGlmIChvcGVyYXRvcikge1xuICAgICAgb3BlcmF0b3IuY2FsbChzaW5rLCB0aGlzLnNvdXJjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpbmsuYWRkKHRoaXMuX3RyeVN1YnNjcmliZShzaW5rKSk7XG4gICAgfVxuXG4gICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICBzaW5rLnN5bmNFcnJvclRocm93YWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgIHRocm93IHNpbmsuc3luY0Vycm9yVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpbms7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3RyeVN1YnNjcmliZShzaW5rOiBTdWJzY3JpYmVyPFQ+KTogVGVhcmRvd25Mb2dpYyB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUoc2luayk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzaW5rLnN5bmNFcnJvclRocm93biA9IHRydWU7XG4gICAgICBzaW5rLnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgc2luay5lcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGZvckVhY2hcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbmV4dCBhIGhhbmRsZXIgZm9yIGVhY2ggdmFsdWUgZW1pdHRlZCBieSB0aGUgb2JzZXJ2YWJsZVxuICAgKiBAcGFyYW0ge1Byb21pc2VDb25zdHJ1Y3Rvcn0gW1Byb21pc2VDdG9yXSBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHVzZWQgdG8gaW5zdGFudGlhdGUgdGhlIFByb21pc2VcbiAgICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgZWl0aGVyIHJlc29sdmVzIG9uIG9ic2VydmFibGUgY29tcGxldGlvbiBvclxuICAgKiAgcmVqZWN0cyB3aXRoIHRoZSBoYW5kbGVkIGVycm9yXG4gICAqL1xuICBmb3JFYWNoKG5leHQ6ICh2YWx1ZTogVCkgPT4gdm9pZCwgUHJvbWlzZUN0b3I/OiB0eXBlb2YgUHJvbWlzZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghUHJvbWlzZUN0b3IpIHtcbiAgICAgIGlmIChyb290LlJ4ICYmIHJvb3QuUnguY29uZmlnICYmIHJvb3QuUnguY29uZmlnLlByb21pc2UpIHtcbiAgICAgICAgUHJvbWlzZUN0b3IgPSByb290LlJ4LmNvbmZpZy5Qcm9taXNlO1xuICAgICAgfSBlbHNlIGlmIChyb290LlByb21pc2UpIHtcbiAgICAgICAgUHJvbWlzZUN0b3IgPSByb290LlByb21pc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFQcm9taXNlQ3Rvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBQcm9taXNlIGltcGwgZm91bmQnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2VDdG9yPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIE11c3QgYmUgZGVjbGFyZWQgaW4gYSBzZXBhcmF0ZSBzdGF0ZW1lbnQgdG8gYXZvaWQgYSBSZWZlcm5jZUVycm9yIHdoZW5cbiAgICAgIC8vIGFjY2Vzc2luZyBzdWJzY3JpcHRpb24gYmVsb3cgaW4gdGhlIGNsb3N1cmUgZHVlIHRvIFRlbXBvcmFsIERlYWQgWm9uZS5cbiAgICAgIGxldCBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgICAgIHN1YnNjcmlwdGlvbiA9IHRoaXMuc3Vic2NyaWJlKCh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBzdWJzY3JpcHRpb24sIHRoZW4gd2UgY2FuIHN1cm1pc2VcbiAgICAgICAgICAvLyB0aGUgbmV4dCBoYW5kbGluZyBpcyBhc3luY2hyb25vdXMuIEFueSBlcnJvcnMgdGhyb3duXG4gICAgICAgICAgLy8gbmVlZCB0byBiZSByZWplY3RlZCBleHBsaWNpdGx5IGFuZCB1bnN1YnNjcmliZSBtdXN0IGJlXG4gICAgICAgICAgLy8gY2FsbGVkIG1hbnVhbGx5XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5leHQodmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgdGhlcmUgaXMgTk8gc3Vic2NyaXB0aW9uLCB0aGVuIHdlJ3JlIGdldHRpbmcgYSBuZXh0ZWRcbiAgICAgICAgICAvLyB2YWx1ZSBzeW5jaHJvbm91c2x5IGR1cmluZyBzdWJzY3JpcHRpb24uIFdlIGNhbiBqdXN0IGNhbGwgaXQuXG4gICAgICAgICAgLy8gSWYgaXQgZXJyb3JzLCBPYnNlcnZhYmxlJ3MgYHN1YnNjcmliZWAgd2lsbCBlbnN1cmUgdGhlXG4gICAgICAgICAgLy8gdW5zdWJzY3JpcHRpb24gbG9naWMgaXMgY2FsbGVkLCB0aGVuIHN5bmNocm9ub3VzbHkgcmV0aHJvdyB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gQWZ0ZXIgdGhhdCwgUHJvbWlzZSB3aWxsIHRyYXAgdGhlIGVycm9yIGFuZCBzZW5kIGl0XG4gICAgICAgICAgLy8gZG93biB0aGUgcmVqZWN0aW9uIHBhdGguXG4gICAgICAgICAgbmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHJlamVjdCwgcmVzb2x2ZSk7XG4gICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3N1YnNjcmliZShzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPGFueT4pOiBUZWFyZG93bkxvZ2ljIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICB9XG5cbiAgLy8gYGlmYCBhbmQgYHRocm93YCBhcmUgc3BlY2lhbCBzbm93IGZsYWtlcywgdGhlIGNvbXBpbGVyIHNlZXMgdGhlbSBhcyByZXNlcnZlZCB3b3Jkc1xuICBzdGF0aWMgaWY6IHR5cGVvZiBJZk9ic2VydmFibGUuY3JlYXRlO1xuICBzdGF0aWMgdGhyb3c6IHR5cGVvZiBFcnJvck9ic2VydmFibGUuY3JlYXRlO1xuXG4gIC8qKlxuICAgKiBBbiBpbnRlcm9wIHBvaW50IGRlZmluZWQgYnkgdGhlIGVzNy1vYnNlcnZhYmxlIHNwZWMgaHR0cHM6Ly9naXRodWIuY29tL3plbnBhcnNpbmcvZXMtb2JzZXJ2YWJsZVxuICAgKiBAbWV0aG9kIFN5bWJvbC5vYnNlcnZhYmxlXG4gICAqIEByZXR1cm4ge09ic2VydmFibGV9IHRoaXMgaW5zdGFuY2Ugb2YgdGhlIG9ic2VydmFibGVcbiAgICovXG4gIFtTeW1ib2xfb2JzZXJ2YWJsZV0oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvT2JzZXJ2YWJsZS50cyIsImltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuL3V0aWwvaXNGdW5jdGlvbic7XG5pbXBvcnQgeyBPYnNlcnZlciwgUGFydGlhbE9ic2VydmVyIH0gZnJvbSAnLi9PYnNlcnZlcic7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBlbXB0eSBhcyBlbXB0eU9ic2VydmVyIH0gZnJvbSAnLi9PYnNlcnZlcic7XG5pbXBvcnQgeyByeFN1YnNjcmliZXIgYXMgcnhTdWJzY3JpYmVyU3ltYm9sIH0gZnJvbSAnLi9zeW1ib2wvcnhTdWJzY3JpYmVyJztcblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGludGVyZmFjZSBhbmQgZXh0ZW5kcyB0aGVcbiAqIHtAbGluayBTdWJzY3JpcHRpb259IGNsYXNzLiBXaGlsZSB0aGUge0BsaW5rIE9ic2VydmVyfSBpcyB0aGUgcHVibGljIEFQSSBmb3JcbiAqIGNvbnN1bWluZyB0aGUgdmFsdWVzIG9mIGFuIHtAbGluayBPYnNlcnZhYmxlfSwgYWxsIE9ic2VydmVycyBnZXQgY29udmVydGVkIHRvXG4gKiBhIFN1YnNjcmliZXIsIGluIG9yZGVyIHRvIHByb3ZpZGUgU3Vic2NyaXB0aW9uLWxpa2UgY2FwYWJpbGl0aWVzIHN1Y2ggYXNcbiAqIGB1bnN1YnNjcmliZWAuIFN1YnNjcmliZXIgaXMgYSBjb21tb24gdHlwZSBpbiBSeEpTLCBhbmQgY3J1Y2lhbCBmb3JcbiAqIGltcGxlbWVudGluZyBvcGVyYXRvcnMsIGJ1dCBpdCBpcyByYXJlbHkgdXNlZCBhcyBhIHB1YmxpYyBBUEkuXG4gKlxuICogQGNsYXNzIFN1YnNjcmliZXI8VD5cbiAqL1xuZXhwb3J0IGNsYXNzIFN1YnNjcmliZXI8VD4gZXh0ZW5kcyBTdWJzY3JpcHRpb24gaW1wbGVtZW50cyBPYnNlcnZlcjxUPiB7XG5cbiAgW3J4U3Vic2NyaWJlclN5bWJvbF0oKSB7IHJldHVybiB0aGlzOyB9XG5cbiAgLyoqXG4gICAqIEEgc3RhdGljIGZhY3RvcnkgZm9yIGEgU3Vic2NyaWJlciwgZ2l2ZW4gYSAocG90ZW50aWFsbHkgcGFydGlhbCkgZGVmaW5pdGlvblxuICAgKiBvZiBhbiBPYnNlcnZlci5cbiAgICogQHBhcmFtIHtmdW5jdGlvbih4OiA/VCk6IHZvaWR9IFtuZXh0XSBUaGUgYG5leHRgIGNhbGxiYWNrIG9mIGFuIE9ic2VydmVyLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGU6ID9hbnkpOiB2b2lkfSBbZXJyb3JdIFRoZSBgZXJyb3JgIGNhbGxiYWNrIG9mIGFuXG4gICAqIE9ic2VydmVyLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gVGhlIGBjb21wbGV0ZWAgY2FsbGJhY2sgb2YgYW5cbiAgICogT2JzZXJ2ZXIuXG4gICAqIEByZXR1cm4ge1N1YnNjcmliZXI8VD59IEEgU3Vic2NyaWJlciB3cmFwcGluZyB0aGUgKHBhcnRpYWxseSBkZWZpbmVkKVxuICAgKiBPYnNlcnZlciByZXByZXNlbnRlZCBieSB0aGUgZ2l2ZW4gYXJndW1lbnRzLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZTxUPihuZXh0PzogKHg/OiBUKSA9PiB2b2lkLFxuICAgICAgICAgICAgICAgICAgIGVycm9yPzogKGU/OiBhbnkpID0+IHZvaWQsXG4gICAgICAgICAgICAgICAgICAgY29tcGxldGU/OiAoKSA9PiB2b2lkKTogU3Vic2NyaWJlcjxUPiB7XG4gICAgY29uc3Qgc3Vic2NyaWJlciA9IG5ldyBTdWJzY3JpYmVyKG5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgc3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUgPSBmYWxzZTtcbiAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgfVxuXG4gIHB1YmxpYyBzeW5jRXJyb3JWYWx1ZTogYW55ID0gbnVsbDtcbiAgcHVibGljIHN5bmNFcnJvclRocm93bjogYm9vbGVhbiA9IGZhbHNlO1xuICBwdWJsaWMgc3luY0Vycm9yVGhyb3dhYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJvdGVjdGVkIGlzU3RvcHBlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcm90ZWN0ZWQgZGVzdGluYXRpb246IFBhcnRpYWxPYnNlcnZlcjxhbnk+OyAvLyB0aGlzIGBhbnlgIGlzIHRoZSBlc2NhcGUgaGF0Y2ggdG8gZXJhc2UgZXh0cmEgdHlwZSBwYXJhbSAoZS5nLiBSKVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09ic2VydmVyfGZ1bmN0aW9uKHZhbHVlOiBUKTogdm9pZH0gW2Rlc3RpbmF0aW9uT3JOZXh0XSBBIHBhcnRpYWxseVxuICAgKiBkZWZpbmVkIE9ic2VydmVyIG9yIGEgYG5leHRgIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGU6ID9hbnkpOiB2b2lkfSBbZXJyb3JdIFRoZSBgZXJyb3JgIGNhbGxiYWNrIG9mIGFuXG4gICAqIE9ic2VydmVyLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFtjb21wbGV0ZV0gVGhlIGBjb21wbGV0ZWAgY2FsbGJhY2sgb2YgYW5cbiAgICogT2JzZXJ2ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbk9yTmV4dD86IFBhcnRpYWxPYnNlcnZlcjxhbnk+IHwgKCh2YWx1ZTogVCkgPT4gdm9pZCksXG4gICAgICAgICAgICAgIGVycm9yPzogKGU/OiBhbnkpID0+IHZvaWQsXG4gICAgICAgICAgICAgIGNvbXBsZXRlPzogKCkgPT4gdm9pZCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGVtcHR5T2JzZXJ2ZXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBpZiAoIWRlc3RpbmF0aW9uT3JOZXh0KSB7XG4gICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IGVtcHR5T2JzZXJ2ZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbk9yTmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAoZGVzdGluYXRpb25Pck5leHQgaW5zdGFuY2VvZiBTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RpbmF0aW9uID0gKDxTdWJzY3JpYmVyPGFueT4+IGRlc3RpbmF0aW9uT3JOZXh0KTtcbiAgICAgICAgICAgICg8YW55PiB0aGlzLmRlc3RpbmF0aW9uKS5hZGQodGhpcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgU2FmZVN1YnNjcmliZXI8VD4odGhpcywgPFBhcnRpYWxPYnNlcnZlcjxhbnk+PiBkZXN0aW5hdGlvbk9yTmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgU2FmZVN1YnNjcmliZXI8VD4odGhpcywgPCgodmFsdWU6IFQpID0+IHZvaWQpPiBkZXN0aW5hdGlvbk9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgbm90aWZpY2F0aW9ucyBvZiB0eXBlIGBuZXh0YCBmcm9tXG4gICAqIHRoZSBPYnNlcnZhYmxlLCB3aXRoIGEgdmFsdWUuIFRoZSBPYnNlcnZhYmxlIG1heSBjYWxsIHRoaXMgbWV0aG9kIDAgb3IgbW9yZVxuICAgKiB0aW1lcy5cbiAgICogQHBhcmFtIHtUfSBbdmFsdWVdIFRoZSBgbmV4dGAgdmFsdWUuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBuZXh0KHZhbHVlPzogVCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgIHRoaXMuX25leHQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFjayB0byByZWNlaXZlIG5vdGlmaWNhdGlvbnMgb2YgdHlwZSBgZXJyb3JgIGZyb21cbiAgICogdGhlIE9ic2VydmFibGUsIHdpdGggYW4gYXR0YWNoZWQge0BsaW5rIEVycm9yfS4gTm90aWZpZXMgdGhlIE9ic2VydmVyIHRoYXRcbiAgICogdGhlIE9ic2VydmFibGUgaGFzIGV4cGVyaWVuY2VkIGFuIGVycm9yIGNvbmRpdGlvbi5cbiAgICogQHBhcmFtIHthbnl9IFtlcnJdIFRoZSBgZXJyb3JgIGV4Y2VwdGlvbi5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIGVycm9yKGVycj86IGFueSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB7QGxpbmsgT2JzZXJ2ZXJ9IGNhbGxiYWNrIHRvIHJlY2VpdmUgYSB2YWx1ZWxlc3Mgbm90aWZpY2F0aW9uIG9mIHR5cGVcbiAgICogYGNvbXBsZXRlYCBmcm9tIHRoZSBPYnNlcnZhYmxlLiBOb3RpZmllcyB0aGUgT2JzZXJ2ZXIgdGhhdCB0aGUgT2JzZXJ2YWJsZVxuICAgKiBoYXMgZmluaXNoZWQgc2VuZGluZyBwdXNoLWJhc2VkIG5vdGlmaWNhdGlvbnMuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBjb21wbGV0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIHVuc3Vic2NyaWJlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgc3VwZXIudW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2Vycm9yKGVycjogYW55KTogdm9pZCB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKTogdm9pZCB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCk6IFN1YnNjcmliZXI8VD4ge1xuICAgIGNvbnN0IHsgX3BhcmVudCwgX3BhcmVudHMgfSA9IHRoaXM7XG4gICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLl9wYXJlbnRzID0gbnVsbDtcbiAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLmlzU3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BhcmVudCA9IF9wYXJlbnQ7XG4gICAgdGhpcy5fcGFyZW50cyA9IF9wYXJlbnRzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBTYWZlU3Vic2NyaWJlcjxUPiBleHRlbmRzIFN1YnNjcmliZXI8VD4ge1xuXG4gIHByaXZhdGUgX2NvbnRleHQ6IGFueTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYXJlbnRTdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+LFxuICAgICAgICAgICAgICBvYnNlcnZlck9yTmV4dD86IFBhcnRpYWxPYnNlcnZlcjxUPiB8ICgodmFsdWU6IFQpID0+IHZvaWQpLFxuICAgICAgICAgICAgICBlcnJvcj86IChlPzogYW55KSA9PiB2b2lkLFxuICAgICAgICAgICAgICBjb21wbGV0ZT86ICgpID0+IHZvaWQpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgbGV0IG5leHQ6ICgodmFsdWU6IFQpID0+IHZvaWQpO1xuICAgIGxldCBjb250ZXh0OiBhbnkgPSB0aGlzO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24ob2JzZXJ2ZXJPck5leHQpKSB7XG4gICAgICBuZXh0ID0gKDwoKHZhbHVlOiBUKSA9PiB2b2lkKT4gb2JzZXJ2ZXJPck5leHQpO1xuICAgIH0gZWxzZSBpZiAob2JzZXJ2ZXJPck5leHQpIHtcbiAgICAgIG5leHQgPSAoPFBhcnRpYWxPYnNlcnZlcjxUPj4gb2JzZXJ2ZXJPck5leHQpLm5leHQ7XG4gICAgICBlcnJvciA9ICg8UGFydGlhbE9ic2VydmVyPFQ+PiBvYnNlcnZlck9yTmV4dCkuZXJyb3I7XG4gICAgICBjb21wbGV0ZSA9ICg8UGFydGlhbE9ic2VydmVyPFQ+PiBvYnNlcnZlck9yTmV4dCkuY29tcGxldGU7XG4gICAgICBpZiAob2JzZXJ2ZXJPck5leHQgIT09IGVtcHR5T2JzZXJ2ZXIpIHtcbiAgICAgICAgY29udGV4dCA9IE9iamVjdC5jcmVhdGUob2JzZXJ2ZXJPck5leHQpO1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihjb250ZXh0LnVuc3Vic2NyaWJlKSkge1xuICAgICAgICAgIHRoaXMuYWRkKDwoKSA9PiB2b2lkPiBjb250ZXh0LnVuc3Vic2NyaWJlLmJpbmQoY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQudW5zdWJzY3JpYmUgPSB0aGlzLnVuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5fbmV4dCA9IG5leHQ7XG4gICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICB0aGlzLl9jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICB9XG5cbiAgbmV4dCh2YWx1ZT86IFQpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkICYmIHRoaXMuX25leHQpIHtcbiAgICAgIGNvbnN0IHsgX3BhcmVudFN1YnNjcmliZXIgfSA9IHRoaXM7XG4gICAgICBpZiAoIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9uZXh0LCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX190cnlPclNldEVycm9yKF9wYXJlbnRTdWJzY3JpYmVyLCB0aGlzLl9uZXh0LCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVycm9yKGVycj86IGFueSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgIGNvbnN0IHsgX3BhcmVudFN1YnNjcmliZXIgfSA9IHRoaXM7XG4gICAgICBpZiAodGhpcy5fZXJyb3IpIHtcbiAgICAgICAgaWYgKCFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9lcnJvciwgZXJyKTtcbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX3RyeU9yU2V0RXJyb3IoX3BhcmVudFN1YnNjcmliZXIsIHRoaXMuX2Vycm9yLCBlcnIpO1xuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgIF9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93biA9IHRydWU7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb21wbGV0ZSgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICBjb25zdCB7IF9wYXJlbnRTdWJzY3JpYmVyIH0gPSB0aGlzO1xuICAgICAgaWYgKHRoaXMuX2NvbXBsZXRlKSB7XG4gICAgICAgIGlmICghX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fY29tcGxldGUpO1xuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50U3Vic2NyaWJlciwgdGhpcy5fY29tcGxldGUpO1xuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX190cnlPclVuc3ViKGZuOiBGdW5jdGlvbiwgdmFsdWU/OiBhbnkpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgZm4uY2FsbCh0aGlzLl9jb250ZXh0LCB2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfX3RyeU9yU2V0RXJyb3IocGFyZW50OiBTdWJzY3JpYmVyPFQ+LCBmbjogRnVuY3Rpb24sIHZhbHVlPzogYW55KTogYm9vbGVhbiB7XG4gICAgdHJ5IHtcbiAgICAgIGZuLmNhbGwodGhpcy5fY29udGV4dCwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcGFyZW50LnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgcGFyZW50LnN5bmNFcnJvclRocm93biA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJvdGVjdGVkIF91bnN1YnNjcmliZSgpOiB2b2lkIHtcbiAgICBjb25zdCB7IF9wYXJlbnRTdWJzY3JpYmVyIH0gPSB0aGlzO1xuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBudWxsO1xuICAgIF9wYXJlbnRTdWJzY3JpYmVyLnVuc3Vic2NyaWJlKCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvU3Vic2NyaWJlci50cyIsImltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgSW5uZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi9Jbm5lclN1YnNjcmliZXInO1xuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuZXhwb3J0IGNsYXNzIE91dGVyU3Vic2NyaWJlcjxULCBSPiBleHRlbmRzIFN1YnNjcmliZXI8VD4ge1xuICBub3RpZnlOZXh0KG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IFIsXG4gICAgICAgICAgICAgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICAgaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBSPik6IHZvaWQge1xuICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgfVxuXG4gIG5vdGlmeUVycm9yKGVycm9yOiBhbnksIGlubmVyU3ViOiBJbm5lclN1YnNjcmliZXI8VCwgUj4pOiB2b2lkIHtcbiAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yKTtcbiAgfVxuXG4gIG5vdGlmeUNvbXBsZXRlKGlubmVyU3ViOiBJbm5lclN1YnNjcmliZXI8VCwgUj4pOiB2b2lkIHtcbiAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvT3V0ZXJTdWJzY3JpYmVyLnRzIiwiaW1wb3J0IHsgcm9vdCB9IGZyb20gJy4vcm9vdCc7XG5pbXBvcnQgeyBpc0FycmF5TGlrZSB9IGZyb20gJy4vaXNBcnJheUxpa2UnO1xuaW1wb3J0IHsgaXNQcm9taXNlIH0gZnJvbSAnLi9pc1Byb21pc2UnO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICcuL2lzT2JqZWN0JztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmFibGVJbnB1dCB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgaXRlcmF0b3IgYXMgU3ltYm9sX2l0ZXJhdG9yIH0gZnJvbSAnLi4vc3ltYm9sL2l0ZXJhdG9yJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBJbm5lclN1YnNjcmliZXIgfSBmcm9tICcuLi9Jbm5lclN1YnNjcmliZXInO1xuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vT3V0ZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IG9ic2VydmFibGUgYXMgU3ltYm9sX29ic2VydmFibGUgfSBmcm9tICcuLi9zeW1ib2wvb2JzZXJ2YWJsZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJzY3JpYmVUb1Jlc3VsdDxULCBSPihvdXRlclN1YnNjcmliZXI6IE91dGVyU3Vic2NyaWJlcjxULCBSPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGFueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlclZhbHVlPzogVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckluZGV4PzogbnVtYmVyKTogU3Vic2NyaXB0aW9uO1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnNjcmliZVRvUmVzdWx0PFQ+KG91dGVyU3Vic2NyaWJlcjogT3V0ZXJTdWJzY3JpYmVyPGFueSwgYW55PixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IE9ic2VydmFibGVJbnB1dDxUPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlclZhbHVlPzogVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckluZGV4PzogbnVtYmVyKTogU3Vic2NyaXB0aW9uIHtcbiAgbGV0IGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPGFueT4gPSBuZXcgSW5uZXJTdWJzY3JpYmVyKG91dGVyU3Vic2NyaWJlciwgb3V0ZXJWYWx1ZSwgb3V0ZXJJbmRleCk7XG5cbiAgaWYgKGRlc3RpbmF0aW9uLmNsb3NlZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICBpZiAocmVzdWx0Ll9pc1NjYWxhcikge1xuICAgICAgZGVzdGluYXRpb24ubmV4dCgoPGFueT5yZXN1bHQpLnZhbHVlKTtcbiAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdC5zdWJzY3JpYmUoZGVzdGluYXRpb24pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0FycmF5TGlrZShyZXN1bHQpKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsZW4gJiYgIWRlc3RpbmF0aW9uLmNsb3NlZDsgaSsrKSB7XG4gICAgICBkZXN0aW5hdGlvbi5uZXh0KHJlc3VsdFtpXSk7XG4gICAgfVxuICAgIGlmICghZGVzdGluYXRpb24uY2xvc2VkKSB7XG4gICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1Byb21pc2UocmVzdWx0KSkge1xuICAgIHJlc3VsdC50aGVuKFxuICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICghZGVzdGluYXRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgZGVzdGluYXRpb24ubmV4dCg8YW55PnZhbHVlKTtcbiAgICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgKGVycjogYW55KSA9PiBkZXN0aW5hdGlvbi5lcnJvcihlcnIpXG4gICAgKVxuICAgIC50aGVuKG51bGwsIChlcnI6IGFueSkgPT4ge1xuICAgICAgLy8gRXNjYXBpbmcgdGhlIFByb21pc2UgdHJhcDogZ2xvYmFsbHkgdGhyb3cgdW5oYW5kbGVkIGVycm9yc1xuICAgICAgcm9vdC5zZXRUaW1lb3V0KCgpID0+IHsgdGhyb3cgZXJyOyB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVzdGluYXRpb247XG4gIH0gZWxzZSBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHRbU3ltYm9sX2l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gPGFueT5yZXN1bHRbU3ltYm9sX2l0ZXJhdG9yXSgpO1xuICAgIGRvIHtcbiAgICAgIGxldCBpdGVtID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKGl0ZW0uZG9uZSkge1xuICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlc3RpbmF0aW9uLm5leHQoaXRlbS52YWx1ZSk7XG4gICAgICBpZiAoZGVzdGluYXRpb24uY2xvc2VkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKHRydWUpO1xuICB9IGVsc2UgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0W1N5bWJvbF9vYnNlcnZhYmxlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IG9icyA9IHJlc3VsdFtTeW1ib2xfb2JzZXJ2YWJsZV0oKTtcbiAgICBpZiAodHlwZW9mIG9icy5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRlc3RpbmF0aW9uLmVycm9yKG5ldyBUeXBlRXJyb3IoJ1Byb3ZpZGVkIG9iamVjdCBkb2VzIG5vdCBjb3JyZWN0bHkgaW1wbGVtZW50IFN5bWJvbC5vYnNlcnZhYmxlJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gb2JzLnN1YnNjcmliZShuZXcgSW5uZXJTdWJzY3JpYmVyKG91dGVyU3Vic2NyaWJlciwgb3V0ZXJWYWx1ZSwgb3V0ZXJJbmRleCkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2YWx1ZSA9IGlzT2JqZWN0KHJlc3VsdCkgPyAnYW4gaW52YWxpZCBvYmplY3QnIDogYCcke3Jlc3VsdH0nYDtcbiAgICBjb25zdCBtc2cgPSBgWW91IHByb3ZpZGVkICR7dmFsdWV9IHdoZXJlIGEgc3RyZWFtIHdhcyBleHBlY3RlZC5gXG4gICAgICArICcgWW91IGNhbiBwcm92aWRlIGFuIE9ic2VydmFibGUsIFByb21pc2UsIEFycmF5LCBvciBJdGVyYWJsZS4nO1xuICAgIGRlc3RpbmF0aW9uLmVycm9yKG5ldyBUeXBlRXJyb3IobXNnKSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQudHMiLCJpbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi91dGlsL2lzQXJyYXknO1xuaW1wb3J0IHsgaXNPYmplY3QgfSBmcm9tICcuL3V0aWwvaXNPYmplY3QnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4vdXRpbC9pc0Z1bmN0aW9uJztcbmltcG9ydCB7IHRyeUNhdGNoIH0gZnJvbSAnLi91dGlsL3RyeUNhdGNoJztcbmltcG9ydCB7IGVycm9yT2JqZWN0IH0gZnJvbSAnLi91dGlsL2Vycm9yT2JqZWN0JztcbmltcG9ydCB7IFVuc3Vic2NyaXB0aW9uRXJyb3IgfSBmcm9tICcuL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQW5vbnltb3VzU3Vic2NyaXB0aW9uIHtcbiAgdW5zdWJzY3JpYmUoKTogdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgVGVhcmRvd25Mb2dpYyA9IEFub255bW91c1N1YnNjcmlwdGlvbiB8IEZ1bmN0aW9uIHwgdm9pZDtcblxuZXhwb3J0IGludGVyZmFjZSBJU3Vic2NyaXB0aW9uIGV4dGVuZHMgQW5vbnltb3VzU3Vic2NyaXB0aW9uIHtcbiAgdW5zdWJzY3JpYmUoKTogdm9pZDtcbiAgcmVhZG9ubHkgY2xvc2VkOiBib29sZWFuO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBkaXNwb3NhYmxlIHJlc291cmNlLCBzdWNoIGFzIHRoZSBleGVjdXRpb24gb2YgYW4gT2JzZXJ2YWJsZS4gQVxuICogU3Vic2NyaXB0aW9uIGhhcyBvbmUgaW1wb3J0YW50IG1ldGhvZCwgYHVuc3Vic2NyaWJlYCwgdGhhdCB0YWtlcyBubyBhcmd1bWVudFxuICogYW5kIGp1c3QgZGlzcG9zZXMgdGhlIHJlc291cmNlIGhlbGQgYnkgdGhlIHN1YnNjcmlwdGlvbi5cbiAqXG4gKiBBZGRpdGlvbmFsbHksIHN1YnNjcmlwdGlvbnMgbWF5IGJlIGdyb3VwZWQgdG9nZXRoZXIgdGhyb3VnaCB0aGUgYGFkZCgpYFxuICogbWV0aG9kLCB3aGljaCB3aWxsIGF0dGFjaCBhIGNoaWxkIFN1YnNjcmlwdGlvbiB0byB0aGUgY3VycmVudCBTdWJzY3JpcHRpb24uXG4gKiBXaGVuIGEgU3Vic2NyaXB0aW9uIGlzIHVuc3Vic2NyaWJlZCwgYWxsIGl0cyBjaGlsZHJlbiAoYW5kIGl0cyBncmFuZGNoaWxkcmVuKVxuICogd2lsbCBiZSB1bnN1YnNjcmliZWQgYXMgd2VsbC5cbiAqXG4gKiBAY2xhc3MgU3Vic2NyaXB0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBTdWJzY3JpcHRpb24gaW1wbGVtZW50cyBJU3Vic2NyaXB0aW9uIHtcbiAgcHVibGljIHN0YXRpYyBFTVBUWTogU3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uKGVtcHR5OiBhbnkpe1xuICAgIGVtcHR5LmNsb3NlZCA9IHRydWU7XG4gICAgcmV0dXJuIGVtcHR5O1xuICB9KG5ldyBTdWJzY3JpcHRpb24oKSkpO1xuXG4gIC8qKlxuICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciB0aGlzIFN1YnNjcmlwdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHVuc3Vic2NyaWJlZC5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBwdWJsaWMgY2xvc2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJvdGVjdGVkIF9wYXJlbnQ6IFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gIHByb3RlY3RlZCBfcGFyZW50czogU3Vic2NyaXB0aW9uW10gPSBudWxsO1xuICBwcml2YXRlIF9zdWJzY3JpcHRpb25zOiBJU3Vic2NyaXB0aW9uW10gPSBudWxsO1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCk6IHZvaWR9IFt1bnN1YnNjcmliZV0gQSBmdW5jdGlvbiBkZXNjcmliaW5nIGhvdyB0b1xuICAgKiBwZXJmb3JtIHRoZSBkaXNwb3NhbCBvZiByZXNvdXJjZXMgd2hlbiB0aGUgYHVuc3Vic2NyaWJlYCBtZXRob2QgaXMgY2FsbGVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IodW5zdWJzY3JpYmU/OiAoKSA9PiB2b2lkKSB7XG4gICAgaWYgKHVuc3Vic2NyaWJlKSB7XG4gICAgICAoPGFueT4gdGhpcykuX3Vuc3Vic2NyaWJlID0gdW5zdWJzY3JpYmU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2VzIHRoZSByZXNvdXJjZXMgaGVsZCBieSB0aGUgc3Vic2NyaXB0aW9uLiBNYXksIGZvciBpbnN0YW5jZSwgY2FuY2VsXG4gICAqIGFuIG9uZ29pbmcgT2JzZXJ2YWJsZSBleGVjdXRpb24gb3IgY2FuY2VsIGFueSBvdGhlciB0eXBlIG9mIHdvcmsgdGhhdFxuICAgKiBzdGFydGVkIHdoZW4gdGhlIFN1YnNjcmlwdGlvbiB3YXMgY3JlYXRlZC5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHVuc3Vic2NyaWJlKCk6IHZvaWQge1xuICAgIGxldCBoYXNFcnJvcnMgPSBmYWxzZTtcbiAgICBsZXQgZXJyb3JzOiBhbnlbXTtcblxuICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB7IF9wYXJlbnQsIF9wYXJlbnRzLCBfdW5zdWJzY3JpYmUsIF9zdWJzY3JpcHRpb25zIH0gPSAoPGFueT4gdGhpcyk7XG5cbiAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLl9wYXJlbnRzID0gbnVsbDtcbiAgICAvLyBudWxsIG91dCBfc3Vic2NyaXB0aW9ucyBmaXJzdCBzbyBhbnkgY2hpbGQgc3Vic2NyaXB0aW9ucyB0aGF0IGF0dGVtcHRcbiAgICAvLyB0byByZW1vdmUgdGhlbXNlbHZlcyBmcm9tIHRoaXMgc3Vic2NyaXB0aW9uIHdpbGwgbm9vcFxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBudWxsO1xuXG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgbGV0IGxlbiA9IF9wYXJlbnRzID8gX3BhcmVudHMubGVuZ3RoIDogMDtcblxuICAgIC8vIGlmIHRoaXMuX3BhcmVudCBpcyBudWxsLCB0aGVuIHNvIGlzIHRoaXMuX3BhcmVudHMsIGFuZCB3ZVxuICAgIC8vIGRvbid0IGhhdmUgdG8gcmVtb3ZlIG91cnNlbHZlcyBmcm9tIGFueSBwYXJlbnQgc3Vic2NyaXB0aW9ucy5cbiAgICB3aGlsZSAoX3BhcmVudCkge1xuICAgICAgX3BhcmVudC5yZW1vdmUodGhpcyk7XG4gICAgICAvLyBpZiB0aGlzLl9wYXJlbnRzIGlzIG51bGwgb3IgaW5kZXggPj0gbGVuLFxuICAgICAgLy8gdGhlbiBfcGFyZW50IGlzIHNldCB0byBudWxsLCBhbmQgdGhlIGxvb3AgZXhpdHNcbiAgICAgIF9wYXJlbnQgPSArK2luZGV4IDwgbGVuICYmIF9wYXJlbnRzW2luZGV4XSB8fCBudWxsO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKF91bnN1YnNjcmliZSkpIHtcbiAgICAgIGxldCB0cmlhbCA9IHRyeUNhdGNoKF91bnN1YnNjcmliZSkuY2FsbCh0aGlzKTtcbiAgICAgIGlmICh0cmlhbCA9PT0gZXJyb3JPYmplY3QpIHtcbiAgICAgICAgaGFzRXJyb3JzID0gdHJ1ZTtcbiAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IChcbiAgICAgICAgICBlcnJvck9iamVjdC5lIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvciA/XG4gICAgICAgICAgICBmbGF0dGVuVW5zdWJzY3JpcHRpb25FcnJvcnMoZXJyb3JPYmplY3QuZS5lcnJvcnMpIDogW2Vycm9yT2JqZWN0LmVdXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoX3N1YnNjcmlwdGlvbnMpKSB7XG5cbiAgICAgIGluZGV4ID0gLTE7XG4gICAgICBsZW4gPSBfc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgIGNvbnN0IHN1YiA9IF9zdWJzY3JpcHRpb25zW2luZGV4XTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHN1YikpIHtcbiAgICAgICAgICBsZXQgdHJpYWwgPSB0cnlDYXRjaChzdWIudW5zdWJzY3JpYmUpLmNhbGwoc3ViKTtcbiAgICAgICAgICBpZiAodHJpYWwgPT09IGVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgICBoYXNFcnJvcnMgPSB0cnVlO1xuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuICAgICAgICAgICAgbGV0IGVyciA9IGVycm9yT2JqZWN0LmU7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvcikge1xuICAgICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlcnIuZXJyb3JzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNFcnJvcnMpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSB0ZWFyIGRvd24gdG8gYmUgY2FsbGVkIGR1cmluZyB0aGUgdW5zdWJzY3JpYmUoKSBvZiB0aGlzXG4gICAqIFN1YnNjcmlwdGlvbi5cbiAgICpcbiAgICogSWYgdGhlIHRlYXIgZG93biBiZWluZyBhZGRlZCBpcyBhIHN1YnNjcmlwdGlvbiB0aGF0IGlzIGFscmVhZHlcbiAgICogdW5zdWJzY3JpYmVkLCBpcyB0aGUgc2FtZSByZWZlcmVuY2UgYGFkZGAgaXMgYmVpbmcgY2FsbGVkIG9uLCBvciBpc1xuICAgKiBgU3Vic2NyaXB0aW9uLkVNUFRZYCwgaXQgd2lsbCBub3QgYmUgYWRkZWQuXG4gICAqXG4gICAqIElmIHRoaXMgc3Vic2NyaXB0aW9uIGlzIGFscmVhZHkgaW4gYW4gYGNsb3NlZGAgc3RhdGUsIHRoZSBwYXNzZWRcbiAgICogdGVhciBkb3duIGxvZ2ljIHdpbGwgYmUgZXhlY3V0ZWQgaW1tZWRpYXRlbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7VGVhcmRvd25Mb2dpY30gdGVhcmRvd24gVGhlIGFkZGl0aW9uYWwgbG9naWMgdG8gZXhlY3V0ZSBvblxuICAgKiB0ZWFyZG93bi5cbiAgICogQHJldHVybiB7U3Vic2NyaXB0aW9ufSBSZXR1cm5zIHRoZSBTdWJzY3JpcHRpb24gdXNlZCBvciBjcmVhdGVkIHRvIGJlXG4gICAqIGFkZGVkIHRvIHRoZSBpbm5lciBzdWJzY3JpcHRpb25zIGxpc3QuIFRoaXMgU3Vic2NyaXB0aW9uIGNhbiBiZSB1c2VkIHdpdGhcbiAgICogYHJlbW92ZSgpYCB0byByZW1vdmUgdGhlIHBhc3NlZCB0ZWFyZG93biBsb2dpYyBmcm9tIHRoZSBpbm5lciBzdWJzY3JpcHRpb25zXG4gICAqIGxpc3QuXG4gICAqL1xuICBhZGQodGVhcmRvd246IFRlYXJkb3duTG9naWMpOiBTdWJzY3JpcHRpb24ge1xuICAgIGlmICghdGVhcmRvd24gfHwgKHRlYXJkb3duID09PSBTdWJzY3JpcHRpb24uRU1QVFkpKSB7XG4gICAgICByZXR1cm4gU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgIH1cblxuICAgIGlmICh0ZWFyZG93biA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgbGV0IHN1YnNjcmlwdGlvbiA9ICg8U3Vic2NyaXB0aW9uPiB0ZWFyZG93bik7XG5cbiAgICBzd2l0Y2ggKHR5cGVvZiB0ZWFyZG93bikge1xuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKDwoKCkgPT4gdm9pZCkgPiB0ZWFyZG93bik7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoc3Vic2NyaXB0aW9uLmNsb3NlZCB8fCB0eXBlb2Ygc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHN1YnNjcmlwdGlvbi5fYWRkUGFyZW50ICE9PSAnZnVuY3Rpb24nIC8qIHF1YWNrIHF1YWNrICovKSB7XG4gICAgICAgICAgY29uc3QgdG1wID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICBzdWJzY3JpcHRpb24uX3N1YnNjcmlwdGlvbnMgPSBbdG1wXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5yZWNvZ25pemVkIHRlYXJkb3duICcgKyB0ZWFyZG93biArICcgYWRkZWQgdG8gU3Vic2NyaXB0aW9uLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zIHx8ICh0aGlzLl9zdWJzY3JpcHRpb25zID0gW10pO1xuXG4gICAgc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgc3Vic2NyaXB0aW9uLl9hZGRQYXJlbnQodGhpcyk7XG5cbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBTdWJzY3JpcHRpb24gZnJvbSB0aGUgaW50ZXJuYWwgbGlzdCBvZiBzdWJzY3JpcHRpb25zIHRoYXQgd2lsbFxuICAgKiB1bnN1YnNjcmliZSBkdXJpbmcgdGhlIHVuc3Vic2NyaWJlIHByb2Nlc3Mgb2YgdGhpcyBTdWJzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7U3Vic2NyaXB0aW9ufSBzdWJzY3JpcHRpb24gVGhlIHN1YnNjcmlwdGlvbiB0byByZW1vdmUuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICByZW1vdmUoc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24pOiB2b2lkIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9ucztcbiAgICBpZiAoc3Vic2NyaXB0aW9ucykge1xuICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uSW5kZXggPSBzdWJzY3JpcHRpb25zLmluZGV4T2Yoc3Vic2NyaXB0aW9uKTtcbiAgICAgIGlmIChzdWJzY3JpcHRpb25JbmRleCAhPT0gLTEpIHtcbiAgICAgICAgc3Vic2NyaXB0aW9ucy5zcGxpY2Uoc3Vic2NyaXB0aW9uSW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2FkZFBhcmVudChwYXJlbnQ6IFN1YnNjcmlwdGlvbikge1xuICAgIGxldCB7IF9wYXJlbnQsIF9wYXJlbnRzIH0gPSB0aGlzO1xuICAgIGlmICghX3BhcmVudCB8fCBfcGFyZW50ID09PSBwYXJlbnQpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBwYXJlbnQsIG9yIHRoZSBuZXcgcGFyZW50IGlzIHRoZSBzYW1lIGFzIHRoZVxuICAgICAgLy8gY3VycmVudCBwYXJlbnQsIHRoZW4gc2V0IHRoaXMuX3BhcmVudCB0byB0aGUgbmV3IHBhcmVudC5cbiAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICB9IGVsc2UgaWYgKCFfcGFyZW50cykge1xuICAgICAgLy8gSWYgdGhlcmUncyBhbHJlYWR5IG9uZSBwYXJlbnQsIGJ1dCBub3QgbXVsdGlwbGUsIGFsbG9jYXRlIGFuIEFycmF5IHRvXG4gICAgICAvLyBzdG9yZSB0aGUgcmVzdCBvZiB0aGUgcGFyZW50IFN1YnNjcmlwdGlvbnMuXG4gICAgICB0aGlzLl9wYXJlbnRzID0gW3BhcmVudF07XG4gICAgfSBlbHNlIGlmIChfcGFyZW50cy5pbmRleE9mKHBhcmVudCkgPT09IC0xKSB7XG4gICAgICAvLyBPbmx5IGFkZCB0aGUgbmV3IHBhcmVudCB0byB0aGUgX3BhcmVudHMgbGlzdCBpZiBpdCdzIG5vdCBhbHJlYWR5IHRoZXJlLlxuICAgICAgX3BhcmVudHMucHVzaChwYXJlbnQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuVW5zdWJzY3JpcHRpb25FcnJvcnMoZXJyb3JzOiBhbnlbXSkge1xuIHJldHVybiBlcnJvcnMucmVkdWNlKChlcnJzLCBlcnIpID0+IGVycnMuY29uY2F0KChlcnIgaW5zdGFuY2VvZiBVbnN1YnNjcmlwdGlvbkVycm9yKSA/IGVyci5lcnJvcnMgOiBlcnIpLCBbXSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL1N1YnNjcmlwdGlvbi50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBPYnNlcnZlciB9IGZyb20gJy4vT2JzZXJ2ZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IElTdWJzY3JpcHRpb24sIFN1YnNjcmlwdGlvbiwgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yIH0gZnJvbSAnLi91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yJztcbmltcG9ydCB7IFN1YmplY3RTdWJzY3JpcHRpb24gfSBmcm9tICcuL1N1YmplY3RTdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgcnhTdWJzY3JpYmVyIGFzIHJ4U3Vic2NyaWJlclN5bWJvbCB9IGZyb20gJy4vc3ltYm9sL3J4U3Vic2NyaWJlcic7XG5cbi8qKlxuICogQGNsYXNzIFN1YmplY3RTdWJzY3JpYmVyPFQ+XG4gKi9cbmV4cG9ydCBjbGFzcyBTdWJqZWN0U3Vic2NyaWJlcjxUPiBleHRlbmRzIFN1YnNjcmliZXI8VD4ge1xuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZGVzdGluYXRpb246IFN1YmplY3Q8VD4pIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gIH1cbn1cblxuLyoqXG4gKiBAY2xhc3MgU3ViamVjdDxUPlxuICovXG5leHBvcnQgY2xhc3MgU3ViamVjdDxUPiBleHRlbmRzIE9ic2VydmFibGU8VD4gaW1wbGVtZW50cyBJU3Vic2NyaXB0aW9uIHtcblxuICBbcnhTdWJzY3JpYmVyU3ltYm9sXSgpIHtcbiAgICByZXR1cm4gbmV3IFN1YmplY3RTdWJzY3JpYmVyKHRoaXMpO1xuICB9XG5cbiAgb2JzZXJ2ZXJzOiBPYnNlcnZlcjxUPltdID0gW107XG5cbiAgY2xvc2VkID0gZmFsc2U7XG5cbiAgaXNTdG9wcGVkID0gZmFsc2U7XG5cbiAgaGFzRXJyb3IgPSBmYWxzZTtcblxuICB0aHJvd25FcnJvcjogYW55ID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgc3RhdGljIGNyZWF0ZTogRnVuY3Rpb24gPSA8VD4oZGVzdGluYXRpb246IE9ic2VydmVyPFQ+LCBzb3VyY2U6IE9ic2VydmFibGU8VD4pOiBBbm9ueW1vdXNTdWJqZWN0PFQ+ID0+IHtcbiAgICByZXR1cm4gbmV3IEFub255bW91c1N1YmplY3Q8VD4oZGVzdGluYXRpb24sIHNvdXJjZSk7XG4gIH1cblxuICBsaWZ0PFI+KG9wZXJhdG9yOiBPcGVyYXRvcjxULCBSPik6IE9ic2VydmFibGU8VD4ge1xuICAgIGNvbnN0IHN1YmplY3QgPSBuZXcgQW5vbnltb3VzU3ViamVjdCh0aGlzLCB0aGlzKTtcbiAgICBzdWJqZWN0Lm9wZXJhdG9yID0gPGFueT5vcGVyYXRvcjtcbiAgICByZXR1cm4gPGFueT5zdWJqZWN0O1xuICB9XG5cbiAgbmV4dCh2YWx1ZT86IFQpIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICBjb25zdCB7IG9ic2VydmVycyB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgICBjb25zdCBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvcHlbaV0ubmV4dCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZXJyb3IoZXJyOiBhbnkpIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgIH1cbiAgICB0aGlzLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICB0aGlzLnRocm93bkVycm9yID0gZXJyO1xuICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICBjb25zdCB7IG9ic2VydmVycyB9ID0gdGhpcztcbiAgICBjb25zdCBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgIGNvbnN0IGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb3B5W2ldLmVycm9yKGVycik7XG4gICAgfVxuICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBjb21wbGV0ZSgpIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgIH1cbiAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgY29uc3QgeyBvYnNlcnZlcnMgfSA9IHRoaXM7XG4gICAgY29uc3QgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICBjb25zdCBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29weVtpXS5jb21wbGV0ZSgpO1xuICAgIH1cbiAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICB9XG5cbiAgdW5zdWJzY3JpYmUoKSB7XG4gICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLm9ic2VydmVycyA9IG51bGw7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3RyeVN1YnNjcmliZShzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+KTogVGVhcmRvd25Mb2dpYyB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyLl90cnlTdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9zdWJzY3JpYmUoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPik6IFN1YnNjcmlwdGlvbiB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgIHN1YnNjcmliZXIuZXJyb3IodGhpcy50aHJvd25FcnJvcik7XG4gICAgICByZXR1cm4gU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2goc3Vic2NyaWJlcik7XG4gICAgICByZXR1cm4gbmV3IFN1YmplY3RTdWJzY3JpcHRpb24odGhpcywgc3Vic2NyaWJlcik7XG4gICAgfVxuICB9XG5cbiAgYXNPYnNlcnZhYmxlKCk6IE9ic2VydmFibGU8VD4ge1xuICAgIGNvbnN0IG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZTxUPigpO1xuICAgICg8YW55Pm9ic2VydmFibGUpLnNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG9ic2VydmFibGU7XG4gIH1cbn1cblxuLyoqXG4gKiBAY2xhc3MgQW5vbnltb3VzU3ViamVjdDxUPlxuICovXG5leHBvcnQgY2xhc3MgQW5vbnltb3VzU3ViamVjdDxUPiBleHRlbmRzIFN1YmplY3Q8VD4ge1xuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZGVzdGluYXRpb24/OiBPYnNlcnZlcjxUPiwgc291cmNlPzogT2JzZXJ2YWJsZTxUPikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIH1cblxuICBuZXh0KHZhbHVlOiBUKSB7XG4gICAgY29uc3QgeyBkZXN0aW5hdGlvbiB9ID0gdGhpcztcbiAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24ubmV4dCkge1xuICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZXJyb3IoZXJyOiBhbnkpIHtcbiAgICBjb25zdCB7IGRlc3RpbmF0aW9uIH0gPSB0aGlzO1xuICAgIGlmIChkZXN0aW5hdGlvbiAmJiBkZXN0aW5hdGlvbi5lcnJvcikge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBsZXRlKCkge1xuICAgIGNvbnN0IHsgZGVzdGluYXRpb24gfSA9IHRoaXM7XG4gICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLmNvbXBsZXRlKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9zdWJzY3JpYmUoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPik6IFN1YnNjcmlwdGlvbiB7XG4gICAgY29uc3QgeyBzb3VyY2UgfSA9IHRoaXM7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvU3ViamVjdC50cyIsIi8vIHR5cGVvZiBhbnkgc28gdGhhdCBpdCB3ZSBkb24ndCBoYXZlIHRvIGNhc3Qgd2hlbiBjb21wYXJpbmcgYSByZXN1bHQgdG8gdGhlIGVycm9yIG9iamVjdFxuZXhwb3J0IGNvbnN0IGVycm9yT2JqZWN0OiBhbnkgPSB7IGU6IHt9IH07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy91dGlsL2Vycm9yT2JqZWN0LnRzIiwiZGVjbGFyZSBsZXQgZ2xvYmFsOiBOb2RlSlMuR2xvYmFsO1xuXG5kZWNsYXJlIG1vZHVsZSBOb2RlSlMge1xuICBpbnRlcmZhY2UgR2xvYmFsIHtcbiAgICB3aW5kb3c6IGFueTtcbiAgICBnbG9iYWw6IGFueTtcbiAgfVxufVxuXG4vKipcbiAqIHdpbmRvdzogYnJvd3NlciBpbiBET00gbWFpbiB0aHJlYWRcbiAqIHNlbGY6IGJyb3dzZXIgaW4gV2ViV29ya2VyXG4gKiBnbG9iYWw6IE5vZGUuanMvb3RoZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJvb3Q6IGFueSA9IChcbiAgICAgdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cud2luZG93ID09PSB3aW5kb3cgJiYgd2luZG93XG4gIHx8IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmXG4gIHx8IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsLmdsb2JhbCA9PT0gZ2xvYmFsICYmIGdsb2JhbFxuKTtcblxuaWYgKCFyb290KSB7XG4gIHRocm93IG5ldyBFcnJvcignUnhKUyBjb3VsZCBub3QgZmluZCBhbnkgZ2xvYmFsIGNvbnRleHQgKHdpbmRvdywgc2VsZiwgZ2xvYmFsKScpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy91dGlsL3Jvb3QudHMiLCJpbXBvcnQgeyBlcnJvck9iamVjdCB9IGZyb20gJy4vZXJyb3JPYmplY3QnO1xuXG5sZXQgdHJ5Q2F0Y2hUYXJnZXQ6IEZ1bmN0aW9uO1xuXG5mdW5jdGlvbiB0cnlDYXRjaGVyKHRoaXM6IGFueSk6IGFueSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHRyeUNhdGNoVGFyZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvck9iamVjdC5lID0gZTtcbiAgICByZXR1cm4gZXJyb3JPYmplY3Q7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyeUNhdGNoPFQgZXh0ZW5kcyBGdW5jdGlvbj4oZm46IFQpOiBUIHtcbiAgdHJ5Q2F0Y2hUYXJnZXQgPSBmbjtcbiAgcmV0dXJuIDxhbnk+dHJ5Q2F0Y2hlcjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3V0aWwvdHJ5Q2F0Y2gudHMiLCJpbXBvcnQgeyBBc3luY0FjdGlvbiB9IGZyb20gJy4vQXN5bmNBY3Rpb24nO1xuaW1wb3J0IHsgQXN5bmNTY2hlZHVsZXIgfSBmcm9tICcuL0FzeW5jU2NoZWR1bGVyJztcblxuLyoqXG4gKlxuICogQXN5bmMgU2NoZWR1bGVyXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlNjaGVkdWxlIHRhc2sgYXMgaWYgeW91IHVzZWQgc2V0VGltZW91dCh0YXNrLCBkdXJhdGlvbik8L3NwYW4+XG4gKlxuICogYGFzeW5jYCBzY2hlZHVsZXIgc2NoZWR1bGVzIHRhc2tzIGFzeW5jaHJvbm91c2x5LCBieSBwdXR0aW5nIHRoZW0gb24gdGhlIEphdmFTY3JpcHRcbiAqIGV2ZW50IGxvb3AgcXVldWUuIEl0IGlzIGJlc3QgdXNlZCB0byBkZWxheSB0YXNrcyBpbiB0aW1lIG9yIHRvIHNjaGVkdWxlIHRhc2tzIHJlcGVhdGluZ1xuICogaW4gaW50ZXJ2YWxzLlxuICpcbiAqIElmIHlvdSBqdXN0IHdhbnQgdG8gXCJkZWZlclwiIHRhc2ssIHRoYXQgaXMgdG8gcGVyZm9ybSBpdCByaWdodCBhZnRlciBjdXJyZW50bHlcbiAqIGV4ZWN1dGluZyBzeW5jaHJvbm91cyBjb2RlIGVuZHMgKGNvbW1vbmx5IGFjaGlldmVkIGJ5IGBzZXRUaW1lb3V0KGRlZmVycmVkVGFzaywgMClgKSxcbiAqIGJldHRlciBjaG9pY2Ugd2lsbCBiZSB0aGUge0BsaW5rIGFzYXB9IHNjaGVkdWxlci5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2UgYXN5bmMgc2NoZWR1bGVyIHRvIGRlbGF5IHRhc2s8L2NhcHRpb24+XG4gKiBjb25zdCB0YXNrID0gKCkgPT4gY29uc29sZS5sb2coJ2l0IHdvcmtzIScpO1xuICpcbiAqIFJ4LlNjaGVkdWxlci5hc3luYy5zY2hlZHVsZSh0YXNrLCAyMDAwKTtcbiAqXG4gKiAvLyBBZnRlciAyIHNlY29uZHMgbG9nczpcbiAqIC8vIFwiaXQgd29ya3MhXCJcbiAqXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+VXNlIGFzeW5jIHNjaGVkdWxlciB0byByZXBlYXQgdGFzayBpbiBpbnRlcnZhbHM8L2NhcHRpb24+XG4gKiBmdW5jdGlvbiB0YXNrKHN0YXRlKSB7XG4gKiAgIGNvbnNvbGUubG9nKHN0YXRlKTtcbiAqICAgdGhpcy5zY2hlZHVsZShzdGF0ZSArIDEsIDEwMDApOyAvLyBgdGhpc2AgcmVmZXJlbmNlcyBjdXJyZW50bHkgZXhlY3V0aW5nIEFjdGlvbixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB3ZSByZXNjaGVkdWxlIHdpdGggbmV3IHN0YXRlIGFuZCBkZWxheVxuICogfVxuICpcbiAqIFJ4LlNjaGVkdWxlci5hc3luYy5zY2hlZHVsZSh0YXNrLCAzMDAwLCAwKTtcbiAqXG4gKiAvLyBMb2dzOlxuICogLy8gMCBhZnRlciAzc1xuICogLy8gMSBhZnRlciA0c1xuICogLy8gMiBhZnRlciA1c1xuICogLy8gMyBhZnRlciA2c1xuICpcbiAqIEBzdGF0aWMgdHJ1ZVxuICogQG5hbWUgYXN5bmNcbiAqIEBvd25lciBTY2hlZHVsZXJcbiAqL1xuXG5leHBvcnQgY29uc3QgYXN5bmMgPSBuZXcgQXN5bmNTY2hlZHVsZXIoQXN5bmNBY3Rpb24pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9zY2hlZHVsZXIvYXN5bmMudHMiLCJpbXBvcnQgeyBJU2NoZWR1bGVyIH0gZnJvbSAnLi4vU2NoZWR1bGVyJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFNjYWxhck9ic2VydmFibGUgfSBmcm9tICcuL1NjYWxhck9ic2VydmFibGUnO1xuaW1wb3J0IHsgRW1wdHlPYnNlcnZhYmxlIH0gZnJvbSAnLi9FbXB0eU9ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgaXNTY2hlZHVsZXIgfSBmcm9tICcuLi91dGlsL2lzU2NoZWR1bGVyJztcbmltcG9ydCB7IFRlYXJkb3duTG9naWMgfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xuZXhwb3J0IGNsYXNzIEFycmF5T2JzZXJ2YWJsZTxUPiBleHRlbmRzIE9ic2VydmFibGU8VD4ge1xuXG4gIHN0YXRpYyBjcmVhdGU8VD4oYXJyYXk6IFRbXSwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VD4ge1xuICAgIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlKGFycmF5LCBzY2hlZHVsZXIpO1xuICB9XG5cbiAgc3RhdGljIG9mPFQ+KGl0ZW0xOiBULCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxUPjtcbiAgc3RhdGljIG9mPFQ+KGl0ZW0xOiBULCBpdGVtMjogVCwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VD47XG4gIHN0YXRpYyBvZjxUPihpdGVtMTogVCwgaXRlbTI6IFQsIGl0ZW0zOiBULCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxUPjtcbiAgc3RhdGljIG9mPFQ+KGl0ZW0xOiBULCBpdGVtMjogVCwgaXRlbTM6IFQsIGl0ZW00OiBULCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxUPjtcbiAgc3RhdGljIG9mPFQ+KGl0ZW0xOiBULCBpdGVtMjogVCwgaXRlbTM6IFQsIGl0ZW00OiBULCBpdGVtNTogVCwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VD47XG4gIHN0YXRpYyBvZjxUPihpdGVtMTogVCwgaXRlbTI6IFQsIGl0ZW0zOiBULCBpdGVtNDogVCwgaXRlbTU6IFQsIGl0ZW02OiBULCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxUPjtcbiAgc3RhdGljIG9mPFQ+KC4uLmFycmF5OiBBcnJheTxUIHwgSVNjaGVkdWxlcj4pOiBPYnNlcnZhYmxlPFQ+O1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgc29tZSB2YWx1ZXMgeW91IHNwZWNpZnkgYXMgYXJndW1lbnRzLFxuICAgKiBpbW1lZGlhdGVseSBvbmUgYWZ0ZXIgdGhlIG90aGVyLCBhbmQgdGhlbiBlbWl0cyBhIGNvbXBsZXRlIG5vdGlmaWNhdGlvbi5cbiAgICpcbiAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkVtaXRzIHRoZSBhcmd1bWVudHMgeW91IHByb3ZpZGUsIHRoZW4gY29tcGxldGVzLlxuICAgKiA8L3NwYW4+XG4gICAqXG4gICAqIDxpbWcgc3JjPVwiLi9pbWcvb2YucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAqXG4gICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IG9ubHlcbiAgICogZW1pdHMgdGhlIGFyZ3VtZW50cyBnaXZlbiwgYW5kIHRoZSBjb21wbGV0ZSBub3RpZmljYXRpb24gdGhlcmVhZnRlci4gSXQgY2FuXG4gICAqIGJlIHVzZWQgZm9yIGNvbXBvc2luZyB3aXRoIG90aGVyIE9ic2VydmFibGVzLCBzdWNoIGFzIHdpdGgge0BsaW5rIGNvbmNhdH0uXG4gICAqIEJ5IGRlZmF1bHQsIGl0IHVzZXMgYSBgbnVsbGAgSVNjaGVkdWxlciwgd2hpY2ggbWVhbnMgdGhlIGBuZXh0YFxuICAgKiBub3RpZmljYXRpb25zIGFyZSBzZW50IHN5bmNocm9ub3VzbHksIGFsdGhvdWdoIHdpdGggYSBkaWZmZXJlbnQgSVNjaGVkdWxlclxuICAgKiBpdCBpcyBwb3NzaWJsZSB0byBkZXRlcm1pbmUgd2hlbiB0aG9zZSBub3RpZmljYXRpb25zIHdpbGwgYmUgZGVsaXZlcmVkLlxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IDEwLCAyMCwgMzAsIHRoZW4gJ2EnLCAnYicsICdjJywgdGhlbiBzdGFydCB0aWNraW5nIGV2ZXJ5IHNlY29uZC48L2NhcHRpb24+XG4gICAqIHZhciBudW1iZXJzID0gUnguT2JzZXJ2YWJsZS5vZigxMCwgMjAsIDMwKTtcbiAgICogdmFyIGxldHRlcnMgPSBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpO1xuICAgKiB2YXIgaW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICAgKiB2YXIgcmVzdWx0ID0gbnVtYmVycy5jb25jYXQobGV0dGVycykuY29uY2F0KGludGVydmFsKTtcbiAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgKiBAc2VlIHtAbGluayBlbXB0eX1cbiAgICogQHNlZSB7QGxpbmsgbmV2ZXJ9XG4gICAqIEBzZWUge0BsaW5rIHRocm93fVxuICAgKlxuICAgKiBAcGFyYW0gey4uLlR9IHZhbHVlcyBBcmd1bWVudHMgdGhhdCByZXByZXNlbnQgYG5leHRgIHZhbHVlcyB0byBiZSBlbWl0dGVkLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gQSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAqIHRoZSBlbWlzc2lvbnMgb2YgdGhlIGBuZXh0YCBub3RpZmljYXRpb25zLlxuICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgZWFjaCBnaXZlbiBpbnB1dCB2YWx1ZS5cbiAgICogQHN0YXRpYyB0cnVlXG4gICAqIEBuYW1lIG9mXG4gICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAqL1xuICBzdGF0aWMgb2Y8VD4oLi4uYXJyYXk6IEFycmF5PFQgfCBJU2NoZWR1bGVyPik6IE9ic2VydmFibGU8VD4ge1xuICAgIGxldCBzY2hlZHVsZXIgPSA8SVNjaGVkdWxlcj5hcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICBpZiAoaXNTY2hlZHVsZXIoc2NoZWR1bGVyKSkge1xuICAgICAgYXJyYXkucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlciA9IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZTxUPig8YW55PmFycmF5LCBzY2hlZHVsZXIpO1xuICAgIH0gZWxzZSBpZiAobGVuID09PSAxKSB7XG4gICAgICByZXR1cm4gbmV3IFNjYWxhck9ic2VydmFibGU8VD4oPGFueT5hcnJheVswXSwgc2NoZWR1bGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGU8VD4oc2NoZWR1bGVyKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZGlzcGF0Y2goc3RhdGU6IGFueSkge1xuXG4gICAgY29uc3QgeyBhcnJheSwgaW5kZXgsIGNvdW50LCBzdWJzY3JpYmVyIH0gPSBzdGF0ZTtcblxuICAgIGlmIChpbmRleCA+PSBjb3VudCkge1xuICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN1YnNjcmliZXIubmV4dChhcnJheVtpbmRleF0pO1xuXG4gICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG5cbiAgICAoPGFueT4gdGhpcykuc2NoZWR1bGUoc3RhdGUpO1xuICB9XG5cbiAgLy8gdmFsdWUgdXNlZCBpZiBBcnJheSBoYXMgb25lIHZhbHVlIGFuZCBfaXNTY2FsYXJcbiAgdmFsdWU6IGFueTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFycmF5OiBUW10sIHByaXZhdGUgc2NoZWR1bGVyPzogSVNjaGVkdWxlcikge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKCFzY2hlZHVsZXIgJiYgYXJyYXkubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLl9pc1NjYWxhciA9IHRydWU7XG4gICAgICB0aGlzLnZhbHVlID0gYXJyYXlbMF07XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9zdWJzY3JpYmUoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPik6IFRlYXJkb3duTG9naWMge1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgIGNvbnN0IGNvdW50ID0gYXJyYXkubGVuZ3RoO1xuICAgIGNvbnN0IHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuXG4gICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShBcnJheU9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgYXJyYXksIGluZGV4LCBjb3VudCwgc3Vic2NyaWJlclxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQgJiYgIXN1YnNjcmliZXIuY2xvc2VkOyBpKyspIHtcbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KGFycmF5W2ldKTtcbiAgICAgIH1cbiAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUudHMiLCJleHBvcnQgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgKDxUPih4OiBhbnkpOiB4IGlzIFRbXSA9PiB4ICYmIHR5cGVvZiB4Lmxlbmd0aCA9PT0gJ251bWJlcicpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy91dGlsL2lzQXJyYXkudHMiLCJpbXBvcnQgeyBTY2hlZHVsZXIgfSBmcm9tICcuLi9TY2hlZHVsZXInO1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2NoZWR1bGVyKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBTY2hlZHVsZXIge1xuICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mICg8YW55PnZhbHVlKS5zY2hlZHVsZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvdXRpbC9pc1NjaGVkdWxlci50cyIsImltcG9ydCB7IElTY2hlZHVsZXIgfSBmcm9tICcuLi9TY2hlZHVsZXInO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGlzcGF0Y2hBcmc8VD4ge1xuICBzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+O1xufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xuZXhwb3J0IGNsYXNzIEVtcHR5T2JzZXJ2YWJsZTxUPiBleHRlbmRzIE9ic2VydmFibGU8VD4ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBubyBpdGVtcyB0byB0aGUgT2JzZXJ2ZXIgYW5kIGltbWVkaWF0ZWx5XG4gICAqIGVtaXRzIGEgY29tcGxldGUgbm90aWZpY2F0aW9uLlxuICAgKlxuICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SnVzdCBlbWl0cyAnY29tcGxldGUnLCBhbmQgbm90aGluZyBlbHNlLlxuICAgKiA8L3NwYW4+XG4gICAqXG4gICAqIDxpbWcgc3JjPVwiLi9pbWcvZW1wdHkucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAqXG4gICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IG9ubHlcbiAgICogZW1pdHMgdGhlIGNvbXBsZXRlIG5vdGlmaWNhdGlvbi4gSXQgY2FuIGJlIHVzZWQgZm9yIGNvbXBvc2luZyB3aXRoIG90aGVyXG4gICAqIE9ic2VydmFibGVzLCBzdWNoIGFzIGluIGEge0BsaW5rIG1lcmdlTWFwfS5cbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbnVtYmVyIDcsIHRoZW4gY29tcGxldGUuPC9jYXB0aW9uPlxuICAgKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5lbXB0eSgpLnN0YXJ0V2l0aCg3KTtcbiAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIGFuZCBmbGF0dGVuIG9ubHkgb2RkIG51bWJlcnMgdG8gdGhlIHNlcXVlbmNlICdhJywgJ2InLCAnYyc8L2NhcHRpb24+XG4gICAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAqIHZhciByZXN1bHQgPSBpbnRlcnZhbC5tZXJnZU1hcCh4ID0+XG4gICAqICAgeCAlIDIgPT09IDEgPyBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpIDogUnguT2JzZXJ2YWJsZS5lbXB0eSgpXG4gICAqICk7XG4gICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAqXG4gICAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZyB0byB0aGUgY29uc29sZTpcbiAgICogLy8geCBpcyBlcXVhbCB0byB0aGUgY291bnQgb24gdGhlIGludGVydmFsIGVnKDAsMSwyLDMsLi4uKVxuICAgKiAvLyB4IHdpbGwgb2NjdXIgZXZlcnkgMTAwMG1zXG4gICAqIC8vIGlmIHggJSAyIGlzIGVxdWFsIHRvIDEgcHJpbnQgYWJjXG4gICAqIC8vIGlmIHggJSAyIGlzIG5vdCBlcXVhbCB0byAxIG5vdGhpbmcgd2lsbCBiZSBvdXRwdXRcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgKiBAc2VlIHtAbGluayBuZXZlcn1cbiAgICogQHNlZSB7QGxpbmsgb2Z9XG4gICAqIEBzZWUge0BsaW5rIHRocm93fVxuICAgKlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gQSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvciBzY2hlZHVsaW5nXG4gICAqIHRoZSBlbWlzc2lvbiBvZiB0aGUgY29tcGxldGUgbm90aWZpY2F0aW9uLlxuICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBcImVtcHR5XCIgT2JzZXJ2YWJsZTogZW1pdHMgb25seSB0aGUgY29tcGxldGVcbiAgICogbm90aWZpY2F0aW9uLlxuICAgKiBAc3RhdGljIHRydWVcbiAgICogQG5hbWUgZW1wdHlcbiAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICovXG4gIHN0YXRpYyBjcmVhdGU8VD4oc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VD4ge1xuICAgIHJldHVybiBuZXcgRW1wdHlPYnNlcnZhYmxlPFQ+KHNjaGVkdWxlcik7XG4gIH1cblxuICBzdGF0aWMgZGlzcGF0Y2g8VD4oYXJnOiBEaXNwYXRjaEFyZzxUPikge1xuICAgIGNvbnN0IHsgc3Vic2NyaWJlciB9ID0gYXJnO1xuICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc2NoZWR1bGVyPzogSVNjaGVkdWxlcikge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3N1YnNjcmliZShzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+KTogVGVhcmRvd25Mb2dpYyB7XG5cbiAgICBjb25zdCBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcblxuICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoRW1wdHlPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7IHN1YnNjcmliZXIgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUudHMiLCJpbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAnLi4vU3ViamVjdCc7XG5pbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IENvbm5lY3RhYmxlT2JzZXJ2YWJsZSwgY29ubmVjdGFibGVPYnNlcnZhYmxlRGVzY3JpcHRvciB9IGZyb20gJy4uL29ic2VydmFibGUvQ29ubmVjdGFibGVPYnNlcnZhYmxlJztcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5leHBvcnQgZnVuY3Rpb24gbXVsdGljYXN0PFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIHN1YmplY3RPclN1YmplY3RGYWN0b3J5OiBmYWN0b3J5T3JWYWx1ZTxTdWJqZWN0PFQ+Pik6IENvbm5lY3RhYmxlT2JzZXJ2YWJsZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBtdWx0aWNhc3Q8VD4oU3ViamVjdEZhY3Rvcnk6ICh0aGlzOiBPYnNlcnZhYmxlPFQ+KSA9PiBTdWJqZWN0PFQ+LCBzZWxlY3Rvcj86IHNlbGVjdG9yPFQ+KTogT2JzZXJ2YWJsZTxUPjtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdHMgb2YgaW52b2tpbmcgYSBzcGVjaWZpZWQgc2VsZWN0b3Igb24gaXRlbXNcbiAqIGVtaXR0ZWQgYnkgYSBDb25uZWN0YWJsZU9ic2VydmFibGUgdGhhdCBzaGFyZXMgYSBzaW5nbGUgc3Vic2NyaXB0aW9uIHRvIHRoZSB1bmRlcmx5aW5nIHN0cmVhbS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL211bHRpY2FzdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN1YmplY3R9IHN1YmplY3RPclN1YmplY3RGYWN0b3J5IC0gRmFjdG9yeSBmdW5jdGlvbiB0byBjcmVhdGUgYW4gaW50ZXJtZWRpYXRlIHN1YmplY3QgdGhyb3VnaFxuICogd2hpY2ggdGhlIHNvdXJjZSBzZXF1ZW5jZSdzIGVsZW1lbnRzIHdpbGwgYmUgbXVsdGljYXN0IHRvIHRoZSBzZWxlY3RvciBmdW5jdGlvblxuICogb3IgU3ViamVjdCB0byBwdXNoIHNvdXJjZSBlbGVtZW50cyBpbnRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3NlbGVjdG9yXSAtIE9wdGlvbmFsIHNlbGVjdG9yIGZ1bmN0aW9uIHRoYXQgY2FuIHVzZSB0aGUgbXVsdGljYXN0ZWQgc291cmNlIHN0cmVhbVxuICogYXMgbWFueSB0aW1lcyBhcyBuZWVkZWQsIHdpdGhvdXQgY2F1c2luZyBtdWx0aXBsZSBzdWJzY3JpcHRpb25zIHRvIHRoZSBzb3VyY2Ugc3RyZWFtLlxuICogU3Vic2NyaWJlcnMgdG8gdGhlIGdpdmVuIHNvdXJjZSB3aWxsIHJlY2VpdmUgYWxsIG5vdGlmaWNhdGlvbnMgb2YgdGhlIHNvdXJjZSBmcm9tIHRoZVxuICogdGltZSBvZiB0aGUgc3Vic2NyaXB0aW9uIGZvcndhcmQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdHMgb2YgaW52b2tpbmcgdGhlIHNlbGVjdG9yXG4gKiBvbiB0aGUgaXRlbXMgZW1pdHRlZCBieSBhIGBDb25uZWN0YWJsZU9ic2VydmFibGVgIHRoYXQgc2hhcmVzIGEgc2luZ2xlIHN1YnNjcmlwdGlvbiB0b1xuICogdGhlIHVuZGVybHlpbmcgc3RyZWFtLlxuICogQG1ldGhvZCBtdWx0aWNhc3RcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aWNhc3Q8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgc3ViamVjdE9yU3ViamVjdEZhY3Rvcnk6IFN1YmplY3Q8VD4gfCAoKCkgPT4gU3ViamVjdDxUPiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yPzogKHNvdXJjZTogT2JzZXJ2YWJsZTxUPikgPT4gT2JzZXJ2YWJsZTxUPik6IE9ic2VydmFibGU8VD4gfCBDb25uZWN0YWJsZU9ic2VydmFibGU8VD4ge1xuICBsZXQgc3ViamVjdEZhY3Rvcnk6ICgpID0+IFN1YmplY3Q8VD47XG4gIGlmICh0eXBlb2Ygc3ViamVjdE9yU3ViamVjdEZhY3RvcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzdWJqZWN0RmFjdG9yeSA9IDwoKSA9PiBTdWJqZWN0PFQ+PnN1YmplY3RPclN1YmplY3RGYWN0b3J5O1xuICB9IGVsc2Uge1xuICAgIHN1YmplY3RGYWN0b3J5ID0gZnVuY3Rpb24gc3ViamVjdEZhY3RvcnkoKSB7XG4gICAgICByZXR1cm4gPFN1YmplY3Q8VD4+c3ViamVjdE9yU3ViamVjdEZhY3Rvcnk7XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBNdWx0aWNhc3RPcGVyYXRvcihzdWJqZWN0RmFjdG9yeSwgc2VsZWN0b3IpKTtcbiAgfVxuXG4gIGNvbnN0IGNvbm5lY3RhYmxlOiBhbnkgPSBPYmplY3QuY3JlYXRlKHRoaXMsIGNvbm5lY3RhYmxlT2JzZXJ2YWJsZURlc2NyaXB0b3IpO1xuICBjb25uZWN0YWJsZS5zb3VyY2UgPSB0aGlzO1xuICBjb25uZWN0YWJsZS5zdWJqZWN0RmFjdG9yeSA9IHN1YmplY3RGYWN0b3J5O1xuXG4gIHJldHVybiA8Q29ubmVjdGFibGVPYnNlcnZhYmxlPFQ+PiBjb25uZWN0YWJsZTtcbn1cblxuZXhwb3J0IHR5cGUgZmFjdG9yeU9yVmFsdWU8VD4gPSBUIHwgKCgpID0+IFQpO1xuZXhwb3J0IHR5cGUgc2VsZWN0b3I8VD4gPSAoc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBPYnNlcnZhYmxlPFQ+O1xuXG5leHBvcnQgY2xhc3MgTXVsdGljYXN0T3BlcmF0b3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc3ViamVjdEZhY3Rvcnk6ICgpID0+IFN1YmplY3Q8VD4sXG4gICAgICAgICAgICAgIHByaXZhdGUgc2VsZWN0b3I6IChzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IE9ic2VydmFibGU8VD4pIHtcbiAgfVxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4sIHNvdXJjZTogYW55KTogYW55IHtcbiAgICBjb25zdCB7IHNlbGVjdG9yIH0gPSB0aGlzO1xuICAgIGNvbnN0IHN1YmplY3QgPSB0aGlzLnN1YmplY3RGYWN0b3J5KCk7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc2VsZWN0b3Ioc3ViamVjdCkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIHN1YnNjcmlwdGlvbi5hZGQoc291cmNlLnN1YnNjcmliZShzdWJqZWN0KSk7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9tdWx0aWNhc3QudHMiLCJpbXBvcnQgeyBQYXJ0aWFsT2JzZXJ2ZXIgfSBmcm9tICcuL09ic2VydmVyJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuL09ic2VydmFibGUnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBwdXNoLWJhc2VkIGV2ZW50IG9yIHZhbHVlIHRoYXQgYW4ge0BsaW5rIE9ic2VydmFibGV9IGNhbiBlbWl0LlxuICogVGhpcyBjbGFzcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBvcGVyYXRvcnMgdGhhdCBtYW5hZ2Ugbm90aWZpY2F0aW9ucyxcbiAqIGxpa2Uge0BsaW5rIG1hdGVyaWFsaXplfSwge0BsaW5rIGRlbWF0ZXJpYWxpemV9LCB7QGxpbmsgb2JzZXJ2ZU9ufSwgYW5kXG4gKiBvdGhlcnMuIEJlc2lkZXMgd3JhcHBpbmcgdGhlIGFjdHVhbCBkZWxpdmVyZWQgdmFsdWUsIGl0IGFsc28gYW5ub3RhdGVzIGl0XG4gKiB3aXRoIG1ldGFkYXRhIG9mLCBmb3IgaW5zdGFuY2UsIHdoYXQgdHlwZSBvZiBwdXNoIG1lc3NhZ2UgaXQgaXMgKGBuZXh0YCxcbiAqIGBlcnJvcmAsIG9yIGBjb21wbGV0ZWApLlxuICpcbiAqIEBzZWUge0BsaW5rIG1hdGVyaWFsaXplfVxuICogQHNlZSB7QGxpbmsgZGVtYXRlcmlhbGl6ZX1cbiAqIEBzZWUge0BsaW5rIG9ic2VydmVPbn1cbiAqXG4gKiBAY2xhc3MgTm90aWZpY2F0aW9uPFQ+XG4gKi9cbmV4cG9ydCBjbGFzcyBOb3RpZmljYXRpb248VD4ge1xuICBoYXNWYWx1ZTogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMga2luZDogc3RyaW5nLCBwdWJsaWMgdmFsdWU/OiBULCBwdWJsaWMgZXJyb3I/OiBhbnkpIHtcbiAgICB0aGlzLmhhc1ZhbHVlID0ga2luZCA9PT0gJ04nO1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGl2ZXJzIHRvIHRoZSBnaXZlbiBgb2JzZXJ2ZXJgIHRoZSB2YWx1ZSB3cmFwcGVkIGJ5IHRoaXMgTm90aWZpY2F0aW9uLlxuICAgKiBAcGFyYW0ge09ic2VydmVyfSBvYnNlcnZlclxuICAgKiBAcmV0dXJuXG4gICAqL1xuICBvYnNlcnZlKG9ic2VydmVyOiBQYXJ0aWFsT2JzZXJ2ZXI8VD4pOiBhbnkge1xuICAgIHN3aXRjaCAodGhpcy5raW5kKSB7XG4gICAgICBjYXNlICdOJzpcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyLm5leHQgJiYgb2JzZXJ2ZXIubmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgIGNhc2UgJ0UnOlxuICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZXJyb3IgJiYgb2JzZXJ2ZXIuZXJyb3IodGhpcy5lcnJvcik7XG4gICAgICBjYXNlICdDJzpcbiAgICAgICAgcmV0dXJuIG9ic2VydmVyLmNvbXBsZXRlICYmIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIHNvbWUge0BsaW5rIE9ic2VydmVyfSBjYWxsYmFja3MsIGRlbGl2ZXIgdGhlIHZhbHVlIHJlcHJlc2VudGVkIGJ5IHRoZVxuICAgKiBjdXJyZW50IE5vdGlmaWNhdGlvbiB0byB0aGUgY29ycmVjdGx5IGNvcnJlc3BvbmRpbmcgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQpOiB2b2lkfSBuZXh0IEFuIE9ic2VydmVyIGBuZXh0YCBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtmdW5jdGlvbihlcnI6IGFueSk6IHZvaWR9IFtlcnJvcl0gQW4gT2JzZXJ2ZXIgYGVycm9yYCBjYWxsYmFjay5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigpOiB2b2lkfSBbY29tcGxldGVdIEFuIE9ic2VydmVyIGBjb21wbGV0ZWAgY2FsbGJhY2suXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIGRvKG5leHQ6ICh2YWx1ZTogVCkgPT4gdm9pZCwgZXJyb3I/OiAoZXJyOiBhbnkpID0+IHZvaWQsIGNvbXBsZXRlPzogKCkgPT4gdm9pZCk6IGFueSB7XG4gICAgY29uc3Qga2luZCA9IHRoaXMua2luZDtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgJ04nOlxuICAgICAgICByZXR1cm4gbmV4dCAmJiBuZXh0KHRoaXMudmFsdWUpO1xuICAgICAgY2FzZSAnRSc6XG4gICAgICAgIHJldHVybiBlcnJvciAmJiBlcnJvcih0aGlzLmVycm9yKTtcbiAgICAgIGNhc2UgJ0MnOlxuICAgICAgICByZXR1cm4gY29tcGxldGUgJiYgY29tcGxldGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYW4gT2JzZXJ2ZXIgb3IgaXRzIGluZGl2aWR1YWwgY2FsbGJhY2sgZnVuY3Rpb25zLCBhbmQgY2FsbHMgYG9ic2VydmVgXG4gICAqIG9yIGBkb2AgbWV0aG9kcyBhY2NvcmRpbmdseS5cbiAgICogQHBhcmFtIHtPYnNlcnZlcnxmdW5jdGlvbih2YWx1ZTogVCk6IHZvaWR9IG5leHRPck9ic2VydmVyIEFuIE9ic2VydmVyIG9yXG4gICAqIHRoZSBgbmV4dGAgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oZXJyOiBhbnkpOiB2b2lkfSBbZXJyb3JdIEFuIE9ic2VydmVyIGBlcnJvcmAgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogdm9pZH0gW2NvbXBsZXRlXSBBbiBPYnNlcnZlciBgY29tcGxldGVgIGNhbGxiYWNrLlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICBhY2NlcHQobmV4dE9yT2JzZXJ2ZXI6IFBhcnRpYWxPYnNlcnZlcjxUPiB8ICgodmFsdWU6IFQpID0+IHZvaWQpLCBlcnJvcj86IChlcnI6IGFueSkgPT4gdm9pZCwgY29tcGxldGU/OiAoKSA9PiB2b2lkKSB7XG4gICAgaWYgKG5leHRPck9ic2VydmVyICYmIHR5cGVvZiAoPFBhcnRpYWxPYnNlcnZlcjxUPj5uZXh0T3JPYnNlcnZlcikubmV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMub2JzZXJ2ZSg8UGFydGlhbE9ic2VydmVyPFQ+Pm5leHRPck9ic2VydmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZG8oPCh2YWx1ZTogVCkgPT4gdm9pZD5uZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHNpbXBsZSBPYnNlcnZhYmxlIHRoYXQganVzdCBkZWxpdmVycyB0aGUgbm90aWZpY2F0aW9uIHJlcHJlc2VudGVkXG4gICAqIGJ5IHRoaXMgTm90aWZpY2F0aW9uIGluc3RhbmNlLlxuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqL1xuICB0b09ic2VydmFibGUoKTogT2JzZXJ2YWJsZTxUPiB7XG4gICAgY29uc3Qga2luZCA9IHRoaXMua2luZDtcbiAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgIGNhc2UgJ04nOlxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5vZih0aGlzLnZhbHVlKTtcbiAgICAgIGNhc2UgJ0UnOlxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS50aHJvdyh0aGlzLmVycm9yKTtcbiAgICAgIGNhc2UgJ0MnOlxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5lbXB0eTxUPigpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuZXhwZWN0ZWQgbm90aWZpY2F0aW9uIGtpbmQgdmFsdWUnKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGNvbXBsZXRlTm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb248YW55PiA9IG5ldyBOb3RpZmljYXRpb24oJ0MnKTtcbiAgcHJpdmF0ZSBzdGF0aWMgdW5kZWZpbmVkVmFsdWVOb3RpZmljYXRpb246IE5vdGlmaWNhdGlvbjxhbnk+ID0gbmV3IE5vdGlmaWNhdGlvbignTicsIHVuZGVmaW5lZCk7XG5cbiAgLyoqXG4gICAqIEEgc2hvcnRjdXQgdG8gY3JlYXRlIGEgTm90aWZpY2F0aW9uIGluc3RhbmNlIG9mIHRoZSB0eXBlIGBuZXh0YCBmcm9tIGFcbiAgICogZ2l2ZW4gdmFsdWUuXG4gICAqIEBwYXJhbSB7VH0gdmFsdWUgVGhlIGBuZXh0YCB2YWx1ZS5cbiAgICogQHJldHVybiB7Tm90aWZpY2F0aW9uPFQ+fSBUaGUgXCJuZXh0XCIgTm90aWZpY2F0aW9uIHJlcHJlc2VudGluZyB0aGVcbiAgICogYXJndW1lbnQuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlTmV4dDxUPih2YWx1ZTogVCk6IE5vdGlmaWNhdGlvbjxUPiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgTm90aWZpY2F0aW9uKCdOJywgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51bmRlZmluZWRWYWx1ZU5vdGlmaWNhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNob3J0Y3V0IHRvIGNyZWF0ZSBhIE5vdGlmaWNhdGlvbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBgZXJyb3JgIGZyb20gYVxuICAgKiBnaXZlbiBlcnJvci5cbiAgICogQHBhcmFtIHthbnl9IFtlcnJdIFRoZSBgZXJyb3JgIGVycm9yLlxuICAgKiBAcmV0dXJuIHtOb3RpZmljYXRpb248VD59IFRoZSBcImVycm9yXCIgTm90aWZpY2F0aW9uIHJlcHJlc2VudGluZyB0aGVcbiAgICogYXJndW1lbnQuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlRXJyb3I8VD4oZXJyPzogYW55KTogTm90aWZpY2F0aW9uPFQ+IHtcbiAgICByZXR1cm4gbmV3IE5vdGlmaWNhdGlvbignRScsIHVuZGVmaW5lZCwgZXJyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNob3J0Y3V0IHRvIGNyZWF0ZSBhIE5vdGlmaWNhdGlvbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBgY29tcGxldGVgLlxuICAgKiBAcmV0dXJuIHtOb3RpZmljYXRpb248YW55Pn0gVGhlIHZhbHVlbGVzcyBcImNvbXBsZXRlXCIgTm90aWZpY2F0aW9uLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUNvbXBsZXRlKCk6IE5vdGlmaWNhdGlvbjxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5jb21wbGV0ZU5vdGlmaWNhdGlvbjtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9Ob3RpZmljYXRpb24udHMiLCJpbXBvcnQgeyByb290IH0gZnJvbSAnLi4vdXRpbC9yb290JztcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4vQWN0aW9uJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBBc3luY1NjaGVkdWxlciB9IGZyb20gJy4vQXN5bmNTY2hlZHVsZXInO1xuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuZXhwb3J0IGNsYXNzIEFzeW5jQWN0aW9uPFQ+IGV4dGVuZHMgQWN0aW9uPFQ+IHtcblxuICBwdWJsaWMgaWQ6IGFueTtcbiAgcHVibGljIHN0YXRlOiBUO1xuICBwdWJsaWMgZGVsYXk6IG51bWJlcjtcbiAgcHJvdGVjdGVkIHBlbmRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgc2NoZWR1bGVyOiBBc3luY1NjaGVkdWxlcixcbiAgICAgICAgICAgICAgcHJvdGVjdGVkIHdvcms6ICh0aGlzOiBBc3luY0FjdGlvbjxUPiwgc3RhdGU/OiBUKSA9PiB2b2lkKSB7XG4gICAgc3VwZXIoc2NoZWR1bGVyLCB3b3JrKTtcbiAgfVxuXG4gIHB1YmxpYyBzY2hlZHVsZShzdGF0ZT86IFQsIGRlbGF5OiBudW1iZXIgPSAwKTogU3Vic2NyaXB0aW9uIHtcblxuICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgIH1cblxuICAgIC8vIEFsd2F5cyByZXBsYWNlIHRoZSBjdXJyZW50IHN0YXRlIHdpdGggdGhlIG5ldyBzdGF0ZS5cbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG5cbiAgICAvLyBTZXQgdGhlIHBlbmRpbmcgZmxhZyBpbmRpY2F0aW5nIHRoYXQgdGhpcyBhY3Rpb24gaGFzIGJlZW4gc2NoZWR1bGVkLCBvclxuICAgIC8vIGhhcyByZWN1cnNpdmVseSByZXNjaGVkdWxlZCBpdHNlbGYuXG4gICAgdGhpcy5wZW5kaW5nID0gdHJ1ZTtcblxuICAgIGNvbnN0IGlkID0gdGhpcy5pZDtcbiAgICBjb25zdCBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcblxuICAgIC8vXG4gICAgLy8gSW1wb3J0YW50IGltcGxlbWVudGF0aW9uIG5vdGU6XG4gICAgLy9cbiAgICAvLyBBY3Rpb25zIG9ubHkgZXhlY3V0ZSBvbmNlIGJ5IGRlZmF1bHQsIHVubGVzcyByZXNjaGVkdWxlZCBmcm9tIHdpdGhpbiB0aGVcbiAgICAvLyBzY2hlZHVsZWQgY2FsbGJhY2suIFRoaXMgYWxsb3dzIHVzIHRvIGltcGxlbWVudCBzaW5nbGUgYW5kIHJlcGVhdFxuICAgIC8vIGFjdGlvbnMgdmlhIHRoZSBzYW1lIGNvZGUgcGF0aCwgd2l0aG91dCBhZGRpbmcgQVBJIHN1cmZhY2UgYXJlYSwgYXMgd2VsbFxuICAgIC8vIGFzIG1pbWljIHRyYWRpdGlvbmFsIHJlY3Vyc2lvbiBidXQgYWNyb3NzIGFzeW5jaHJvbm91cyBib3VuZGFyaWVzLlxuICAgIC8vXG4gICAgLy8gSG93ZXZlciwgSlMgcnVudGltZXMgYW5kIHRpbWVycyBkaXN0aW5ndWlzaCBiZXR3ZWVuIGludGVydmFscyBhY2hpZXZlZCBieVxuICAgIC8vIHNlcmlhbCBgc2V0VGltZW91dGAgY2FsbHMgdnMuIGEgc2luZ2xlIGBzZXRJbnRlcnZhbGAgY2FsbC4gQW4gaW50ZXJ2YWwgb2ZcbiAgICAvLyBzZXJpYWwgYHNldFRpbWVvdXRgIGNhbGxzIGNhbiBiZSBpbmRpdmlkdWFsbHkgZGVsYXllZCwgd2hpY2ggZGVsYXlzXG4gICAgLy8gc2NoZWR1bGluZyB0aGUgbmV4dCBgc2V0VGltZW91dGAsIGFuZCBzbyBvbi4gYHNldEludGVydmFsYCBhdHRlbXB0cyB0b1xuICAgIC8vIGd1YXJhbnRlZSB0aGUgaW50ZXJ2YWwgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIG1vcmUgcHJlY2lzZWx5IHRvIHRoZVxuICAgIC8vIGludGVydmFsIHBlcmlvZCwgcmVnYXJkbGVzcyBvZiBsb2FkLlxuICAgIC8vXG4gICAgLy8gVGhlcmVmb3JlLCB3ZSB1c2UgYHNldEludGVydmFsYCB0byBzY2hlZHVsZSBzaW5nbGUgYW5kIHJlcGVhdCBhY3Rpb25zLlxuICAgIC8vIElmIHRoZSBhY3Rpb24gcmVzY2hlZHVsZXMgaXRzZWxmIHdpdGggdGhlIHNhbWUgZGVsYXksIHRoZSBpbnRlcnZhbCBpcyBub3RcbiAgICAvLyBjYW5jZWxlZC4gSWYgdGhlIGFjdGlvbiBkb2Vzbid0IHJlc2NoZWR1bGUsIG9yIHJlc2NoZWR1bGVzIHdpdGggYVxuICAgIC8vIGRpZmZlcmVudCBkZWxheSwgdGhlIGludGVydmFsIHdpbGwgYmUgY2FuY2VsZWQgYWZ0ZXIgc2NoZWR1bGVkIGNhbGxiYWNrXG4gICAgLy8gZXhlY3V0aW9uLlxuICAgIC8vXG4gICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIGRlbGF5KTtcbiAgICB9XG5cbiAgICB0aGlzLmRlbGF5ID0gZGVsYXk7XG4gICAgLy8gSWYgdGhpcyBhY3Rpb24gaGFzIGFscmVhZHkgYW4gYXN5bmMgSWQsIGRvbid0IHJlcXVlc3QgYSBuZXcgb25lLlxuICAgIHRoaXMuaWQgPSB0aGlzLmlkIHx8IHRoaXMucmVxdWVzdEFzeW5jSWQoc2NoZWR1bGVyLCB0aGlzLmlkLCBkZWxheSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHByb3RlY3RlZCByZXF1ZXN0QXN5bmNJZChzY2hlZHVsZXI6IEFzeW5jU2NoZWR1bGVyLCBpZD86IGFueSwgZGVsYXk6IG51bWJlciA9IDApOiBhbnkge1xuICAgIHJldHVybiByb290LnNldEludGVydmFsKHNjaGVkdWxlci5mbHVzaC5iaW5kKHNjaGVkdWxlciwgdGhpcyksIGRlbGF5KTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZWN5Y2xlQXN5bmNJZChzY2hlZHVsZXI6IEFzeW5jU2NoZWR1bGVyLCBpZDogYW55LCBkZWxheTogbnVtYmVyID0gMCk6IGFueSB7XG4gICAgLy8gSWYgdGhpcyBhY3Rpb24gaXMgcmVzY2hlZHVsZWQgd2l0aCB0aGUgc2FtZSBkZWxheSB0aW1lLCBkb24ndCBjbGVhciB0aGUgaW50ZXJ2YWwgaWQuXG4gICAgaWYgKGRlbGF5ICE9PSBudWxsICYmIHRoaXMuZGVsYXkgPT09IGRlbGF5KSB7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSwgaWYgdGhlIGFjdGlvbidzIGRlbGF5IHRpbWUgaXMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgZGVsYXksXG4gICAgLy8gY2xlYXIgdGhlIGludGVydmFsIGlkXG4gICAgcmV0dXJuIHJvb3QuY2xlYXJJbnRlcnZhbChpZCkgJiYgdW5kZWZpbmVkIHx8IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbW1lZGlhdGVseSBleGVjdXRlcyB0aGlzIGFjdGlvbiBhbmQgdGhlIGB3b3JrYCBpdCBjb250YWlucy5cbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgcHVibGljIGV4ZWN1dGUoc3RhdGU6IFQsIGRlbGF5OiBudW1iZXIpOiBhbnkge1xuXG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdleGVjdXRpbmcgYSBjYW5jZWxsZWQgYWN0aW9uJyk7XG4gICAgfVxuXG4gICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgY29uc3QgZXJyb3IgPSB0aGlzLl9leGVjdXRlKHN0YXRlLCBkZWxheSk7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBlbmRpbmcgPT09IGZhbHNlICYmIHRoaXMuaWQgIT0gbnVsbCkge1xuICAgICAgLy8gRGVxdWV1ZSBpZiB0aGUgYWN0aW9uIGRpZG4ndCByZXNjaGVkdWxlIGl0c2VsZi4gRG9uJ3QgY2FsbFxuICAgICAgLy8gdW5zdWJzY3JpYmUoKSwgYmVjYXVzZSB0aGUgYWN0aW9uIGNvdWxkIHJlc2NoZWR1bGUgbGF0ZXIuXG4gICAgICAvLyBGb3IgZXhhbXBsZTpcbiAgICAgIC8vIGBgYFxuICAgICAgLy8gc2NoZWR1bGVyLnNjaGVkdWxlKGZ1bmN0aW9uIGRvV29yayhjb3VudGVyKSB7XG4gICAgICAvLyAgIC8qIC4uLiBJJ20gYSBidXN5IHdvcmtlciBiZWUgLi4uICovXG4gICAgICAvLyAgIHZhciBvcmlnaW5hbEFjdGlvbiA9IHRoaXM7XG4gICAgICAvLyAgIC8qIHdhaXQgMTAwbXMgYmVmb3JlIHJlc2NoZWR1bGluZyB0aGUgYWN0aW9uICovXG4gICAgICAvLyAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gICAgIG9yaWdpbmFsQWN0aW9uLnNjaGVkdWxlKGNvdW50ZXIgKyAxKTtcbiAgICAgIC8vICAgfSwgMTAwKTtcbiAgICAgIC8vIH0sIDEwMDApO1xuICAgICAgLy8gYGBgXG4gICAgICB0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZCh0aGlzLnNjaGVkdWxlciwgdGhpcy5pZCwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9leGVjdXRlKHN0YXRlOiBULCBkZWxheTogbnVtYmVyKTogYW55IHtcbiAgICBsZXQgZXJyb3JlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGxldCBlcnJvclZhbHVlOiBhbnkgPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMud29yayhzdGF0ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JlZCA9IHRydWU7XG4gICAgICBlcnJvclZhbHVlID0gISFlICYmIGUgfHwgbmV3IEVycm9yKGUpO1xuICAgIH1cbiAgICBpZiAoZXJyb3JlZCkge1xuICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgcmV0dXJuIGVycm9yVmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF91bnN1YnNjcmliZSgpIHtcblxuICAgIGNvbnN0IGlkID0gdGhpcy5pZDtcbiAgICBjb25zdCBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICBjb25zdCBhY3Rpb25zID0gc2NoZWR1bGVyLmFjdGlvbnM7XG4gICAgY29uc3QgaW5kZXggPSBhY3Rpb25zLmluZGV4T2YodGhpcyk7XG5cbiAgICB0aGlzLndvcmsgID0gbnVsbDtcbiAgICB0aGlzLmRlbGF5ID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnNjaGVkdWxlciA9IG51bGw7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBhY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuXG4gICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9zY2hlZHVsZXIvQXN5bmNBY3Rpb24udHMiLCJpbXBvcnQgeyBTY2hlZHVsZXIgfSBmcm9tICcuLi9TY2hlZHVsZXInO1xuaW1wb3J0IHsgQXN5bmNBY3Rpb24gfSBmcm9tICcuL0FzeW5jQWN0aW9uJztcblxuZXhwb3J0IGNsYXNzIEFzeW5jU2NoZWR1bGVyIGV4dGVuZHMgU2NoZWR1bGVyIHtcbiAgcHVibGljIGFjdGlvbnM6IEFycmF5PEFzeW5jQWN0aW9uPGFueT4+ID0gW107XG4gIC8qKlxuICAgKiBBIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciB0aGUgU2NoZWR1bGVyIGlzIGN1cnJlbnRseSBleGVjdXRpbmcgYSBiYXRjaCBvZlxuICAgKiBxdWV1ZWQgYWN0aW9ucy5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBwdWJsaWMgYWN0aXZlOiBib29sZWFuID0gZmFsc2U7XG4gIC8qKlxuICAgKiBBbiBpbnRlcm5hbCBJRCB1c2VkIHRvIHRyYWNrIHRoZSBsYXRlc3QgYXN5bmNocm9ub3VzIHRhc2sgc3VjaCBhcyB0aG9zZVxuICAgKiBjb21pbmcgZnJvbSBgc2V0VGltZW91dGAsIGBzZXRJbnRlcnZhbGAsIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLCBhbmRcbiAgICogb3RoZXJzLlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgcHVibGljIHNjaGVkdWxlZDogYW55ID0gdW5kZWZpbmVkO1xuXG4gIHB1YmxpYyBmbHVzaChhY3Rpb246IEFzeW5jQWN0aW9uPGFueT4pOiB2b2lkIHtcblxuICAgIGNvbnN0IHthY3Rpb25zfSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIGFjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBlcnJvcjogYW55O1xuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcblxuICAgIGRvIHtcbiAgICAgIGlmIChlcnJvciA9IGFjdGlvbi5leGVjdXRlKGFjdGlvbi5zdGF0ZSwgYWN0aW9uLmRlbGF5KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IHdoaWxlIChhY3Rpb24gPSBhY3Rpb25zLnNoaWZ0KCkpOyAvLyBleGhhdXN0IHRoZSBzY2hlZHVsZXIgcXVldWVcblxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHdoaWxlIChhY3Rpb24gPSBhY3Rpb25zLnNoaWZ0KCkpIHtcbiAgICAgICAgYWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvc2NoZWR1bGVyL0FzeW5jU2NoZWR1bGVyLnRzIiwiaW1wb3J0IHsgcm9vdCB9IGZyb20gJy4uL3V0aWwvcm9vdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzeW1ib2xJdGVyYXRvclBvbnlmaWxsKHJvb3Q6IGFueSkge1xuICBjb25zdCBTeW1ib2w6IGFueSA9IHJvb3QuU3ltYm9sO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKCFTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgIFN5bWJvbC5pdGVyYXRvciA9IFN5bWJvbCgnaXRlcmF0b3IgcG9seWZpbGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIFN5bWJvbC5pdGVyYXRvcjtcbiAgfSBlbHNlIHtcbiAgICAvLyBbZm9yIE1vemlsbGEgR2Vja28gMjctMzU6XShodHRwczovL216bC5sYS8yZXdFMXpDKVxuICAgIGNvbnN0IHsgU2V0IH0gPSByb290O1xuICAgIGlmIChTZXQgJiYgdHlwZW9mIG5ldyBTZXQoKVsnQEBpdGVyYXRvciddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gJ0BAaXRlcmF0b3InO1xuICAgIH1cbiAgICBjb25zdCB7IE1hcCB9ID0gcm9vdDtcbiAgICAvLyByZXF1aXJlZCBmb3IgY29tcGF0YWJpbGl0eSB3aXRoIGVzNi1zaGltXG4gICAgaWYgKE1hcCkge1xuICAgICAgbGV0IGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNYXAucHJvdG90eXBlKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBsZXQga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgLy8gYWNjb3JkaW5nIHRvIHNwZWMsIE1hcC5wcm90b3R5cGVbQEBpdGVyYXRvcl0gYW5kIE1hcC5vcm90b3R5cGUuZW50cmllcyBtdXN0IGJlIGVxdWFsLlxuICAgICAgICBpZiAoa2V5ICE9PSAnZW50cmllcycgJiYga2V5ICE9PSAnc2l6ZScgJiYgTWFwLnByb3RvdHlwZVtrZXldID09PSBNYXAucHJvdG90eXBlWydlbnRyaWVzJ10pIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnQEBpdGVyYXRvcic7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGl0ZXJhdG9yID0gc3ltYm9sSXRlcmF0b3JQb255ZmlsbChyb290KTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgaXRlcmF0b3IgaW5zdGVhZFxuICovXG5leHBvcnQgY29uc3QgJCRpdGVyYXRvciA9IGl0ZXJhdG9yO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9zeW1ib2wvaXRlcmF0b3IudHMiLCJpbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAnLi9TdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi9TdWJzY3JpcHRpb24nO1xuXG4vKipcbiAqIEBjbGFzcyBBc3luY1N1YmplY3Q8VD5cbiAqL1xuZXhwb3J0IGNsYXNzIEFzeW5jU3ViamVjdDxUPiBleHRlbmRzIFN1YmplY3Q8VD4ge1xuICBwcml2YXRlIHZhbHVlOiBUID0gbnVsbDtcbiAgcHJpdmF0ZSBoYXNOZXh0OiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgaGFzQ29tcGxldGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJvdGVjdGVkIF9zdWJzY3JpYmUoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxhbnk+KTogU3Vic2NyaXB0aW9uIHtcbiAgICBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgc3Vic2NyaWJlci5lcnJvcih0aGlzLnRocm93bkVycm9yKTtcbiAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmhhc0NvbXBsZXRlZCAmJiB0aGlzLmhhc05leHQpIHtcbiAgICAgIHN1YnNjcmliZXIubmV4dCh0aGlzLnZhbHVlKTtcbiAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5fc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICB9XG5cbiAgbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuaGFzTmV4dCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZXJyb3IoZXJyb3I6IGFueSk6IHZvaWQge1xuICAgIGlmICghdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgIHN1cGVyLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBjb21wbGV0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuaGFzTmV4dCkge1xuICAgICAgc3VwZXIubmV4dCh0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgc3VwZXIuY29tcGxldGUoKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9Bc3luY1N1YmplY3QudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IE9ic2VydmVyIH0gZnJvbSAnLi4vT2JzZXJ2ZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE91dGVyU3Vic2NyaWJlciB9IGZyb20gJy4uL091dGVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBTdWJzY3JpYmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHN1YnNjcmliZVRvUmVzdWx0IH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUFsbDxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBjb25jdXJyZW50PzogbnVtYmVyKTogVDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUFsbDxULCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBjb25jdXJyZW50PzogbnVtYmVyKTogU3Vic2NyaWJhYmxlPFI+O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgaGlnaGVyLW9yZGVyIE9ic2VydmFibGUgaW50byBhIGZpcnN0LW9yZGVyIE9ic2VydmFibGUgd2hpY2hcbiAqIGNvbmN1cnJlbnRseSBkZWxpdmVycyBhbGwgdmFsdWVzIHRoYXQgYXJlIGVtaXR0ZWQgb24gdGhlIGlubmVyIE9ic2VydmFibGVzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBhbiBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21lcmdlQWxsLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBtZXJnZUFsbGAgc3Vic2NyaWJlcyB0byBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgT2JzZXJ2YWJsZXMsIGFsc28ga25vd24gYXNcbiAqIGEgaGlnaGVyLW9yZGVyIE9ic2VydmFibGUuIEVhY2ggdGltZSBpdCBvYnNlcnZlcyBvbmUgb2YgdGhlc2UgZW1pdHRlZCBpbm5lclxuICogT2JzZXJ2YWJsZXMsIGl0IHN1YnNjcmliZXMgdG8gdGhhdCBhbmQgZGVsaXZlcnMgYWxsIHRoZSB2YWx1ZXMgZnJvbSB0aGVcbiAqIGlubmVyIE9ic2VydmFibGUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgb25seVxuICogY29tcGxldGVzIG9uY2UgYWxsIGlubmVyIE9ic2VydmFibGVzIGhhdmUgY29tcGxldGVkLiBBbnkgZXJyb3IgZGVsaXZlcmVkIGJ5XG4gKiBhIGlubmVyIE9ic2VydmFibGUgd2lsbCBiZSBpbW1lZGlhdGVseSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5TcGF3biBhIG5ldyBpbnRlcnZhbCBPYnNlcnZhYmxlIGZvciBlYWNoIGNsaWNrIGV2ZW50LCBhbmQgYmxlbmQgdGhlaXIgb3V0cHV0cyBhcyBvbmUgT2JzZXJ2YWJsZTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgaGlnaGVyT3JkZXIgPSBjbGlja3MubWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiB2YXIgZmlyc3RPcmRlciA9IGhpZ2hlck9yZGVyLm1lcmdlQWxsKCk7XG4gKiBmaXJzdE9yZGVyLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db3VudCBmcm9tIDAgdG8gOSBldmVyeSBzZWNvbmQgZm9yIGVhY2ggY2xpY2ssIGJ1dCBvbmx5IGFsbG93IDIgY29uY3VycmVudCB0aW1lcnM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGhpZ2hlck9yZGVyID0gY2xpY2tzLm1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgxMCkpO1xuICogdmFyIGZpcnN0T3JkZXIgPSBoaWdoZXJPcmRlci5tZXJnZUFsbCgyKTtcbiAqIGZpcnN0T3JkZXIuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0fVxuICogQHNlZSB7QGxpbmsgbWVyZ2V9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwVG99XG4gKiBAc2VlIHtAbGluayBtZXJnZVNjYW59XG4gKiBAc2VlIHtAbGluayBzd2l0Y2h9XG4gKiBAc2VlIHtAbGluayB6aXBBbGx9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2YgaW5uZXJcbiAqIE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHZhbHVlcyBjb21pbmcgZnJvbSBhbGwgdGhlXG4gKiBpbm5lciBPYnNlcnZhYmxlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgbWVyZ2VBbGxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUFsbDxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBjb25jdXJyZW50OiBudW1iZXIgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpOiBUIHtcbiAgcmV0dXJuIDxhbnk+dGhpcy5saWZ0PGFueT4obmV3IE1lcmdlQWxsT3BlcmF0b3I8VD4oY29uY3VycmVudCkpO1xufVxuXG5leHBvcnQgY2xhc3MgTWVyZ2VBbGxPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPE9ic2VydmFibGU8VD4sIFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjb25jdXJyZW50OiBudW1iZXIpIHtcbiAgfVxuXG4gIGNhbGwob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+LCBzb3VyY2U6IGFueSk6IGFueSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1lcmdlQWxsU3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5jb25jdXJyZW50KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmV4cG9ydCBjbGFzcyBNZXJnZUFsbFN1YnNjcmliZXI8VD4gZXh0ZW5kcyBPdXRlclN1YnNjcmliZXI8T2JzZXJ2YWJsZTxUPiwgVD4ge1xuICBwcml2YXRlIGhhc0NvbXBsZXRlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGJ1ZmZlcjogT2JzZXJ2YWJsZTxUPltdID0gW107XG4gIHByaXZhdGUgYWN0aXZlOiBudW1iZXIgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBPYnNlcnZlcjxUPiwgcHJpdmF0ZSBjb25jdXJyZW50OiBudW1iZXIpIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQob2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxUPikge1xuICAgIGlmICh0aGlzLmFjdGl2ZSA8IHRoaXMuY29uY3VycmVudCkge1xuICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0PE9ic2VydmFibGU8VD4sIFQ+KHRoaXMsIG9ic2VydmFibGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChvYnNlcnZhYmxlKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbXBsZXRlKCkge1xuICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5idWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgbm90aWZ5Q29tcGxldGUoaW5uZXJTdWI6IFN1YnNjcmlwdGlvbikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcbiAgICB0aGlzLmFjdGl2ZS0tO1xuICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fbmV4dChidWZmZXIuc2hpZnQoKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmhhc0NvbXBsZXRlZCkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9tZXJnZUFsbC50cyIsImltcG9ydCB7IHJvb3QgfSBmcm9tICcuLi91dGlsL3Jvb3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3ltYm9sT2JzZXJ2YWJsZShjb250ZXh0OiBhbnkpIHtcbiAgbGV0ICQkb2JzZXJ2YWJsZTogYW55O1xuICBsZXQgU3ltYm9sID0gY29udGV4dC5TeW1ib2w7XG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoU3ltYm9sLm9ic2VydmFibGUpIHtcbiAgICAgICQkb2JzZXJ2YWJsZSA9IFN5bWJvbC5vYnNlcnZhYmxlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgICQkb2JzZXJ2YWJsZSA9IFN5bWJvbCgnb2JzZXJ2YWJsZScpO1xuICAgICAgICBTeW1ib2wub2JzZXJ2YWJsZSA9ICQkb2JzZXJ2YWJsZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgJCRvYnNlcnZhYmxlID0gJ0BAb2JzZXJ2YWJsZSc7XG4gIH1cblxuICByZXR1cm4gJCRvYnNlcnZhYmxlO1xufVxuXG5leHBvcnQgY29uc3Qgb2JzZXJ2YWJsZSA9IGdldFN5bWJvbE9ic2VydmFibGUocm9vdCk7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIG9ic2VydmFibGUgaW5zdGVhZFxuICovXG5leHBvcnQgY29uc3QgJCRvYnNlcnZhYmxlID0gb2JzZXJ2YWJsZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvc3ltYm9sL29ic2VydmFibGUudHMiLCJpbXBvcnQgeyByb290IH0gZnJvbSAnLi4vdXRpbC9yb290JztcblxuY29uc3QgU3ltYm9sOiBhbnkgPSByb290LlN5bWJvbDtcblxuZXhwb3J0IGNvbnN0IHJ4U3Vic2NyaWJlciA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nKSA/XG4gIFN5bWJvbC5mb3IoJ3J4U3Vic2NyaWJlcicpIDogJ0BAcnhTdWJzY3JpYmVyJztcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2UgcnhTdWJzY3JpYmVyIGluc3RlYWRcbiAqL1xuZXhwb3J0IGNvbnN0ICQkcnhTdWJzY3JpYmVyID0gcnhTdWJzY3JpYmVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9zeW1ib2wvcnhTdWJzY3JpYmVyLnRzIiwiLyoqXG4gKiBBbiBlcnJvciB0aHJvd24gd2hlbiBhbiBlbGVtZW50IHdhcyBxdWVyaWVkIGF0IGEgY2VydGFpbiBpbmRleCBvZiBhblxuICogT2JzZXJ2YWJsZSwgYnV0IG5vIHN1Y2ggaW5kZXggb3IgcG9zaXRpb24gZXhpc3RzIGluIHRoYXQgc2VxdWVuY2UuXG4gKlxuICogQHNlZSB7QGxpbmsgZWxlbWVudEF0fVxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqIEBzZWUge0BsaW5rIHRha2VMYXN0fVxuICpcbiAqIEBjbGFzcyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvclxuICovXG5leHBvcnQgY2xhc3MgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IGVycjogYW55ID0gc3VwZXIoJ2FyZ3VtZW50IG91dCBvZiByYW5nZScpO1xuICAgICg8YW55PiB0aGlzKS5uYW1lID0gZXJyLm5hbWUgPSAnQXJndW1lbnRPdXRPZlJhbmdlRXJyb3InO1xuICAgICg8YW55PiB0aGlzKS5zdGFjayA9IGVyci5zdGFjaztcbiAgICAoPGFueT4gdGhpcykubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3V0aWwvQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IudHMiLCIvKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIGFuIE9ic2VydmFibGUgb3IgYSBzZXF1ZW5jZSB3YXMgcXVlcmllZCBidXQgaGFzIG5vXG4gKiBlbGVtZW50cy5cbiAqXG4gKiBAc2VlIHtAbGluayBmaXJzdH1cbiAqIEBzZWUge0BsaW5rIGxhc3R9XG4gKiBAc2VlIHtAbGluayBzaW5nbGV9XG4gKlxuICogQGNsYXNzIEVtcHR5RXJyb3JcbiAqL1xuZXhwb3J0IGNsYXNzIEVtcHR5RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnN0IGVycjogYW55ID0gc3VwZXIoJ25vIGVsZW1lbnRzIGluIHNlcXVlbmNlJyk7XG4gICAgKDxhbnk+IHRoaXMpLm5hbWUgPSBlcnIubmFtZSA9ICdFbXB0eUVycm9yJztcbiAgICAoPGFueT4gdGhpcykuc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgKDxhbnk+IHRoaXMpLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy91dGlsL0VtcHR5RXJyb3IudHMiLCIvKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIGFuIGFjdGlvbiBpcyBpbnZhbGlkIGJlY2F1c2UgdGhlIG9iamVjdCBoYXMgYmVlblxuICogdW5zdWJzY3JpYmVkLlxuICpcbiAqIEBzZWUge0BsaW5rIFN1YmplY3R9XG4gKiBAc2VlIHtAbGluayBCZWhhdmlvclN1YmplY3R9XG4gKlxuICogQGNsYXNzIE9iamVjdFVuc3Vic2NyaWJlZEVycm9yXG4gKi9cbmV4cG9ydCBjbGFzcyBPYmplY3RVbnN1YnNjcmliZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc3QgZXJyOiBhbnkgPSBzdXBlcignb2JqZWN0IHVuc3Vic2NyaWJlZCcpO1xuICAgICg8YW55PiB0aGlzKS5uYW1lID0gZXJyLm5hbWUgPSAnT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InO1xuICAgICg8YW55PiB0aGlzKS5zdGFjayA9IGVyci5zdGFjaztcbiAgICAoPGFueT4gdGhpcykubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IudHMiLCJleHBvcnQgZnVuY3Rpb24gaXNEYXRlKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBEYXRlIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4oK3ZhbHVlKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvdXRpbC9pc0RhdGUudHMiLCJleHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih4OiBhbnkpOiB4IGlzIEZ1bmN0aW9uIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy91dGlsL2lzRnVuY3Rpb24udHMiLCJpbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi4vdXRpbC9pc0FycmF5JztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtZXJpYyh2YWw6IGFueSk6IHZhbCBpcyBudW1iZXIge1xuICAvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAobnVsbHx0cnVlfGZhbHNlfFwiXCIpXG4gIC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcbiAgLy8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG4gIC8vIGFkZGluZyAxIGNvcnJlY3RzIGxvc3Mgb2YgcHJlY2lzaW9uIGZyb20gcGFyc2VGbG9hdCAoIzE1MTAwKVxuICByZXR1cm4gIWlzQXJyYXkodmFsKSAmJiAodmFsIC0gcGFyc2VGbG9hdCh2YWwpICsgMSkgPj0gMDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3V0aWwvaXNOdW1lcmljLnRzIiwiaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJy4vU3ViamVjdCc7XG5pbXBvcnQgeyBJU2NoZWR1bGVyIH0gZnJvbSAnLi9TY2hlZHVsZXInO1xuaW1wb3J0IHsgcXVldWUgfSBmcm9tICcuL3NjaGVkdWxlci9xdWV1ZSc7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE9ic2VydmVPblN1YnNjcmliZXIgfSBmcm9tICcuL29wZXJhdG9yL29ic2VydmVPbic7XG5pbXBvcnQgeyBPYmplY3RVbnN1YnNjcmliZWRFcnJvciB9IGZyb20gJy4vdXRpbC9PYmplY3RVbnN1YnNjcmliZWRFcnJvcic7XG5pbXBvcnQgeyBTdWJqZWN0U3Vic2NyaXB0aW9uIH0gZnJvbSAnLi9TdWJqZWN0U3Vic2NyaXB0aW9uJztcbi8qKlxuICogQGNsYXNzIFJlcGxheVN1YmplY3Q8VD5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlcGxheVN1YmplY3Q8VD4gZXh0ZW5kcyBTdWJqZWN0PFQ+IHtcbiAgcHJpdmF0ZSBfZXZlbnRzOiBSZXBsYXlFdmVudDxUPltdID0gW107XG4gIHByaXZhdGUgX2J1ZmZlclNpemU6IG51bWJlcjtcbiAgcHJpdmF0ZSBfd2luZG93VGltZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKGJ1ZmZlclNpemU6IG51bWJlciA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgICAgICAgd2luZG93VGltZTogbnVtYmVyID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgICAgICBwcml2YXRlIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2J1ZmZlclNpemUgPSBidWZmZXJTaXplIDwgMSA/IDEgOiBidWZmZXJTaXplO1xuICAgIHRoaXMuX3dpbmRvd1RpbWUgPSB3aW5kb3dUaW1lIDwgMSA/IDEgOiB3aW5kb3dUaW1lO1xuICB9XG5cbiAgbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIGNvbnN0IG5vdyA9IHRoaXMuX2dldE5vdygpO1xuICAgIHRoaXMuX2V2ZW50cy5wdXNoKG5ldyBSZXBsYXlFdmVudChub3csIHZhbHVlKSk7XG4gICAgdGhpcy5fdHJpbUJ1ZmZlclRoZW5HZXRFdmVudHMoKTtcbiAgICBzdXBlci5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4pOiBTdWJzY3JpcHRpb24ge1xuICAgIGNvbnN0IF9ldmVudHMgPSB0aGlzLl90cmltQnVmZmVyVGhlbkdldEV2ZW50cygpO1xuICAgIGNvbnN0IHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgIGxldCBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmhhc0Vycm9yKSB7XG4gICAgICBzdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgc3Vic2NyaXB0aW9uID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9ic2VydmVycy5wdXNoKHN1YnNjcmliZXIpO1xuICAgICAgc3Vic2NyaXB0aW9uID0gbmV3IFN1YmplY3RTdWJzY3JpcHRpb24odGhpcywgc3Vic2NyaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgc3Vic2NyaWJlci5hZGQoc3Vic2NyaWJlciA9IG5ldyBPYnNlcnZlT25TdWJzY3JpYmVyPFQ+KHN1YnNjcmliZXIsIHNjaGVkdWxlcikpO1xuICAgIH1cblxuICAgIGNvbnN0IGxlbiA9IF9ldmVudHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuICYmICFzdWJzY3JpYmVyLmNsb3NlZDsgaSsrKSB7XG4gICAgICBzdWJzY3JpYmVyLm5leHQoX2V2ZW50c1tpXS52YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgIHN1YnNjcmliZXIuZXJyb3IodGhpcy50aHJvd25FcnJvcik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cblxuICBfZ2V0Tm93KCk6IG51bWJlciB7XG4gICAgcmV0dXJuICh0aGlzLnNjaGVkdWxlciB8fCBxdWV1ZSkubm93KCk7XG4gIH1cblxuICBwcml2YXRlIF90cmltQnVmZmVyVGhlbkdldEV2ZW50cygpOiBSZXBsYXlFdmVudDxUPltdIHtcbiAgICBjb25zdCBub3cgPSB0aGlzLl9nZXROb3coKTtcbiAgICBjb25zdCBfYnVmZmVyU2l6ZSA9IHRoaXMuX2J1ZmZlclNpemU7XG4gICAgY29uc3QgX3dpbmRvd1RpbWUgPSB0aGlzLl93aW5kb3dUaW1lO1xuICAgIGNvbnN0IF9ldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgICBsZXQgZXZlbnRzQ291bnQgPSBfZXZlbnRzLmxlbmd0aDtcbiAgICBsZXQgc3BsaWNlQ291bnQgPSAwO1xuXG4gICAgLy8gVHJpbSBldmVudHMgdGhhdCBmYWxsIG91dCBvZiB0aGUgdGltZSB3aW5kb3cuXG4gICAgLy8gU3RhcnQgYXQgdGhlIGZyb250IG9mIHRoZSBsaXN0LiBCcmVhayBlYXJseSBvbmNlXG4gICAgLy8gd2UgZW5jb3VudGVyIGFuIGV2ZW50IHRoYXQgZmFsbHMgd2l0aGluIHRoZSB3aW5kb3cuXG4gICAgd2hpbGUgKHNwbGljZUNvdW50IDwgZXZlbnRzQ291bnQpIHtcbiAgICAgIGlmICgobm93IC0gX2V2ZW50c1tzcGxpY2VDb3VudF0udGltZSkgPCBfd2luZG93VGltZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNwbGljZUNvdW50Kys7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50c0NvdW50ID4gX2J1ZmZlclNpemUpIHtcbiAgICAgIHNwbGljZUNvdW50ID0gTWF0aC5tYXgoc3BsaWNlQ291bnQsIGV2ZW50c0NvdW50IC0gX2J1ZmZlclNpemUpO1xuICAgIH1cblxuICAgIGlmIChzcGxpY2VDb3VudCA+IDApIHtcbiAgICAgIF9ldmVudHMuc3BsaWNlKDAsIHNwbGljZUNvdW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2V2ZW50cztcbiAgfVxufVxuXG5jbGFzcyBSZXBsYXlFdmVudDxUPiB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB0aW1lOiBudW1iZXIsIHB1YmxpYyB2YWx1ZTogVCkge1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL1JlcGxheVN1YmplY3QudHMiLCJpbXBvcnQgeyBJU2NoZWR1bGVyIH0gZnJvbSAnLi4vU2NoZWR1bGVyJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IFRlYXJkb3duTG9naWMgfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xuZXhwb3J0IGNsYXNzIFNjYWxhck9ic2VydmFibGU8VD4gZXh0ZW5kcyBPYnNlcnZhYmxlPFQ+IHtcbiAgc3RhdGljIGNyZWF0ZTxUPih2YWx1ZTogVCwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IFNjYWxhck9ic2VydmFibGU8VD4ge1xuICAgIHJldHVybiBuZXcgU2NhbGFyT2JzZXJ2YWJsZSh2YWx1ZSwgc2NoZWR1bGVyKTtcbiAgfVxuXG4gIHN0YXRpYyBkaXNwYXRjaChzdGF0ZTogYW55KTogdm9pZCB7XG4gICAgY29uc3QgeyBkb25lLCB2YWx1ZSwgc3Vic2NyaWJlciB9ID0gc3RhdGU7XG5cbiAgICBpZiAoZG9uZSkge1xuICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhdGUuZG9uZSA9IHRydWU7XG4gICAgKDxhbnk+IHRoaXMpLnNjaGVkdWxlKHN0YXRlKTtcbiAgfVxuXG4gIF9pc1NjYWxhcjogYm9vbGVhbiA9IHRydWU7XG5cbiAgY29uc3RydWN0b3IocHVibGljIHZhbHVlOiBULCBwcml2YXRlIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgIHRoaXMuX2lzU2NhbGFyID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9zdWJzY3JpYmUoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPik6IFRlYXJkb3duTG9naWMge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICBjb25zdCBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcblxuICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoU2NhbGFyT2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwge1xuICAgICAgICBkb25lOiBmYWxzZSwgdmFsdWUsIHN1YnNjcmliZXJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29ic2VydmFibGUvU2NhbGFyT2JzZXJ2YWJsZS50cyIsImltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmFibGVJbnB1dCB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgQXJyYXlPYnNlcnZhYmxlIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUnO1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJy4uL3V0aWwvaXNBcnJheSc7XG5pbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IE91dGVyU3Vic2NyaWJlciB9IGZyb20gJy4uL091dGVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBJbm5lclN1YnNjcmliZXIgfSBmcm9tICcuLi9Jbm5lclN1YnNjcmliZXInO1xuaW1wb3J0IHsgc3Vic2NyaWJlVG9SZXN1bHQgfSBmcm9tICcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0JztcbmNvbnN0IG5vbmUgPSB7fTtcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZUxhdGVzdDxULCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBwcm9qZWN0OiAodjE6IFQpID0+IFIpOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVMYXRlc3Q8VCwgVDIsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCBwcm9qZWN0OiAodjE6IFQsIHYyOiBUMikgPT4gUik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gY29tYmluZUxhdGVzdDxULCBUMiwgVDMsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgcHJvamVjdDogKHYxOiBULCB2MjogVDIsIHYzOiBUMykgPT4gUik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gY29tYmluZUxhdGVzdDxULCBUMiwgVDMsIFQ0LCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCBwcm9qZWN0OiAodjE6IFQsIHYyOiBUMiwgdjM6IFQzLCB2NDogVDQpID0+IFIpOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVMYXRlc3Q8VCwgVDIsIFQzLCBUNCwgVDUsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4sIHY1OiBPYnNlcnZhYmxlSW5wdXQ8VDU+LCBwcm9qZWN0OiAodjE6IFQsIHYyOiBUMiwgdjM6IFQzLCB2NDogVDQsIHY1OiBUNSkgPT4gUik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gY29tYmluZUxhdGVzdDxULCBUMiwgVDMsIFQ0LCBUNSwgVDYsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4sIHY1OiBPYnNlcnZhYmxlSW5wdXQ8VDU+LCB2NjogT2JzZXJ2YWJsZUlucHV0PFQ2PiwgcHJvamVjdDogKHYxOiBULCB2MjogVDIsIHYzOiBUMywgdjQ6IFQ0LCB2NTogVDUsIHY2OiBUNikgPT4gUik6IE9ic2VydmFibGU8Uj4gO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVMYXRlc3Q8VCwgVDI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+KTogT2JzZXJ2YWJsZTxbVCwgVDJdPjtcbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lTGF0ZXN0PFQsIFQyLCBUMz4odGhpczogT2JzZXJ2YWJsZTxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+KTogT2JzZXJ2YWJsZTxbVCwgVDIsIFQzXT47XG5leHBvcnQgZnVuY3Rpb24gY29tYmluZUxhdGVzdDxULCBUMiwgVDMsIFQ0Pih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+KTogT2JzZXJ2YWJsZTxbVCwgVDIsIFQzLCBUNF0+O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVMYXRlc3Q8VCwgVDIsIFQzLCBUNCwgVDU+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4sIHY1OiBPYnNlcnZhYmxlSW5wdXQ8VDU+KTogT2JzZXJ2YWJsZTxbVCwgVDIsIFQzLCBUNCwgVDVdPjtcbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lTGF0ZXN0PFQsIFQyLCBUMywgVDQsIFQ1LCBUNj4odGhpczogT2JzZXJ2YWJsZTxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCB2NDogT2JzZXJ2YWJsZUlucHV0PFQ0PiwgdjU6IE9ic2VydmFibGVJbnB1dDxUNT4sIHY2OiBPYnNlcnZhYmxlSW5wdXQ8VDY+KTogT2JzZXJ2YWJsZTxbVCwgVDIsIFQzLCBUNCwgVDUsIFQ2XT4gO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVMYXRlc3Q8VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgLi4ub2JzZXJ2YWJsZXM6IEFycmF5PE9ic2VydmFibGVJbnB1dDxUPiB8ICgoLi4udmFsdWVzOiBBcnJheTxUPikgPT4gUik+KTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lTGF0ZXN0PFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIGFycmF5OiBPYnNlcnZhYmxlSW5wdXQ8VD5bXSk6IE9ic2VydmFibGU8QXJyYXk8VD4+O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVMYXRlc3Q8VCwgVE90aGVyLCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBhcnJheTogT2JzZXJ2YWJsZUlucHV0PFRPdGhlcj5bXSwgcHJvamVjdDogKHYxOiBULCAuLi52YWx1ZXM6IEFycmF5PFRPdGhlcj4pID0+IFIpOiBPYnNlcnZhYmxlPFI+O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cblxuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0byBjcmVhdGUgYW4gT2JzZXJ2YWJsZSB3aG9zZSB2YWx1ZXMgYXJlXG4gKiBjYWxjdWxhdGVkIGZyb20gdGhlIGxhdGVzdCB2YWx1ZXMgb2YgZWFjaCBvZiBpdHMgaW5wdXQgT2JzZXJ2YWJsZXMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPldoZW5ldmVyIGFueSBpbnB1dCBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUsIGl0XG4gKiBjb21wdXRlcyBhIGZvcm11bGEgdXNpbmcgdGhlIGxhdGVzdCB2YWx1ZXMgZnJvbSBhbGwgdGhlIGlucHV0cywgdGhlbiBlbWl0c1xuICogdGhlIG91dHB1dCBvZiB0aGF0IGZvcm11bGEuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29tYmluZUxhdGVzdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgY29tYmluZUxhdGVzdGAgY29tYmluZXMgdGhlIHZhbHVlcyBmcm9tIHRoaXMgT2JzZXJ2YWJsZSB3aXRoIHZhbHVlcyBmcm9tXG4gKiBPYnNlcnZhYmxlcyBwYXNzZWQgYXMgYXJndW1lbnRzLiBUaGlzIGlzIGRvbmUgYnkgc3Vic2NyaWJpbmcgdG8gZWFjaFxuICogT2JzZXJ2YWJsZSwgaW4gb3JkZXIsIGFuZCBjb2xsZWN0aW5nIGFuIGFycmF5IG9mIGVhY2ggb2YgdGhlIG1vc3QgcmVjZW50XG4gKiB2YWx1ZXMgYW55IHRpbWUgYW55IG9mIHRoZSBpbnB1dCBPYnNlcnZhYmxlcyBlbWl0cywgdGhlbiBlaXRoZXIgdGFraW5nIHRoYXRcbiAqIGFycmF5IGFuZCBwYXNzaW5nIGl0IGFzIGFyZ3VtZW50cyB0byBhbiBvcHRpb25hbCBgcHJvamVjdGAgZnVuY3Rpb24gYW5kXG4gKiBlbWl0dGluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoYXQsIG9yIGp1c3QgZW1pdHRpbmcgdGhlIGFycmF5IG9mIHJlY2VudFxuICogdmFsdWVzIGRpcmVjdGx5IGlmIHRoZXJlIGlzIG5vIGBwcm9qZWN0YCBmdW5jdGlvbi5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5EeW5hbWljYWxseSBjYWxjdWxhdGUgdGhlIEJvZHktTWFzcyBJbmRleCBmcm9tIGFuIE9ic2VydmFibGUgb2Ygd2VpZ2h0IGFuZCBvbmUgZm9yIGhlaWdodDwvY2FwdGlvbj5cbiAqIHZhciB3ZWlnaHQgPSBSeC5PYnNlcnZhYmxlLm9mKDcwLCA3MiwgNzYsIDc5LCA3NSk7XG4gKiB2YXIgaGVpZ2h0ID0gUnguT2JzZXJ2YWJsZS5vZigxLjc2LCAxLjc3LCAxLjc4KTtcbiAqIHZhciBibWkgPSB3ZWlnaHQuY29tYmluZUxhdGVzdChoZWlnaHQsICh3LCBoKSA9PiB3IC8gKGggKiBoKSk7XG4gKiBibWkuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coJ0JNSSBpcyAnICsgeCkpO1xuICpcbiAqIC8vIFdpdGggb3V0cHV0IHRvIGNvbnNvbGU6XG4gKiAvLyBCTUkgaXMgMjQuMjEyMjkzMzg4NDI5NzUzXG4gKiAvLyBCTUkgaXMgMjMuOTM5NDgwOTkyMDUyMDlcbiAqIC8vIEJNSSBpcyAyMy42NzEyNTM2Mjk1OTIyMjJcbiAqXG4gKiBAc2VlIHtAbGluayBjb21iaW5lQWxsfVxuICogQHNlZSB7QGxpbmsgbWVyZ2V9XG4gKiBAc2VlIHtAbGluayB3aXRoTGF0ZXN0RnJvbX1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGVJbnB1dH0gb3RoZXIgQW4gaW5wdXQgT2JzZXJ2YWJsZSB0byBjb21iaW5lIHdpdGggdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gTW9yZSB0aGFuIG9uZSBpbnB1dCBPYnNlcnZhYmxlcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJvamVjdF0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gcHJvamVjdCB0aGUgdmFsdWVzIGZyb21cbiAqIHRoZSBjb21iaW5lZCBsYXRlc3QgdmFsdWVzIGludG8gYSBuZXcgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiBwcm9qZWN0ZWQgdmFsdWVzIGZyb20gdGhlIG1vc3QgcmVjZW50XG4gKiB2YWx1ZXMgZnJvbSBlYWNoIGlucHV0IE9ic2VydmFibGUsIG9yIGFuIGFycmF5IG9mIHRoZSBtb3N0IHJlY2VudCB2YWx1ZXMgZnJvbVxuICogZWFjaCBpbnB1dCBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBjb21iaW5lTGF0ZXN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZUxhdGVzdDxULCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCAuLi5vYnNlcnZhYmxlczogQXJyYXk8T2JzZXJ2YWJsZUlucHV0PGFueT4gfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5PE9ic2VydmFibGVJbnB1dDxhbnk+PiB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCguLi52YWx1ZXM6IEFycmF5PGFueT4pID0+IFIpPik6IE9ic2VydmFibGU8Uj4ge1xuICBsZXQgcHJvamVjdDogKC4uLnZhbHVlczogQXJyYXk8YW55PikgPT4gUiA9IG51bGw7XG4gIGlmICh0eXBlb2Ygb2JzZXJ2YWJsZXNbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICBwcm9qZWN0ID0gPCguLi52YWx1ZXM6IEFycmF5PGFueT4pID0+IFI+b2JzZXJ2YWJsZXMucG9wKCk7XG4gIH1cblxuICAvLyBpZiB0aGUgZmlyc3QgYW5kIG9ubHkgb3RoZXIgYXJndW1lbnQgYmVzaWRlcyB0aGUgcmVzdWx0U2VsZWN0b3IgaXMgYW4gYXJyYXlcbiAgLy8gYXNzdW1lIGl0J3MgYmVlbiBjYWxsZWQgd2l0aCBgY29tYmluZUxhdGVzdChbb2JzMSwgb2JzMiwgb2JzM10sIHByb2plY3QpYFxuICBpZiAob2JzZXJ2YWJsZXMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkob2JzZXJ2YWJsZXNbMF0pKSB7XG4gICAgb2JzZXJ2YWJsZXMgPSAoPGFueT5vYnNlcnZhYmxlc1swXSkuc2xpY2UoKTtcbiAgfVxuXG4gIG9ic2VydmFibGVzLnVuc2hpZnQodGhpcyk7XG5cbiAgcmV0dXJuIHRoaXMubGlmdC5jYWxsKG5ldyBBcnJheU9ic2VydmFibGUob2JzZXJ2YWJsZXMpLCBuZXcgQ29tYmluZUxhdGVzdE9wZXJhdG9yKHByb2plY3QpKTtcbn1cblxuZXhwb3J0IGNsYXNzIENvbWJpbmVMYXRlc3RPcGVyYXRvcjxULCBSPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFI+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwcm9qZWN0PzogKC4uLnZhbHVlczogQXJyYXk8YW55PikgPT4gUikge1xuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFI+LCBzb3VyY2U6IGFueSk6IGFueSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IENvbWJpbmVMYXRlc3RTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCkpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5leHBvcnQgY2xhc3MgQ29tYmluZUxhdGVzdFN1YnNjcmliZXI8VCwgUj4gZXh0ZW5kcyBPdXRlclN1YnNjcmliZXI8VCwgUj4ge1xuICBwcml2YXRlIGFjdGl2ZTogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSB2YWx1ZXM6IGFueVtdID0gW107XG4gIHByaXZhdGUgb2JzZXJ2YWJsZXM6IGFueVtdID0gW107XG4gIHByaXZhdGUgdG9SZXNwb25kOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8Uj4sIHByaXZhdGUgcHJvamVjdD86ICguLi52YWx1ZXM6IEFycmF5PGFueT4pID0+IFIpIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQob2JzZXJ2YWJsZTogYW55KSB7XG4gICAgdGhpcy52YWx1ZXMucHVzaChub25lKTtcbiAgICB0aGlzLm9ic2VydmFibGVzLnB1c2gob2JzZXJ2YWJsZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbXBsZXRlKCkge1xuICAgIGNvbnN0IG9ic2VydmFibGVzID0gdGhpcy5vYnNlcnZhYmxlcztcbiAgICBjb25zdCBsZW4gPSBvYnNlcnZhYmxlcy5sZW5ndGg7XG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFjdGl2ZSA9IGxlbjtcbiAgICAgIHRoaXMudG9SZXNwb25kID0gbGVuO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBvYnNlcnZhYmxlID0gb2JzZXJ2YWJsZXNbaV07XG4gICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG9ic2VydmFibGUsIG9ic2VydmFibGUsIGkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBub3RpZnlDb21wbGV0ZSh1bnVzZWQ6IFN1YnNjcmliZXI8Uj4pOiB2b2lkIHtcbiAgICBpZiAoKHRoaXMuYWN0aXZlIC09IDEpID09PSAwKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgbm90aWZ5TmV4dChvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBSLFxuICAgICAgICAgICAgIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgIGlubmVyU3ViOiBJbm5lclN1YnNjcmliZXI8VCwgUj4pOiB2b2lkIHtcbiAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcbiAgICBjb25zdCBvbGRWYWwgPSB2YWx1ZXNbb3V0ZXJJbmRleF07XG4gICAgY29uc3QgdG9SZXNwb25kID0gIXRoaXMudG9SZXNwb25kXG4gICAgICA/IDBcbiAgICAgIDogb2xkVmFsID09PSBub25lID8gLS10aGlzLnRvUmVzcG9uZCA6IHRoaXMudG9SZXNwb25kO1xuICAgIHZhbHVlc1tvdXRlckluZGV4XSA9IGlubmVyVmFsdWU7XG5cbiAgICBpZiAodG9SZXNwb25kID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5wcm9qZWN0KSB7XG4gICAgICAgIHRoaXMuX3RyeVByb2plY3QodmFsdWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZXMuc2xpY2UoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfdHJ5UHJvamVjdCh2YWx1ZXM6IGFueVtdKSB7XG4gICAgbGV0IHJlc3VsdDogYW55O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QuYXBwbHkodGhpcywgdmFsdWVzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvY29tYmluZUxhdGVzdC50cyIsImltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmFibGVJbnB1dCB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgSVNjaGVkdWxlciB9IGZyb20gJy4uL1NjaGVkdWxlcic7XG5pbXBvcnQgeyBpc1NjaGVkdWxlciB9IGZyb20gJy4uL3V0aWwvaXNTY2hlZHVsZXInO1xuaW1wb3J0IHsgQXJyYXlPYnNlcnZhYmxlIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUnO1xuaW1wb3J0IHsgTWVyZ2VBbGxPcGVyYXRvciB9IGZyb20gJy4vbWVyZ2VBbGwnO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQ8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VD47XG5leHBvcnQgZnVuY3Rpb24gY29uY2F0PFQsIFQyPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VCB8IFQyPjtcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQ8VCwgVDIsIFQzPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQgfCBUMiB8IFQzPjtcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQ8VCwgVDIsIFQzLCBUND4odGhpczogT2JzZXJ2YWJsZTxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCB2NDogT2JzZXJ2YWJsZUlucHV0PFQ0Piwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VCB8IFQyIHwgVDMgfCBUND47XG5leHBvcnQgZnVuY3Rpb24gY29uY2F0PFQsIFQyLCBUMywgVDQsIFQ1Pih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCB2NTogT2JzZXJ2YWJsZUlucHV0PFQ1Piwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VCB8IFQyIHwgVDMgfCBUNCB8IFQ1PjtcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQ8VCwgVDIsIFQzLCBUNCwgVDUsIFQ2Pih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCB2NTogT2JzZXJ2YWJsZUlucHV0PFQ1PiwgdjY6IE9ic2VydmFibGVJbnB1dDxUNj4sIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQgfCBUMiB8IFQzIHwgVDQgfCBUNSB8IFQ2PjtcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQ8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgLi4ub2JzZXJ2YWJsZXM6IEFycmF5PE9ic2VydmFibGVJbnB1dDxUPiB8IElTY2hlZHVsZXI+KTogT2JzZXJ2YWJsZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQ8VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgLi4ub2JzZXJ2YWJsZXM6IEFycmF5PE9ic2VydmFibGVJbnB1dDxhbnk+IHwgSVNjaGVkdWxlcj4pOiBPYnNlcnZhYmxlPFI+O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cblxuLyoqXG4gKiBDcmVhdGVzIGFuIG91dHB1dCBPYnNlcnZhYmxlIHdoaWNoIHNlcXVlbnRpYWxseSBlbWl0cyBhbGwgdmFsdWVzIGZyb20gZXZlcnlcbiAqIGdpdmVuIGlucHV0IE9ic2VydmFibGUgYWZ0ZXIgdGhlIGN1cnJlbnQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29uY2F0ZW5hdGVzIG11bHRpcGxlIE9ic2VydmFibGVzIHRvZ2V0aGVyIGJ5XG4gKiBzZXF1ZW50aWFsbHkgZW1pdHRpbmcgdGhlaXIgdmFsdWVzLCBvbmUgT2JzZXJ2YWJsZSBhZnRlciB0aGUgb3RoZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29uY2F0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEpvaW5zIHRoaXMgT2JzZXJ2YWJsZSB3aXRoIG11bHRpcGxlIG90aGVyIE9ic2VydmFibGVzIGJ5IHN1YnNjcmliaW5nIHRvIHRoZW1cbiAqIG9uZSBhdCBhIHRpbWUsIHN0YXJ0aW5nIHdpdGggdGhlIHNvdXJjZSwgYW5kIG1lcmdpbmcgdGhlaXIgcmVzdWx0cyBpbnRvIHRoZVxuICogb3V0cHV0IE9ic2VydmFibGUuIFdpbGwgd2FpdCBmb3IgZWFjaCBPYnNlcnZhYmxlIHRvIGNvbXBsZXRlIGJlZm9yZSBtb3ZpbmdcbiAqIG9uIHRvIHRoZSBuZXh0LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbmNhdGVuYXRlIGEgdGltZXIgY291bnRpbmcgZnJvbSAwIHRvIDMgd2l0aCBhIHN5bmNocm9ub3VzIHNlcXVlbmNlIGZyb20gMSB0byAxMDwvY2FwdGlvbj5cbiAqIHZhciB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSg0KTtcbiAqIHZhciBzZXF1ZW5jZSA9IFJ4Lk9ic2VydmFibGUucmFuZ2UoMSwgMTApO1xuICogdmFyIHJlc3VsdCA9IHRpbWVyLmNvbmNhdChzZXF1ZW5jZSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIHJlc3VsdHMgaW46XG4gKiAvLyAxMDAwbXMtPiAwIC0xMDAwbXMtPiAxIC0xMDAwbXMtPiAyIC0xMDAwbXMtPiAzIC1pbW1lZGlhdGUtPiAxIC4uLiAxMFxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbmNhdGVuYXRlIDMgT2JzZXJ2YWJsZXM8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIxID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDEwKTtcbiAqIHZhciB0aW1lcjIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDIwMDApLnRha2UoNik7XG4gKiB2YXIgdGltZXIzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApLnRha2UoMTApO1xuICogdmFyIHJlc3VsdCA9IHRpbWVyMS5jb25jYXQodGltZXIyLCB0aW1lcjMpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyByZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyAoUHJpbnRzIHRvIGNvbnNvbGUgc2VxdWVudGlhbGx5KVxuICogLy8gLTEwMDBtcy0+IDAgLTEwMDBtcy0+IDEgLTEwMDBtcy0+IC4uLiA5XG4gKiAvLyAtMjAwMG1zLT4gMCAtMjAwMG1zLT4gMSAtMjAwMG1zLT4gLi4uIDVcbiAqIC8vIC01MDBtcy0+IDAgLTUwMG1zLT4gMSAtNTAwbXMtPiAuLi4gOVxuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcFRvfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBvdGhlciBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbmNhdGVuYXRlIGFmdGVyIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIE1vcmUgdGhhbiBvbmUgaW5wdXQgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9bnVsbF0gQW4gb3B0aW9uYWwgSVNjaGVkdWxlciB0byBzY2hlZHVsZSBlYWNoXG4gKiBPYnNlcnZhYmxlIHN1YnNjcmlwdGlvbiBvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFsbCB2YWx1ZXMgb2YgZWFjaCBwYXNzZWQgT2JzZXJ2YWJsZSBtZXJnZWQgaW50byBhXG4gKiBzaW5nbGUgT2JzZXJ2YWJsZSwgaW4gb3JkZXIsIGluIHNlcmlhbCBmYXNoaW9uLlxuICogQG1ldGhvZCBjb25jYXRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQ8VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgLi4ub2JzZXJ2YWJsZXM6IEFycmF5PE9ic2VydmFibGVJbnB1dDxhbnk+IHwgSVNjaGVkdWxlcj4pOiBPYnNlcnZhYmxlPFI+IHtcbiAgcmV0dXJuIHRoaXMubGlmdC5jYWxsKGNvbmNhdFN0YXRpYzxULCBSPih0aGlzLCAuLi5vYnNlcnZhYmxlcykpO1xufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRTdGF0aWM8VD4odjE6IE9ic2VydmFibGVJbnB1dDxUPiwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VD47XG5leHBvcnQgZnVuY3Rpb24gY29uY2F0U3RhdGljPFQsIFQyPih2MTogT2JzZXJ2YWJsZUlucHV0PFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VCB8IFQyPjtcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRTdGF0aWM8VCwgVDIsIFQzPih2MTogT2JzZXJ2YWJsZUlucHV0PFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQgfCBUMiB8IFQzPjtcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRTdGF0aWM8VCwgVDIsIFQzLCBUND4odjE6IE9ic2VydmFibGVJbnB1dDxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCB2NDogT2JzZXJ2YWJsZUlucHV0PFQ0Piwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VCB8IFQyIHwgVDMgfCBUND47XG5leHBvcnQgZnVuY3Rpb24gY29uY2F0U3RhdGljPFQsIFQyLCBUMywgVDQsIFQ1Pih2MTogT2JzZXJ2YWJsZUlucHV0PFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCB2NTogT2JzZXJ2YWJsZUlucHV0PFQ1Piwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VCB8IFQyIHwgVDMgfCBUNCB8IFQ1PjtcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRTdGF0aWM8VCwgVDIsIFQzLCBUNCwgVDUsIFQ2Pih2MTogT2JzZXJ2YWJsZUlucHV0PFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCB2NTogT2JzZXJ2YWJsZUlucHV0PFQ1PiwgdjY6IE9ic2VydmFibGVJbnB1dDxUNj4sIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQgfCBUMiB8IFQzIHwgVDQgfCBUNSB8IFQ2PjtcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRTdGF0aWM8VD4oLi4ub2JzZXJ2YWJsZXM6IChPYnNlcnZhYmxlSW5wdXQ8VD4gfCBJU2NoZWR1bGVyKVtdKTogT2JzZXJ2YWJsZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRTdGF0aWM8VCwgUj4oLi4ub2JzZXJ2YWJsZXM6IChPYnNlcnZhYmxlSW5wdXQ8YW55PiB8IElTY2hlZHVsZXIpW10pOiBPYnNlcnZhYmxlPFI+O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ3JlYXRlcyBhbiBvdXRwdXQgT2JzZXJ2YWJsZSB3aGljaCBzZXF1ZW50aWFsbHkgZW1pdHMgYWxsIHZhbHVlcyBmcm9tIGdpdmVuXG4gKiBPYnNlcnZhYmxlIGFuZCB0aGVuIG1vdmVzIG9uIHRvIHRoZSBuZXh0LlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db25jYXRlbmF0ZXMgbXVsdGlwbGUgT2JzZXJ2YWJsZXMgdG9nZXRoZXIgYnlcbiAqIHNlcXVlbnRpYWxseSBlbWl0dGluZyB0aGVpciB2YWx1ZXMsIG9uZSBPYnNlcnZhYmxlIGFmdGVyIHRoZSBvdGhlci48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9jb25jYXQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGNvbmNhdGAgam9pbnMgbXVsdGlwbGUgT2JzZXJ2YWJsZXMgdG9nZXRoZXIsIGJ5IHN1YnNjcmliaW5nIHRvIHRoZW0gb25lIGF0IGEgdGltZSBhbmRcbiAqIG1lcmdpbmcgdGhlaXIgcmVzdWx0cyBpbnRvIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gWW91IGNhbiBwYXNzIGVpdGhlciBhbiBhcnJheSBvZlxuICogT2JzZXJ2YWJsZXMsIG9yIHB1dCB0aGVtIGRpcmVjdGx5IGFzIGFyZ3VtZW50cy4gUGFzc2luZyBhbiBlbXB0eSBhcnJheSB3aWxsIHJlc3VsdFxuICogaW4gT2JzZXJ2YWJsZSB0aGF0IGNvbXBsZXRlcyBpbW1lZGlhdGVseS5cbiAqXG4gKiBgY29uY2F0YCB3aWxsIHN1YnNjcmliZSB0byBmaXJzdCBpbnB1dCBPYnNlcnZhYmxlIGFuZCBlbWl0IGFsbCBpdHMgdmFsdWVzLCB3aXRob3V0XG4gKiBjaGFuZ2luZyBvciBhZmZlY3RpbmcgdGhlbSBpbiBhbnkgd2F5LiBXaGVuIHRoYXQgT2JzZXJ2YWJsZSBjb21wbGV0ZXMsIGl0IHdpbGxcbiAqIHN1YnNjcmliZSB0byB0aGVuIG5leHQgT2JzZXJ2YWJsZSBwYXNzZWQgYW5kLCBhZ2FpbiwgZW1pdCBpdHMgdmFsdWVzLiBUaGlzIHdpbGwgYmVcbiAqIHJlcGVhdGVkLCB1bnRpbCB0aGUgb3BlcmF0b3IgcnVucyBvdXQgb2YgT2JzZXJ2YWJsZXMuIFdoZW4gbGFzdCBpbnB1dCBPYnNlcnZhYmxlIGNvbXBsZXRlcyxcbiAqIGBjb25jYXRgIHdpbGwgY29tcGxldGUgYXMgd2VsbC4gQXQgYW55IGdpdmVuIG1vbWVudCBvbmx5IG9uZSBPYnNlcnZhYmxlIHBhc3NlZCB0byBvcGVyYXRvclxuICogZW1pdHMgdmFsdWVzLiBJZiB5b3Ugd291bGQgbGlrZSB0byBlbWl0IHZhbHVlcyBmcm9tIHBhc3NlZCBPYnNlcnZhYmxlcyBjb25jdXJyZW50bHksIGNoZWNrIG91dFxuICoge0BsaW5rIG1lcmdlfSBpbnN0ZWFkLCBlc3BlY2lhbGx5IHdpdGggb3B0aW9uYWwgYGNvbmN1cnJlbnRgIHBhcmFtZXRlci4gQXMgYSBtYXR0ZXIgb2YgZmFjdCxcbiAqIGBjb25jYXRgIGlzIGFuIGVxdWl2YWxlbnQgb2YgYG1lcmdlYCBvcGVyYXRvciB3aXRoIGBjb25jdXJyZW50YCBwYXJhbWV0ZXIgc2V0IHRvIGAxYC5cbiAqXG4gKiBOb3RlIHRoYXQgaWYgc29tZSBpbnB1dCBPYnNlcnZhYmxlIG5ldmVyIGNvbXBsZXRlcywgYGNvbmNhdGAgd2lsbCBhbHNvIG5ldmVyIGNvbXBsZXRlXG4gKiBhbmQgT2JzZXJ2YWJsZXMgZm9sbG93aW5nIHRoZSBvbmUgdGhhdCBkaWQgbm90IGNvbXBsZXRlIHdpbGwgbmV2ZXIgYmUgc3Vic2NyaWJlZC4gT24gdGhlIG90aGVyXG4gKiBoYW5kLCBpZiBzb21lIE9ic2VydmFibGUgc2ltcGx5IGNvbXBsZXRlcyBpbW1lZGlhdGVseSBhZnRlciBpdCBpcyBzdWJzY3JpYmVkLCBpdCB3aWxsIGJlXG4gKiBpbnZpc2libGUgZm9yIGBjb25jYXRgLCB3aGljaCB3aWxsIGp1c3QgbW92ZSBvbiB0byB0aGUgbmV4dCBPYnNlcnZhYmxlLlxuICpcbiAqIElmIGFueSBPYnNlcnZhYmxlIGluIGNoYWluIGVycm9ycywgaW5zdGVhZCBvZiBwYXNzaW5nIGNvbnRyb2wgdG8gdGhlIG5leHQgT2JzZXJ2YWJsZSxcbiAqIGBjb25jYXRgIHdpbGwgZXJyb3IgaW1tZWRpYXRlbHkgYXMgd2VsbC4gT2JzZXJ2YWJsZXMgdGhhdCB3b3VsZCBiZSBzdWJzY3JpYmVkIGFmdGVyXG4gKiB0aGUgb25lIHRoYXQgZW1pdHRlZCBlcnJvciwgbmV2ZXIgd2lsbC5cbiAqXG4gKiBJZiB5b3UgcGFzcyB0byBgY29uY2F0YCB0aGUgc2FtZSBPYnNlcnZhYmxlIG1hbnkgdGltZXMsIGl0cyBzdHJlYW0gb2YgdmFsdWVzXG4gKiB3aWxsIGJlIFwicmVwbGF5ZWRcIiBvbiBldmVyeSBzdWJzY3JpcHRpb24sIHdoaWNoIG1lYW5zIHlvdSBjYW4gcmVwZWF0IGdpdmVuIE9ic2VydmFibGVcbiAqIGFzIG1hbnkgdGltZXMgYXMgeW91IGxpa2UuIElmIHBhc3NpbmcgdGhlIHNhbWUgT2JzZXJ2YWJsZSB0byBgY29uY2F0YCAxMDAwIHRpbWVzIGJlY29tZXMgdGVkaW91cyxcbiAqIHlvdSBjYW4gYWx3YXlzIHVzZSB7QGxpbmsgcmVwZWF0fS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db25jYXRlbmF0ZSBhIHRpbWVyIGNvdW50aW5nIGZyb20gMCB0byAzIHdpdGggYSBzeW5jaHJvbm91cyBzZXF1ZW5jZSBmcm9tIDEgdG8gMTA8L2NhcHRpb24+XG4gKiB2YXIgdGltZXIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoNCk7XG4gKiB2YXIgc2VxdWVuY2UgPSBSeC5PYnNlcnZhYmxlLnJhbmdlKDEsIDEwKTtcbiAqIHZhciByZXN1bHQgPSBSeC5PYnNlcnZhYmxlLmNvbmNhdCh0aW1lciwgc2VxdWVuY2UpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyByZXN1bHRzIGluOlxuICogLy8gMCAtMTAwMG1zLT4gMSAtMTAwMG1zLT4gMiAtMTAwMG1zLT4gMyAtaW1tZWRpYXRlLT4gMSAuLi4gMTBcbiAqXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29uY2F0ZW5hdGUgYW4gYXJyYXkgb2YgMyBPYnNlcnZhYmxlczwvY2FwdGlvbj5cbiAqIHZhciB0aW1lcjEgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoMTApO1xuICogdmFyIHRpbWVyMiA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMjAwMCkudGFrZSg2KTtcbiAqIHZhciB0aW1lcjMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMCkudGFrZSgxMCk7XG4gKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5jb25jYXQoW3RpbWVyMSwgdGltZXIyLCB0aW1lcjNdKTsgLy8gbm90ZSB0aGF0IGFycmF5IGlzIHBhc3NlZFxuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyByZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyAoUHJpbnRzIHRvIGNvbnNvbGUgc2VxdWVudGlhbGx5KVxuICogLy8gLTEwMDBtcy0+IDAgLTEwMDBtcy0+IDEgLTEwMDBtcy0+IC4uLiA5XG4gKiAvLyAtMjAwMG1zLT4gMCAtMjAwMG1zLT4gMSAtMjAwMG1zLT4gLi4uIDVcbiAqIC8vIC01MDBtcy0+IDAgLTUwMG1zLT4gMSAtNTAwbXMtPiAuLi4gOVxuICpcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db25jYXRlbmF0ZSB0aGUgc2FtZSBPYnNlcnZhYmxlIHRvIHJlcGVhdCBpdDwvY2FwdGlvbj5cbiAqIGNvbnN0IHRpbWVyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKS50YWtlKDIpO1xuICpcbiAqIFJ4Lk9ic2VydmFibGUuY29uY2F0KHRpbWVyLCB0aW1lcikgLy8gY29uY2F0aW5nIHRoZSBzYW1lIE9ic2VydmFibGUhXG4gKiAuc3Vic2NyaWJlKFxuICogICB2YWx1ZSA9PiBjb25zb2xlLmxvZyh2YWx1ZSksXG4gKiAgIGVyciA9PiB7fSxcbiAqICAgKCkgPT4gY29uc29sZS5sb2coJy4uLmFuZCBpdCBpcyBkb25lIScpXG4gKiApO1xuICpcbiAqIC8vIExvZ3M6XG4gKiAvLyAwIGFmdGVyIDFzXG4gKiAvLyAxIGFmdGVyIDJzXG4gKiAvLyAwIGFmdGVyIDNzXG4gKiAvLyAxIGFmdGVyIDRzXG4gKiAvLyBcIi4uLmFuZCBpdCBpcyBkb25lIVwiIGFsc28gYWZ0ZXIgNHNcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXBUb31cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGVJbnB1dH0gaW5wdXQxIEFuIGlucHV0IE9ic2VydmFibGUgdG8gY29uY2F0ZW5hdGUgd2l0aCBvdGhlcnMuXG4gKiBAcGFyYW0ge09ic2VydmFibGVJbnB1dH0gaW5wdXQyIEFuIGlucHV0IE9ic2VydmFibGUgdG8gY29uY2F0ZW5hdGUgd2l0aCBvdGhlcnMuXG4gKiBNb3JlIHRoYW4gb25lIGlucHV0IE9ic2VydmFibGVzIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPW51bGxdIEFuIG9wdGlvbmFsIElTY2hlZHVsZXIgdG8gc2NoZWR1bGUgZWFjaFxuICogT2JzZXJ2YWJsZSBzdWJzY3JpcHRpb24gb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbGwgdmFsdWVzIG9mIGVhY2ggcGFzc2VkIE9ic2VydmFibGUgbWVyZ2VkIGludG8gYVxuICogc2luZ2xlIE9ic2VydmFibGUsIGluIG9yZGVyLCBpbiBzZXJpYWwgZmFzaGlvbi5cbiAqIEBzdGF0aWMgdHJ1ZVxuICogQG5hbWUgY29uY2F0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0U3RhdGljPFQsIFI+KC4uLm9ic2VydmFibGVzOiBBcnJheTxPYnNlcnZhYmxlSW5wdXQ8YW55PiB8IElTY2hlZHVsZXI+KTogT2JzZXJ2YWJsZTxSPiB7XG4gIGxldCBzY2hlZHVsZXI6IElTY2hlZHVsZXIgPSBudWxsO1xuICBsZXQgYXJncyA9IDxhbnlbXT5vYnNlcnZhYmxlcztcbiAgaWYgKGlzU2NoZWR1bGVyKGFyZ3Nbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV0pKSB7XG4gICAgc2NoZWR1bGVyID0gYXJncy5wb3AoKTtcbiAgfVxuXG4gIGlmIChzY2hlZHVsZXIgPT09IG51bGwgJiYgb2JzZXJ2YWJsZXMubGVuZ3RoID09PSAxICYmIG9ic2VydmFibGVzWzBdIGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xuICAgIHJldHVybiA8T2JzZXJ2YWJsZTxSPj5vYnNlcnZhYmxlc1swXTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlKG9ic2VydmFibGVzLCBzY2hlZHVsZXIpLmxpZnQobmV3IE1lcmdlQWxsT3BlcmF0b3I8Uj4oMSkpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9jb25jYXQudHMiLCJpbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcblxuLyoqXG4gKiBBcHBsaWVzIGEgZ2l2ZW4gYHByb2plY3RgIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLCBhbmQgZW1pdHMgdGhlIHJlc3VsdGluZyB2YWx1ZXMgYXMgYW4gT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TGlrZSBbQXJyYXkucHJvdG90eXBlLm1hcCgpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9tYXApLFxuICogaXQgcGFzc2VzIGVhY2ggc291cmNlIHZhbHVlIHRocm91Z2ggYSB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbiB0byBnZXRcbiAqIGNvcnJlc3BvbmRpbmcgb3V0cHV0IHZhbHVlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9tYXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogU2ltaWxhciB0byB0aGUgd2VsbCBrbm93biBgQXJyYXkucHJvdG90eXBlLm1hcGAgZnVuY3Rpb24sIHRoaXMgb3BlcmF0b3JcbiAqIGFwcGxpZXMgYSBwcm9qZWN0aW9uIHRvIGVhY2ggdmFsdWUgYW5kIGVtaXRzIHRoYXQgcHJvamVjdGlvbiBpbiB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBldmVyeSBldmVyeSBjbGljayB0byB0aGUgY2xpZW50WCBwb3NpdGlvbiBvZiB0aGF0IGNsaWNrPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBwb3NpdGlvbnMgPSBjbGlja3MubWFwKGV2ID0+IGV2LmNsaWVudFgpO1xuICogcG9zaXRpb25zLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBtYXBUb31cbiAqIEBzZWUge0BsaW5rIHBsdWNrfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIpOiBSfSBwcm9qZWN0IFRoZSBmdW5jdGlvbiB0byBhcHBseVxuICogdG8gZWFjaCBgdmFsdWVgIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBUaGUgYGluZGV4YCBwYXJhbWV0ZXIgaXNcbiAqIHRoZSBudW1iZXIgYGlgIGZvciB0aGUgaS10aCBlbWlzc2lvbiB0aGF0IGhhcyBoYXBwZW5lZCBzaW5jZSB0aGVcbiAqIHN1YnNjcmlwdGlvbiwgc3RhcnRpbmcgZnJvbSB0aGUgbnVtYmVyIGAwYC5cbiAqIEBwYXJhbSB7YW55fSBbdGhpc0FyZ10gQW4gb3B0aW9uYWwgYXJndW1lbnQgdG8gZGVmaW5lIHdoYXQgYHRoaXNgIGlzIGluIHRoZVxuICogYHByb2plY3RgIGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIHRyYW5zZm9ybWVkIGJ5IHRoZSBnaXZlbiBgcHJvamVjdGAgZnVuY3Rpb24uXG4gKiBAbWV0aG9kIG1hcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcDxULCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBwcm9qZWN0OiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IFIsIHRoaXNBcmc/OiBhbnkpOiBPYnNlcnZhYmxlPFI+IHtcbiAgaWYgKHR5cGVvZiBwcm9qZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgaXMgbm90IGEgZnVuY3Rpb24uIEFyZSB5b3UgbG9va2luZyBmb3IgYG1hcFRvKClgPycpO1xuICB9XG4gIHJldHVybiB0aGlzLmxpZnQobmV3IE1hcE9wZXJhdG9yKHByb2plY3QsIHRoaXNBcmcpKTtcbn1cblxuZXhwb3J0IGNsYXNzIE1hcE9wZXJhdG9yPFQsIFI+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgUj4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHByb2plY3Q6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gUiwgcHJpdmF0ZSB0aGlzQXJnOiBhbnkpIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxSPiwgc291cmNlOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBNYXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCwgdGhpcy50aGlzQXJnKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIE1hcFN1YnNjcmliZXI8VCwgUj4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgY291bnQ6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgdGhpc0FyZzogYW55O1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFI+LFxuICAgICAgICAgICAgICBwcml2YXRlIHByb2plY3Q6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gUixcbiAgICAgICAgICAgICAgdGhpc0FyZzogYW55KSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmcgfHwgdGhpcztcbiAgfVxuXG4gIC8vIE5PVEU6IFRoaXMgbG9va3MgdW5vcHRpbWl6ZWQsIGJ1dCBpdCdzIGFjdHVhbGx5IHB1cnBvc2VmdWxseSBOT1RcbiAgLy8gdXNpbmcgdHJ5L2NhdGNoIG9wdGltaXphdGlvbnMuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCkge1xuICAgIGxldCByZXN1bHQ6IGFueTtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0LmNhbGwodGhpcy50aGlzQXJnLCB2YWx1ZSwgdGhpcy5jb3VudCsrKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvbWFwLnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgSVNjaGVkdWxlciB9IGZyb20gJy4uL1NjaGVkdWxlcic7XG5pbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IFBhcnRpYWxPYnNlcnZlciB9IGZyb20gJy4uL09ic2VydmVyJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IE5vdGlmaWNhdGlvbiB9IGZyb20gJy4uL05vdGlmaWNhdGlvbic7XG5pbXBvcnQgeyBUZWFyZG93bkxvZ2ljIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4uL3NjaGVkdWxlci9BY3Rpb24nO1xuXG4vKipcbiAqIEBzZWUge0BsaW5rIE5vdGlmaWNhdGlvbn1cbiAqXG4gKiBAcGFyYW0gc2NoZWR1bGVyXG4gKiBAcGFyYW0gZGVsYXlcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj58V2ViU29ja2V0U3ViamVjdDxUPnxPYnNlcnZhYmxlPFQ+fVxuICogQG1ldGhvZCBvYnNlcnZlT25cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvYnNlcnZlT248VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgc2NoZWR1bGVyOiBJU2NoZWR1bGVyLCBkZWxheTogbnVtYmVyID0gMCk6IE9ic2VydmFibGU8VD4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBPYnNlcnZlT25PcGVyYXRvcihzY2hlZHVsZXIsIGRlbGF5KSk7XG59XG5cbmV4cG9ydCBjbGFzcyBPYnNlcnZlT25PcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzY2hlZHVsZXI6IElTY2hlZHVsZXIsIHByaXZhdGUgZGVsYXk6IG51bWJlciA9IDApIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPiwgc291cmNlOiBhbnkpOiBUZWFyZG93bkxvZ2ljIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgT2JzZXJ2ZU9uU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnNjaGVkdWxlciwgdGhpcy5kZWxheSkpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5leHBvcnQgY2xhc3MgT2JzZXJ2ZU9uU3Vic2NyaWJlcjxUPiBleHRlbmRzIFN1YnNjcmliZXI8VD4ge1xuICBzdGF0aWMgZGlzcGF0Y2godGhpczogQWN0aW9uPE9ic2VydmVPbk1lc3NhZ2U+LCBhcmc6IE9ic2VydmVPbk1lc3NhZ2UpIHtcbiAgICBjb25zdCB7IG5vdGlmaWNhdGlvbiwgZGVzdGluYXRpb24gfSA9IGFyZztcbiAgICBub3RpZmljYXRpb24ub2JzZXJ2ZShkZXN0aW5hdGlvbik7XG4gICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8VD4sXG4gICAgICAgICAgICAgIHByaXZhdGUgc2NoZWR1bGVyOiBJU2NoZWR1bGVyLFxuICAgICAgICAgICAgICBwcml2YXRlIGRlbGF5OiBudW1iZXIgPSAwKSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICB9XG5cbiAgcHJpdmF0ZSBzY2hlZHVsZU1lc3NhZ2Uobm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb248YW55Pik6IHZvaWQge1xuICAgIHRoaXMuYWRkKHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKFxuICAgICAgT2JzZXJ2ZU9uU3Vic2NyaWJlci5kaXNwYXRjaCxcbiAgICAgIHRoaXMuZGVsYXksXG4gICAgICBuZXcgT2JzZXJ2ZU9uTWVzc2FnZShub3RpZmljYXRpb24sIHRoaXMuZGVzdGluYXRpb24pXG4gICAgKSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpOiB2b2lkIHtcbiAgICB0aGlzLnNjaGVkdWxlTWVzc2FnZShOb3RpZmljYXRpb24uY3JlYXRlTmV4dCh2YWx1ZSkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9lcnJvcihlcnI6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuc2NoZWR1bGVNZXNzYWdlKE5vdGlmaWNhdGlvbi5jcmVhdGVFcnJvcihlcnIpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKTogdm9pZCB7XG4gICAgdGhpcy5zY2hlZHVsZU1lc3NhZ2UoTm90aWZpY2F0aW9uLmNyZWF0ZUNvbXBsZXRlKCkpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBPYnNlcnZlT25NZXNzYWdlIHtcbiAgY29uc3RydWN0b3IocHVibGljIG5vdGlmaWNhdGlvbjogTm90aWZpY2F0aW9uPGFueT4sXG4gICAgICAgICAgICAgIHB1YmxpYyBkZXN0aW5hdGlvbjogUGFydGlhbE9ic2VydmVyPGFueT4pIHtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9vYnNlcnZlT24udHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIGFjY3VtdWxhdG9yOiAoYWNjOiBUW10sIHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBUW10sIHNlZWQ6IFRbXSk6IE9ic2VydmFibGU8VFtdPjtcbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2U8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgYWNjdW11bGF0b3I6IChhY2M6IFQsIHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBULCBzZWVkPzogVCk6IE9ic2VydmFibGU8VD47XG5leHBvcnQgZnVuY3Rpb24gcmVkdWNlPFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIGFjY3VtdWxhdG9yOiAoYWNjOiBSLCB2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gUiwgc2VlZDogUik6IE9ic2VydmFibGU8Uj47XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuXG4vKipcbiAqIEFwcGxpZXMgYW4gYWNjdW11bGF0b3IgZnVuY3Rpb24gb3ZlciB0aGUgc291cmNlIE9ic2VydmFibGUsIGFuZCByZXR1cm5zIHRoZVxuICogYWNjdW11bGF0ZWQgcmVzdWx0IHdoZW4gdGhlIHNvdXJjZSBjb21wbGV0ZXMsIGdpdmVuIGFuIG9wdGlvbmFsIHNlZWQgdmFsdWUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbWJpbmVzIHRvZ2V0aGVyIGFsbCB2YWx1ZXMgZW1pdHRlZCBvbiB0aGUgc291cmNlLFxuICogdXNpbmcgYW4gYWNjdW11bGF0b3IgZnVuY3Rpb24gdGhhdCBrbm93cyBob3cgdG8gam9pbiBhIG5ldyBzb3VyY2UgdmFsdWUgaW50b1xuICogdGhlIGFjY3VtdWxhdGlvbiBmcm9tIHRoZSBwYXN0Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3JlZHVjZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBMaWtlXG4gKiBbQXJyYXkucHJvdG90eXBlLnJlZHVjZSgpXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9yZWR1Y2UpLFxuICogYHJlZHVjZWAgYXBwbGllcyBhbiBgYWNjdW11bGF0b3JgIGZ1bmN0aW9uIGFnYWluc3QgYW4gYWNjdW11bGF0aW9uIGFuZCBlYWNoXG4gKiB2YWx1ZSBvZiB0aGUgc291cmNlIE9ic2VydmFibGUgKGZyb20gdGhlIHBhc3QpIHRvIHJlZHVjZSBpdCB0byBhIHNpbmdsZVxuICogdmFsdWUsIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLiBOb3RlIHRoYXQgYHJlZHVjZWAgd2lsbCBvbmx5IGVtaXRcbiAqIG9uZSB2YWx1ZSwgb25seSB3aGVuIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBjb21wbGV0ZXMuIEl0IGlzIGVxdWl2YWxlbnQgdG9cbiAqIGFwcGx5aW5nIG9wZXJhdG9yIHtAbGluayBzY2FufSBmb2xsb3dlZCBieSBvcGVyYXRvciB7QGxpbmsgbGFzdH0uXG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgYXBwbGllcyBhIHNwZWNpZmllZCBgYWNjdW11bGF0b3JgIGZ1bmN0aW9uIHRvIGVhY2hcbiAqIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIGEgYHNlZWRgIHZhbHVlIGlzIHNwZWNpZmllZCwgdGhlblxuICogdGhhdCB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGluaXRpYWwgdmFsdWUgZm9yIHRoZSBhY2N1bXVsYXRvci4gSWYgbm8gc2VlZFxuICogdmFsdWUgaXMgc3BlY2lmaWVkLCB0aGUgZmlyc3QgaXRlbSBvZiB0aGUgc291cmNlIGlzIHVzZWQgYXMgdGhlIHNlZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q291bnQgdGhlIG51bWJlciBvZiBjbGljayBldmVudHMgdGhhdCBoYXBwZW5lZCBpbiA1IHNlY29uZHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzSW5GaXZlU2Vjb25kcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKVxuICogICAudGFrZVVudGlsKFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwMCkpO1xuICogdmFyIG9uZXMgPSBjbGlja3NJbkZpdmVTZWNvbmRzLm1hcFRvKDEpO1xuICogdmFyIHNlZWQgPSAwO1xuICogdmFyIGNvdW50ID0gb25lcy5yZWR1Y2UoKGFjYywgb25lKSA9PiBhY2MgKyBvbmUsIHNlZWQpO1xuICogY291bnQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvdW50fVxuICogQHNlZSB7QGxpbmsgZXhwYW5kfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VTY2FufVxuICogQHNlZSB7QGxpbmsgc2Nhbn1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFjYzogUiwgdmFsdWU6IFQsIGluZGV4OiBudW1iZXIpOiBSfSBhY2N1bXVsYXRvciBUaGUgYWNjdW11bGF0b3IgZnVuY3Rpb25cbiAqIGNhbGxlZCBvbiBlYWNoIHNvdXJjZSB2YWx1ZS5cbiAqIEBwYXJhbSB7Un0gW3NlZWRdIFRoZSBpbml0aWFsIGFjY3VtdWxhdGlvbiB2YWx1ZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhIHNpbmdsZSB2YWx1ZSB0aGF0IGlzIHRoZVxuICogcmVzdWx0IG9mIGFjY3VtdWxhdGluZyB0aGUgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCByZWR1Y2VcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2U8VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgYWNjdW11bGF0b3I6IChhY2M6IFIsIHZhbHVlOiBULCBpbmRleD86IG51bWJlcikgPT4gUiwgc2VlZD86IFIpOiBPYnNlcnZhYmxlPFI+IHtcbiAgbGV0IGhhc1NlZWQgPSBmYWxzZTtcbiAgLy8gcHJvdmlkaW5nIGEgc2VlZCBvZiBgdW5kZWZpbmVkYCAqc2hvdWxkKiBiZSB2YWxpZCBhbmQgdHJpZ2dlclxuICAvLyBoYXNTZWVkISBzbyBkb24ndCB1c2UgYHNlZWQgIT09IHVuZGVmaW5lZGAgY2hlY2tzIVxuICAvLyBGb3IgdGhpcyByZWFzb24sIHdlIGhhdmUgdG8gY2hlY2sgaXQgaGVyZSBhdCB0aGUgb3JpZ2luYWwgY2FsbCBzaXRlXG4gIC8vIG90aGVyd2lzZSBpbnNpZGUgT3BlcmF0b3IvU3Vic2NyaWJlciB3ZSB3b24ndCBrbm93IGlmIGB1bmRlZmluZWRgXG4gIC8vIG1lYW5zIHRoZXkgZGlkbid0IHByb3ZpZGUgYW55dGhpbmcgb3IgaWYgdGhleSBsaXRlcmFsbHkgcHJvdmlkZWQgYHVuZGVmaW5lZGBcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgIGhhc1NlZWQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgUmVkdWNlT3BlcmF0b3IoYWNjdW11bGF0b3IsIHNlZWQsIGhhc1NlZWQpKTtcbn1cblxuZXhwb3J0IGNsYXNzIFJlZHVjZU9wZXJhdG9yPFQsIFI+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgUj4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFjY3VtdWxhdG9yOiAoYWNjOiBSLCB2YWx1ZTogVCwgaW5kZXg/OiBudW1iZXIpID0+IFIsIHByaXZhdGUgc2VlZD86IFIsIHByaXZhdGUgaGFzU2VlZDogYm9vbGVhbiA9IGZhbHNlKSB7fVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxSPiwgc291cmNlOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBSZWR1Y2VTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuYWNjdW11bGF0b3IsIHRoaXMuc2VlZCwgdGhpcy5oYXNTZWVkKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmV4cG9ydCBjbGFzcyBSZWR1Y2VTdWJzY3JpYmVyPFQsIFI+IGV4dGVuZHMgU3Vic2NyaWJlcjxUPiB7XG4gIHByaXZhdGUgaW5kZXg6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgYWNjOiBUIHwgUjtcbiAgcHJpdmF0ZSBoYXNWYWx1ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFI+LFxuICAgICAgICAgICAgICBwcml2YXRlIGFjY3VtdWxhdG9yOiAoYWNjOiBSLCB2YWx1ZTogVCwgaW5kZXg/OiBudW1iZXIpID0+IFIsXG4gICAgICAgICAgICAgIHNlZWQ6IFIsXG4gICAgICAgICAgICAgIHByaXZhdGUgaGFzU2VlZDogYm9vbGVhbikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgICB0aGlzLmFjYyA9IHNlZWQ7XG5cbiAgICBpZiAoIXRoaXMuaGFzU2VlZCkge1xuICAgICAgdGhpcy5pbmRleCsrO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCkge1xuICAgIGlmICh0aGlzLmhhc1ZhbHVlIHx8ICh0aGlzLmhhc1ZhbHVlID0gdGhpcy5oYXNTZWVkKSkge1xuICAgICAgdGhpcy5fdHJ5UmVkdWNlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hY2MgPSB2YWx1ZTtcbiAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX3RyeVJlZHVjZSh2YWx1ZTogVCkge1xuICAgIGxldCByZXN1bHQ6IGFueTtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5hY2N1bXVsYXRvcig8Uj50aGlzLmFjYywgdmFsdWUsIHRoaXMuaW5kZXgrKyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYWNjID0gcmVzdWx0O1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jb21wbGV0ZSgpIHtcbiAgICBpZiAodGhpcy5oYXNWYWx1ZSB8fCB0aGlzLmhhc1NlZWQpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLmFjYyk7XG4gICAgfVxuICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9yZWR1Y2UudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZhYmxlSW5wdXQgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IEFycmF5T2JzZXJ2YWJsZSB9IGZyb20gJy4uL29ic2VydmFibGUvQXJyYXlPYnNlcnZhYmxlJztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICcuLi91dGlsL2lzQXJyYXknO1xuaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBQYXJ0aWFsT2JzZXJ2ZXIgfSBmcm9tICcuLi9PYnNlcnZlcic7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBPdXRlclN1YnNjcmliZXIgfSBmcm9tICcuLi9PdXRlclN1YnNjcmliZXInO1xuaW1wb3J0IHsgSW5uZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vSW5uZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IHN1YnNjcmliZVRvUmVzdWx0IH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCc7XG5pbXBvcnQgeyBpdGVyYXRvciBhcyBTeW1ib2xfaXRlcmF0b3IgfSBmcm9tICcuLi9zeW1ib2wvaXRlcmF0b3InO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmV4cG9ydCBmdW5jdGlvbiB6aXBQcm90bzxULCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBwcm9qZWN0OiAodjE6IFQpID0+IFIpOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIHppcFByb3RvPFQsIFQyLCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgcHJvamVjdDogKHYxOiBULCB2MjogVDIpID0+IFIpOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIHppcFByb3RvPFQsIFQyLCBUMywgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCBwcm9qZWN0OiAodjE6IFQsIHYyOiBUMiwgdjM6IFQzKSA9PiBSKTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiB6aXBQcm90bzxULCBUMiwgVDMsIFQ0LCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCBwcm9qZWN0OiAodjE6IFQsIHYyOiBUMiwgdjM6IFQzLCB2NDogVDQpID0+IFIpOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIHppcFByb3RvPFQsIFQyLCBUMywgVDQsIFQ1LCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCB2NTogT2JzZXJ2YWJsZUlucHV0PFQ1PiwgcHJvamVjdDogKHYxOiBULCB2MjogVDIsIHYzOiBUMywgdjQ6IFQ0LCB2NTogVDUpID0+IFIpOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIHppcFByb3RvPFQsIFQyLCBUMywgVDQsIFQ1LCBUNiwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCB2NDogT2JzZXJ2YWJsZUlucHV0PFQ0PiwgdjU6IE9ic2VydmFibGVJbnB1dDxUNT4sIHY2OiBPYnNlcnZhYmxlSW5wdXQ8VDY+LCBwcm9qZWN0OiAodjE6IFQsIHYyOiBUMiwgdjM6IFQzLCB2NDogVDQsIHY1OiBUNSwgdjY6IFQ2KSA9PiBSKTogT2JzZXJ2YWJsZTxSPiA7XG5leHBvcnQgZnVuY3Rpb24gemlwUHJvdG88VCwgVDI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+KTogT2JzZXJ2YWJsZTxbVCwgVDJdPjtcbmV4cG9ydCBmdW5jdGlvbiB6aXBQcm90bzxULCBUMiwgVDM+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPik6IE9ic2VydmFibGU8W1QsIFQyLCBUM10+O1xuZXhwb3J0IGZ1bmN0aW9uIHppcFByb3RvPFQsIFQyLCBUMywgVDQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4pOiBPYnNlcnZhYmxlPFtULCBUMiwgVDMsIFQ0XT47XG5leHBvcnQgZnVuY3Rpb24gemlwUHJvdG88VCwgVDIsIFQzLCBUNCwgVDU+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4sIHY1OiBPYnNlcnZhYmxlSW5wdXQ8VDU+KTogT2JzZXJ2YWJsZTxbVCwgVDIsIFQzLCBUNCwgVDVdPjtcbmV4cG9ydCBmdW5jdGlvbiB6aXBQcm90bzxULCBUMiwgVDMsIFQ0LCBUNSwgVDY+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4sIHY1OiBPYnNlcnZhYmxlSW5wdXQ8VDU+LCB2NjogT2JzZXJ2YWJsZUlucHV0PFQ2Pik6IE9ic2VydmFibGU8W1QsIFQyLCBUMywgVDQsIFQ1LCBUNl0+IDtcbmV4cG9ydCBmdW5jdGlvbiB6aXBQcm90bzxULCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCAuLi5vYnNlcnZhYmxlczogQXJyYXk8T2JzZXJ2YWJsZUlucHV0PFQ+IHwgKCguLi52YWx1ZXM6IEFycmF5PFQ+KSA9PiBSKT4pOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIHppcFByb3RvPFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIGFycmF5OiBBcnJheTxPYnNlcnZhYmxlSW5wdXQ8VD4+KTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiB6aXBQcm90bzxULCBUT3RoZXIsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIGFycmF5OiBBcnJheTxPYnNlcnZhYmxlSW5wdXQ8VE90aGVyPj4sIHByb2plY3Q6ICh2MTogVCwgLi4udmFsdWVzOiBBcnJheTxUT3RoZXI+KSA9PiBSKTogT2JzZXJ2YWJsZTxSPjtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbi8qKlxuICogQHBhcmFtIG9ic2VydmFibGVzXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fVxuICogQG1ldGhvZCB6aXBcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6aXBQcm90bzxULCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCAuLi5vYnNlcnZhYmxlczogQXJyYXk8T2JzZXJ2YWJsZUlucHV0PGFueT4gfCAoKC4uLnZhbHVlczogQXJyYXk8YW55PikgPT4gUik+KTogT2JzZXJ2YWJsZTxSPiB7XG4gIHJldHVybiB0aGlzLmxpZnQuY2FsbCh6aXBTdGF0aWM8Uj4odGhpcywgLi4ub2JzZXJ2YWJsZXMpKTtcbn1cblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5leHBvcnQgZnVuY3Rpb24gemlwU3RhdGljPFQsIFQyPih2MTogT2JzZXJ2YWJsZUlucHV0PFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPik6IE9ic2VydmFibGU8W1QsIFQyXT47XG5leHBvcnQgZnVuY3Rpb24gemlwU3RhdGljPFQsIFQyLCBUMz4odjE6IE9ic2VydmFibGVJbnB1dDxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+KTogT2JzZXJ2YWJsZTxbVCwgVDIsIFQzXT47XG5leHBvcnQgZnVuY3Rpb24gemlwU3RhdGljPFQsIFQyLCBUMywgVDQ+KHYxOiBPYnNlcnZhYmxlSW5wdXQ8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4pOiBPYnNlcnZhYmxlPFtULCBUMiwgVDMsIFQ0XT47XG5leHBvcnQgZnVuY3Rpb24gemlwU3RhdGljPFQsIFQyLCBUMywgVDQsIFQ1Pih2MTogT2JzZXJ2YWJsZUlucHV0PFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCB2NTogT2JzZXJ2YWJsZUlucHV0PFQ1Pik6IE9ic2VydmFibGU8W1QsIFQyLCBUMywgVDQsIFQ1XT47XG5leHBvcnQgZnVuY3Rpb24gemlwU3RhdGljPFQsIFQyLCBUMywgVDQsIFQ1LCBUNj4odjE6IE9ic2VydmFibGVJbnB1dDxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCB2NDogT2JzZXJ2YWJsZUlucHV0PFQ0PiwgdjU6IE9ic2VydmFibGVJbnB1dDxUNT4sIHY2OiBPYnNlcnZhYmxlSW5wdXQ8VDY+KTogT2JzZXJ2YWJsZTxbVCwgVDIsIFQzLCBUNCwgVDUsIFQ2XT47XG5cbmV4cG9ydCBmdW5jdGlvbiB6aXBTdGF0aWM8VCwgUj4odjE6IE9ic2VydmFibGVJbnB1dDxUPiwgcHJvamVjdDogKHYxOiBUKSA9PiBSKTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiB6aXBTdGF0aWM8VCwgVDIsIFI+KHYxOiBPYnNlcnZhYmxlSW5wdXQ8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCBwcm9qZWN0OiAodjE6IFQsIHYyOiBUMikgPT4gUik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gemlwU3RhdGljPFQsIFQyLCBUMywgUj4odjE6IE9ic2VydmFibGVJbnB1dDxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCBwcm9qZWN0OiAodjE6IFQsIHYyOiBUMiwgdjM6IFQzKSA9PiBSKTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiB6aXBTdGF0aWM8VCwgVDIsIFQzLCBUNCwgUj4odjE6IE9ic2VydmFibGVJbnB1dDxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCB2NDogT2JzZXJ2YWJsZUlucHV0PFQ0PiwgcHJvamVjdDogKHYxOiBULCB2MjogVDIsIHYzOiBUMywgdjQ6IFQ0KSA9PiBSKTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiB6aXBTdGF0aWM8VCwgVDIsIFQzLCBUNCwgVDUsIFI+KHYxOiBPYnNlcnZhYmxlSW5wdXQ8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4sIHY1OiBPYnNlcnZhYmxlSW5wdXQ8VDU+LCBwcm9qZWN0OiAodjE6IFQsIHYyOiBUMiwgdjM6IFQzLCB2NDogVDQsIHY1OiBUNSkgPT4gUik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gemlwU3RhdGljPFQsIFQyLCBUMywgVDQsIFQ1LCBUNiwgUj4odjE6IE9ic2VydmFibGVJbnB1dDxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCB2NDogT2JzZXJ2YWJsZUlucHV0PFQ0PiwgdjU6IE9ic2VydmFibGVJbnB1dDxUNT4sIHY2OiBPYnNlcnZhYmxlSW5wdXQ8VDY+LCBwcm9qZWN0OiAodjE6IFQsIHYyOiBUMiwgdjM6IFQzLCB2NDogVDQsIHY1OiBUNSwgdjY6IFQ2KSA9PiBSKTogT2JzZXJ2YWJsZTxSPjtcblxuZXhwb3J0IGZ1bmN0aW9uIHppcFN0YXRpYzxUPihhcnJheTogT2JzZXJ2YWJsZUlucHV0PFQ+W10pOiBPYnNlcnZhYmxlPFRbXT47XG5leHBvcnQgZnVuY3Rpb24gemlwU3RhdGljPFI+KGFycmF5OiBPYnNlcnZhYmxlSW5wdXQ8YW55PltdKTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiB6aXBTdGF0aWM8VCwgUj4oYXJyYXk6IE9ic2VydmFibGVJbnB1dDxUPltdLCBwcm9qZWN0OiAoLi4udmFsdWVzOiBBcnJheTxUPikgPT4gUik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gemlwU3RhdGljPFI+KGFycmF5OiBPYnNlcnZhYmxlSW5wdXQ8YW55PltdLCBwcm9qZWN0OiAoLi4udmFsdWVzOiBBcnJheTxhbnk+KSA9PiBSKTogT2JzZXJ2YWJsZTxSPjtcblxuZXhwb3J0IGZ1bmN0aW9uIHppcFN0YXRpYzxUPiguLi5vYnNlcnZhYmxlczogQXJyYXk8T2JzZXJ2YWJsZUlucHV0PFQ+Pik6IE9ic2VydmFibGU8VFtdPjtcbmV4cG9ydCBmdW5jdGlvbiB6aXBTdGF0aWM8VCwgUj4oLi4ub2JzZXJ2YWJsZXM6IEFycmF5PE9ic2VydmFibGVJbnB1dDxUPiB8ICgoLi4udmFsdWVzOiBBcnJheTxUPikgPT4gUik+KTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiB6aXBTdGF0aWM8Uj4oLi4ub2JzZXJ2YWJsZXM6IEFycmF5PE9ic2VydmFibGVJbnB1dDxhbnk+IHwgKCguLi52YWx1ZXM6IEFycmF5PGFueT4pID0+IFIpPik6IE9ic2VydmFibGU8Uj47XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuXG4vKipcbiAqIENvbWJpbmVzIG11bHRpcGxlIE9ic2VydmFibGVzIHRvIGNyZWF0ZSBhbiBPYnNlcnZhYmxlIHdob3NlIHZhbHVlcyBhcmUgY2FsY3VsYXRlZCBmcm9tIHRoZSB2YWx1ZXMsIGluIG9yZGVyLCBvZiBlYWNoXG4gKiBvZiBpdHMgaW5wdXQgT2JzZXJ2YWJsZXMuXG4gKlxuICogSWYgdGhlIGxhdGVzdCBwYXJhbWV0ZXIgaXMgYSBmdW5jdGlvbiwgdGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlIGNyZWF0ZWQgdmFsdWUgZnJvbSB0aGUgaW5wdXQgdmFsdWVzLlxuICogT3RoZXJ3aXNlLCBhbiBhcnJheSBvZiB0aGUgaW5wdXQgdmFsdWVzIGlzIHJldHVybmVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbWJpbmUgYWdlIGFuZCBuYW1lIGZyb20gZGlmZmVyZW50IHNvdXJjZXM8L2NhcHRpb24+XG4gKlxuICogbGV0IGFnZSQgPSBPYnNlcnZhYmxlLm9mPG51bWJlcj4oMjcsIDI1LCAyOSk7XG4gKiBsZXQgbmFtZSQgPSBPYnNlcnZhYmxlLm9mPHN0cmluZz4oJ0ZvbycsICdCYXInLCAnQmVlcicpO1xuICogbGV0IGlzRGV2JCA9IE9ic2VydmFibGUub2Y8Ym9vbGVhbj4odHJ1ZSwgdHJ1ZSwgZmFsc2UpO1xuICpcbiAqIE9ic2VydmFibGVcbiAqICAgICAuemlwKGFnZSQsXG4gKiAgICAgICAgICBuYW1lJCxcbiAqICAgICAgICAgIGlzRGV2JCxcbiAqICAgICAgICAgIChhZ2U6IG51bWJlciwgbmFtZTogc3RyaW5nLCBpc0RldjogYm9vbGVhbikgPT4gKHsgYWdlLCBuYW1lLCBpc0RldiB9KSlcbiAqICAgICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIG91dHB1dHNcbiAqIC8vIHsgYWdlOiAyNywgbmFtZTogJ0ZvbycsIGlzRGV2OiB0cnVlIH1cbiAqIC8vIHsgYWdlOiAyNSwgbmFtZTogJ0JhcicsIGlzRGV2OiB0cnVlIH1cbiAqIC8vIHsgYWdlOiAyOSwgbmFtZTogJ0JlZXInLCBpc0RldjogZmFsc2UgfVxuICpcbiAqIEBwYXJhbSBvYnNlcnZhYmxlc1xuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn1cbiAqIEBzdGF0aWMgdHJ1ZVxuICogQG5hbWUgemlwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gemlwU3RhdGljPFQsIFI+KC4uLm9ic2VydmFibGVzOiBBcnJheTxPYnNlcnZhYmxlSW5wdXQ8YW55PiB8ICgoLi4udmFsdWVzOiBBcnJheTxhbnk+KSA9PiBSKT4pOiBPYnNlcnZhYmxlPFI+IHtcbiAgY29uc3QgcHJvamVjdCA9IDwoKC4uLnlzOiBBcnJheTxhbnk+KSA9PiBSKT4gb2JzZXJ2YWJsZXNbb2JzZXJ2YWJsZXMubGVuZ3RoIC0gMV07XG4gIGlmICh0eXBlb2YgcHJvamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9ic2VydmFibGVzLnBvcCgpO1xuICB9XG4gIHJldHVybiBuZXcgQXJyYXlPYnNlcnZhYmxlKG9ic2VydmFibGVzKS5saWZ0KG5ldyBaaXBPcGVyYXRvcihwcm9qZWN0KSk7XG59XG5cbmV4cG9ydCBjbGFzcyBaaXBPcGVyYXRvcjxULCBSPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFI+IHtcblxuICBwcm9qZWN0OiAoLi4udmFsdWVzOiBBcnJheTxhbnk+KSA9PiBSO1xuXG4gIGNvbnN0cnVjdG9yKHByb2plY3Q/OiAoLi4udmFsdWVzOiBBcnJheTxhbnk+KSA9PiBSKSB7XG4gICAgdGhpcy5wcm9qZWN0ID0gcHJvamVjdDtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxSPiwgc291cmNlOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBaaXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCkpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5leHBvcnQgY2xhc3MgWmlwU3Vic2NyaWJlcjxULCBSPiBleHRlbmRzIFN1YnNjcmliZXI8VD4ge1xuICBwcml2YXRlIHZhbHVlczogYW55O1xuICBwcml2YXRlIHByb2plY3Q6ICguLi52YWx1ZXM6IEFycmF5PGFueT4pID0+IFI7XG4gIHByaXZhdGUgaXRlcmF0b3JzOiBMb29rQWhlYWRJdGVyYXRvcjxhbnk+W10gPSBbXTtcbiAgcHJpdmF0ZSBhY3RpdmUgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFI+LFxuICAgICAgICAgICAgICBwcm9qZWN0PzogKC4uLnZhbHVlczogQXJyYXk8YW55PikgPT4gUixcbiAgICAgICAgICAgICAgdmFsdWVzOiBhbnkgPSBPYmplY3QuY3JlYXRlKG51bGwpKSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICAgIHRoaXMucHJvamVjdCA9ICh0eXBlb2YgcHJvamVjdCA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9qZWN0IDogbnVsbDtcbiAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogYW55KSB7XG4gICAgY29uc3QgaXRlcmF0b3JzID0gdGhpcy5pdGVyYXRvcnM7XG4gICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBpdGVyYXRvcnMucHVzaChuZXcgU3RhdGljQXJyYXlJdGVyYXRvcih2YWx1ZSkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlW1N5bWJvbF9pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGl0ZXJhdG9ycy5wdXNoKG5ldyBTdGF0aWNJdGVyYXRvcih2YWx1ZVtTeW1ib2xfaXRlcmF0b3JdKCkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0b3JzLnB1c2gobmV3IFppcEJ1ZmZlckl0ZXJhdG9yKHRoaXMuZGVzdGluYXRpb24sIHRoaXMsIHZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jb21wbGV0ZSgpIHtcbiAgICBjb25zdCBpdGVyYXRvcnMgPSB0aGlzLml0ZXJhdG9ycztcbiAgICBjb25zdCBsZW4gPSBpdGVyYXRvcnMubGVuZ3RoO1xuXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYWN0aXZlID0gbGVuO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxldCBpdGVyYXRvcjogWmlwQnVmZmVySXRlcmF0b3I8YW55LCBhbnk+ID0gPGFueT5pdGVyYXRvcnNbaV07XG4gICAgICBpZiAoaXRlcmF0b3Iuc3RpbGxVbnN1YnNjcmliZWQpIHtcbiAgICAgICAgdGhpcy5hZGQoaXRlcmF0b3Iuc3Vic2NyaWJlKGl0ZXJhdG9yLCBpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFjdGl2ZS0tOyAvLyBub3QgYW4gb2JzZXJ2YWJsZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5vdGlmeUluYWN0aXZlKCkge1xuICAgIHRoaXMuYWN0aXZlLS07XG4gICAgaWYgKHRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgY2hlY2tJdGVyYXRvcnMoKSB7XG4gICAgY29uc3QgaXRlcmF0b3JzID0gdGhpcy5pdGVyYXRvcnM7XG4gICAgY29uc3QgbGVuID0gaXRlcmF0b3JzLmxlbmd0aDtcbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG5cbiAgICAvLyBhYm9ydCBpZiBub3QgYWxsIG9mIHRoZW0gaGF2ZSB2YWx1ZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBsZXQgaXRlcmF0b3IgPSBpdGVyYXRvcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yLmhhc1ZhbHVlID09PSAnZnVuY3Rpb24nICYmICFpdGVyYXRvci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgc2hvdWxkQ29tcGxldGUgPSBmYWxzZTtcbiAgICBjb25zdCBhcmdzOiBhbnlbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxldCBpdGVyYXRvciA9IGl0ZXJhdG9yc1tpXTtcbiAgICAgIGxldCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBpdCdzIGNvbXBsZXRlZCBub3cgdGhhdCB5b3UndmUgZ290dGVuXG4gICAgICAvLyB0aGUgbmV4dCB2YWx1ZS5cbiAgICAgIGlmIChpdGVyYXRvci5oYXNDb21wbGV0ZWQoKSkge1xuICAgICAgICBzaG91bGRDb21wbGV0ZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGFyZ3MucHVzaChyZXN1bHQudmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnByb2plY3QpIHtcbiAgICAgIHRoaXMuX3RyeVByb2plY3QoYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc3RpbmF0aW9uLm5leHQoYXJncyk7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZENvbXBsZXRlKSB7XG4gICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfdHJ5UHJvamVjdChhcmdzOiBhbnlbXSkge1xuICAgIGxldCByZXN1bHQ6IGFueTtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5wcm9qZWN0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgTG9va0FoZWFkSXRlcmF0b3I8VD4gZXh0ZW5kcyBJdGVyYXRvcjxUPiB7XG4gIGhhc1ZhbHVlKCk6IGJvb2xlYW47XG4gIGhhc0NvbXBsZXRlZCgpOiBib29sZWFuO1xufVxuXG5jbGFzcyBTdGF0aWNJdGVyYXRvcjxUPiBpbXBsZW1lbnRzIExvb2tBaGVhZEl0ZXJhdG9yPFQ+IHtcbiAgcHJpdmF0ZSBuZXh0UmVzdWx0OiBJdGVyYXRvclJlc3VsdDxUPjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGl0ZXJhdG9yOiBJdGVyYXRvcjxUPikge1xuICAgIHRoaXMubmV4dFJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgfVxuXG4gIGhhc1ZhbHVlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgbmV4dCgpOiBJdGVyYXRvclJlc3VsdDxUPiB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5uZXh0UmVzdWx0O1xuICAgIHRoaXMubmV4dFJlc3VsdCA9IHRoaXMuaXRlcmF0b3IubmV4dCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBoYXNDb21wbGV0ZWQoKSB7XG4gICAgY29uc3QgbmV4dFJlc3VsdCA9IHRoaXMubmV4dFJlc3VsdDtcbiAgICByZXR1cm4gbmV4dFJlc3VsdCAmJiBuZXh0UmVzdWx0LmRvbmU7XG4gIH1cbn1cblxuY2xhc3MgU3RhdGljQXJyYXlJdGVyYXRvcjxUPiBpbXBsZW1lbnRzIExvb2tBaGVhZEl0ZXJhdG9yPFQ+IHtcbiAgcHJpdmF0ZSBpbmRleCA9IDA7XG4gIHByaXZhdGUgbGVuZ3RoID0gMDtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFycmF5OiBUW10pIHtcbiAgICB0aGlzLmxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgfVxuXG4gIFtTeW1ib2xfaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbmV4dCh2YWx1ZT86IGFueSk6IEl0ZXJhdG9yUmVzdWx0PFQ+IHtcbiAgICBjb25zdCBpID0gdGhpcy5pbmRleCsrO1xuICAgIGNvbnN0IGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICByZXR1cm4gaSA8IHRoaXMubGVuZ3RoID8geyB2YWx1ZTogYXJyYXlbaV0sIGRvbmU6IGZhbHNlIH0gOiB7IHZhbHVlOiBudWxsLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBoYXNWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGggPiB0aGlzLmluZGV4O1xuICB9XG5cbiAgaGFzQ29tcGxldGVkKCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aCA9PT0gdGhpcy5pbmRleDtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgWmlwQnVmZmVySXRlcmF0b3I8VCwgUj4gZXh0ZW5kcyBPdXRlclN1YnNjcmliZXI8VCwgUj4gaW1wbGVtZW50cyBMb29rQWhlYWRJdGVyYXRvcjxUPiB7XG4gIHN0aWxsVW5zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgYnVmZmVyOiBUW10gPSBbXTtcbiAgaXNDb21wbGV0ZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBQYXJ0aWFsT2JzZXJ2ZXI8VD4sXG4gICAgICAgICAgICAgIHByaXZhdGUgcGFyZW50OiBaaXBTdWJzY3JpYmVyPFQsIFI+LFxuICAgICAgICAgICAgICBwcml2YXRlIG9ic2VydmFibGU6IE9ic2VydmFibGU8VD4pIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gIH1cblxuICBbU3ltYm9sX2l0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIE5PVEU6IHRoZXJlIGlzIGFjdHVhbGx5IGEgbmFtZSBjb2xsaXNpb24gaGVyZSB3aXRoIFN1YnNjcmliZXIubmV4dCBhbmQgSXRlcmF0b3IubmV4dFxuICAvLyAgICB0aGlzIGlzIGxlZ2l0IGJlY2F1c2UgYG5leHQoKWAgd2lsbCBuZXZlciBiZSBjYWxsZWQgYnkgYSBzdWJzY3JpcHRpb24gaW4gdGhpcyBjYXNlLlxuICBuZXh0KCk6IEl0ZXJhdG9yUmVzdWx0PFQ+IHtcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmlzQ29tcGxldGUpIHtcbiAgICAgIHJldHVybiB7IHZhbHVlOiBudWxsLCBkb25lOiB0cnVlIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHZhbHVlOiBidWZmZXIuc2hpZnQoKSwgZG9uZTogZmFsc2UgfTtcbiAgICB9XG4gIH1cblxuICBoYXNWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIubGVuZ3RoID4gMDtcbiAgfVxuXG4gIGhhc0NvbXBsZXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIubGVuZ3RoID09PSAwICYmIHRoaXMuaXNDb21wbGV0ZTtcbiAgfVxuXG4gIG5vdGlmeUNvbXBsZXRlKCkge1xuICAgIGlmICh0aGlzLmJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgdGhpcy5wYXJlbnQubm90aWZ5SW5hY3RpdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIG5vdGlmeU5leHQob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogYW55LFxuICAgICAgICAgICAgIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgIGlubmVyU3ViOiBJbm5lclN1YnNjcmliZXI8VCwgUj4pOiB2b2lkIHtcbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGlubmVyVmFsdWUpO1xuICAgIHRoaXMucGFyZW50LmNoZWNrSXRlcmF0b3JzKCk7XG4gIH1cblxuICBzdWJzY3JpYmUodmFsdWU6IGFueSwgaW5kZXg6IG51bWJlcikge1xuICAgIHJldHVybiBzdWJzY3JpYmVUb1Jlc3VsdDxhbnksIGFueT4odGhpcywgdGhpcy5vYnNlcnZhYmxlLCB0aGlzLCBpbmRleCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvemlwLnRzIiwiaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJy4vU3ViamVjdCc7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiwgSVN1YnNjcmlwdGlvbiB9IGZyb20gJy4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yIH0gZnJvbSAnLi91dGlsL09iamVjdFVuc3Vic2NyaWJlZEVycm9yJztcblxuLyoqXG4gKiBAY2xhc3MgQmVoYXZpb3JTdWJqZWN0PFQ+XG4gKi9cbmV4cG9ydCBjbGFzcyBCZWhhdmlvclN1YmplY3Q8VD4gZXh0ZW5kcyBTdWJqZWN0PFQ+IHtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF92YWx1ZTogVCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBnZXQgdmFsdWUoKTogVCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4pOiBTdWJzY3JpcHRpb24ge1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN1cGVyLl9zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgaWYgKHN1YnNjcmlwdGlvbiAmJiAhKDxJU3Vic2NyaXB0aW9uPnN1YnNjcmlwdGlvbikuY2xvc2VkKSB7XG4gICAgICBzdWJzY3JpYmVyLm5leHQodGhpcy5fdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICB9XG5cbiAgZ2V0VmFsdWUoKTogVCB7XG4gICAgaWYgKHRoaXMuaGFzRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMudGhyb3duRXJyb3I7XG4gICAgfSBlbHNlIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gIH1cblxuICBuZXh0KHZhbHVlOiBUKTogdm9pZCB7XG4gICAgc3VwZXIubmV4dCh0aGlzLl92YWx1ZSA9IHZhbHVlKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9CZWhhdmlvclN1YmplY3QudHMiLCJleHBvcnQgaW50ZXJmYWNlIE5leHRPYnNlcnZlcjxUPiB7XG4gIGNsb3NlZD86IGJvb2xlYW47XG4gIG5leHQ6ICh2YWx1ZTogVCkgPT4gdm9pZDtcbiAgZXJyb3I/OiAoZXJyOiBhbnkpID0+IHZvaWQ7XG4gIGNvbXBsZXRlPzogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFcnJvck9ic2VydmVyPFQ+IHtcbiAgY2xvc2VkPzogYm9vbGVhbjtcbiAgbmV4dD86ICh2YWx1ZTogVCkgPT4gdm9pZDtcbiAgZXJyb3I6IChlcnI6IGFueSkgPT4gdm9pZDtcbiAgY29tcGxldGU/OiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbXBsZXRpb25PYnNlcnZlcjxUPiB7XG4gIGNsb3NlZD86IGJvb2xlYW47XG4gIG5leHQ/OiAodmFsdWU6IFQpID0+IHZvaWQ7XG4gIGVycm9yPzogKGVycjogYW55KSA9PiB2b2lkO1xuICBjb21wbGV0ZTogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgUGFydGlhbE9ic2VydmVyPFQ+ID0gTmV4dE9ic2VydmVyPFQ+IHwgRXJyb3JPYnNlcnZlcjxUPiB8IENvbXBsZXRpb25PYnNlcnZlcjxUPjtcblxuZXhwb3J0IGludGVyZmFjZSBPYnNlcnZlcjxUPiB7XG4gIGNsb3NlZD86IGJvb2xlYW47XG4gIG5leHQ6ICh2YWx1ZTogVCkgPT4gdm9pZDtcbiAgZXJyb3I6IChlcnI6IGFueSkgPT4gdm9pZDtcbiAgY29tcGxldGU6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBjb25zdCBlbXB0eTogT2JzZXJ2ZXI8YW55PiA9IHtcbiAgY2xvc2VkOiB0cnVlLFxuICBuZXh0KHZhbHVlOiBhbnkpOiB2b2lkIHsgLyogbm9vcCAqL30sXG4gIGVycm9yKGVycjogYW55KTogdm9pZCB7IHRocm93IGVycjsgfSxcbiAgY29tcGxldGUoKTogdm9pZCB7IC8qbm9vcCovIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL09ic2VydmVyLnRzIiwiaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJy4vU3ViamVjdCc7XG5pbXBvcnQgeyBPYnNlcnZlciB9IGZyb20gJy4vT2JzZXJ2ZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi9TdWJzY3JpcHRpb24nO1xuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuZXhwb3J0IGNsYXNzIFN1YmplY3RTdWJzY3JpcHRpb248VD4gZXh0ZW5kcyBTdWJzY3JpcHRpb24ge1xuICBjbG9zZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgc3ViamVjdDogU3ViamVjdDxUPiwgcHVibGljIHN1YnNjcmliZXI6IE9ic2VydmVyPFQ+KSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHVuc3Vic2NyaWJlKCkge1xuICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcblxuICAgIGNvbnN0IHN1YmplY3QgPSB0aGlzLnN1YmplY3Q7XG4gICAgY29uc3Qgb2JzZXJ2ZXJzID0gc3ViamVjdC5vYnNlcnZlcnM7XG5cbiAgICB0aGlzLnN1YmplY3QgPSBudWxsO1xuXG4gICAgaWYgKCFvYnNlcnZlcnMgfHwgb2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCB8fCBzdWJqZWN0LmlzU3RvcHBlZCB8fCBzdWJqZWN0LmNsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN1YnNjcmliZXJJbmRleCA9IG9ic2VydmVycy5pbmRleE9mKHRoaXMuc3Vic2NyaWJlcik7XG5cbiAgICBpZiAoc3Vic2NyaWJlckluZGV4ICE9PSAtMSkge1xuICAgICAgb2JzZXJ2ZXJzLnNwbGljZShzdWJzY3JpYmVySW5kZXgsIDEpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9TdWJqZWN0U3Vic2NyaXB0aW9uLnRzIiwiaW1wb3J0IHsgU3ViamVjdCwgU3ViamVjdFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJqZWN0JztcbmltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBUZWFyZG93bkxvZ2ljIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcblxuLyoqXG4gKiBAY2xhc3MgQ29ubmVjdGFibGVPYnNlcnZhYmxlPFQ+XG4gKi9cbmV4cG9ydCBjbGFzcyBDb25uZWN0YWJsZU9ic2VydmFibGU8VD4gZXh0ZW5kcyBPYnNlcnZhYmxlPFQ+IHtcblxuICBwcm90ZWN0ZWQgX3N1YmplY3Q6IFN1YmplY3Q8VD47XG4gIHByb3RlY3RlZCBfcmVmQ291bnQ6IG51bWJlciA9IDA7XG4gIHByb3RlY3RlZCBfY29ubmVjdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBzb3VyY2U6IE9ic2VydmFibGU8VD4sXG4gICAgICAgICAgICAgIHByb3RlY3RlZCBzdWJqZWN0RmFjdG9yeTogKCkgPT4gU3ViamVjdDxUPikge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3N1YnNjcmliZShzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3ViamVjdCgpLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRTdWJqZWN0KCk6IFN1YmplY3Q8VD4ge1xuICAgIGNvbnN0IHN1YmplY3QgPSB0aGlzLl9zdWJqZWN0O1xuICAgIGlmICghc3ViamVjdCB8fCBzdWJqZWN0LmlzU3RvcHBlZCkge1xuICAgICAgdGhpcy5fc3ViamVjdCA9IHRoaXMuc3ViamVjdEZhY3RvcnkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N1YmplY3Q7XG4gIH1cblxuICBjb25uZWN0KCk6IFN1YnNjcmlwdGlvbiB7XG4gICAgbGV0IGNvbm5lY3Rpb24gPSB0aGlzLl9jb25uZWN0aW9uO1xuICAgIGlmICghY29ubmVjdGlvbikge1xuICAgICAgY29ubmVjdGlvbiA9IHRoaXMuX2Nvbm5lY3Rpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgICBjb25uZWN0aW9uLmFkZCh0aGlzLnNvdXJjZVxuICAgICAgICAuc3Vic2NyaWJlKG5ldyBDb25uZWN0YWJsZVN1YnNjcmliZXIodGhpcy5nZXRTdWJqZWN0KCksIHRoaXMpKSk7XG4gICAgICBpZiAoY29ubmVjdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICAgIGNvbm5lY3Rpb24gPSBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gIH1cblxuICByZWZDb3VudCgpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBSZWZDb3VudE9wZXJhdG9yPFQ+KHRoaXMpKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgY29ubmVjdGFibGVPYnNlcnZhYmxlRGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yTWFwID0ge1xuICBvcGVyYXRvcjogeyB2YWx1ZTogbnVsbCB9LFxuICBfcmVmQ291bnQ6IHsgdmFsdWU6IDAsIHdyaXRhYmxlOiB0cnVlIH0sXG4gIF9zdWJqZWN0OiB7IHZhbHVlOiBudWxsLCB3cml0YWJsZTogdHJ1ZSB9LFxuICBfY29ubmVjdGlvbjogeyB2YWx1ZTogbnVsbCwgd3JpdGFibGU6IHRydWUgfSxcbiAgX3N1YnNjcmliZTogeyB2YWx1ZTogKDxhbnk+IENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUpLl9zdWJzY3JpYmUgfSxcbiAgZ2V0U3ViamVjdDogeyB2YWx1ZTogKDxhbnk+IENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUpLmdldFN1YmplY3QgfSxcbiAgY29ubmVjdDogeyB2YWx1ZTogKDxhbnk+IENvbm5lY3RhYmxlT2JzZXJ2YWJsZS5wcm90b3R5cGUpLmNvbm5lY3QgfSxcbiAgcmVmQ291bnQ6IHsgdmFsdWU6ICg8YW55PiBDb25uZWN0YWJsZU9ic2VydmFibGUucHJvdG90eXBlKS5yZWZDb3VudCB9XG59O1xuXG5jbGFzcyBDb25uZWN0YWJsZVN1YnNjcmliZXI8VD4gZXh0ZW5kcyBTdWJqZWN0U3Vic2NyaWJlcjxUPiB7XG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJqZWN0PFQ+LFxuICAgICAgICAgICAgICBwcml2YXRlIGNvbm5lY3RhYmxlOiBDb25uZWN0YWJsZU9ic2VydmFibGU8VD4pIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gIH1cbiAgcHJvdGVjdGVkIF9lcnJvcihlcnI6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuX3Vuc3Vic2NyaWJlKCk7XG4gICAgc3VwZXIuX2Vycm9yKGVycik7XG4gIH1cbiAgcHJvdGVjdGVkIF9jb21wbGV0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLl91bnN1YnNjcmliZSgpO1xuICAgIHN1cGVyLl9jb21wbGV0ZSgpO1xuICB9XG4gIHByb3RlY3RlZCBfdW5zdWJzY3JpYmUoKSB7XG4gICAgY29uc3QgeyBjb25uZWN0YWJsZSB9ID0gdGhpcztcbiAgICBpZiAoY29ubmVjdGFibGUpIHtcbiAgICAgIHRoaXMuY29ubmVjdGFibGUgPSBudWxsO1xuICAgICAgY29uc3QgY29ubmVjdGlvbiA9ICg8YW55PiBjb25uZWN0YWJsZSkuX2Nvbm5lY3Rpb247XG4gICAgICAoPGFueT4gY29ubmVjdGFibGUpLl9yZWZDb3VudCA9IDA7XG4gICAgICAoPGFueT4gY29ubmVjdGFibGUpLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgICg8YW55PiBjb25uZWN0YWJsZSkuX2Nvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgY29ubmVjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBSZWZDb3VudE9wZXJhdG9yPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbm5lY3RhYmxlOiBDb25uZWN0YWJsZU9ic2VydmFibGU8VD4pIHtcbiAgfVxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4sIHNvdXJjZTogYW55KTogVGVhcmRvd25Mb2dpYyB7XG5cbiAgICBjb25zdCB7IGNvbm5lY3RhYmxlIH0gPSB0aGlzO1xuICAgICg8YW55PiBjb25uZWN0YWJsZSkuX3JlZkNvdW50Kys7XG5cbiAgICBjb25zdCByZWZDb3VudGVyID0gbmV3IFJlZkNvdW50U3Vic2NyaWJlcihzdWJzY3JpYmVyLCBjb25uZWN0YWJsZSk7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc291cmNlLnN1YnNjcmliZShyZWZDb3VudGVyKTtcblxuICAgIGlmICghcmVmQ291bnRlci5jbG9zZWQpIHtcbiAgICAgICg8YW55PiByZWZDb3VudGVyKS5jb25uZWN0aW9uID0gY29ubmVjdGFibGUuY29ubmVjdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbn1cblxuY2xhc3MgUmVmQ291bnRTdWJzY3JpYmVyPFQ+IGV4dGVuZHMgU3Vic2NyaWJlcjxUPiB7XG5cbiAgcHJpdmF0ZSBjb25uZWN0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8VD4sXG4gICAgICAgICAgICAgIHByaXZhdGUgY29ubmVjdGFibGU6IENvbm5lY3RhYmxlT2JzZXJ2YWJsZTxUPikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfdW5zdWJzY3JpYmUoKSB7XG5cbiAgICBjb25zdCB7IGNvbm5lY3RhYmxlIH0gPSB0aGlzO1xuICAgIGlmICghY29ubmVjdGFibGUpIHtcbiAgICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jb25uZWN0YWJsZSA9IG51bGw7XG4gICAgY29uc3QgcmVmQ291bnQgPSAoPGFueT4gY29ubmVjdGFibGUpLl9yZWZDb3VudDtcbiAgICBpZiAocmVmQ291bnQgPD0gMCkge1xuICAgICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAoPGFueT4gY29ubmVjdGFibGUpLl9yZWZDb3VudCA9IHJlZkNvdW50IC0gMTtcbiAgICBpZiAocmVmQ291bnQgPiAxKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vL1xuICAgIC8vIENvbXBhcmUgdGhlIGxvY2FsIFJlZkNvdW50U3Vic2NyaWJlcidzIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIHRvIHRoZVxuICAgIC8vIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uIG9uIHRoZSBzaGFyZWQgQ29ubmVjdGFibGVPYnNlcnZhYmxlLiBJbiBjYXNlc1xuICAgIC8vIHdoZXJlIHRoZSBDb25uZWN0YWJsZU9ic2VydmFibGUgc291cmNlIHN5bmNocm9ub3VzbHkgZW1pdHMgdmFsdWVzLCBhbmRcbiAgICAvLyB0aGUgUmVmQ291bnRTdWJzY3JpYmVyJ3MgZG93bnN0cmVhbSBPYnNlcnZlcnMgc3luY2hyb25vdXNseSB1bnN1YnNjcmliZSxcbiAgICAvLyBleGVjdXRpb24gY29udGludWVzIHRvIGhlcmUgYmVmb3JlIHRoZSBSZWZDb3VudE9wZXJhdG9yIGhhcyBhIGNoYW5jZSB0b1xuICAgIC8vIHN1cHBseSB0aGUgUmVmQ291bnRTdWJzY3JpYmVyIHdpdGggdGhlIHNoYXJlZCBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbi5cbiAgICAvLyBGb3IgZXhhbXBsZTpcbiAgICAvLyBgYGBcbiAgICAvLyBPYnNlcnZhYmxlLnJhbmdlKDAsIDEwKVxuICAgIC8vICAgLnB1Ymxpc2goKVxuICAgIC8vICAgLnJlZkNvdW50KClcbiAgICAvLyAgIC50YWtlKDUpXG4gICAgLy8gICAuc3Vic2NyaWJlKCk7XG4gICAgLy8gYGBgXG4gICAgLy8gSW4gb3JkZXIgdG8gYWNjb3VudCBmb3IgdGhpcyBjYXNlLCBSZWZDb3VudFN1YnNjcmliZXIgc2hvdWxkIG9ubHkgZGlzcG9zZVxuICAgIC8vIHRoZSBDb25uZWN0YWJsZU9ic2VydmFibGUncyBzaGFyZWQgY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gaWYgdGhlXG4gICAgLy8gY29ubmVjdGlvbiBTdWJzY3JpcHRpb24gZXhpc3RzLCAqYW5kKiBlaXRoZXI6XG4gICAgLy8gICBhLiBSZWZDb3VudFN1YnNjcmliZXIgZG9lc24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBzaGFyZWQgY29ubmVjdGlvblxuICAgIC8vICAgICAgU3Vic2NyaXB0aW9uIHlldCwgb3IsXG4gICAgLy8gICBiLiBSZWZDb3VudFN1YnNjcmliZXIncyBjb25uZWN0aW9uIFN1YnNjcmlwdGlvbiByZWZlcmVuY2UgaXMgaWRlbnRpY2FsXG4gICAgLy8gICAgICB0byB0aGUgc2hhcmVkIGNvbm5lY3Rpb24gU3Vic2NyaXB0aW9uXG4gICAgLy8vXG4gICAgY29uc3QgeyBjb25uZWN0aW9uIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNoYXJlZENvbm5lY3Rpb24gPSAoPGFueT4gY29ubmVjdGFibGUpLl9jb25uZWN0aW9uO1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IG51bGw7XG5cbiAgICBpZiAoc2hhcmVkQ29ubmVjdGlvbiAmJiAoIWNvbm5lY3Rpb24gfHwgc2hhcmVkQ29ubmVjdGlvbiA9PT0gY29ubmVjdGlvbikpIHtcbiAgICAgIHNoYXJlZENvbm5lY3Rpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9Db25uZWN0YWJsZU9ic2VydmFibGUudHMiLCJpbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi4vdXRpbC9pc0FycmF5JztcbmltcG9ydCB7IGlzQXJyYXlMaWtlIH0gZnJvbSAnLi4vdXRpbC9pc0FycmF5TGlrZSc7XG5pbXBvcnQgeyBpc1Byb21pc2UgfSBmcm9tICcuLi91dGlsL2lzUHJvbWlzZSc7XG5pbXBvcnQgeyBQcm9taXNlT2JzZXJ2YWJsZSB9IGZyb20gJy4vUHJvbWlzZU9ic2VydmFibGUnO1xuaW1wb3J0IHsgSXRlcmF0b3JPYnNlcnZhYmxlIH0gZnJvbScuL0l0ZXJhdG9yT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBBcnJheU9ic2VydmFibGUgfSBmcm9tICcuL0FycmF5T2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBBcnJheUxpa2VPYnNlcnZhYmxlIH0gZnJvbSAnLi9BcnJheUxpa2VPYnNlcnZhYmxlJztcblxuaW1wb3J0IHsgSVNjaGVkdWxlciB9IGZyb20gJy4uL1NjaGVkdWxlcic7XG5pbXBvcnQgeyBpdGVyYXRvciBhcyBTeW1ib2xfaXRlcmF0b3IgfSBmcm9tICcuLi9zeW1ib2wvaXRlcmF0b3InO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2YWJsZUlucHV0IH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBPYnNlcnZlT25TdWJzY3JpYmVyIH0gZnJvbSAnLi4vb3BlcmF0b3Ivb2JzZXJ2ZU9uJztcbmltcG9ydCB7IG9ic2VydmFibGUgYXMgU3ltYm9sX29ic2VydmFibGUgfSBmcm9tICcuLi9zeW1ib2wvb2JzZXJ2YWJsZSc7XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG5leHBvcnQgY2xhc3MgRnJvbU9ic2VydmFibGU8VD4gZXh0ZW5kcyBPYnNlcnZhYmxlPFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpc2g6IE9ic2VydmFibGVJbnB1dDxUPiwgcHJpdmF0ZSBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKSB7XG4gICAgc3VwZXIobnVsbCk7XG4gIH1cblxuICBzdGF0aWMgY3JlYXRlPFQ+KGlzaDogT2JzZXJ2YWJsZUlucHV0PFQ+LCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxUPjtcbiAgc3RhdGljIGNyZWF0ZTxULCBSPihpc2g6IEFycmF5TGlrZTxUPiwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8Uj47XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSBmcm9tIGFuIEFycmF5LCBhbiBhcnJheS1saWtlIG9iamVjdCwgYSBQcm9taXNlLCBhblxuICAgKiBpdGVyYWJsZSBvYmplY3QsIG9yIGFuIE9ic2VydmFibGUtbGlrZSBvYmplY3QuXG4gICAqXG4gICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db252ZXJ0cyBhbG1vc3QgYW55dGhpbmcgdG8gYW4gT2JzZXJ2YWJsZS48L3NwYW4+XG4gICAqXG4gICAqIDxpbWcgc3JjPVwiLi9pbWcvZnJvbS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICpcbiAgICogQ29udmVydCB2YXJpb3VzIG90aGVyIG9iamVjdHMgYW5kIGRhdGEgdHlwZXMgaW50byBPYnNlcnZhYmxlcy4gYGZyb21gXG4gICAqIGNvbnZlcnRzIGEgUHJvbWlzZSBvciBhbiBhcnJheS1saWtlIG9yIGFuXG4gICAqIFtpdGVyYWJsZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvSXRlcmF0aW9uX3Byb3RvY29scyNpdGVyYWJsZSlcbiAgICogb2JqZWN0IGludG8gYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyBpbiB0aGF0IHByb21pc2Ugb3IgYXJyYXkgb3JcbiAgICogaXRlcmFibGUuIEEgU3RyaW5nLCBpbiB0aGlzIGNvbnRleHQsIGlzIHRyZWF0ZWQgYXMgYW4gYXJyYXkgb2YgY2hhcmFjdGVycy5cbiAgICogT2JzZXJ2YWJsZS1saWtlIG9iamVjdHMgKGNvbnRhaW5zIGEgZnVuY3Rpb24gbmFtZWQgd2l0aCB0aGUgRVMyMDE1IFN5bWJvbFxuICAgKiBmb3IgT2JzZXJ2YWJsZSkgY2FuIGFsc28gYmUgY29udmVydGVkIHRocm91Z2ggdGhpcyBvcGVyYXRvci5cbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+Q29udmVydHMgYW4gYXJyYXkgdG8gYW4gT2JzZXJ2YWJsZTwvY2FwdGlvbj5cbiAgICogdmFyIGFycmF5ID0gWzEwLCAyMCwgMzBdO1xuICAgKiB2YXIgcmVzdWx0ID0gUnguT2JzZXJ2YWJsZS5mcm9tKGFycmF5KTtcbiAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICpcbiAgICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICAgKiAvLyAxMCAyMCAzMFxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0IGFuIGluZmluaXRlIGl0ZXJhYmxlIChmcm9tIGEgZ2VuZXJhdG9yKSB0byBhbiBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICAgKiBmdW5jdGlvbiogZ2VuZXJhdGVEb3VibGVzKHNlZWQpIHtcbiAgICogICB2YXIgaSA9IHNlZWQ7XG4gICAqICAgd2hpbGUgKHRydWUpIHtcbiAgICogICAgIHlpZWxkIGk7XG4gICAqICAgICBpID0gMiAqIGk7IC8vIGRvdWJsZSBpdFxuICAgKiAgIH1cbiAgICogfVxuICAgKlxuICAgKiB2YXIgaXRlcmF0b3IgPSBnZW5lcmF0ZURvdWJsZXMoMyk7XG4gICAqIHZhciByZXN1bHQgPSBSeC5PYnNlcnZhYmxlLmZyb20oaXRlcmF0b3IpLnRha2UoMTApO1xuICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgKlxuICAgKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gICAqIC8vIDMgNiAxMiAyNCA0OCA5NiAxOTIgMzg0IDc2OCAxNTM2XG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGNyZWF0ZX1cbiAgICogQHNlZSB7QGxpbmsgZnJvbUV2ZW50fVxuICAgKiBAc2VlIHtAbGluayBmcm9tRXZlbnRQYXR0ZXJufVxuICAgKiBAc2VlIHtAbGluayBmcm9tUHJvbWlzZX1cbiAgICpcbiAgICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXQ8VD59IGlzaCBBIHN1YnNjcmliYWJsZSBvYmplY3QsIGEgUHJvbWlzZSwgYW5cbiAgICogT2JzZXJ2YWJsZS1saWtlLCBhbiBBcnJheSwgYW4gaXRlcmFibGUgb3IgYW4gYXJyYXktbGlrZSBvYmplY3QgdG8gYmVcbiAgICogY29udmVydGVkLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gVGhlIHNjaGVkdWxlciBvbiB3aGljaCB0byBzY2hlZHVsZSB0aGVcbiAgICogZW1pc3Npb25zIG9mIHZhbHVlcy5cbiAgICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gVGhlIE9ic2VydmFibGUgd2hvc2UgdmFsdWVzIGFyZSBvcmlnaW5hbGx5IGZyb20gdGhlXG4gICAqIGlucHV0IG9iamVjdCB0aGF0IHdhcyBjb252ZXJ0ZWQuXG4gICAqIEBzdGF0aWMgdHJ1ZVxuICAgKiBAbmFtZSBmcm9tXG4gICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlPFQ+KGlzaDogT2JzZXJ2YWJsZUlucHV0PFQ+LCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxUPiB7XG4gICAgaWYgKGlzaCAhPSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIGlzaFtTeW1ib2xfb2JzZXJ2YWJsZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKGlzaCBpbnN0YW5jZW9mIE9ic2VydmFibGUgJiYgIXNjaGVkdWxlcikge1xuICAgICAgICAgIHJldHVybiBpc2g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGcm9tT2JzZXJ2YWJsZTxUPihpc2gsIHNjaGVkdWxlcik7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaXNoKSkge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZTxUPihpc2gsIHNjaGVkdWxlcik7XG4gICAgICB9IGVsc2UgaWYgKGlzUHJvbWlzZShpc2gpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZU9ic2VydmFibGU8VD4oaXNoLCBzY2hlZHVsZXIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaXNoW1N5bWJvbF9pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGlzaCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJdGVyYXRvck9ic2VydmFibGU8VD4oaXNoLCBzY2hlZHVsZXIpO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5TGlrZShpc2gpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlMaWtlT2JzZXJ2YWJsZShpc2gsIHNjaGVkdWxlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigoaXNoICE9PSBudWxsICYmIHR5cGVvZiBpc2ggfHwgaXNoKSArICcgaXMgbm90IG9ic2VydmFibGUnKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4pIHtcbiAgICBjb25zdCBpc2ggPSB0aGlzLmlzaDtcbiAgICBjb25zdCBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICBpZiAoc2NoZWR1bGVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBpc2hbU3ltYm9sX29ic2VydmFibGVdKCkuc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaXNoW1N5bWJvbF9vYnNlcnZhYmxlXSgpLnN1YnNjcmliZShuZXcgT2JzZXJ2ZU9uU3Vic2NyaWJlcihzdWJzY3JpYmVyLCBzY2hlZHVsZXIsIDApKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9Gcm9tT2JzZXJ2YWJsZS50cyIsImltcG9ydCB7IHJvb3QgfSBmcm9tICcuLi91dGlsL3Jvb3QnO1xuaW1wb3J0IHsgSVNjaGVkdWxlciB9IGZyb20gJy4uL1NjaGVkdWxlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBUZWFyZG93bkxvZ2ljIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9taXNlT2JzZXJ2YWJsZTxUPiBleHRlbmRzIE9ic2VydmFibGU8VD4ge1xuXG4gIHB1YmxpYyB2YWx1ZTogVDtcblxuICAvKipcbiAgICogQ29udmVydHMgYSBQcm9taXNlIHRvIGFuIE9ic2VydmFibGUuXG4gICAqXG4gICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5SZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBqdXN0IGVtaXRzIHRoZSBQcm9taXNlJ3NcbiAgICogcmVzb2x2ZWQgdmFsdWUsIHRoZW4gY29tcGxldGVzLjwvc3Bhbj5cbiAgICpcbiAgICogQ29udmVydHMgYW4gRVMyMDE1IFByb21pc2Ugb3IgYSBQcm9taXNlcy9BKyBzcGVjIGNvbXBsaWFudCBQcm9taXNlIHRvIGFuXG4gICAqIE9ic2VydmFibGUuIElmIHRoZSBQcm9taXNlIHJlc29sdmVzIHdpdGggYSB2YWx1ZSwgdGhlIG91dHB1dCBPYnNlcnZhYmxlXG4gICAqIGVtaXRzIHRoYXQgcmVzb2x2ZWQgdmFsdWUgYXMgYSBgbmV4dGAsIGFuZCB0aGVuIGNvbXBsZXRlcy4gSWYgdGhlIFByb21pc2VcbiAgICogaXMgcmVqZWN0ZWQsIHRoZW4gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzIHRoZSBjb3JyZXNwb25kaW5nIEVycm9yLlxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0IHRoZSBQcm9taXNlIHJldHVybmVkIGJ5IEZldGNoIHRvIGFuIE9ic2VydmFibGU8L2NhcHRpb24+XG4gICAqIHZhciByZXN1bHQgPSBSeC5PYnNlcnZhYmxlLmZyb21Qcm9taXNlKGZldGNoKCdodHRwOi8vbXlzZXJ2ZXIuY29tLycpKTtcbiAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpLCBlID0+IGNvbnNvbGUuZXJyb3IoZSkpO1xuICAgKlxuICAgKiBAc2VlIHtAbGluayBiaW5kQ2FsbGJhY2t9XG4gICAqIEBzZWUge0BsaW5rIGZyb219XG4gICAqXG4gICAqIEBwYXJhbSB7UHJvbWlzZTxUPn0gcHJvbWlzZSBUaGUgcHJvbWlzZSB0byBiZSBjb252ZXJ0ZWQuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBBbiBvcHRpb25hbCBJU2NoZWR1bGVyIHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgKiB0aGUgZGVsaXZlcnkgb2YgdGhlIHJlc29sdmVkIHZhbHVlIChvciB0aGUgcmVqZWN0aW9uKS5cbiAgICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB3aGljaCB3cmFwcyB0aGUgUHJvbWlzZS5cbiAgICogQHN0YXRpYyB0cnVlXG4gICAqIEBuYW1lIGZyb21Qcm9taXNlXG4gICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlPFQ+KHByb21pc2U6IFByb21pc2U8VD4sIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VPYnNlcnZhYmxlKHByb21pc2UsIHNjaGVkdWxlcik7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHByb21pc2U6IFByb21pc2U8VD4sIHByaXZhdGUgc2NoZWR1bGVyPzogSVNjaGVkdWxlcikge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3N1YnNjcmliZShzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+KTogVGVhcmRvd25Mb2dpYyB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcbiAgICBjb25zdCBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcblxuICAgIGlmIChzY2hlZHVsZXIgPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuX2lzU2NhbGFyKSB7XG4gICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICBzdWJzY3JpYmVyLm5leHQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlLnRoZW4oXG4gICAgICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9pc1NjYWxhciA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgICAudGhlbihudWxsLCBlcnIgPT4ge1xuICAgICAgICAgIC8vIGVzY2FwZSB0aGUgcHJvbWlzZSB0cmFwLCB0aHJvdyB1bmhhbmRsZWQgZXJyb3JzXG4gICAgICAgICAgcm9vdC5zZXRUaW1lb3V0KCgpID0+IHsgdGhyb3cgZXJyOyB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl9pc1NjYWxhcikge1xuICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIDAsIHsgdmFsdWU6IHRoaXMudmFsdWUsIHN1YnNjcmliZXIgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2UudGhlbihcbiAgICAgICAgICAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2lzU2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgICAgICAgICAgc3Vic2NyaWJlci5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgMCwgeyB2YWx1ZSwgc3Vic2NyaWJlciB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgICAgIHN1YnNjcmliZXIuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaEVycm9yLCAwLCB7IGVyciwgc3Vic2NyaWJlciB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbihudWxsLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2NhcGUgdGhlIHByb21pc2UgdHJhcCwgdGhyb3cgdW5oYW5kbGVkIGVycm9yc1xuICAgICAgICAgICAgcm9vdC5zZXRUaW1lb3V0KCgpID0+IHsgdGhyb3cgZXJyOyB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaW50ZXJmYWNlIERpc3BhdGNoTmV4dEFyZzxUPiB7XG4gIHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD47XG4gIHZhbHVlOiBUO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hOZXh0PFQ+KGFyZzogRGlzcGF0Y2hOZXh0QXJnPFQ+KSB7XG4gIGNvbnN0IHsgdmFsdWUsIHN1YnNjcmliZXIgfSA9IGFyZztcbiAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICB9XG59XG5cbmludGVyZmFjZSBEaXNwYXRjaEVycm9yQXJnPFQ+IHtcbiAgc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPjtcbiAgZXJyOiBhbnk7XG59XG5mdW5jdGlvbiBkaXNwYXRjaEVycm9yPFQ+KGFyZzogRGlzcGF0Y2hFcnJvckFyZzxUPikge1xuICBjb25zdCB7IGVyciwgc3Vic2NyaWJlciB9ID0gYXJnO1xuICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29ic2VydmFibGUvUHJvbWlzZU9ic2VydmFibGUudHMiLCJpbXBvcnQgeyByb290IH0gZnJvbSAnLi4vLi4vdXRpbC9yb290JztcbmltcG9ydCB7IHRyeUNhdGNoIH0gZnJvbSAnLi4vLi4vdXRpbC90cnlDYXRjaCc7XG5pbXBvcnQgeyBlcnJvck9iamVjdCB9IGZyb20gJy4uLy4uL3V0aWwvZXJyb3JPYmplY3QnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uLy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4uLy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBNYXBPcGVyYXRvciB9IGZyb20gJy4uLy4uL29wZXJhdG9yL21hcCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWpheFJlcXVlc3Qge1xuICB1cmw/OiBzdHJpbmc7XG4gIGJvZHk/OiBhbnk7XG4gIHVzZXI/OiBzdHJpbmc7XG4gIGFzeW5jPzogYm9vbGVhbjtcbiAgbWV0aG9kPzogc3RyaW5nO1xuICBoZWFkZXJzPzogT2JqZWN0O1xuICB0aW1lb3V0PzogbnVtYmVyO1xuICBwYXNzd29yZD86IHN0cmluZztcbiAgaGFzQ29udGVudD86IGJvb2xlYW47XG4gIGNyb3NzRG9tYWluPzogYm9vbGVhbjtcbiAgd2l0aENyZWRlbnRpYWxzPzogYm9vbGVhbjtcbiAgY3JlYXRlWEhSPzogKCkgPT4gWE1MSHR0cFJlcXVlc3Q7XG4gIHByb2dyZXNzU3Vic2NyaWJlcj86IFN1YnNjcmliZXI8YW55PjtcbiAgcmVzcG9uc2VUeXBlPzogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBnZXRDT1JTUmVxdWVzdCh0aGlzOiBBamF4UmVxdWVzdCk6IFhNTEh0dHBSZXF1ZXN0IHtcbiAgaWYgKHJvb3QuWE1MSHR0cFJlcXVlc3QpIHtcbiAgICByZXR1cm4gbmV3IHJvb3QuWE1MSHR0cFJlcXVlc3QoKTtcbiAgfSBlbHNlIGlmICghIXJvb3QuWERvbWFpblJlcXVlc3QpIHtcbiAgICByZXR1cm4gbmV3IHJvb3QuWERvbWFpblJlcXVlc3QoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NPUlMgaXMgbm90IHN1cHBvcnRlZCBieSB5b3VyIGJyb3dzZXInKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRYTUxIdHRwUmVxdWVzdCgpOiBYTUxIdHRwUmVxdWVzdCB7XG4gIGlmIChyb290LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgcmV0dXJuIG5ldyByb290LlhNTEh0dHBSZXF1ZXN0KCk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHByb2dJZDogc3RyaW5nO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwcm9nSWRzID0gWydNc3htbDIuWE1MSFRUUCcsICdNaWNyb3NvZnQuWE1MSFRUUCcsICdNc3htbDIuWE1MSFRUUC40LjAnXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcHJvZ0lkID0gcHJvZ0lkc1tpXTtcbiAgICAgICAgICBpZiAobmV3IHJvb3QuQWN0aXZlWE9iamVjdChwcm9nSWQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvL3N1cHByZXNzIGV4Y2VwdGlvbnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyByb290LkFjdGl2ZVhPYmplY3QocHJvZ0lkKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1hNTEh0dHBSZXF1ZXN0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgeW91ciBicm93c2VyJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWpheENyZWF0aW9uTWV0aG9kIHtcbiAgKHVybE9yUmVxdWVzdDogc3RyaW5nIHwgQWpheFJlcXVlc3QpOiBPYnNlcnZhYmxlPEFqYXhSZXNwb25zZT47XG4gIGdldCh1cmw6IHN0cmluZywgaGVhZGVycz86IE9iamVjdCk6IE9ic2VydmFibGU8QWpheFJlc3BvbnNlPjtcbiAgcG9zdCh1cmw6IHN0cmluZywgYm9keT86IGFueSwgaGVhZGVycz86IE9iamVjdCk6IE9ic2VydmFibGU8QWpheFJlc3BvbnNlPjtcbiAgcHV0KHVybDogc3RyaW5nLCBib2R5PzogYW55LCBoZWFkZXJzPzogT2JqZWN0KTogT2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U+O1xuICBwYXRjaCh1cmw6IHN0cmluZywgYm9keT86IGFueSwgaGVhZGVycz86IE9iamVjdCk6IE9ic2VydmFibGU8QWpheFJlc3BvbnNlPjtcbiAgZGVsZXRlKHVybDogc3RyaW5nLCBoZWFkZXJzPzogT2JqZWN0KTogT2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U+O1xuICBnZXRKU09OPFQ+KHVybDogc3RyaW5nLCBoZWFkZXJzPzogT2JqZWN0KTogT2JzZXJ2YWJsZTxUPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFqYXhHZXQodXJsOiBzdHJpbmcsIGhlYWRlcnM6IE9iamVjdCA9IG51bGwpIHtcbiAgcmV0dXJuIG5ldyBBamF4T2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U+KHsgbWV0aG9kOiAnR0VUJywgdXJsLCBoZWFkZXJzIH0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFqYXhQb3N0KHVybDogc3RyaW5nLCBib2R5PzogYW55LCBoZWFkZXJzPzogT2JqZWN0KTogT2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U+IHtcbiAgcmV0dXJuIG5ldyBBamF4T2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U+KHsgbWV0aG9kOiAnUE9TVCcsIHVybCwgYm9keSwgaGVhZGVycyB9KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBhamF4RGVsZXRlKHVybDogc3RyaW5nLCBoZWFkZXJzPzogT2JqZWN0KTogT2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U+IHtcbiAgcmV0dXJuIG5ldyBBamF4T2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U+KHsgbWV0aG9kOiAnREVMRVRFJywgdXJsLCBoZWFkZXJzIH0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGFqYXhQdXQodXJsOiBzdHJpbmcsIGJvZHk/OiBhbnksIGhlYWRlcnM/OiBPYmplY3QpOiBPYnNlcnZhYmxlPEFqYXhSZXNwb25zZT4ge1xuICByZXR1cm4gbmV3IEFqYXhPYnNlcnZhYmxlPEFqYXhSZXNwb25zZT4oeyBtZXRob2Q6ICdQVVQnLCB1cmwsIGJvZHksIGhlYWRlcnMgfSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYWpheFBhdGNoKHVybDogc3RyaW5nLCBib2R5PzogYW55LCBoZWFkZXJzPzogT2JqZWN0KTogT2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U+IHtcbiAgcmV0dXJuIG5ldyBBamF4T2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U+KHsgbWV0aG9kOiAnUEFUQ0gnLCB1cmwsIGJvZHksIGhlYWRlcnMgfSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYWpheEdldEpTT048VD4odXJsOiBzdHJpbmcsIGhlYWRlcnM/OiBPYmplY3QpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIG5ldyBBamF4T2JzZXJ2YWJsZTxBamF4UmVzcG9uc2U+KHsgbWV0aG9kOiAnR0VUJywgdXJsLCByZXNwb25zZVR5cGU6ICdqc29uJywgaGVhZGVycyB9KVxuICAgIC5saWZ0PFQ+KG5ldyBNYXBPcGVyYXRvcjxBamF4UmVzcG9uc2UsIFQ+KCh4OiBBamF4UmVzcG9uc2UsIGluZGV4OiBudW1iZXIpOiBUID0+IHgucmVzcG9uc2UsIG51bGwpKTtcbn07XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG5leHBvcnQgY2xhc3MgQWpheE9ic2VydmFibGU8VD4gZXh0ZW5kcyBPYnNlcnZhYmxlPFQ+IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb2JzZXJ2YWJsZSBmb3IgYW4gQWpheCByZXF1ZXN0IHdpdGggZWl0aGVyIGEgcmVxdWVzdCBvYmplY3Qgd2l0aFxuICAgKiB1cmwsIGhlYWRlcnMsIGV0YyBvciBhIHN0cmluZyBmb3IgYSBVUkwuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIHNvdXJjZSA9IFJ4Lk9ic2VydmFibGUuYWpheCgnL3Byb2R1Y3RzJyk7XG4gICAqIHNvdXJjZSA9IFJ4Lk9ic2VydmFibGUuYWpheCh7IHVybDogJ3Byb2R1Y3RzJywgbWV0aG9kOiAnR0VUJyB9KTtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSByZXF1ZXN0IENhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICogICBBIHN0cmluZyBvZiB0aGUgVVJMIHRvIG1ha2UgdGhlIEFqYXggY2FsbC5cbiAgICogICBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXNcbiAgICogICAtIHVybDogVVJMIG9mIHRoZSByZXF1ZXN0XG4gICAqICAgLSBib2R5OiBUaGUgYm9keSBvZiB0aGUgcmVxdWVzdFxuICAgKiAgIC0gbWV0aG9kOiBNZXRob2Qgb2YgdGhlIHJlcXVlc3QsIHN1Y2ggYXMgR0VULCBQT1NULCBQVVQsIFBBVENILCBERUxFVEVcbiAgICogICAtIGFzeW5jOiBXaGV0aGVyIHRoZSByZXF1ZXN0IGlzIGFzeW5jXG4gICAqICAgLSBoZWFkZXJzOiBPcHRpb25hbCBoZWFkZXJzXG4gICAqICAgLSBjcm9zc0RvbWFpbjogdHJ1ZSBpZiBhIGNyb3NzIGRvbWFpbiByZXF1ZXN0LCBlbHNlIGZhbHNlXG4gICAqICAgLSBjcmVhdGVYSFI6IGEgZnVuY3Rpb24gdG8gb3ZlcnJpZGUgaWYgeW91IG5lZWQgdG8gdXNlIGFuIGFsdGVybmF0ZVxuICAgKiAgIFhNTEh0dHBSZXF1ZXN0IGltcGxlbWVudGF0aW9uLlxuICAgKiAgIC0gcmVzdWx0U2VsZWN0b3I6IGEgZnVuY3Rpb24gdG8gdXNlIHRvIGFsdGVyIHRoZSBvdXRwdXQgdmFsdWUgdHlwZSBvZlxuICAgKiAgIHRoZSBPYnNlcnZhYmxlLiBHZXRzIHtAbGluayBBamF4UmVzcG9uc2V9IGFzIGFuIGFyZ3VtZW50LlxuICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGNvbnRhaW5pbmcgdGhlIFhNTEh0dHBSZXF1ZXN0LlxuICAgKiBAc3RhdGljIHRydWVcbiAgICogQG5hbWUgYWpheFxuICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAqL1xuICBzdGF0aWMgY3JlYXRlOiBBamF4Q3JlYXRpb25NZXRob2QgPSAoKCkgPT4ge1xuICAgIGNvbnN0IGNyZWF0ZTogYW55ID0gKHVybE9yUmVxdWVzdDogc3RyaW5nIHwgQWpheFJlcXVlc3QpID0+IHtcbiAgICAgIHJldHVybiBuZXcgQWpheE9ic2VydmFibGUodXJsT3JSZXF1ZXN0KTtcbiAgICB9O1xuXG4gICAgY3JlYXRlLmdldCA9IGFqYXhHZXQ7XG4gICAgY3JlYXRlLnBvc3QgPSBhamF4UG9zdDtcbiAgICBjcmVhdGUuZGVsZXRlID0gYWpheERlbGV0ZTtcbiAgICBjcmVhdGUucHV0ID0gYWpheFB1dDtcbiAgICBjcmVhdGUucGF0Y2ggPSBhamF4UGF0Y2g7XG4gICAgY3JlYXRlLmdldEpTT04gPSBhamF4R2V0SlNPTjtcblxuICAgIHJldHVybiA8QWpheENyZWF0aW9uTWV0aG9kPmNyZWF0ZTtcbiAgfSkoKTtcblxuICBwcml2YXRlIHJlcXVlc3Q6IEFqYXhSZXF1ZXN0O1xuXG4gIGNvbnN0cnVjdG9yKHVybE9yUmVxdWVzdDogc3RyaW5nIHwgQWpheFJlcXVlc3QpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29uc3QgcmVxdWVzdDogQWpheFJlcXVlc3QgPSB7XG4gICAgICBhc3luYzogdHJ1ZSxcbiAgICAgIGNyZWF0ZVhIUjogZnVuY3Rpb24odGhpczogQWpheFJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Jvc3NEb21haW4gPyBnZXRDT1JTUmVxdWVzdC5jYWxsKHRoaXMpIDogZ2V0WE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIH0sXG4gICAgICBjcm9zc0RvbWFpbjogZmFsc2UsXG4gICAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgICAgaGVhZGVyczoge30sXG4gICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbicsXG4gICAgICB0aW1lb3V0OiAwXG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgdXJsT3JSZXF1ZXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgcmVxdWVzdC51cmwgPSB1cmxPclJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBpbiB1cmxPclJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHVybE9yUmVxdWVzdC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgIHJlcXVlc3RbcHJvcF0gPSB1cmxPclJlcXVlc3RbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICB9XG5cbiAgcHJvdGVjdGVkIF9zdWJzY3JpYmUoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPik6IFRlYXJkb3duTG9naWMge1xuICAgIHJldHVybiBuZXcgQWpheFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5yZXF1ZXN0KTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuZXhwb3J0IGNsYXNzIEFqYXhTdWJzY3JpYmVyPFQ+IGV4dGVuZHMgU3Vic2NyaWJlcjxFdmVudD4ge1xuICBwcml2YXRlIHhocjogWE1MSHR0cFJlcXVlc3Q7XG4gIHByaXZhdGUgZG9uZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFQ+LCBwdWJsaWMgcmVxdWVzdDogQWpheFJlcXVlc3QpIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG5cbiAgICBjb25zdCBoZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzID0gcmVxdWVzdC5oZWFkZXJzIHx8IHt9O1xuXG4gICAgLy8gZm9yY2UgQ09SUyBpZiByZXF1ZXN0ZWRcbiAgICBpZiAoIXJlcXVlc3QuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbJ1gtUmVxdWVzdGVkLVdpdGgnXSkge1xuICAgICAgaGVhZGVyc1snWC1SZXF1ZXN0ZWQtV2l0aCddID0gJ1hNTEh0dHBSZXF1ZXN0JztcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgY29udGVudCB0eXBlIGlzIHNldFxuICAgIGlmICghKCdDb250ZW50LVR5cGUnIGluIGhlYWRlcnMpICYmICEocm9vdC5Gb3JtRGF0YSAmJiByZXF1ZXN0LmJvZHkgaW5zdGFuY2VvZiByb290LkZvcm1EYXRhKSAmJiB0eXBlb2YgcmVxdWVzdC5ib2R5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkOyBjaGFyc2V0PVVURi04JztcbiAgICB9XG5cbiAgICAvLyBwcm9wZXJseSBzZXJpYWxpemUgYm9keVxuICAgIHJlcXVlc3QuYm9keSA9IHRoaXMuc2VyaWFsaXplQm9keShyZXF1ZXN0LmJvZHksIHJlcXVlc3QuaGVhZGVyc1snQ29udGVudC1UeXBlJ10pO1xuXG4gICAgdGhpcy5zZW5kKCk7XG4gIH1cblxuICBuZXh0KGU6IEV2ZW50KTogdm9pZCB7XG4gICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICBjb25zdCB7IHhociwgcmVxdWVzdCwgZGVzdGluYXRpb24gfSA9IHRoaXM7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBuZXcgQWpheFJlc3BvbnNlKGUsIHhociwgcmVxdWVzdCk7XG5cbiAgICBkZXN0aW5hdGlvbi5uZXh0KHJlc3BvbnNlKTtcbiAgfVxuXG4gIHByaXZhdGUgc2VuZCgpOiBYTUxIdHRwUmVxdWVzdCB7XG4gICAgY29uc3Qge1xuICAgICAgcmVxdWVzdCxcbiAgICAgIHJlcXVlc3Q6IHsgdXNlciwgbWV0aG9kLCB1cmwsIGFzeW5jLCBwYXNzd29yZCwgaGVhZGVycywgYm9keSB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgY3JlYXRlWEhSID0gcmVxdWVzdC5jcmVhdGVYSFI7XG4gICAgY29uc3QgeGhyOiBYTUxIdHRwUmVxdWVzdCA9IHRyeUNhdGNoKGNyZWF0ZVhIUikuY2FsbChyZXF1ZXN0KTtcblxuICAgIGlmICg8YW55PnhociA9PT0gZXJyb3JPYmplY3QpIHtcbiAgICAgIHRoaXMuZXJyb3IoZXJyb3JPYmplY3QuZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueGhyID0geGhyO1xuXG4gICAgICAvLyBzZXQgdXAgdGhlIGV2ZW50cyBiZWZvcmUgb3BlbiBYSFJcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9Vc2luZ19YTUxIdHRwUmVxdWVzdFxuICAgICAgLy8gWW91IG5lZWQgdG8gYWRkIHRoZSBldmVudCBsaXN0ZW5lcnMgYmVmb3JlIGNhbGxpbmcgb3BlbigpIG9uIHRoZSByZXF1ZXN0LlxuICAgICAgLy8gT3RoZXJ3aXNlIHRoZSBwcm9ncmVzcyBldmVudHMgd2lsbCBub3QgZmlyZS5cbiAgICAgIHRoaXMuc2V0dXBFdmVudHMoeGhyLCByZXF1ZXN0KTtcbiAgICAgIC8vIG9wZW4gWEhSXG4gICAgICBsZXQgcmVzdWx0OiBhbnk7XG4gICAgICBpZiAodXNlcikge1xuICAgICAgICByZXN1bHQgPSB0cnlDYXRjaCh4aHIub3BlbikuY2FsbCh4aHIsIG1ldGhvZCwgdXJsLCBhc3luYywgdXNlciwgcGFzc3dvcmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdHJ5Q2F0Y2goeGhyLm9wZW4pLmNhbGwoeGhyLCBtZXRob2QsIHVybCwgYXN5bmMpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdCkge1xuICAgICAgICB0aGlzLmVycm9yKGVycm9yT2JqZWN0LmUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gdGltZW91dCwgcmVzcG9uc2VUeXBlIGFuZCB3aXRoQ3JlZGVudGlhbHMgY2FuIGJlIHNldCBvbmNlIHRoZSBYSFIgaXMgb3BlblxuICAgICAgeGhyLnRpbWVvdXQgPSByZXF1ZXN0LnRpbWVvdXQ7XG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gcmVxdWVzdC5yZXNwb25zZVR5cGU7XG5cbiAgICAgIGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhcmVxdWVzdC53aXRoQ3JlZGVudGlhbHM7XG4gICAgICB9XG5cbiAgICAgIC8vIHNldCBoZWFkZXJzXG4gICAgICB0aGlzLnNldEhlYWRlcnMoeGhyLCBoZWFkZXJzKTtcblxuICAgICAgLy8gZmluYWxseSBzZW5kIHRoZSByZXF1ZXN0XG4gICAgICByZXN1bHQgPSBib2R5ID8gdHJ5Q2F0Y2goeGhyLnNlbmQpLmNhbGwoeGhyLCBib2R5KSA6IHRyeUNhdGNoKHhoci5zZW5kKS5jYWxsKHhocik7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdCkge1xuICAgICAgICB0aGlzLmVycm9yKGVycm9yT2JqZWN0LmUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geGhyO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXJpYWxpemVCb2R5KGJvZHk6IGFueSwgY29udGVudFR5cGU/OiBzdHJpbmcpIHtcbiAgICBpZiAoIWJvZHkgfHwgdHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gYm9keTtcbiAgICB9IGVsc2UgaWYgKHJvb3QuRm9ybURhdGEgJiYgYm9keSBpbnN0YW5jZW9mIHJvb3QuRm9ybURhdGEpIHtcbiAgICAgIHJldHVybiBib2R5O1xuICAgIH1cblxuICAgIGlmIChjb250ZW50VHlwZSkge1xuICAgICAgY29uc3Qgc3BsaXRJbmRleCA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJzsnKTtcbiAgICAgIGlmIChzcGxpdEluZGV4ICE9PSAtMSkge1xuICAgICAgICBjb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLnN1YnN0cmluZygwLCBzcGxpdEluZGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKGNvbnRlbnRUeXBlKSB7XG4gICAgICBjYXNlICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOlxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYm9keSkubWFwKGtleSA9PiBgJHtlbmNvZGVVUkkoa2V5KX09JHtlbmNvZGVVUkkoYm9keVtrZXldKX1gKS5qb2luKCcmJyk7XG4gICAgICBjYXNlICdhcHBsaWNhdGlvbi9qc29uJzpcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRIZWFkZXJzKHhocjogWE1MSHR0cFJlcXVlc3QsIGhlYWRlcnM6IE9iamVjdCkge1xuICAgIGZvciAobGV0IGtleSBpbiBoZWFkZXJzKSB7XG4gICAgICBpZiAoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNldHVwRXZlbnRzKHhocjogWE1MSHR0cFJlcXVlc3QsIHJlcXVlc3Q6IEFqYXhSZXF1ZXN0KSB7XG4gICAgY29uc3QgcHJvZ3Jlc3NTdWJzY3JpYmVyID0gcmVxdWVzdC5wcm9ncmVzc1N1YnNjcmliZXI7XG5cbiAgICBmdW5jdGlvbiB4aHJUaW1lb3V0KHRoaXM6IFhNTEh0dHBSZXF1ZXN0LCBlOiBQcm9ncmVzc0V2ZW50KSB7XG4gICAgICBjb25zdCB7c3Vic2NyaWJlciwgcHJvZ3Jlc3NTdWJzY3JpYmVyLCByZXF1ZXN0IH0gPSAoPGFueT54aHJUaW1lb3V0KTtcbiAgICAgIGlmIChwcm9ncmVzc1N1YnNjcmliZXIpIHtcbiAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyLmVycm9yKGUpO1xuICAgICAgfVxuICAgICAgc3Vic2NyaWJlci5lcnJvcihuZXcgQWpheFRpbWVvdXRFcnJvcih0aGlzLCByZXF1ZXN0KSk7IC8vVE9ETzogTWFrZSBiZXR0ZXJlci5cbiAgICB9O1xuICAgIHhoci5vbnRpbWVvdXQgPSB4aHJUaW1lb3V0O1xuICAgICg8YW55PnhoclRpbWVvdXQpLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICg8YW55PnhoclRpbWVvdXQpLnN1YnNjcmliZXIgPSB0aGlzO1xuICAgICg8YW55PnhoclRpbWVvdXQpLnByb2dyZXNzU3Vic2NyaWJlciA9IHByb2dyZXNzU3Vic2NyaWJlcjtcbiAgICBpZiAoeGhyLnVwbG9hZCAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgIGlmIChwcm9ncmVzc1N1YnNjcmliZXIpIHtcbiAgICAgICAgbGV0IHhoclByb2dyZXNzOiAoZTogUHJvZ3Jlc3NFdmVudCkgPT4gdm9pZDtcbiAgICAgICAgeGhyUHJvZ3Jlc3MgPSBmdW5jdGlvbihlOiBQcm9ncmVzc0V2ZW50KSB7XG4gICAgICAgICAgY29uc3QgeyBwcm9ncmVzc1N1YnNjcmliZXIgfSA9ICg8YW55PnhoclByb2dyZXNzKTtcbiAgICAgICAgICBwcm9ncmVzc1N1YnNjcmliZXIubmV4dChlKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJvb3QuWERvbWFpblJlcXVlc3QpIHtcbiAgICAgICAgICB4aHIub25wcm9ncmVzcyA9IHhoclByb2dyZXNzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci51cGxvYWQub25wcm9ncmVzcyA9IHhoclByb2dyZXNzO1xuICAgICAgICB9XG4gICAgICAgICg8YW55PnhoclByb2dyZXNzKS5wcm9ncmVzc1N1YnNjcmliZXIgPSBwcm9ncmVzc1N1YnNjcmliZXI7XG4gICAgICB9XG4gICAgICBsZXQgeGhyRXJyb3I6IChlOiBFcnJvckV2ZW50KSA9PiB2b2lkO1xuICAgICAgeGhyRXJyb3IgPSBmdW5jdGlvbih0aGlzOiBYTUxIdHRwUmVxdWVzdCwgZTogRXJyb3JFdmVudCkge1xuICAgICAgICBjb25zdCB7IHByb2dyZXNzU3Vic2NyaWJlciwgc3Vic2NyaWJlciwgcmVxdWVzdCB9ID0gKDxhbnk+eGhyRXJyb3IpO1xuICAgICAgICBpZiAocHJvZ3Jlc3NTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgcHJvZ3Jlc3NTdWJzY3JpYmVyLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIuZXJyb3IobmV3IEFqYXhFcnJvcignYWpheCBlcnJvcicsIHRoaXMsIHJlcXVlc3QpKTtcbiAgICAgIH07XG4gICAgICB4aHIub25lcnJvciA9IHhockVycm9yO1xuICAgICAgKDxhbnk+eGhyRXJyb3IpLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgKDxhbnk+eGhyRXJyb3IpLnN1YnNjcmliZXIgPSB0aGlzO1xuICAgICAgKDxhbnk+eGhyRXJyb3IpLnByb2dyZXNzU3Vic2NyaWJlciA9IHByb2dyZXNzU3Vic2NyaWJlcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB4aHJSZWFkeVN0YXRlQ2hhbmdlKHRoaXM6IFhNTEh0dHBSZXF1ZXN0LCBlOiBQcm9ncmVzc0V2ZW50KSB7XG4gICAgICBjb25zdCB7IHN1YnNjcmliZXIsIHByb2dyZXNzU3Vic2NyaWJlciwgcmVxdWVzdCB9ID0gKDxhbnk+eGhyUmVhZHlTdGF0ZUNoYW5nZSk7XG4gICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgIC8vIG5vcm1hbGl6ZSBJRTkgYnVnIChodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwKVxuICAgICAgICBsZXQgc3RhdHVzOiBudW1iZXIgPSB0aGlzLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHRoaXMuc3RhdHVzO1xuICAgICAgICBsZXQgcmVzcG9uc2U6IGFueSA9ICh0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gIChcbiAgICAgICAgICB0aGlzLnJlc3BvbnNlIHx8IHRoaXMucmVzcG9uc2VUZXh0KSA6IHRoaXMucmVzcG9uc2UpO1xuXG4gICAgICAgIC8vIGZpeCBzdGF0dXMgY29kZSB3aGVuIGl0IGlzIDAgKDAgc3RhdHVzIGlzIHVuZG9jdW1lbnRlZCkuXG4gICAgICAgIC8vIE9jY3VycyB3aGVuIGFjY2Vzc2luZyBmaWxlIHJlc291cmNlcyBvciBvbiBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXG4gICAgICAgIC8vIHdoaWxlIHJldHJpZXZpbmcgZmlsZXMgZnJvbSBhcHBsaWNhdGlvbiBjYWNoZS5cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgIHN0YXR1cyA9IHJlc3BvbnNlID8gMjAwIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgyMDAgPD0gc3RhdHVzICYmIHN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgIGlmIChwcm9ncmVzc1N1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHByb2dyZXNzU3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdWJzY3JpYmVyLm5leHQoZSk7XG4gICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwcm9ncmVzc1N1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHByb2dyZXNzU3Vic2NyaWJlci5lcnJvcihlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3Vic2NyaWJlci5lcnJvcihuZXcgQWpheEVycm9yKCdhamF4IGVycm9yICcgKyBzdGF0dXMsIHRoaXMsIHJlcXVlc3QpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHhoclJlYWR5U3RhdGVDaGFuZ2U7XG4gICAgKDxhbnk+eGhyUmVhZHlTdGF0ZUNoYW5nZSkuc3Vic2NyaWJlciA9IHRoaXM7XG4gICAgKDxhbnk+eGhyUmVhZHlTdGF0ZUNoYW5nZSkucHJvZ3Jlc3NTdWJzY3JpYmVyID0gcHJvZ3Jlc3NTdWJzY3JpYmVyO1xuICAgICg8YW55PnhoclJlYWR5U3RhdGVDaGFuZ2UpLnJlcXVlc3QgPSByZXF1ZXN0O1xuICB9XG5cbiAgdW5zdWJzY3JpYmUoKSB7XG4gICAgY29uc3QgeyBkb25lLCB4aHIgfSA9IHRoaXM7XG4gICAgaWYgKCFkb25lICYmIHhociAmJiB4aHIucmVhZHlTdGF0ZSAhPT0gNCAmJiB0eXBlb2YgeGhyLmFib3J0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB4aHIuYWJvcnQoKTtcbiAgICB9XG4gICAgc3VwZXIudW5zdWJzY3JpYmUoKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgbm9ybWFsaXplZCBBSkFYIHJlc3BvbnNlLlxuICpcbiAqIEBzZWUge0BsaW5rIGFqYXh9XG4gKlxuICogQGNsYXNzIEFqYXhSZXNwb25zZVxuICovXG5leHBvcnQgY2xhc3MgQWpheFJlc3BvbnNlIHtcbiAgLyoqIEB0eXBlIHtudW1iZXJ9IFRoZSBIVFRQIHN0YXR1cyBjb2RlICovXG4gIHN0YXR1czogbnVtYmVyO1xuXG4gIC8qKiBAdHlwZSB7c3RyaW5nfEFycmF5QnVmZmVyfERvY3VtZW50fG9iamVjdHxhbnl9IFRoZSByZXNwb25zZSBkYXRhICovXG4gIHJlc3BvbnNlOiBhbnk7XG5cbiAgLyoqIEB0eXBlIHtzdHJpbmd9IFRoZSByYXcgcmVzcG9uc2VUZXh0ICovXG4gIHJlc3BvbnNlVGV4dDogc3RyaW5nO1xuXG4gIC8qKiBAdHlwZSB7c3RyaW5nfSBUaGUgcmVzcG9uc2VUeXBlIChlLmcuICdqc29uJywgJ2FycmF5YnVmZmVyJywgb3IgJ3htbCcpICovXG4gIHJlc3BvbnNlVHlwZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBvcmlnaW5hbEV2ZW50OiBFdmVudCwgcHVibGljIHhocjogWE1MSHR0cFJlcXVlc3QsIHB1YmxpYyByZXF1ZXN0OiBBamF4UmVxdWVzdCkge1xuICAgIHRoaXMuc3RhdHVzID0geGhyLnN0YXR1cztcbiAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IHhoci5yZXNwb25zZVR5cGUgfHwgcmVxdWVzdC5yZXNwb25zZVR5cGU7XG5cbiAgICBzd2l0Y2ggKHRoaXMucmVzcG9uc2VUeXBlKSB7XG4gICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgaWYgKCdyZXNwb25zZScgaW4geGhyKSB7XG4gICAgICAgICAgLy9JRSBkb2VzIG5vdCBzdXBwb3J0IGpzb24gYXMgcmVzcG9uc2VUeXBlLCBwYXJzZSBpdCBpbnRlcm5hbGx5XG4gICAgICAgICAgdGhpcy5yZXNwb25zZSA9IHhoci5yZXNwb25zZVR5cGUgPyB4aHIucmVzcG9uc2UgOiBKU09OLnBhcnNlKHhoci5yZXNwb25zZSB8fCB4aHIucmVzcG9uc2VUZXh0IHx8ICdudWxsJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZXNwb25zZSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCB8fCAnbnVsbCcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAneG1sJzpcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHhoci5yZXNwb25zZVhNTDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0JzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMucmVzcG9uc2UgPSAoJ3Jlc3BvbnNlJyBpbiB4aHIpID8geGhyLnJlc3BvbnNlIDogeGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQSBub3JtYWxpemVkIEFKQVggZXJyb3IuXG4gKlxuICogQHNlZSB7QGxpbmsgYWpheH1cbiAqXG4gKiBAY2xhc3MgQWpheEVycm9yXG4gKi9cbmV4cG9ydCBjbGFzcyBBamF4RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKiBAdHlwZSB7WE1MSHR0cFJlcXVlc3R9IFRoZSBYSFIgaW5zdGFuY2UgYXNzb2NpYXRlZCB3aXRoIHRoZSBlcnJvciAqL1xuICB4aHI6IFhNTEh0dHBSZXF1ZXN0O1xuXG4gIC8qKiBAdHlwZSB7QWpheFJlcXVlc3R9IFRoZSBBamF4UmVxdWVzdCBhc3NvY2lhdGVkIHdpdGggdGhlIGVycm9yICovXG4gIHJlcXVlc3Q6IEFqYXhSZXF1ZXN0O1xuXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSBUaGUgSFRUUCBzdGF0dXMgY29kZSAqL1xuICBzdGF0dXM6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcsIHhocjogWE1MSHR0cFJlcXVlc3QsIHJlcXVlc3Q6IEFqYXhSZXF1ZXN0KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnhociA9IHhocjtcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgIHRoaXMuc3RhdHVzID0geGhyLnN0YXR1cztcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUge0BsaW5rIGFqYXh9XG4gKlxuICogQGNsYXNzIEFqYXhUaW1lb3V0RXJyb3JcbiAqL1xuZXhwb3J0IGNsYXNzIEFqYXhUaW1lb3V0RXJyb3IgZXh0ZW5kcyBBamF4RXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih4aHI6IFhNTEh0dHBSZXF1ZXN0LCByZXF1ZXN0OiBBamF4UmVxdWVzdCkge1xuICAgIHN1cGVyKCdhamF4IHRpbWVvdXQnLCB4aHIsIHJlcXVlc3QpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29ic2VydmFibGUvZG9tL0FqYXhPYnNlcnZhYmxlLnRzIiwiaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyB0cnlDYXRjaCB9IGZyb20gJy4uL3V0aWwvdHJ5Q2F0Y2gnO1xuaW1wb3J0IHsgZXJyb3JPYmplY3QgfSBmcm9tICcuLi91dGlsL2Vycm9yT2JqZWN0JztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFRlYXJkb3duTG9naWMgfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0aW5jdFVudGlsQ2hhbmdlZDxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBjb21wYXJlPzogKHg6IFQsIHk6IFQpID0+IGJvb2xlYW4pOiBPYnNlcnZhYmxlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RpbmN0VW50aWxDaGFuZ2VkPFQsIEs+KHRoaXM6IE9ic2VydmFibGU8VD4sIGNvbXBhcmU6ICh4OiBLLCB5OiBLKSA9PiBib29sZWFuLCBrZXlTZWxlY3RvcjogKHg6IFQpID0+IEspOiBPYnNlcnZhYmxlPFQ+O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cblxuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBhcmUgZGlzdGluY3QgYnkgY29tcGFyaXNvbiBmcm9tIHRoZSBwcmV2aW91cyBpdGVtLlxuICpcbiAqIElmIGEgY29tcGFyYXRvciBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdGhlbiBpdCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBpdGVtIHRvIHRlc3QgZm9yIHdoZXRoZXIgb3Igbm90IHRoYXQgdmFsdWUgc2hvdWxkIGJlIGVtaXR0ZWQuXG4gKlxuICogSWYgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIGlzIG5vdCBwcm92aWRlZCwgYW4gZXF1YWxpdHkgY2hlY2sgaXMgdXNlZCBieSBkZWZhdWx0LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkEgc2ltcGxlIGV4YW1wbGUgd2l0aCBudW1iZXJzPC9jYXB0aW9uPlxuICogT2JzZXJ2YWJsZS5vZigxLCAxLCAyLCAyLCAyLCAxLCAxLCAyLCAzLCAzLCA0KVxuICogICAuZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICogICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpOyAvLyAxLCAyLCAxLCAyLCAzLCA0XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QW4gZXhhbXBsZSB1c2luZyBhIGNvbXBhcmUgZnVuY3Rpb248L2NhcHRpb24+XG4gKiBpbnRlcmZhY2UgUGVyc29uIHtcbiAqICAgIGFnZTogbnVtYmVyLFxuICogICAgbmFtZTogc3RyaW5nXG4gKiB9XG4gKlxuICogT2JzZXJ2YWJsZS5vZjxQZXJzb24+KFxuICogICAgIHsgYWdlOiA0LCBuYW1lOiAnRm9vJ30sXG4gKiAgICAgeyBhZ2U6IDcsIG5hbWU6ICdCYXInfSxcbiAqICAgICB7IGFnZTogNSwgbmFtZTogJ0Zvbyd9KVxuICogICAgIHsgYWdlOiA2LCBuYW1lOiAnRm9vJ30pXG4gKiAgICAgLmRpc3RpbmN0VW50aWxDaGFuZ2VkKChwOiBQZXJzb24sIHE6IFBlcnNvbikgPT4gcC5uYW1lID09PSBxLm5hbWUpXG4gKiAgICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBkaXNwbGF5czpcbiAqIC8vIHsgYWdlOiA0LCBuYW1lOiAnRm9vJyB9XG4gKiAvLyB7IGFnZTogNywgbmFtZTogJ0JhcicgfVxuICogLy8geyBhZ2U6IDUsIG5hbWU6ICdGb28nIH1cbiAqXG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdH1cbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjb21wYXJlXSBPcHRpb25hbCBjb21wYXJpc29uIGZ1bmN0aW9uIGNhbGxlZCB0byB0ZXN0IGlmIGFuIGl0ZW0gaXMgZGlzdGluY3QgZnJvbSB0aGUgcHJldmlvdXMgaXRlbSBpbiB0aGUgc291cmNlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggZGlzdGluY3QgdmFsdWVzLlxuICogQG1ldGhvZCBkaXN0aW5jdFVudGlsQ2hhbmdlZFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RpbmN0VW50aWxDaGFuZ2VkPFQsIEs+KHRoaXM6IE9ic2VydmFibGU8VD4sIGNvbXBhcmU/OiAoeDogSywgeTogSykgPT4gYm9vbGVhbiwga2V5U2VsZWN0b3I/OiAoeDogVCkgPT4gSyk6IE9ic2VydmFibGU8VD4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEaXN0aW5jdFVudGlsQ2hhbmdlZE9wZXJhdG9yPFQsIEs+KGNvbXBhcmUsIGtleVNlbGVjdG9yKSk7XG59XG5cbmNsYXNzIERpc3RpbmN0VW50aWxDaGFuZ2VkT3BlcmF0b3I8VCwgSz4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29tcGFyZTogKHg6IEssIHk6IEspID0+IGJvb2xlYW4sXG4gICAgICAgICAgICAgIHByaXZhdGUga2V5U2VsZWN0b3I6ICh4OiBUKSA9PiBLKSB7XG4gIH1cblxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4sIHNvdXJjZTogYW55KTogVGVhcmRvd25Mb2dpYyB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERpc3RpbmN0VW50aWxDaGFuZ2VkU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmNvbXBhcmUsIHRoaXMua2V5U2VsZWN0b3IpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgRGlzdGluY3RVbnRpbENoYW5nZWRTdWJzY3JpYmVyPFQsIEs+IGV4dGVuZHMgU3Vic2NyaWJlcjxUPiB7XG4gIHByaXZhdGUga2V5OiBLO1xuICBwcml2YXRlIGhhc0tleTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFQ+LFxuICAgICAgICAgICAgICBjb21wYXJlOiAoeDogSywgeTogSykgPT4gYm9vbGVhbixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBrZXlTZWxlY3RvcjogKHg6IFQpID0+IEspIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gICAgaWYgKHR5cGVvZiBjb21wYXJlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmNvbXBhcmUgPSBjb21wYXJlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY29tcGFyZSh4OiBhbnksIHk6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB4ID09PSB5O1xuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHZhbHVlOiBUKTogdm9pZCB7XG5cbiAgICBjb25zdCBrZXlTZWxlY3RvciA9IHRoaXMua2V5U2VsZWN0b3I7XG4gICAgbGV0IGtleTogYW55ID0gdmFsdWU7XG5cbiAgICBpZiAoa2V5U2VsZWN0b3IpIHtcbiAgICAgIGtleSA9IHRyeUNhdGNoKHRoaXMua2V5U2VsZWN0b3IpKHZhbHVlKTtcbiAgICAgIGlmIChrZXkgPT09IGVycm9yT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycm9yT2JqZWN0LmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCByZXN1bHQ6IGFueSA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuaGFzS2V5KSB7XG4gICAgICByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLmNvbXBhcmUpKHRoaXMua2V5LCBrZXkpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyb3JPYmplY3QuZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGFzS2V5ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoQm9vbGVhbihyZXN1bHQpID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9kaXN0aW5jdFVudGlsQ2hhbmdlZC50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlcjxULCBTIGV4dGVuZHMgVD4odGhpczogT2JzZXJ2YWJsZTxUPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWRpY2F0ZTogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiB2YWx1ZSBpcyBTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0FyZz86IGFueSk6IE9ic2VydmFibGU8Uz47XG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZWRpY2F0ZTogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBib29sZWFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzQXJnPzogYW55KTogT2JzZXJ2YWJsZTxUPjtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbi8qKlxuICogRmlsdGVyIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJ5IG9ubHkgZW1pdHRpbmcgdGhvc2UgdGhhdFxuICogc2F0aXNmeSBhIHNwZWNpZmllZCBwcmVkaWNhdGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxpa2VcbiAqIFtBcnJheS5wcm90b3R5cGUuZmlsdGVyKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbHRlciksXG4gKiBpdCBvbmx5IGVtaXRzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIGlmIGl0IHBhc3NlcyBhIGNyaXRlcmlvbiBmdW5jdGlvbi48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9maWx0ZXIucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogU2ltaWxhciB0byB0aGUgd2VsbC1rbm93biBgQXJyYXkucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kLCB0aGlzIG9wZXJhdG9yXG4gKiB0YWtlcyB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIHBhc3NlcyB0aGVtIHRocm91Z2ggYSBgcHJlZGljYXRlYFxuICogZnVuY3Rpb24gYW5kIG9ubHkgZW1pdHMgdGhvc2UgdmFsdWVzIHRoYXQgeWllbGRlZCBgdHJ1ZWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBvbmx5IGNsaWNrIGV2ZW50cyB3aG9zZSB0YXJnZXQgd2FzIGEgRElWIGVsZW1lbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGNsaWNrc09uRGl2cyA9IGNsaWNrcy5maWx0ZXIoZXYgPT4gZXYudGFyZ2V0LnRhZ05hbWUgPT09ICdESVYnKTtcbiAqIGNsaWNrc09uRGl2cy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgZGlzdGluY3R9XG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdFVudGlsQ2hhbmdlZH1cbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkfVxuICogQHNlZSB7QGxpbmsgaWdub3JlRWxlbWVudHN9XG4gKiBAc2VlIHtAbGluayBwYXJ0aXRpb259XG4gKiBAc2VlIHtAbGluayBza2lwfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIpOiBib29sZWFufSBwcmVkaWNhdGUgQSBmdW5jdGlvbiB0aGF0XG4gKiBldmFsdWF0ZXMgZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgaXQgcmV0dXJucyBgdHJ1ZWAsXG4gKiB0aGUgdmFsdWUgaXMgZW1pdHRlZCwgaWYgYGZhbHNlYCB0aGUgdmFsdWUgaXMgbm90IHBhc3NlZCB0byB0aGUgb3V0cHV0XG4gKiBPYnNlcnZhYmxlLiBUaGUgYGluZGV4YCBwYXJhbWV0ZXIgaXMgdGhlIG51bWJlciBgaWAgZm9yIHRoZSBpLXRoIHNvdXJjZVxuICogZW1pc3Npb24gdGhhdCBoYXMgaGFwcGVuZWQgc2luY2UgdGhlIHN1YnNjcmlwdGlvbiwgc3RhcnRpbmcgZnJvbSB0aGUgbnVtYmVyXG4gKiBgMGAuXG4gKiBAcGFyYW0ge2FueX0gW3RoaXNBcmddIEFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIGRldGVybWluZSB0aGUgdmFsdWUgb2YgYHRoaXNgXG4gKiBpbiB0aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIG9mIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgdGhhdCB3ZXJlXG4gKiBhbGxvd2VkIGJ5IHRoZSBgcHJlZGljYXRlYCBmdW5jdGlvbi5cbiAqIEBtZXRob2QgZmlsdGVyXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIHByZWRpY2F0ZTogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBib29sZWFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzQXJnPzogYW55KTogT2JzZXJ2YWJsZTxUPiB7XG4gIHJldHVybiB0aGlzLmxpZnQobmV3IEZpbHRlck9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpc0FyZykpO1xufVxuXG5jbGFzcyBGaWx0ZXJPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwcmVkaWNhdGU6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gYm9vbGVhbixcbiAgICAgICAgICAgICAgcHJpdmF0ZSB0aGlzQXJnPzogYW55KSB7XG4gIH1cblxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4sIHNvdXJjZTogYW55KTogVGVhcmRvd25Mb2dpYyB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEZpbHRlclN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcmVkaWNhdGUsIHRoaXMudGhpc0FyZykpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBGaWx0ZXJTdWJzY3JpYmVyPFQ+IGV4dGVuZHMgU3Vic2NyaWJlcjxUPiB7XG5cbiAgY291bnQ6IG51bWJlciA9IDA7XG5cbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8VD4sXG4gICAgICAgICAgICAgIHByaXZhdGUgcHJlZGljYXRlOiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IGJvb2xlYW4sXG4gICAgICAgICAgICAgIHByaXZhdGUgdGhpc0FyZzogYW55KSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICB9XG5cbiAgLy8gdGhlIHRyeSBjYXRjaCBibG9jayBiZWxvdyBpcyBsZWZ0IHNwZWNpZmljYWxseSBmb3JcbiAgLy8gb3B0aW1pemF0aW9uIGFuZCBwZXJmIHJlYXNvbnMuIGEgdHJ5Q2F0Y2hlciBpcyBub3QgbmVjZXNzYXJ5IGhlcmUuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCkge1xuICAgIGxldCByZXN1bHQ6IGFueTtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUuY2FsbCh0aGlzLnRoaXNBcmcsIHZhbHVlLCB0aGlzLmNvdW50KyspO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9maWx0ZXIudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5leHBvcnQgZnVuY3Rpb24gZmluZDxULCBTIGV4dGVuZHMgVD4odGhpczogT2JzZXJ2YWJsZTxUPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGU6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gdmFsdWUgaXMgUyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzQXJnPzogYW55KTogT2JzZXJ2YWJsZTxTPjtcbmV4cG9ydCBmdW5jdGlvbiBmaW5kPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGU6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gYm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNBcmc/OiBhbnkpOiBPYnNlcnZhYmxlPFQ+O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cblxuLyoqXG4gKiBFbWl0cyBvbmx5IHRoZSBmaXJzdCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IG1lZXRzIHNvbWVcbiAqIGNvbmRpdGlvbi5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RmluZHMgdGhlIGZpcnN0IHZhbHVlIHRoYXQgcGFzc2VzIHNvbWUgdGVzdCBhbmQgZW1pdHNcbiAqIHRoYXQuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZmluZC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgZmluZGAgc2VhcmNoZXMgZm9yIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IG1hdGNoZXMgdGhlXG4gKiBzcGVjaWZpZWQgY29uZGl0aW9uIGVtYm9kaWVkIGJ5IHRoZSBgcHJlZGljYXRlYCwgYW5kIHJldHVybnMgdGhlIGZpcnN0XG4gKiBvY2N1cnJlbmNlIGluIHRoZSBzb3VyY2UuIFVubGlrZSB7QGxpbmsgZmlyc3R9LCB0aGUgYHByZWRpY2F0ZWAgaXMgcmVxdWlyZWRcbiAqIGluIGBmaW5kYCwgYW5kIGRvZXMgbm90IGVtaXQgYW4gZXJyb3IgaWYgYSB2YWxpZCB2YWx1ZSBpcyBub3QgZm91bmQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RmluZCBhbmQgZW1pdCB0aGUgZmlyc3QgY2xpY2sgdGhhdCBoYXBwZW5zIG9uIGEgRElWIGVsZW1lbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5maW5kKGV2ID0+IGV2LnRhcmdldC50YWdOYW1lID09PSAnRElWJyk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGZpbHRlcn1cbiAqIEBzZWUge0BsaW5rIGZpcnN0fVxuICogQHNlZSB7QGxpbmsgZmluZEluZGV4fVxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pOiBib29sZWFufSBwcmVkaWNhdGVcbiAqIEEgZnVuY3Rpb24gY2FsbGVkIHdpdGggZWFjaCBpdGVtIHRvIHRlc3QgZm9yIGNvbmRpdGlvbiBtYXRjaGluZy5cbiAqIEBwYXJhbSB7YW55fSBbdGhpc0FyZ10gQW4gb3B0aW9uYWwgYXJndW1lbnQgdG8gZGV0ZXJtaW5lIHRoZSB2YWx1ZSBvZiBgdGhpc2BcbiAqIGluIHRoZSBgcHJlZGljYXRlYCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgb2YgdGhlIGZpcnN0IGl0ZW0gdGhhdCBtYXRjaGVzIHRoZVxuICogY29uZGl0aW9uLlxuICogQG1ldGhvZCBmaW5kXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZDxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBwcmVkaWNhdGU6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBib29sZWFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0FyZz86IGFueSk6IE9ic2VydmFibGU8VD4ge1xuICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ByZWRpY2F0ZSBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9XG4gIHJldHVybiA8YW55PnRoaXMubGlmdDxhbnk+KG5ldyBGaW5kVmFsdWVPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXMsIGZhbHNlLCB0aGlzQXJnKSk7XG59XG5cbmV4cG9ydCBjbGFzcyBGaW5kVmFsdWVPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwcmVkaWNhdGU6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBib29sZWFuLFxuICAgICAgICAgICAgICBwcml2YXRlIHNvdXJjZTogT2JzZXJ2YWJsZTxUPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSB5aWVsZEluZGV4OiBib29sZWFuLFxuICAgICAgICAgICAgICBwcml2YXRlIHRoaXNBcmc/OiBhbnkpIHtcbiAgfVxuXG4gIGNhbGwob2JzZXJ2ZXI6IFN1YnNjcmliZXI8VD4sIHNvdXJjZTogYW55KTogYW55IHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRmluZFZhbHVlU3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5wcmVkaWNhdGUsIHRoaXMuc291cmNlLCB0aGlzLnlpZWxkSW5kZXgsIHRoaXMudGhpc0FyZykpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5leHBvcnQgY2xhc3MgRmluZFZhbHVlU3Vic2NyaWJlcjxUPiBleHRlbmRzIFN1YnNjcmliZXI8VD4ge1xuICBwcml2YXRlIGluZGV4OiBudW1iZXIgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFQ+LFxuICAgICAgICAgICAgICBwcml2YXRlIHByZWRpY2F0ZTogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IGJvb2xlYW4sXG4gICAgICAgICAgICAgIHByaXZhdGUgc291cmNlOiBPYnNlcnZhYmxlPFQ+LFxuICAgICAgICAgICAgICBwcml2YXRlIHlpZWxkSW5kZXg6IGJvb2xlYW4sXG4gICAgICAgICAgICAgIHByaXZhdGUgdGhpc0FyZz86IGFueSkge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgbm90aWZ5Q29tcGxldGUodmFsdWU6IGFueSk6IHZvaWQge1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcblxuICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpOiB2b2lkIHtcbiAgICBjb25zdCB7IHByZWRpY2F0ZSwgdGhpc0FyZyB9ID0gdGhpcztcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcHJlZGljYXRlLmNhbGwodGhpc0FyZyB8fCB0aGlzLCB2YWx1ZSwgaW5kZXgsIHRoaXMuc291cmNlKTtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgdGhpcy5ub3RpZnlDb21wbGV0ZSh0aGlzLnlpZWxkSW5kZXggPyBpbmRleCA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbXBsZXRlKCk6IHZvaWQge1xuICAgIHRoaXMubm90aWZ5Q29tcGxldGUodGhpcy55aWVsZEluZGV4ID8gLTEgOiB1bmRlZmluZWQpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL2ZpbmQudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZhYmxlSW5wdXQgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IElTY2hlZHVsZXIgfSBmcm9tICcuLi9TY2hlZHVsZXInO1xuaW1wb3J0IHsgQXJyYXlPYnNlcnZhYmxlIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUnO1xuaW1wb3J0IHsgTWVyZ2VBbGxPcGVyYXRvciB9IGZyb20gJy4vbWVyZ2VBbGwnO1xuaW1wb3J0IHsgaXNTY2hlZHVsZXIgfSBmcm9tICcuLi91dGlsL2lzU2NoZWR1bGVyJztcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VD47XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgY29uY3VycmVudD86IG51bWJlciwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VD47XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgVDI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxUIHwgVDI+O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFQyPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgY29uY3VycmVudD86IG51bWJlciwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VCB8IFQyPjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxULCBUMiwgVDM+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VCB8IFQyIHwgVDM+O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFQyLCBUMz4odGhpczogT2JzZXJ2YWJsZTxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCBjb25jdXJyZW50PzogbnVtYmVyLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxUIHwgVDIgfCBUMz47XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgVDIsIFQzLCBUND4odGhpczogT2JzZXJ2YWJsZTxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCB2NDogT2JzZXJ2YWJsZUlucHV0PFQ0Piwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VCB8IFQyIHwgVDMgfCBUND47XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgVDIsIFQzLCBUND4odGhpczogT2JzZXJ2YWJsZTxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCB2NDogT2JzZXJ2YWJsZUlucHV0PFQ0PiwgY29uY3VycmVudD86IG51bWJlciwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VCB8IFQyIHwgVDMgfCBUND47XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgVDIsIFQzLCBUNCwgVDU+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4sIHY1OiBPYnNlcnZhYmxlSW5wdXQ8VDU+LCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxUIHwgVDIgfCBUMyB8IFQ0IHwgVDU+O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFQyLCBUMywgVDQsIFQ1Pih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCB2NTogT2JzZXJ2YWJsZUlucHV0PFQ1PiwgY29uY3VycmVudD86IG51bWJlciwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VCB8IFQyIHwgVDMgfCBUNCB8IFQ1PjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxULCBUMiwgVDMsIFQ0LCBUNSwgVDY+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4sIHY1OiBPYnNlcnZhYmxlSW5wdXQ8VDU+LCB2NjogT2JzZXJ2YWJsZUlucHV0PFQ2Piwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VCB8IFQyIHwgVDMgfCBUNCB8IFQ1IHwgVDY+O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlPFQsIFQyLCBUMywgVDQsIFQ1LCBUNj4odGhpczogT2JzZXJ2YWJsZTxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCB2NDogT2JzZXJ2YWJsZUlucHV0PFQ0PiwgdjU6IE9ic2VydmFibGVJbnB1dDxUNT4sIHY2OiBPYnNlcnZhYmxlSW5wdXQ8VDY+LCBjb25jdXJyZW50PzogbnVtYmVyLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxUIHwgVDIgfCBUMyB8IFQ0IHwgVDUgfCBUNj47XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgLi4ub2JzZXJ2YWJsZXM6IEFycmF5PE9ic2VydmFibGVJbnB1dDxUPiB8IElTY2hlZHVsZXIgfCBudW1iZXI+KTogT2JzZXJ2YWJsZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZTxULCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCAuLi5vYnNlcnZhYmxlczogQXJyYXk8T2JzZXJ2YWJsZUlucHV0PGFueT4gfCBJU2NoZWR1bGVyIHwgbnVtYmVyPik6IE9ic2VydmFibGU8Uj47XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb3V0cHV0IE9ic2VydmFibGUgd2hpY2ggY29uY3VycmVudGx5IGVtaXRzIGFsbCB2YWx1ZXMgZnJvbSBldmVyeVxuICogZ2l2ZW4gaW5wdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RmxhdHRlbnMgbXVsdGlwbGUgT2JzZXJ2YWJsZXMgdG9nZXRoZXIgYnkgYmxlbmRpbmdcbiAqIHRoZWlyIHZhbHVlcyBpbnRvIG9uZSBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21lcmdlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBtZXJnZWAgc3Vic2NyaWJlcyB0byBlYWNoIGdpdmVuIGlucHV0IE9ic2VydmFibGUgKGVpdGhlciB0aGUgc291cmNlIG9yIGFuXG4gKiBPYnNlcnZhYmxlIGdpdmVuIGFzIGFyZ3VtZW50KSwgYW5kIHNpbXBseSBmb3J3YXJkcyAod2l0aG91dCBkb2luZyBhbnlcbiAqIHRyYW5zZm9ybWF0aW9uKSBhbGwgdGhlIHZhbHVlcyBmcm9tIGFsbCB0aGUgaW5wdXQgT2JzZXJ2YWJsZXMgdG8gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIG9ubHkgY29tcGxldGVzIG9uY2UgYWxsIGlucHV0IE9ic2VydmFibGVzXG4gKiBoYXZlIGNvbXBsZXRlZC4gQW55IGVycm9yIGRlbGl2ZXJlZCBieSBhbiBpbnB1dCBPYnNlcnZhYmxlIHdpbGwgYmUgaW1tZWRpYXRlbHlcbiAqIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1lcmdlIHRvZ2V0aGVyIHR3byBPYnNlcnZhYmxlczogMXMgaW50ZXJ2YWwgYW5kIGNsaWNrczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgdGltZXIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIGNsaWNrc09yVGltZXIgPSBjbGlja3MubWVyZ2UodGltZXIpO1xuICogY2xpY2tzT3JUaW1lci5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWVyZ2UgdG9nZXRoZXIgMyBPYnNlcnZhYmxlcywgYnV0IG9ubHkgMiBydW4gY29uY3VycmVudGx5PC9jYXB0aW9uPlxuICogdmFyIHRpbWVyMSA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSgxMCk7XG4gKiB2YXIgdGltZXIyID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgyMDAwKS50YWtlKDYpO1xuICogdmFyIHRpbWVyMyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKS50YWtlKDEwKTtcbiAqIHZhciBjb25jdXJyZW50ID0gMjsgLy8gdGhlIGFyZ3VtZW50XG4gKiB2YXIgbWVyZ2VkID0gdGltZXIxLm1lcmdlKHRpbWVyMiwgdGltZXIzLCBjb25jdXJyZW50KTtcbiAqIG1lcmdlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWVyZ2VBbGx9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwVG99XG4gKiBAc2VlIHtAbGluayBtZXJnZVNjYW59XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlSW5wdXR9IG90aGVyIEFuIGlucHV0IE9ic2VydmFibGUgdG8gbWVyZ2Ugd2l0aCB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBNb3JlIHRoYW4gb25lIGlucHV0IE9ic2VydmFibGVzIG1heSBiZSBnaXZlbiBhcyBhcmd1bWVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVudD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldIE1heGltdW0gbnVtYmVyIG9mIGlucHV0XG4gKiBPYnNlcnZhYmxlcyBiZWluZyBzdWJzY3JpYmVkIHRvIGNvbmN1cnJlbnRseS5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPW51bGxdIFRoZSBJU2NoZWR1bGVyIHRvIHVzZSBmb3IgbWFuYWdpbmdcbiAqIGNvbmN1cnJlbmN5IG9mIGlucHV0IE9ic2VydmFibGVzLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIHRoYXQgYXJlIHRoZSByZXN1bHQgb2ZcbiAqIGV2ZXJ5IGlucHV0IE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIG1lcmdlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2U8VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgLi4ub2JzZXJ2YWJsZXM6IEFycmF5PE9ic2VydmFibGVJbnB1dDxhbnk+IHwgSVNjaGVkdWxlciB8IG51bWJlcj4pOiBPYnNlcnZhYmxlPFI+IHtcbiAgcmV0dXJuIHRoaXMubGlmdC5jYWxsKG1lcmdlU3RhdGljPFQsIFI+KHRoaXMsIC4uLm9ic2VydmFibGVzKSk7XG59XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU3RhdGljPFQ+KHYxOiBPYnNlcnZhYmxlSW5wdXQ8VD4sIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU3RhdGljPFQ+KHYxOiBPYnNlcnZhYmxlSW5wdXQ8VD4sIGNvbmN1cnJlbnQ/OiBudW1iZXIsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU3RhdGljPFQsIFQyPih2MTogT2JzZXJ2YWJsZUlucHV0PFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VCB8IFQyPjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVN0YXRpYzxULCBUMj4odjE6IE9ic2VydmFibGVJbnB1dDxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIGNvbmN1cnJlbnQ/OiBudW1iZXIsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQgfCBUMj47XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VTdGF0aWM8VCwgVDIsIFQzPih2MTogT2JzZXJ2YWJsZUlucHV0PFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQgfCBUMiB8IFQzPjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVN0YXRpYzxULCBUMiwgVDM+KHYxOiBPYnNlcnZhYmxlSW5wdXQ8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgY29uY3VycmVudD86IG51bWJlciwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VCB8IFQyIHwgVDM+O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU3RhdGljPFQsIFQyLCBUMywgVDQ+KHYxOiBPYnNlcnZhYmxlSW5wdXQ8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4sIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQgfCBUMiB8IFQzIHwgVDQ+O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU3RhdGljPFQsIFQyLCBUMywgVDQ+KHYxOiBPYnNlcnZhYmxlSW5wdXQ8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4sIGNvbmN1cnJlbnQ/OiBudW1iZXIsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQgfCBUMiB8IFQzIHwgVDQ+O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU3RhdGljPFQsIFQyLCBUMywgVDQsIFQ1Pih2MTogT2JzZXJ2YWJsZUlucHV0PFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCB2NTogT2JzZXJ2YWJsZUlucHV0PFQ1Piwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VCB8IFQyIHwgVDMgfCBUNCB8IFQ1PjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVN0YXRpYzxULCBUMiwgVDMsIFQ0LCBUNT4odjE6IE9ic2VydmFibGVJbnB1dDxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCB2NDogT2JzZXJ2YWJsZUlucHV0PFQ0PiwgdjU6IE9ic2VydmFibGVJbnB1dDxUNT4sIGNvbmN1cnJlbnQ/OiBudW1iZXIsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQgfCBUMiB8IFQzIHwgVDQgfCBUNT47XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VTdGF0aWM8VCwgVDIsIFQzLCBUNCwgVDUsIFQ2Pih2MTogT2JzZXJ2YWJsZUlucHV0PFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCB2NTogT2JzZXJ2YWJsZUlucHV0PFQ1PiwgdjY6IE9ic2VydmFibGVJbnB1dDxUNj4sIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQgfCBUMiB8IFQzIHwgVDQgfCBUNSB8IFQ2PjtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVN0YXRpYzxULCBUMiwgVDMsIFQ0LCBUNSwgVDY+KHYxOiBPYnNlcnZhYmxlSW5wdXQ8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4sIHY1OiBPYnNlcnZhYmxlSW5wdXQ8VDU+LCB2NjogT2JzZXJ2YWJsZUlucHV0PFQ2PiwgY29uY3VycmVudD86IG51bWJlciwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VCB8IFQyIHwgVDMgfCBUNCB8IFQ1IHwgVDY+O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU3RhdGljPFQ+KC4uLm9ic2VydmFibGVzOiAoT2JzZXJ2YWJsZUlucHV0PFQ+IHwgSVNjaGVkdWxlciB8IG51bWJlcilbXSk6IE9ic2VydmFibGU8VD47XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VTdGF0aWM8VCwgUj4oLi4ub2JzZXJ2YWJsZXM6IChPYnNlcnZhYmxlSW5wdXQ8YW55PiB8IElTY2hlZHVsZXIgfCBudW1iZXIpW10pOiBPYnNlcnZhYmxlPFI+O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbi8qKlxuICogQ3JlYXRlcyBhbiBvdXRwdXQgT2JzZXJ2YWJsZSB3aGljaCBjb25jdXJyZW50bHkgZW1pdHMgYWxsIHZhbHVlcyBmcm9tIGV2ZXJ5XG4gKiBnaXZlbiBpbnB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0b2dldGhlciBieSBibGVuZGluZ1xuICogdGhlaXIgdmFsdWVzIGludG8gb25lIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWVyZ2UucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYG1lcmdlYCBzdWJzY3JpYmVzIHRvIGVhY2ggZ2l2ZW4gaW5wdXQgT2JzZXJ2YWJsZSAoYXMgYXJndW1lbnRzKSwgYW5kIHNpbXBseVxuICogZm9yd2FyZHMgKHdpdGhvdXQgZG9pbmcgYW55IHRyYW5zZm9ybWF0aW9uKSBhbGwgdGhlIHZhbHVlcyBmcm9tIGFsbCB0aGUgaW5wdXRcbiAqIE9ic2VydmFibGVzIHRvIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIG9ubHkgY29tcGxldGVzXG4gKiBvbmNlIGFsbCBpbnB1dCBPYnNlcnZhYmxlcyBoYXZlIGNvbXBsZXRlZC4gQW55IGVycm9yIGRlbGl2ZXJlZCBieSBhbiBpbnB1dFxuICogT2JzZXJ2YWJsZSB3aWxsIGJlIGltbWVkaWF0ZWx5IGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1lcmdlIHRvZ2V0aGVyIHR3byBPYnNlcnZhYmxlczogMXMgaW50ZXJ2YWwgYW5kIGNsaWNrczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgdGltZXIgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIGNsaWNrc09yVGltZXIgPSBSeC5PYnNlcnZhYmxlLm1lcmdlKGNsaWNrcywgdGltZXIpO1xuICogY2xpY2tzT3JUaW1lci5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gdGltZXIgd2lsbCBlbWl0IGFzY2VuZGluZyB2YWx1ZXMsIG9uZSBldmVyeSBzZWNvbmQoMTAwMG1zKSB0byBjb25zb2xlXG4gKiAvLyBjbGlja3MgbG9ncyBNb3VzZUV2ZW50cyB0byBjb25zb2xlIGV2ZXJ5dGltZSB0aGUgXCJkb2N1bWVudFwiIGlzIGNsaWNrZWRcbiAqIC8vIFNpbmNlIHRoZSB0d28gc3RyZWFtcyBhcmUgbWVyZ2VkIHlvdSBzZWUgdGhlc2UgaGFwcGVuaW5nXG4gKiAvLyBhcyB0aGV5IG9jY3VyLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1lcmdlIHRvZ2V0aGVyIDMgT2JzZXJ2YWJsZXMsIGJ1dCBvbmx5IDIgcnVuIGNvbmN1cnJlbnRseTwvY2FwdGlvbj5cbiAqIHZhciB0aW1lcjEgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoMTApO1xuICogdmFyIHRpbWVyMiA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMjAwMCkudGFrZSg2KTtcbiAqIHZhciB0aW1lcjMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDUwMCkudGFrZSgxMCk7XG4gKiB2YXIgY29uY3VycmVudCA9IDI7IC8vIHRoZSBhcmd1bWVudFxuICogdmFyIG1lcmdlZCA9IFJ4Lk9ic2VydmFibGUubWVyZ2UodGltZXIxLCB0aW1lcjIsIHRpbWVyMywgY29uY3VycmVudCk7XG4gKiBtZXJnZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIC0gRmlyc3QgdGltZXIxIGFuZCB0aW1lcjIgd2lsbCBydW4gY29uY3VycmVudGx5XG4gKiAvLyAtIHRpbWVyMSB3aWxsIGVtaXQgYSB2YWx1ZSBldmVyeSAxMDAwbXMgZm9yIDEwIGl0ZXJhdGlvbnNcbiAqIC8vIC0gdGltZXIyIHdpbGwgZW1pdCBhIHZhbHVlIGV2ZXJ5IDIwMDBtcyBmb3IgNiBpdGVyYXRpb25zXG4gKiAvLyAtIGFmdGVyIHRpbWVyMSBoaXRzIGl0J3MgbWF4IGl0ZXJhdGlvbiwgdGltZXIyIHdpbGxcbiAqIC8vICAgY29udGludWUsIGFuZCB0aW1lcjMgd2lsbCBzdGFydCB0byBydW4gY29uY3VycmVudGx5IHdpdGggdGltZXIyXG4gKiAvLyAtIHdoZW4gdGltZXIyIGhpdHMgaXQncyBtYXggaXRlcmF0aW9uIGl0IHRlcm1pbmF0ZXMsIGFuZFxuICogLy8gICB0aW1lcjMgd2lsbCBjb250aW51ZSB0byBlbWl0IGEgdmFsdWUgZXZlcnkgNTAwbXMgdW50aWwgaXQgaXMgY29tcGxldGVcbiAqXG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqXG4gKiBAcGFyYW0gey4uLk9ic2VydmFibGVJbnB1dH0gb2JzZXJ2YWJsZXMgSW5wdXQgT2JzZXJ2YWJsZXMgdG8gbWVyZ2UgdG9nZXRoZXIuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZiBpbnB1dFxuICogT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1udWxsXSBUaGUgSVNjaGVkdWxlciB0byB1c2UgZm9yIG1hbmFnaW5nXG4gKiBjb25jdXJyZW5jeSBvZiBpbnB1dCBPYnNlcnZhYmxlcy5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyB0aGF0IGFyZSB0aGUgcmVzdWx0IG9mXG4gKiBldmVyeSBpbnB1dCBPYnNlcnZhYmxlLlxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSBtZXJnZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU3RhdGljPFQsIFI+KC4uLm9ic2VydmFibGVzOiBBcnJheTxPYnNlcnZhYmxlSW5wdXQ8YW55PiB8IElTY2hlZHVsZXIgfCBudW1iZXI+KTogT2JzZXJ2YWJsZTxSPiB7XG4gbGV0IGNvbmN1cnJlbnQgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gbGV0IHNjaGVkdWxlcjogSVNjaGVkdWxlciA9IG51bGw7XG4gIGxldCBsYXN0OiBhbnkgPSBvYnNlcnZhYmxlc1tvYnNlcnZhYmxlcy5sZW5ndGggLSAxXTtcbiAgaWYgKGlzU2NoZWR1bGVyKGxhc3QpKSB7XG4gICAgc2NoZWR1bGVyID0gPElTY2hlZHVsZXI+b2JzZXJ2YWJsZXMucG9wKCk7XG4gICAgaWYgKG9ic2VydmFibGVzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIG9ic2VydmFibGVzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdID09PSAnbnVtYmVyJykge1xuICAgICAgY29uY3VycmVudCA9IDxudW1iZXI+b2JzZXJ2YWJsZXMucG9wKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBsYXN0ID09PSAnbnVtYmVyJykge1xuICAgIGNvbmN1cnJlbnQgPSA8bnVtYmVyPm9ic2VydmFibGVzLnBvcCgpO1xuICB9XG5cbiAgaWYgKHNjaGVkdWxlciA9PT0gbnVsbCAmJiBvYnNlcnZhYmxlcy5sZW5ndGggPT09IDEgJiYgb2JzZXJ2YWJsZXNbMF0gaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XG4gICAgcmV0dXJuIDxPYnNlcnZhYmxlPFI+Pm9ic2VydmFibGVzWzBdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGUoPGFueT5vYnNlcnZhYmxlcywgc2NoZWR1bGVyKS5saWZ0KG5ldyBNZXJnZUFsbE9wZXJhdG9yPFI+KGNvbmN1cnJlbnQpKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvbWVyZ2UudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZhYmxlSW5wdXQgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IHN1YnNjcmliZVRvUmVzdWx0IH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCc7XG5pbXBvcnQgeyBPdXRlclN1YnNjcmliZXIgfSBmcm9tICcuLi9PdXRlclN1YnNjcmliZXInO1xuaW1wb3J0IHsgSW5uZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vSW5uZXJTdWJzY3JpYmVyJztcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VNYXA8VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgcHJvamVjdDogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBPYnNlcnZhYmxlSW5wdXQ8Uj4sIGNvbmN1cnJlbnQ/OiBudW1iZXIpOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlTWFwPFQsIEksIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHByb2plY3Q6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gT2JzZXJ2YWJsZUlucHV0PEk+LCByZXN1bHRTZWxlY3RvcjogKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKSA9PiBSLCBjb25jdXJyZW50PzogbnVtYmVyKTogT2JzZXJ2YWJsZTxSPjtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TWFwcyBlYWNoIHZhbHVlIHRvIGFuIE9ic2VydmFibGUsIHRoZW4gZmxhdHRlbnMgYWxsIG9mXG4gKiB0aGVzZSBpbm5lciBPYnNlcnZhYmxlcyB1c2luZyB7QGxpbmsgbWVyZ2VBbGx9Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21lcmdlTWFwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGJhc2VkIG9uIGFwcGx5aW5nIGEgZnVuY3Rpb24gdGhhdCB5b3VcbiAqIHN1cHBseSB0byBlYWNoIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHdoZXJlIHRoYXQgZnVuY3Rpb25cbiAqIHJldHVybnMgYW4gT2JzZXJ2YWJsZSwgYW5kIHRoZW4gbWVyZ2luZyB0aG9zZSByZXN1bHRpbmcgT2JzZXJ2YWJsZXMgYW5kXG4gKiBlbWl0dGluZyB0aGUgcmVzdWx0cyBvZiB0aGlzIG1lcmdlci5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgYW5kIGZsYXR0ZW4gZWFjaCBsZXR0ZXIgdG8gYW4gT2JzZXJ2YWJsZSB0aWNraW5nIGV2ZXJ5IDEgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGxldHRlcnMgPSBSeC5PYnNlcnZhYmxlLm9mKCdhJywgJ2InLCAnYycpO1xuICogdmFyIHJlc3VsdCA9IGxldHRlcnMubWVyZ2VNYXAoeCA9PlxuICogICBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLm1hcChpID0+IHgraSlcbiAqICk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIFJlc3VsdHMgaW4gdGhlIGZvbGxvd2luZzpcbiAqIC8vIGEwXG4gKiAvLyBiMFxuICogLy8gYzBcbiAqIC8vIGExXG4gKiAvLyBiMVxuICogLy8gYzFcbiAqIC8vIGNvbnRpbnVlcyB0byBsaXN0IGEsYixjIHdpdGggcmVzcGVjdGl2ZSBhc2NlbmRpbmcgaW50ZWdlcnNcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0TWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2V9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlTWFwVG99XG4gKiBAc2VlIHtAbGluayBtZXJnZVNjYW59XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXB9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgP2luZGV4OiBudW1iZXIpOiBPYnNlcnZhYmxlSW5wdXR9IHByb2plY3QgQSBmdW5jdGlvblxuICogdGhhdCwgd2hlbiBhcHBsaWVkIHRvIGFuIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHJldHVybnMgYW5cbiAqIE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKTogYW55fSBbcmVzdWx0U2VsZWN0b3JdXG4gKiBBIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSAob3V0ZXIpIGVtaXNzaW9uIGFuZCB0aGUgaW5uZXIgT2JzZXJ2YWJsZVxuICogZW1pc3Npb24uIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlOlxuICogLSBgb3V0ZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogLSBgb3V0ZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2YgaW5wdXRcbiAqIE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgdGhlXG4gKiBwcm9qZWN0aW9uIGZ1bmN0aW9uIChhbmQgdGhlIG9wdGlvbmFsIGByZXN1bHRTZWxlY3RvcmApIHRvIGVhY2ggaXRlbSBlbWl0dGVkXG4gKiBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIG1lcmdpbmcgdGhlIHJlc3VsdHMgb2YgdGhlIE9ic2VydmFibGVzIG9idGFpbmVkXG4gKiBmcm9tIHRoaXMgdHJhbnNmb3JtYXRpb24uXG4gKiBAbWV0aG9kIG1lcmdlTWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VNYXA8VCwgSSwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgcHJvamVjdDogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBPYnNlcnZhYmxlSW5wdXQ8ST4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U2VsZWN0b3I/OiAoKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKSA9PiBSKSB8IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25jdXJyZW50OiBudW1iZXIgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpOiBPYnNlcnZhYmxlPEkgfCBSPiB7XG4gIGlmICh0eXBlb2YgcmVzdWx0U2VsZWN0b3IgPT09ICdudW1iZXInKSB7XG4gICAgY29uY3VycmVudCA9IDxudW1iZXI+cmVzdWx0U2VsZWN0b3I7XG4gICAgcmVzdWx0U2VsZWN0b3IgPSBudWxsO1xuICB9XG4gIHJldHVybiB0aGlzLmxpZnQobmV3IE1lcmdlTWFwT3BlcmF0b3IocHJvamVjdCwgPGFueT5yZXN1bHRTZWxlY3RvciwgY29uY3VycmVudCkpO1xufVxuXG5leHBvcnQgY2xhc3MgTWVyZ2VNYXBPcGVyYXRvcjxULCBJLCBSPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIEk+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwcm9qZWN0OiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IE9ic2VydmFibGVJbnB1dDxJPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSByZXN1bHRTZWxlY3Rvcj86IChvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcikgPT4gUixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBjb25jdXJyZW50OiBudW1iZXIgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgfVxuXG4gIGNhbGwob2JzZXJ2ZXI6IFN1YnNjcmliZXI8ST4sIHNvdXJjZTogYW55KTogYW55IHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWVyZ2VNYXBTdWJzY3JpYmVyKFxuICAgICAgb2JzZXJ2ZXIsIHRoaXMucHJvamVjdCwgdGhpcy5yZXN1bHRTZWxlY3RvciwgdGhpcy5jb25jdXJyZW50XG4gICAgKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmV4cG9ydCBjbGFzcyBNZXJnZU1hcFN1YnNjcmliZXI8VCwgSSwgUj4gZXh0ZW5kcyBPdXRlclN1YnNjcmliZXI8VCwgST4ge1xuICBwcml2YXRlIGhhc0NvbXBsZXRlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGJ1ZmZlcjogVFtdID0gW107XG4gIHByaXZhdGUgYWN0aXZlOiBudW1iZXIgPSAwO1xuICBwcm90ZWN0ZWQgaW5kZXg6IG51bWJlciA9IDA7XG5cbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8ST4sXG4gICAgICAgICAgICAgIHByaXZhdGUgcHJvamVjdDogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBPYnNlcnZhYmxlSW5wdXQ8ST4sXG4gICAgICAgICAgICAgIHByaXZhdGUgcmVzdWx0U2VsZWN0b3I/OiAob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpID0+IFIsXG4gICAgICAgICAgICAgIHByaXZhdGUgY29uY3VycmVudDogbnVtYmVyID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHZhbHVlOiBUKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuYWN0aXZlIDwgdGhpcy5jb25jdXJyZW50KSB7XG4gICAgICB0aGlzLl90cnlOZXh0KHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5idWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF90cnlOZXh0KHZhbHVlOiBUKSB7XG4gICAgbGV0IHJlc3VsdDogT2JzZXJ2YWJsZUlucHV0PEk+O1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QodmFsdWUsIGluZGV4KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUrKztcbiAgICB0aGlzLl9pbm5lclN1YihyZXN1bHQsIHZhbHVlLCBpbmRleCk7XG4gIH1cblxuICBwcml2YXRlIF9pbm5lclN1Yihpc2g6IE9ic2VydmFibGVJbnB1dDxJPiwgdmFsdWU6IFQsIGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdDxULCBJPih0aGlzLCBpc2gsIHZhbHVlLCBpbmRleCkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jb21wbGV0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuYWN0aXZlID09PSAwICYmIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIG5vdGlmeU5leHQob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSxcbiAgICAgICAgICAgICBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgICBpbm5lclN1YjogSW5uZXJTdWJzY3JpYmVyPFQsIEk+KTogdm9pZCB7XG4gICAgaWYgKHRoaXMucmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgIHRoaXMuX25vdGlmeVJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfbm90aWZ5UmVzdWx0U2VsZWN0b3Iob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpIHtcbiAgICBsZXQgcmVzdWx0OiBSO1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQocmVzdWx0KTtcbiAgfVxuXG4gIG5vdGlmeUNvbXBsZXRlKGlubmVyU3ViOiBTdWJzY3JpcHRpb24pOiB2b2lkIHtcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgdGhpcy5hY3RpdmUtLTtcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX25leHQoYnVmZmVyLnNoaWZ0KCkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvbWVyZ2VNYXAudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZhYmxlSW5wdXQgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgUGFydGlhbE9ic2VydmVyIH0gZnJvbSAnLi4vT2JzZXJ2ZXInO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE91dGVyU3Vic2NyaWJlciB9IGZyb20gJy4uL091dGVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBJbm5lclN1YnNjcmliZXIgfSBmcm9tICcuLi9Jbm5lclN1YnNjcmliZXInO1xuaW1wb3J0IHsgc3Vic2NyaWJlVG9SZXN1bHQgfSBmcm9tICcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0JztcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VNYXBUbzxULCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBvYnNlcnZhYmxlOiBPYnNlcnZhYmxlSW5wdXQ8Uj4sIGNvbmN1cnJlbnQ/OiBudW1iZXIpOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlTWFwVG88VCwgSSwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgb2JzZXJ2YWJsZTogT2JzZXJ2YWJsZUlucHV0PEk+LCByZXN1bHRTZWxlY3RvcjogKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKSA9PiBSLCBjb25jdXJyZW50PzogbnVtYmVyKTogT2JzZXJ2YWJsZTxSPjtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gdGhlIHNhbWUgT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgbXVsdGlwbGVcbiAqIHRpbWVzIGluIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBtZXJnZU1hcH0sIGJ1dCBtYXBzIGVhY2ggdmFsdWUgYWx3YXlzXG4gKiB0byB0aGUgc2FtZSBpbm5lciBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21lcmdlTWFwVG8ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogTWFwcyBlYWNoIHNvdXJjZSB2YWx1ZSB0byB0aGUgZ2l2ZW4gT2JzZXJ2YWJsZSBgaW5uZXJPYnNlcnZhYmxlYCByZWdhcmRsZXNzXG4gKiBvZiB0aGUgc291cmNlIHZhbHVlLCBhbmQgdGhlbiBtZXJnZXMgdGhvc2UgcmVzdWx0aW5nIE9ic2VydmFibGVzIGludG8gb25lXG4gKiBzaW5nbGUgT2JzZXJ2YWJsZSwgd2hpY2ggaXMgdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkZvciBlYWNoIGNsaWNrIGV2ZW50LCBzdGFydCBhbiBpbnRlcnZhbCBPYnNlcnZhYmxlIHRpY2tpbmcgZXZlcnkgMSBzZWNvbmQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5tZXJnZU1hcFRvKFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXBUb31cbiAqIEBzZWUge0BsaW5rIG1lcmdlfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VBbGx9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIG1lcmdlU2Nhbn1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcFRvfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBpbm5lck9ic2VydmFibGUgQW4gT2JzZXJ2YWJsZSB0byByZXBsYWNlIGVhY2ggdmFsdWUgZnJvbVxuICogdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcik6IGFueX0gW3Jlc3VsdFNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmFzZWQgb24gdGhlIHZhbHVlc1xuICogYW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBzb3VyY2UgKG91dGVyKSBlbWlzc2lvbiBhbmQgdGhlIGlubmVyIE9ic2VydmFibGVcbiAqIGVtaXNzaW9uLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZTpcbiAqIC0gYG91dGVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIC0gYG91dGVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVudD1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldIE1heGltdW0gbnVtYmVyIG9mIGlucHV0XG4gKiBPYnNlcnZhYmxlcyBiZWluZyBzdWJzY3JpYmVkIHRvIGNvbmN1cnJlbnRseS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBmcm9tIHRoZSBnaXZlblxuICogYGlubmVyT2JzZXJ2YWJsZWAgKGFuZCBvcHRpb25hbGx5IHRyYW5zZm9ybWVkIHRocm91Z2ggYHJlc3VsdFNlbGVjdG9yYCkgZXZlcnlcbiAqIHRpbWUgYSB2YWx1ZSBpcyBlbWl0dGVkIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgbWVyZ2VNYXBUb1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlTWFwVG88VCwgSSwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgaW5uZXJPYnNlcnZhYmxlOiBPYnNlcnZhYmxlPEk+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U2VsZWN0b3I/OiAoKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKSA9PiBSKSB8IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmN1cnJlbnQ6IG51bWJlciA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk6IE9ic2VydmFibGU8Uj4ge1xuICBpZiAodHlwZW9mIHJlc3VsdFNlbGVjdG9yID09PSAnbnVtYmVyJykge1xuICAgIGNvbmN1cnJlbnQgPSA8bnVtYmVyPnJlc3VsdFNlbGVjdG9yO1xuICAgIHJlc3VsdFNlbGVjdG9yID0gbnVsbDtcbiAgfVxuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBNZXJnZU1hcFRvT3BlcmF0b3IoaW5uZXJPYnNlcnZhYmxlLCA8YW55PnJlc3VsdFNlbGVjdG9yLCBjb25jdXJyZW50KSk7XG59XG5cbi8vIFRPRE86IEZpZ3VyZSBvdXQgY29ycmVjdCBzaWduYXR1cmUgaGVyZTogYW4gT3BlcmF0b3I8T2JzZXJ2YWJsZTxUPiwgUj5cbi8vICAgICAgIG5lZWRzIHRvIGltcGxlbWVudCBjYWxsKG9ic2VydmVyOiBTdWJzY3JpYmVyPFI+KTogU3Vic2NyaWJlcjxPYnNlcnZhYmxlPFQ+PlxuZXhwb3J0IGNsYXNzIE1lcmdlTWFwVG9PcGVyYXRvcjxULCBJLCBSPiBpbXBsZW1lbnRzIE9wZXJhdG9yPE9ic2VydmFibGU8VD4sIFI+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpc2g6IE9ic2VydmFibGVJbnB1dDxJPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSByZXN1bHRTZWxlY3Rvcj86IChvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcikgPT4gUixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBjb25jdXJyZW50OiBudW1iZXIgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgfVxuXG4gIGNhbGwob2JzZXJ2ZXI6IFN1YnNjcmliZXI8Uj4sIHNvdXJjZTogYW55KTogYW55IHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWVyZ2VNYXBUb1N1YnNjcmliZXIob2JzZXJ2ZXIsIHRoaXMuaXNoLCB0aGlzLnJlc3VsdFNlbGVjdG9yLCB0aGlzLmNvbmN1cnJlbnQpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuZXhwb3J0IGNsYXNzIE1lcmdlTWFwVG9TdWJzY3JpYmVyPFQsIEksIFI+IGV4dGVuZHMgT3V0ZXJTdWJzY3JpYmVyPFQsIEk+IHtcbiAgcHJpdmF0ZSBoYXNDb21wbGV0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBidWZmZXI6IFRbXSA9IFtdO1xuICBwcml2YXRlIGFjdGl2ZTogbnVtYmVyID0gMDtcbiAgcHJvdGVjdGVkIGluZGV4OiBudW1iZXIgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFI+LFxuICAgICAgICAgICAgICBwcml2YXRlIGlzaDogT2JzZXJ2YWJsZUlucHV0PEk+LFxuICAgICAgICAgICAgICBwcml2YXRlIHJlc3VsdFNlbGVjdG9yPzogKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKSA9PiBSLFxuICAgICAgICAgICAgICBwcml2YXRlIGNvbmN1cnJlbnQ6IG51bWJlciA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmFjdGl2ZSA8IHRoaXMuY29uY3VycmVudCkge1xuICAgICAgY29uc3QgcmVzdWx0U2VsZWN0b3IgPSB0aGlzLnJlc3VsdFNlbGVjdG9yO1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgICBjb25zdCBpc2ggPSB0aGlzLmlzaDtcbiAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcblxuICAgICAgdGhpcy5hY3RpdmUrKztcbiAgICAgIHRoaXMuX2lubmVyU3ViKGlzaCwgZGVzdGluYXRpb24sIHJlc3VsdFNlbGVjdG9yLCB2YWx1ZSwgaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9pbm5lclN1Yihpc2g6IE9ic2VydmFibGVJbnB1dDxJPixcbiAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb246IFBhcnRpYWxPYnNlcnZlcjxJPixcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0U2VsZWN0b3I6IChvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcikgPT4gUixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFQsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdDxULCBJPih0aGlzLCBpc2gsIHZhbHVlLCBpbmRleCkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jb21wbGV0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuYWN0aXZlID09PSAwICYmIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIG5vdGlmeU5leHQob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSxcbiAgICAgICAgICAgICBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgICBpbm5lclN1YjogSW5uZXJTdWJzY3JpYmVyPFQsIEk+KTogdm9pZCB7XG4gICAgY29uc3QgeyByZXN1bHRTZWxlY3RvciwgZGVzdGluYXRpb24gfSA9IHRoaXM7XG4gICAgaWYgKHJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICB0aGlzLnRyeVNlbGVjdFJlc3VsdChvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyeVNlbGVjdFJlc3VsdChvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgIGNvbnN0IHsgcmVzdWx0U2VsZWN0b3IsIGRlc3RpbmF0aW9uIH0gPSB0aGlzO1xuICAgIGxldCByZXN1bHQ6IFI7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gIH1cblxuICBub3RpZnlFcnJvcihlcnI6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgfVxuXG4gIG5vdGlmeUNvbXBsZXRlKGlubmVyU3ViOiBTdWJzY3JpcHRpb24pOiB2b2lkIHtcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgdGhpcy5hY3RpdmUtLTtcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX25leHQoYnVmZmVyLnNoaWZ0KCkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvbWVyZ2VNYXBUby50cyIsImltcG9ydCB7IE9ic2VydmFibGUsIE9ic2VydmFibGVJbnB1dCB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgRnJvbU9ic2VydmFibGUgfSBmcm9tICcuLi9vYnNlcnZhYmxlL0Zyb21PYnNlcnZhYmxlJztcbmltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJy4uL3V0aWwvaXNBcnJheSc7XG5pbXBvcnQgeyBPdXRlclN1YnNjcmliZXIgfSBmcm9tICcuLi9PdXRlclN1YnNjcmliZXInO1xuaW1wb3J0IHsgSW5uZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vSW5uZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IHN1YnNjcmliZVRvUmVzdWx0IH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCc7XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0PFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHY6IE9ic2VydmFibGVJbnB1dDxSPik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gb25FcnJvclJlc3VtZU5leHQ8VCwgVDIsIFQzLCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4pOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0PFQsIFQyLCBUMywgVDQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4pOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0PFQsIFQyLCBUMywgVDQsIFQ1LCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCB2NTogT2JzZXJ2YWJsZUlucHV0PFQ1Pik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gb25FcnJvclJlc3VtZU5leHQ8VCwgVDIsIFQzLCBUNCwgVDUsIFQ2LCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCB2NTogT2JzZXJ2YWJsZUlucHV0PFQ1PiwgdjY6IE9ic2VydmFibGVJbnB1dDxUNj4pOiBPYnNlcnZhYmxlPFI+IDtcbmV4cG9ydCBmdW5jdGlvbiBvbkVycm9yUmVzdW1lTmV4dDxULCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCAuLi5vYnNlcnZhYmxlczogQXJyYXk8T2JzZXJ2YWJsZUlucHV0PGFueT4gfCAoKC4uLnZhbHVlczogQXJyYXk8YW55PikgPT4gUik+KTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiBvbkVycm9yUmVzdW1lTmV4dDxULCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBhcnJheTogT2JzZXJ2YWJsZUlucHV0PGFueT5bXSk6IE9ic2VydmFibGU8Uj47XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0PFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIC4uLm5leHRTb3VyY2VzOiBBcnJheTxPYnNlcnZhYmxlSW5wdXQ8YW55PiB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXk8T2JzZXJ2YWJsZUlucHV0PGFueT4+IHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKC4uLnZhbHVlczogQXJyYXk8YW55PikgPT4gUik+KTogT2JzZXJ2YWJsZTxSPiB7XG4gIGlmIChuZXh0U291cmNlcy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShuZXh0U291cmNlc1swXSkpIHtcbiAgICBuZXh0U291cmNlcyA9IDxBcnJheTxPYnNlcnZhYmxlPGFueT4+Pm5leHRTb3VyY2VzWzBdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgT25FcnJvclJlc3VtZU5leHRPcGVyYXRvcjxULCBSPihuZXh0U291cmNlcykpO1xufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmV4cG9ydCBmdW5jdGlvbiBvbkVycm9yUmVzdW1lTmV4dFN0YXRpYzxSPih2OiBPYnNlcnZhYmxlSW5wdXQ8Uj4pOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0U3RhdGljPFQyLCBUMywgUj4odjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+KTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiBvbkVycm9yUmVzdW1lTmV4dFN0YXRpYzxUMiwgVDMsIFQ0LCBSPih2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+KTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiBvbkVycm9yUmVzdW1lTmV4dFN0YXRpYzxUMiwgVDMsIFQ0LCBUNSwgUj4odjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCB2NDogT2JzZXJ2YWJsZUlucHV0PFQ0PiwgdjU6IE9ic2VydmFibGVJbnB1dDxUNT4pOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0U3RhdGljPFQyLCBUMywgVDQsIFQ1LCBUNiwgUj4odjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCB2NDogT2JzZXJ2YWJsZUlucHV0PFQ0PiwgdjU6IE9ic2VydmFibGVJbnB1dDxUNT4sIHY2OiBPYnNlcnZhYmxlSW5wdXQ8VDY+KTogT2JzZXJ2YWJsZTxSPjtcblxuZXhwb3J0IGZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0U3RhdGljPFI+KC4uLm9ic2VydmFibGVzOiBBcnJheTxPYnNlcnZhYmxlSW5wdXQ8YW55PiB8ICgoLi4udmFsdWVzOiBBcnJheTxhbnk+KSA9PiBSKT4pOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIG9uRXJyb3JSZXN1bWVOZXh0U3RhdGljPFI+KGFycmF5OiBPYnNlcnZhYmxlSW5wdXQ8YW55PltdKTogT2JzZXJ2YWJsZTxSPjtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbmV4cG9ydCBmdW5jdGlvbiBvbkVycm9yUmVzdW1lTmV4dFN0YXRpYzxULCBSPiguLi5uZXh0U291cmNlczogQXJyYXk8T2JzZXJ2YWJsZUlucHV0PGFueT4gfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheTxPYnNlcnZhYmxlSW5wdXQ8YW55Pj4gfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKC4uLnZhbHVlczogQXJyYXk8YW55PikgPT4gUik+KTogT2JzZXJ2YWJsZTxSPiB7XG4gIGxldCBzb3VyY2U6IE9ic2VydmFibGVJbnB1dDxhbnk+ID0gbnVsbDtcblxuICBpZiAobmV4dFNvdXJjZXMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobmV4dFNvdXJjZXNbMF0pKSB7XG4gICAgbmV4dFNvdXJjZXMgPSA8QXJyYXk8T2JzZXJ2YWJsZUlucHV0PGFueT4+Pm5leHRTb3VyY2VzWzBdO1xuICB9XG4gIHNvdXJjZSA9IG5leHRTb3VyY2VzLnNoaWZ0KCk7XG5cbiAgcmV0dXJuIG5ldyBGcm9tT2JzZXJ2YWJsZShzb3VyY2UsIG51bGwpLmxpZnQobmV3IE9uRXJyb3JSZXN1bWVOZXh0T3BlcmF0b3I8VCwgUj4obmV4dFNvdXJjZXMpKTtcbn1cblxuY2xhc3MgT25FcnJvclJlc3VtZU5leHRPcGVyYXRvcjxULCBSPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFI+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBuZXh0U291cmNlczogQXJyYXk8T2JzZXJ2YWJsZUlucHV0PGFueT4+KSB7XG4gIH1cblxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8Uj4sIHNvdXJjZTogYW55KTogYW55IHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgT25FcnJvclJlc3VtZU5leHRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubmV4dFNvdXJjZXMpKTtcbiAgfVxufVxuXG5jbGFzcyBPbkVycm9yUmVzdW1lTmV4dFN1YnNjcmliZXI8VCwgUj4gZXh0ZW5kcyBPdXRlclN1YnNjcmliZXI8VCwgUj4ge1xuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZGVzdGluYXRpb246IFN1YnNjcmliZXI8VD4sXG4gICAgICAgICAgICAgIHByaXZhdGUgbmV4dFNvdXJjZXM6IEFycmF5PE9ic2VydmFibGVJbnB1dDxhbnk+Pikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIG5vdGlmeUVycm9yKGVycm9yOiBhbnksIGlubmVyU3ViOiBJbm5lclN1YnNjcmliZXI8VCwgYW55Pik6IHZvaWQge1xuICAgIHRoaXMuc3Vic2NyaWJlVG9OZXh0U291cmNlKCk7XG4gIH1cblxuICBub3RpZnlDb21wbGV0ZShpbm5lclN1YjogSW5uZXJTdWJzY3JpYmVyPFQsIGFueT4pOiB2b2lkIHtcbiAgICB0aGlzLnN1YnNjcmliZVRvTmV4dFNvdXJjZSgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9lcnJvcihlcnI6IGFueSk6IHZvaWQge1xuICAgIHRoaXMuc3Vic2NyaWJlVG9OZXh0U291cmNlKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbXBsZXRlKCk6IHZvaWQge1xuICAgIHRoaXMuc3Vic2NyaWJlVG9OZXh0U291cmNlKCk7XG4gIH1cblxuICBwcml2YXRlIHN1YnNjcmliZVRvTmV4dFNvdXJjZSgpOiB2b2lkIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5uZXh0U291cmNlcy5zaGlmdCgpO1xuICAgIGlmIChuZXh0KSB7XG4gICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBuZXh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3Ivb25FcnJvclJlc3VtZU5leHQudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi4vdXRpbC9pc0FycmF5JztcbmltcG9ydCB7IEFycmF5T2JzZXJ2YWJsZSB9IGZyb20gJy4uL29ic2VydmFibGUvQXJyYXlPYnNlcnZhYmxlJztcbmltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBUZWFyZG93bkxvZ2ljIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE91dGVyU3Vic2NyaWJlciB9IGZyb20gJy4uL091dGVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBJbm5lclN1YnNjcmliZXIgfSBmcm9tICcuLi9Jbm5lclN1YnNjcmliZXInO1xuaW1wb3J0IHsgc3Vic2NyaWJlVG9SZXN1bHQgfSBmcm9tICcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0JztcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5leHBvcnQgZnVuY3Rpb24gcmFjZTxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCAuLi5vYnNlcnZhYmxlczogQXJyYXk8T2JzZXJ2YWJsZTxUPiB8IEFycmF5PE9ic2VydmFibGU8VD4+Pik6IE9ic2VydmFibGU8VD47XG5leHBvcnQgZnVuY3Rpb24gcmFjZTxULCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCAuLi5vYnNlcnZhYmxlczogQXJyYXk8T2JzZXJ2YWJsZTxhbnk+IHwgQXJyYXk8T2JzZXJ2YWJsZTxUPj4+KTogT2JzZXJ2YWJsZTxSPjtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgZmlyc3Qgc291cmNlIE9ic2VydmFibGUgdG8gZW1pdCBhbiBpdGVtXG4gKiBmcm9tIHRoZSBjb21iaW5hdGlvbiBvZiB0aGlzIE9ic2VydmFibGUgYW5kIHN1cHBsaWVkIE9ic2VydmFibGVzLlxuICogQHBhcmFtIHsuLi5PYnNlcnZhYmxlc30gLi4ub2JzZXJ2YWJsZXMgU291cmNlcyB1c2VkIHRvIHJhY2UgZm9yIHdoaWNoIE9ic2VydmFibGUgZW1pdHMgZmlyc3QuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgb3V0cHV0IG9mIHRoZSBmaXJzdCBPYnNlcnZhYmxlIHRvIGVtaXQgYW4gaXRlbS5cbiAqIEBtZXRob2QgcmFjZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhY2U8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgLi4ub2JzZXJ2YWJsZXM6IEFycmF5PE9ic2VydmFibGU8VD4gfCBBcnJheTxPYnNlcnZhYmxlPFQ+Pj4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgLy8gaWYgdGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gYXJyYXksIGl0IHdhcyBtb3N0IGxpa2VseSBjYWxsZWQgd2l0aFxuICAvLyBgcGFpcihbb2JzMSwgb2JzMiwgLi4uXSlgXG4gIGlmIChvYnNlcnZhYmxlcy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShvYnNlcnZhYmxlc1swXSkpIHtcbiAgICBvYnNlcnZhYmxlcyA9IDxBcnJheTxPYnNlcnZhYmxlPFQ+Pj5vYnNlcnZhYmxlc1swXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmxpZnQuY2FsbChyYWNlU3RhdGljPFQ+KHRoaXMsIC4uLm9ic2VydmFibGVzKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgZmlyc3Qgc291cmNlIE9ic2VydmFibGUgdG8gZW1pdCBhbiBpdGVtLlxuICogQHBhcmFtIHsuLi5PYnNlcnZhYmxlc30gLi4ub2JzZXJ2YWJsZXMgc291cmNlcyB1c2VkIHRvIHJhY2UgZm9yIHdoaWNoIE9ic2VydmFibGUgZW1pdHMgZmlyc3QuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBhbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgb3V0cHV0IG9mIHRoZSBmaXJzdCBPYnNlcnZhYmxlIHRvIGVtaXQgYW4gaXRlbS5cbiAqIEBzdGF0aWMgdHJ1ZVxuICogQG5hbWUgcmFjZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhY2VTdGF0aWM8VD4oLi4ub2JzZXJ2YWJsZXM6IEFycmF5PE9ic2VydmFibGU8VD4gfCBBcnJheTxPYnNlcnZhYmxlPFQ+Pj4pOiBPYnNlcnZhYmxlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIHJhY2VTdGF0aWM8VD4oLi4ub2JzZXJ2YWJsZXM6IEFycmF5PE9ic2VydmFibGU8YW55PiB8IEFycmF5PE9ic2VydmFibGU8YW55Pj4+KTogT2JzZXJ2YWJsZTxUPiB7XG4gIC8vIGlmIHRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIGFycmF5LCBpdCB3YXMgbW9zdCBsaWtlbHkgY2FsbGVkIHdpdGhcbiAgLy8gYHBhaXIoW29iczEsIG9iczIsIC4uLl0pYFxuICBpZiAob2JzZXJ2YWJsZXMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGlzQXJyYXkob2JzZXJ2YWJsZXNbMF0pKSB7XG4gICAgICBvYnNlcnZhYmxlcyA9IDxBcnJheTxPYnNlcnZhYmxlPGFueT4+Pm9ic2VydmFibGVzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gPE9ic2VydmFibGU8YW55Pj5vYnNlcnZhYmxlc1swXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IEFycmF5T2JzZXJ2YWJsZTxUPig8YW55Pm9ic2VydmFibGVzKS5saWZ0KG5ldyBSYWNlT3BlcmF0b3I8VD4oKSk7XG59XG5cbmV4cG9ydCBjbGFzcyBSYWNlT3BlcmF0b3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUPiB7XG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPiwgc291cmNlOiBhbnkpOiBUZWFyZG93bkxvZ2ljIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgUmFjZVN1YnNjcmliZXIoc3Vic2NyaWJlcikpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5leHBvcnQgY2xhc3MgUmFjZVN1YnNjcmliZXI8VD4gZXh0ZW5kcyBPdXRlclN1YnNjcmliZXI8VCwgVD4ge1xuICBwcml2YXRlIGhhc0ZpcnN0OiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgb2JzZXJ2YWJsZXM6IE9ic2VydmFibGU8YW55PltdID0gW107XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxUPikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dChvYnNlcnZhYmxlOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLm9ic2VydmFibGVzLnB1c2gob2JzZXJ2YWJsZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbXBsZXRlKCkge1xuICAgIGNvbnN0IG9ic2VydmFibGVzID0gdGhpcy5vYnNlcnZhYmxlcztcbiAgICBjb25zdCBsZW4gPSBvYnNlcnZhYmxlcy5sZW5ndGg7XG5cbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuICYmICF0aGlzLmhhc0ZpcnN0OyBpKyspIHtcbiAgICAgICAgbGV0IG9ic2VydmFibGUgPSBvYnNlcnZhYmxlc1tpXTtcbiAgICAgICAgbGV0IHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG9ic2VydmFibGUsIG9ic2VydmFibGUsIGkpO1xuXG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkKHN1YnNjcmlwdGlvbik7XG4gICAgICB9XG4gICAgICB0aGlzLm9ic2VydmFibGVzID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBub3RpZnlOZXh0KG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IFQsXG4gICAgICAgICAgICAgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICAgaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBUPik6IHZvaWQge1xuICAgIGlmICghdGhpcy5oYXNGaXJzdCkge1xuICAgICAgdGhpcy5oYXNGaXJzdCA9IHRydWU7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpICE9PSBvdXRlckluZGV4KSB7XG4gICAgICAgICAgbGV0IHN1YnNjcmlwdGlvbiA9IHRoaXMuc3Vic2NyaXB0aW9uc1tpXTtcblxuICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIHRoaXMucmVtb3ZlKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvcmFjZS50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgSVNjaGVkdWxlciB9IGZyb20gJy4uL1NjaGVkdWxlcic7XG5pbXBvcnQgeyBhc3luYyB9IGZyb20gJy4uL3NjaGVkdWxlci9hc3luYyc7XG5cbi8qKlxuICogQHBhcmFtIHNjaGVkdWxlclxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUaW1lSW50ZXJ2YWw8YW55Pj58V2ViU29ja2V0U3ViamVjdDxUPnxPYnNlcnZhYmxlPFQ+fVxuICogQG1ldGhvZCB0aW1lSW50ZXJ2YWxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aW1lSW50ZXJ2YWw8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgc2NoZWR1bGVyOiBJU2NoZWR1bGVyID0gYXN5bmMpOiBPYnNlcnZhYmxlPFRpbWVJbnRlcnZhbDxUPj4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBUaW1lSW50ZXJ2YWxPcGVyYXRvcihzY2hlZHVsZXIpKTtcbn1cblxuZXhwb3J0IGNsYXNzIFRpbWVJbnRlcnZhbDxUPiB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB2YWx1ZTogVCwgcHVibGljIGludGVydmFsOiBudW1iZXIpIHtcblxuICB9XG59O1xuXG5jbGFzcyBUaW1lSW50ZXJ2YWxPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFRpbWVJbnRlcnZhbDxUPj4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNjaGVkdWxlcjogSVNjaGVkdWxlcikge1xuXG4gIH1cblxuICBjYWxsKG9ic2VydmVyOiBTdWJzY3JpYmVyPFRpbWVJbnRlcnZhbDxUPj4sIHNvdXJjZTogYW55KTogYW55IHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGltZUludGVydmFsU3Vic2NyaWJlcihvYnNlcnZlciwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgVGltZUludGVydmFsU3Vic2NyaWJlcjxUPiBleHRlbmRzIFN1YnNjcmliZXI8VD4ge1xuICBwcml2YXRlIGxhc3RUaW1lOiBudW1iZXIgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFRpbWVJbnRlcnZhbDxUPj4sIHByaXZhdGUgc2NoZWR1bGVyOiBJU2NoZWR1bGVyKSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuXG4gICAgdGhpcy5sYXN0VGltZSA9IHNjaGVkdWxlci5ub3coKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCkge1xuICAgIGxldCBub3cgPSB0aGlzLnNjaGVkdWxlci5ub3coKTtcbiAgICBsZXQgc3BhbiA9IG5vdyAtIHRoaXMubGFzdFRpbWU7XG4gICAgdGhpcy5sYXN0VGltZSA9IG5vdztcblxuICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChuZXcgVGltZUludGVydmFsKHZhbHVlLCBzcGFuKSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvdGltZUludGVydmFsLnRzIiwiaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBJU2NoZWR1bGVyIH0gZnJvbSAnLi4vU2NoZWR1bGVyJztcbmltcG9ydCB7IGFzeW5jIH0gZnJvbSAnLi4vc2NoZWR1bGVyL2FzeW5jJztcblxuLyoqXG4gKiBAcGFyYW0gc2NoZWR1bGVyXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRpbWVzdGFtcDxhbnk+PnxXZWJTb2NrZXRTdWJqZWN0PFQ+fE9ic2VydmFibGU8VD59XG4gKiBAbWV0aG9kIHRpbWVzdGFtcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVzdGFtcDxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBzY2hlZHVsZXI6IElTY2hlZHVsZXIgPSBhc3luYyk6IE9ic2VydmFibGU8VGltZXN0YW1wPFQ+PiB7XG4gIHJldHVybiB0aGlzLmxpZnQobmV3IFRpbWVzdGFtcE9wZXJhdG9yKHNjaGVkdWxlcikpO1xufVxuXG5leHBvcnQgY2xhc3MgVGltZXN0YW1wPFQ+IHtcbiAgY29uc3RydWN0b3IocHVibGljIHZhbHVlOiBULCBwdWJsaWMgdGltZXN0YW1wOiBudW1iZXIpIHtcbiAgfVxufTtcblxuY2xhc3MgVGltZXN0YW1wT3BlcmF0b3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUaW1lc3RhbXA8VD4+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzY2hlZHVsZXI6IElTY2hlZHVsZXIpIHtcbiAgfVxuXG4gIGNhbGwob2JzZXJ2ZXI6IFN1YnNjcmliZXI8VGltZXN0YW1wPFQ+Piwgc291cmNlOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUaW1lc3RhbXBTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLnNjaGVkdWxlcikpO1xuICB9XG59XG5cbmNsYXNzIFRpbWVzdGFtcFN1YnNjcmliZXI8VD4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8VGltZXN0YW1wPFQ+PiwgcHJpdmF0ZSBzY2hlZHVsZXI6IElTY2hlZHVsZXIpIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpOiB2b2lkIHtcbiAgICBjb25zdCBub3cgPSB0aGlzLnNjaGVkdWxlci5ub3coKTtcblxuICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChuZXcgVGltZXN0YW1wKHZhbHVlLCBub3cpKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci90aW1lc3RhbXAudHMiLCJpbXBvcnQgeyBBc3luY0FjdGlvbiB9IGZyb20gJy4vQXN5bmNBY3Rpb24nO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IEFzeW5jU2NoZWR1bGVyIH0gZnJvbSAnLi9Bc3luY1NjaGVkdWxlcic7XG5cbmV4cG9ydCBjbGFzcyBWaXJ0dWFsVGltZVNjaGVkdWxlciBleHRlbmRzIEFzeW5jU2NoZWR1bGVyIHtcblxuICBwcm90ZWN0ZWQgc3RhdGljIGZyYW1lVGltZUZhY3RvcjogbnVtYmVyID0gMTA7XG5cbiAgcHVibGljIGZyYW1lOiBudW1iZXIgPSAwO1xuICBwdWJsaWMgaW5kZXg6IG51bWJlciA9IC0xO1xuXG4gIGNvbnN0cnVjdG9yKFNjaGVkdWxlckFjdGlvbjogdHlwZW9mIEFzeW5jQWN0aW9uID0gVmlydHVhbEFjdGlvbixcbiAgICAgICAgICAgICAgcHVibGljIG1heEZyYW1lczogbnVtYmVyID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgc3VwZXIoU2NoZWR1bGVyQWN0aW9uLCAoKSA9PiB0aGlzLmZyYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9tcHQgdGhlIFNjaGVkdWxlciB0byBleGVjdXRlIGFsbCBvZiBpdHMgcXVldWVkIGFjdGlvbnMsIHRoZXJlZm9yZVxuICAgKiBjbGVhcmluZyBpdHMgcXVldWUuXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBwdWJsaWMgZmx1c2goKTogdm9pZCB7XG5cbiAgICBjb25zdCB7YWN0aW9ucywgbWF4RnJhbWVzfSA9IHRoaXM7XG4gICAgbGV0IGVycm9yOiBhbnksIGFjdGlvbjogQXN5bmNBY3Rpb248YW55PjtcblxuICAgIHdoaWxlICgoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKSAmJiAodGhpcy5mcmFtZSA9IGFjdGlvbi5kZWxheSkgPD0gbWF4RnJhbWVzKSB7XG4gICAgICBpZiAoZXJyb3IgPSBhY3Rpb24uZXhlY3V0ZShhY3Rpb24uc3RhdGUsIGFjdGlvbi5kZWxheSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB3aGlsZSAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKSB7XG4gICAgICAgIGFjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5leHBvcnQgY2xhc3MgVmlydHVhbEFjdGlvbjxUPiBleHRlbmRzIEFzeW5jQWN0aW9uPFQ+IHtcblxuICBwcm90ZWN0ZWQgYWN0aXZlOiBib29sZWFuID0gdHJ1ZTtcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgc2NoZWR1bGVyOiBWaXJ0dWFsVGltZVNjaGVkdWxlcixcbiAgICAgICAgICAgICAgcHJvdGVjdGVkIHdvcms6ICh0aGlzOiBWaXJ0dWFsQWN0aW9uPFQ+LCBzdGF0ZT86IFQpID0+IHZvaWQsXG4gICAgICAgICAgICAgIHByb3RlY3RlZCBpbmRleDogbnVtYmVyID0gc2NoZWR1bGVyLmluZGV4ICs9IDEpIHtcbiAgICBzdXBlcihzY2hlZHVsZXIsIHdvcmspO1xuICAgIHRoaXMuaW5kZXggPSBzY2hlZHVsZXIuaW5kZXggPSBpbmRleDtcbiAgfVxuXG4gIHB1YmxpYyBzY2hlZHVsZShzdGF0ZT86IFQsIGRlbGF5OiBudW1iZXIgPSAwKTogU3Vic2NyaXB0aW9uIHtcbiAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgIHJldHVybiBzdXBlci5zY2hlZHVsZShzdGF0ZSwgZGVsYXkpO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIC8vIElmIGFuIGFjdGlvbiBpcyByZXNjaGVkdWxlZCwgd2Ugc2F2ZSBhbGxvY2F0aW9ucyBieSBtdXRhdGluZyBpdHMgc3RhdGUsXG4gICAgLy8gcHVzaGluZyBpdCB0byB0aGUgZW5kIG9mIHRoZSBzY2hlZHVsZXIgcXVldWUsIGFuZCByZWN5Y2xpbmcgdGhlIGFjdGlvbi5cbiAgICAvLyBCdXQgc2luY2UgdGhlIFZpcnR1YWxUaW1lU2NoZWR1bGVyIGlzIHVzZWQgZm9yIHRlc3RpbmcsIFZpcnR1YWxBY3Rpb25zXG4gICAgLy8gbXVzdCBiZSBpbW11dGFibGUgc28gdGhleSBjYW4gYmUgaW5zcGVjdGVkIGxhdGVyLlxuICAgIGNvbnN0IGFjdGlvbiA9IG5ldyBWaXJ0dWFsQWN0aW9uKHRoaXMuc2NoZWR1bGVyLCB0aGlzLndvcmspO1xuICAgIHRoaXMuYWRkKGFjdGlvbik7XG4gICAgcmV0dXJuIGFjdGlvbi5zY2hlZHVsZShzdGF0ZSwgZGVsYXkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlcXVlc3RBc3luY0lkKHNjaGVkdWxlcjogVmlydHVhbFRpbWVTY2hlZHVsZXIsIGlkPzogYW55LCBkZWxheTogbnVtYmVyID0gMCk6IGFueSB7XG4gICAgdGhpcy5kZWxheSA9IHNjaGVkdWxlci5mcmFtZSArIGRlbGF5O1xuICAgIGNvbnN0IHthY3Rpb25zfSA9IHNjaGVkdWxlcjtcbiAgICBhY3Rpb25zLnB1c2godGhpcyk7XG4gICAgYWN0aW9ucy5zb3J0KFZpcnR1YWxBY3Rpb24uc29ydEFjdGlvbnMpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlY3ljbGVBc3luY0lkKHNjaGVkdWxlcjogVmlydHVhbFRpbWVTY2hlZHVsZXIsIGlkPzogYW55LCBkZWxheTogbnVtYmVyID0gMCk6IGFueSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHByb3RlY3RlZCBfZXhlY3V0ZShzdGF0ZTogVCwgZGVsYXk6IG51bWJlcik6IGFueSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gc3VwZXIuX2V4ZWN1dGUoc3RhdGUsIGRlbGF5KTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIHNvcnRBY3Rpb25zPFQ+KGE6IFZpcnR1YWxBY3Rpb248VD4sIGI6IFZpcnR1YWxBY3Rpb248VD4pIHtcbiAgICBpZiAoYS5kZWxheSA9PT0gYi5kZWxheSkge1xuICAgICAgaWYgKGEuaW5kZXggPT09IGIuaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IGVsc2UgaWYgKGEuaW5kZXggPiBiLmluZGV4KSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYS5kZWxheSA+IGIuZGVsYXkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3NjaGVkdWxlci9WaXJ0dWFsVGltZVNjaGVkdWxlci50cyIsImltcG9ydCB7IEFzYXBBY3Rpb24gfSBmcm9tICcuL0FzYXBBY3Rpb24nO1xuaW1wb3J0IHsgQXNhcFNjaGVkdWxlciB9IGZyb20gJy4vQXNhcFNjaGVkdWxlcic7XG5cbi8qKlxuICpcbiAqIEFzYXAgU2NoZWR1bGVyXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlBlcmZvcm0gdGFzayBhcyBmYXN0IGFzIGl0IGNhbiBiZSBwZXJmb3JtZWQgYXN5bmNocm9ub3VzbHk8L3NwYW4+XG4gKlxuICogYGFzYXBgIHNjaGVkdWxlciBiZWhhdmVzIHRoZSBzYW1lIGFzIHtAbGluayBhc3luY30gc2NoZWR1bGVyIHdoZW4geW91IHVzZSBpdCB0byBkZWxheSB0YXNrXG4gKiBpbiB0aW1lLiBJZiBob3dldmVyIHlvdSBzZXQgZGVsYXkgdG8gYDBgLCBgYXNhcGAgd2lsbCB3YWl0IGZvciBjdXJyZW50IHN5bmNocm9ub3VzbHkgZXhlY3V0aW5nXG4gKiBjb2RlIHRvIGVuZCBhbmQgdGhlbiBpdCB3aWxsIHRyeSB0byBleGVjdXRlIGdpdmVuIHRhc2sgYXMgZmFzdCBhcyBwb3NzaWJsZS5cbiAqXG4gKiBgYXNhcGAgc2NoZWR1bGVyIHdpbGwgZG8gaXRzIGJlc3QgdG8gbWluaW1pemUgdGltZSBiZXR3ZWVuIGVuZCBvZiBjdXJyZW50bHkgZXhlY3V0aW5nIGNvZGVcbiAqIGFuZCBzdGFydCBvZiBzY2hlZHVsZWQgdGFzay4gVGhpcyBtYWtlcyBpdCBiZXN0IGNhbmRpZGF0ZSBmb3IgcGVyZm9ybWluZyBzbyBjYWxsZWQgXCJkZWZlcnJpbmdcIi5cbiAqIFRyYWRpdGlvbmFsbHkgdGhpcyB3YXMgYWNoaWV2ZWQgYnkgY2FsbGluZyBgc2V0VGltZW91dChkZWZlcnJlZFRhc2ssIDApYCwgYnV0IHRoYXQgdGVjaG5pcXVlIGludm9sdmVzXG4gKiBzb21lIChhbHRob3VnaCBtaW5pbWFsKSB1bndhbnRlZCBkZWxheS5cbiAqXG4gKiBOb3RlIHRoYXQgdXNpbmcgYGFzYXBgIHNjaGVkdWxlciBkb2VzIG5vdCBuZWNlc3NhcmlseSBtZWFuIHRoYXQgeW91ciB0YXNrIHdpbGwgYmUgZmlyc3QgdG8gcHJvY2Vzc1xuICogYWZ0ZXIgY3VycmVudGx5IGV4ZWN1dGluZyBjb2RlLiBJbiBwYXJ0aWN1bGFyLCBpZiBzb21lIHRhc2sgd2FzIGFsc28gc2NoZWR1bGVkIHdpdGggYGFzYXBgIGJlZm9yZSxcbiAqIHRoYXQgdGFzayB3aWxsIGV4ZWN1dGUgZmlyc3QuIFRoYXQgYmVpbmcgc2FpZCwgaWYgeW91IG5lZWQgdG8gc2NoZWR1bGUgdGFzayBhc3luY2hyb25vdXNseSwgYnV0XG4gKiBhcyBzb29uIGFzIHBvc3NpYmxlLCBgYXNhcGAgc2NoZWR1bGVyIGlzIHlvdXIgYmVzdCBiZXQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29tcGFyZSBhc3luYyBhbmQgYXNhcCBzY2hlZHVsZXI8L2NhcHRpb24+XG4gKlxuICogUnguU2NoZWR1bGVyLmFzeW5jLnNjaGVkdWxlKCgpID0+IGNvbnNvbGUubG9nKCdhc3luYycpKTsgLy8gc2NoZWR1bGluZyAnYXN5bmMnIGZpcnN0Li4uXG4gKiBSeC5TY2hlZHVsZXIuYXNhcC5zY2hlZHVsZSgoKSA9PiBjb25zb2xlLmxvZygnYXNhcCcpKTtcbiAqXG4gKiAvLyBMb2dzOlxuICogLy8gXCJhc2FwXCJcbiAqIC8vIFwiYXN5bmNcIlxuICogLy8gLi4uIGJ1dCAnYXNhcCcgZ29lcyBmaXJzdCFcbiAqXG4gKiBAc3RhdGljIHRydWVcbiAqIEBuYW1lIGFzYXBcbiAqIEBvd25lciBTY2hlZHVsZXJcbiAqL1xuXG5leHBvcnQgY29uc3QgYXNhcCA9IG5ldyBBc2FwU2NoZWR1bGVyKEFzYXBBY3Rpb24pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9zY2hlZHVsZXIvYXNhcC50cyIsImltcG9ydCB7IFF1ZXVlQWN0aW9uIH0gZnJvbSAnLi9RdWV1ZUFjdGlvbic7XG5pbXBvcnQgeyBRdWV1ZVNjaGVkdWxlciB9IGZyb20gJy4vUXVldWVTY2hlZHVsZXInO1xuXG4vKipcbiAqXG4gKiBRdWV1ZSBTY2hlZHVsZXJcbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+UHV0IGV2ZXJ5IG5leHQgdGFzayBvbiBhIHF1ZXVlLCBpbnN0ZWFkIG9mIGV4ZWN1dGluZyBpdCBpbW1lZGlhdGVseTwvc3Bhbj5cbiAqXG4gKiBgcXVldWVgIHNjaGVkdWxlciwgd2hlbiB1c2VkIHdpdGggZGVsYXksIGJlaGF2ZXMgdGhlIHNhbWUgYXMge0BsaW5rIGFzeW5jfSBzY2hlZHVsZXIuXG4gKlxuICogV2hlbiB1c2VkIHdpdGhvdXQgZGVsYXksIGl0IHNjaGVkdWxlcyBnaXZlbiB0YXNrIHN5bmNocm9ub3VzbHkgLSBleGVjdXRlcyBpdCByaWdodCB3aGVuXG4gKiBpdCBpcyBzY2hlZHVsZWQuIEhvd2V2ZXIgd2hlbiBjYWxsZWQgcmVjdXJzaXZlbHksIHRoYXQgaXMgd2hlbiBpbnNpZGUgdGhlIHNjaGVkdWxlZCB0YXNrLFxuICogYW5vdGhlciB0YXNrIGlzIHNjaGVkdWxlZCB3aXRoIHF1ZXVlIHNjaGVkdWxlciwgaW5zdGVhZCBvZiBleGVjdXRpbmcgaW1tZWRpYXRlbHkgYXMgd2VsbCxcbiAqIHRoYXQgdGFzayB3aWxsIGJlIHB1dCBvbiBhIHF1ZXVlIGFuZCB3YWl0IGZvciBjdXJyZW50IG9uZSB0byBmaW5pc2guXG4gKlxuICogVGhpcyBtZWFucyB0aGF0IHdoZW4geW91IGV4ZWN1dGUgdGFzayB3aXRoIGBxdWV1ZWAgc2NoZWR1bGVyLCB5b3UgYXJlIHN1cmUgaXQgd2lsbCBlbmRcbiAqIGJlZm9yZSBhbnkgb3RoZXIgdGFzayBzY2hlZHVsZWQgd2l0aCB0aGF0IHNjaGVkdWxlciB3aWxsIHN0YXJ0LlxuICpcbiAqIEBleGFtcGxlcyA8Y2FwdGlvbj5TY2hlZHVsZSByZWN1cnNpdmVseSBmaXJzdCwgdGhlbiBkbyBzb21ldGhpbmc8L2NhcHRpb24+XG4gKlxuICogUnguU2NoZWR1bGVyLnF1ZXVlLnNjaGVkdWxlKCgpID0+IHtcbiAqICAgUnguU2NoZWR1bGVyLnF1ZXVlLnNjaGVkdWxlKCgpID0+IGNvbnNvbGUubG9nKCdzZWNvbmQnKSk7IC8vIHdpbGwgbm90IGhhcHBlbiBub3csIGJ1dCB3aWxsIGJlIHB1dCBvbiBhIHF1ZXVlXG4gKlxuICogICBjb25zb2xlLmxvZygnZmlyc3QnKTtcbiAqIH0pO1xuICpcbiAqIC8vIExvZ3M6XG4gKiAvLyBcImZpcnN0XCJcbiAqIC8vIFwic2Vjb25kXCJcbiAqXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmVzY2hlZHVsZSBpdHNlbGYgcmVjdXJzaXZlbHk8L2NhcHRpb24+XG4gKlxuICogUnguU2NoZWR1bGVyLnF1ZXVlLnNjaGVkdWxlKGZ1bmN0aW9uKHN0YXRlKSB7XG4gKiAgIGlmIChzdGF0ZSAhPT0gMCkge1xuICogICAgIGNvbnNvbGUubG9nKCdiZWZvcmUnLCBzdGF0ZSk7XG4gKiAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSAtIDEpOyAvLyBgdGhpc2AgcmVmZXJlbmNlcyBjdXJyZW50bHkgZXhlY3V0aW5nIEFjdGlvbixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdlIHJlc2NoZWR1bGUgd2l0aCBuZXcgc3RhdGVcbiAqICAgICBjb25zb2xlLmxvZygnYWZ0ZXInLCBzdGF0ZSk7XG4gKiAgIH1cbiAqIH0sIDAsIDMpO1xuICpcbiAqIC8vIEluIHNjaGVkdWxlciB0aGF0IHJ1bnMgcmVjdXJzaXZlbHksIHlvdSB3b3VsZCBleHBlY3Q6XG4gKiAvLyBcImJlZm9yZVwiLCAzXG4gKiAvLyBcImJlZm9yZVwiLCAyXG4gKiAvLyBcImJlZm9yZVwiLCAxXG4gKiAvLyBcImFmdGVyXCIsIDFcbiAqIC8vIFwiYWZ0ZXJcIiwgMlxuICogLy8gXCJhZnRlclwiLCAzXG4gKlxuICogLy8gQnV0IHdpdGggcXVldWUgaXQgbG9nczpcbiAqIC8vIFwiYmVmb3JlXCIsIDNcbiAqIC8vIFwiYWZ0ZXJcIiwgM1xuICogLy8gXCJiZWZvcmVcIiwgMlxuICogLy8gXCJhZnRlclwiLCAyXG4gKiAvLyBcImJlZm9yZVwiLCAxXG4gKiAvLyBcImFmdGVyXCIsIDFcbiAqXG4gKlxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSBxdWV1ZVxuICogQG93bmVyIFNjaGVkdWxlclxuICovXG5cbmV4cG9ydCBjb25zdCBxdWV1ZSA9IG5ldyBRdWV1ZVNjaGVkdWxlcihRdWV1ZUFjdGlvbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3NjaGVkdWxlci9xdWV1ZS50cyIsImV4cG9ydCBjbGFzcyBTdWJzY3JpcHRpb25Mb2cge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgc3Vic2NyaWJlZEZyYW1lOiBudW1iZXIsXG4gICAgICAgICAgICAgIHB1YmxpYyB1bnN1YnNjcmliZWRGcmFtZTogbnVtYmVyID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3Rlc3RpbmcvU3Vic2NyaXB0aW9uTG9nLnRzIiwiaW1wb3J0IHsgU2NoZWR1bGVyIH0gZnJvbSAnLi4vU2NoZWR1bGVyJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbkxvZyB9IGZyb20gJy4vU3Vic2NyaXB0aW9uTG9nJztcblxuZXhwb3J0IGNsYXNzIFN1YnNjcmlwdGlvbkxvZ2dhYmxlIHtcbiAgcHVibGljIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbkxvZ1tdID0gW107XG4gIHNjaGVkdWxlcjogU2NoZWR1bGVyO1xuXG4gIGxvZ1N1YnNjcmliZWRGcmFtZSgpOiBudW1iZXIge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKG5ldyBTdWJzY3JpcHRpb25Mb2codGhpcy5zY2hlZHVsZXIubm93KCkpKTtcbiAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aCAtIDE7XG4gIH1cblxuICBsb2dVbnN1YnNjcmliZWRGcmFtZShpbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uTG9ncyA9IHRoaXMuc3Vic2NyaXB0aW9ucztcbiAgICBjb25zdCBvbGRTdWJzY3JpcHRpb25Mb2cgPSBzdWJzY3JpcHRpb25Mb2dzW2luZGV4XTtcbiAgICBzdWJzY3JpcHRpb25Mb2dzW2luZGV4XSA9IG5ldyBTdWJzY3JpcHRpb25Mb2coXG4gICAgICBvbGRTdWJzY3JpcHRpb25Mb2cuc3Vic2NyaWJlZEZyYW1lLFxuICAgICAgdGhpcy5zY2hlZHVsZXIubm93KClcbiAgICApO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3Rlc3RpbmcvU3Vic2NyaXB0aW9uTG9nZ2FibGUudHMiLCIvKipcclxuICogQW4gZXJyb3IgdGhyb3duIHdoZW4gZHVldGltZSBlbGFwc2VzLlxyXG4gKlxyXG4gKiBAc2VlIHtAbGluayB0aW1lb3V0fVxyXG4gKlxyXG4gKiBAY2xhc3MgVGltZW91dEVycm9yXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgY29uc3QgZXJyOiBhbnkgPSBzdXBlcignVGltZW91dCBoYXMgb2NjdXJyZWQnKTtcclxuICAgICg8YW55PiB0aGlzKS5uYW1lID0gZXJyLm5hbWUgPSAnVGltZW91dEVycm9yJztcclxuICAgICg8YW55PiB0aGlzKS5zdGFjayA9IGVyci5zdGFjaztcclxuICAgICg8YW55PiB0aGlzKS5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XHJcbiAgfVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvdXRpbC9UaW1lb3V0RXJyb3IudHMiLCIvKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIG9uZSBvciBtb3JlIGVycm9ycyBoYXZlIG9jY3VycmVkIGR1cmluZyB0aGVcbiAqIGB1bnN1YnNjcmliZWAgb2YgYSB7QGxpbmsgU3Vic2NyaXB0aW9ufS5cbiAqL1xuZXhwb3J0IGNsYXNzIFVuc3Vic2NyaXB0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBlcnJvcnM6IGFueVtdKSB7XG4gICAgc3VwZXIoKTtcbiAgICBjb25zdCBlcnI6IGFueSA9IEVycm9yLmNhbGwodGhpcywgZXJyb3JzID9cbiAgICAgIGAke2Vycm9ycy5sZW5ndGh9IGVycm9ycyBvY2N1cnJlZCBkdXJpbmcgdW5zdWJzY3JpcHRpb246XG4gICR7ZXJyb3JzLm1hcCgoZXJyLCBpKSA9PiBgJHtpICsgMX0pICR7ZXJyLnRvU3RyaW5nKCl9YCkuam9pbignXFxuICAnKX1gIDogJycpO1xuICAgICg8YW55PiB0aGlzKS5uYW1lID0gZXJyLm5hbWUgPSAnVW5zdWJzY3JpcHRpb25FcnJvcic7XG4gICAgKDxhbnk+IHRoaXMpLnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICg8YW55PiB0aGlzKS5tZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvdXRpbC9VbnN1YnNjcmlwdGlvbkVycm9yLnRzIiwiZXhwb3J0IGZ1bmN0aW9uIGFwcGx5TWl4aW5zKGRlcml2ZWRDdG9yOiBhbnksIGJhc2VDdG9yczogYW55W10pIHtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGJhc2VDdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGJhc2VDdG9yID0gYmFzZUN0b3JzW2ldO1xuICAgIGNvbnN0IHByb3BlcnR5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGJhc2VDdG9yLnByb3RvdHlwZSk7XG4gICAgZm9yIChsZXQgaiA9IDAsIGxlbjIgPSBwcm9wZXJ0eUtleXMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICBjb25zdCBuYW1lID0gcHJvcGVydHlLZXlzW2pdO1xuICAgICAgZGVyaXZlZEN0b3IucHJvdG90eXBlW25hbWVdID0gYmFzZUN0b3IucHJvdG90eXBlW25hbWVdO1xuICAgIH1cbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvdXRpbC9hcHBseU1peGlucy50cyIsImV4cG9ydCBjb25zdCBpc0FycmF5TGlrZSA9ICg8VD4oeDogYW55KTogeCBpcyBBcnJheUxpa2U8VD4gPT4geCAmJiB0eXBlb2YgeC5sZW5ndGggPT09ICdudW1iZXInKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3V0aWwvaXNBcnJheUxpa2UudHMiLCJleHBvcnQgZnVuY3Rpb24gaXNPYmplY3QoeDogYW55KTogeCBpcyBPYmplY3Qge1xuICByZXR1cm4geCAhPSBudWxsICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0Jztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvdXRpbC9pc09iamVjdC50cyIsImV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2U8VD4odmFsdWU6IGFueSB8IFByb21pc2U8VD4pOiB2YWx1ZSBpcyBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiAoPGFueT52YWx1ZSkuc3Vic2NyaWJlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiAodmFsdWUgYXMgYW55KS50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy91dGlsL2lzUHJvbWlzZS50cyIsIi8qIHRzbGludDpkaXNhYmxlOm5vLWVtcHR5ICovXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHsgfVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy91dGlsL25vb3AudHMiLCJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSA2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgUnggZnJvbSAncnhqcy9SeCc7XG5jb25zdCBjb2xvcnMgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTldO1xuY29uc3QgbmFtZSA9IFsnYmx1ZScsICdyZWQnLCAneWVsbG93JywgJ2dyZWVuJywgJ2JsYWNrJywgJ3doaXRlJywgJ2dyYXknLCAncGluaycsICcjM0QyNjJBJywgJyMxMjdDNTYnXTtcbmNvbnN0IG5hbWVMaXN0ID0gW1xuICAgIHsgc3JjOiAnLi9pbWFnZXMvMS5qcGcnLCBuYW1lOiAn5Y+y6ICD54m5JyB9LFxuICAgIHsgc3JjOiAnLi9pbWFnZXMvMi5qcGcnLCBuYW1lOiAn56uL5ra1JyB9LFxuICAgIHsgc3JjOiAnLi9pbWFnZXMvMy5qcGcnLCBuYW1lOiAn5YWI6LGqJyB9LFxuICAgIHsgc3JjOiAnLi9pbWFnZXMvNC5qcGcnLCBuYW1lOiAn6L6w6LGqJyB9LFxuICAgIHsgc3JjOiAnLi9pbWFnZXMvNS5qcGcnLCBuYW1lOiAn562x5ra1JyB9LFxuICAgIHsgc3JjOiAnLi9pbWFnZXMvNi5qcGcnLCBuYW1lOiAn5aOr6LGqJyB9LFxuICAgIHsgc3JjOiAnLi9pbWFnZXMvNy5qcGcnLCBuYW1lOiAn6YSt56uL5paHJyB9LFxuICAgIHsgc3JjOiAnLi9pbWFnZXMvOC5qcGcnLCBuYW1lOiAn5aSn5a+25ZOlJyB9LFxuICAgIHsgc3JjOiAnLi9pbWFnZXMvOS5qcGcnLCBuYW1lOiAn56WQ6KqgJyB9LFxuICAgIHsgc3JjOiAnLi9pbWFnZXMvMTAuanBnJywgbmFtZTogJ+e2reWwvCcgfSxcbiAgICB7IHNyYzogJy4vaW1hZ2VzLzEuanBnJywgbmFtZTogJ+WPsuiAg+eJuScgfSxcbiAgICB7IHNyYzogJy4vaW1hZ2VzLzIuanBnJywgbmFtZTogJ+eri+a2tScgfSxcbiAgICB7IHNyYzogJy4vaW1hZ2VzLzMuanBnJywgbmFtZTogJ+WFiOixqicgfSxcbiAgICB7IHNyYzogJy4vaW1hZ2VzLzQuanBnJywgbmFtZTogJ+i+sOixqicgfSxcbiAgICB7IHNyYzogJy4vaW1hZ2VzLzUuanBnJywgbmFtZTogJ+etsea2tScgfSxcbiAgICB7IHNyYzogJy4vaW1hZ2VzLzYuanBnJywgbmFtZTogJ+Wjq+ixqicgfSxcbiAgICB7IHNyYzogJy4vaW1hZ2VzLzcuanBnJywgbmFtZTogJ+mEreeri+aWhycgfSxcbiAgICB7IHNyYzogJy4vaW1hZ2VzLzguanBnJywgbmFtZTogJ+Wkp+WvtuWTpScgfSxcbiAgICB7IHNyYzogJy4vaW1hZ2VzLzkuanBnJywgbmFtZTogJ+elkOiqoCcgfSxcbiAgICB7IHNyYzogJy4vaW1hZ2VzLzEwLmpwZycsIG5hbWU6ICfntq3lsLwnIH0sXG5dO1xuY29uc3Qgc3RhcnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXJtJyk7XG5jb25zdCBzdG9wID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0b3AnKTtcbmNvbnN0IHN0YXJ0Q2xpY2sgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChzdGFydCwgJ2NsaWNrJyk7XG5jb25zdCBzdG9wQ2xpY2sgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChzdG9wLCAnY2xpY2snKTtcbmNvbnN0IHRpbWVyID0gc3BlZWQgPT4gUnguT2JzZXJ2YWJsZS50aW1lcigxMDAgKyBzcGVlZCk7XG5jb25zdCBzb3VyY2UgPSBSYW5kb21OdW1iZXJzID0+IFJ4Lk9ic2VydmFibGVcbiAgICAuaW50ZXJ2YWwoMTAwKVxuICAgIC50YWtlKFJhbmRvbU51bWJlcnMpXG4gICAgLm1hcChlID0+IHRpbWVyKGUgKiAxMCkubWFwKCgpID0+IGUpKVxuICAgIC5jb25jYXRBbGwoKVxuICAgIC50YWtlVW50aWwoc3RvcENsaWNrKVxuICAgIC5kbyh7XG4gICAgICBuZXh0OiAoZSkgPT4ge1xuICAgICAgICAvLyBjb25zdCBzbG90ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjApO1xuICAgICAgICAvLyBjb25zdCB0b3AgPSAtc2xvdCAqIDMwMDtcbiAgICAgICAgY29uc3QgdG9wID0gZSAqIC0zMDA7XG4gICAgICAgIGlmICgkKCcjc2xvdG1hY2hpbmUgaW1nJykubGVuZ3RoIDwgNTApIHtcbiAgICAgICAgICBjb25zdCBpbWdFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgICAgaW1nRWxlbWVudC5zcmMgPSBuYW1lTGlzdFtlICUgMjBdLnNyYztcbiAgICAgICAgICBpbWdFbGVtZW50Lm5hbWUgPSBuYW1lTGlzdFtlICUgMjBdLm5hbWU7XG4gICAgICAgICAgaW1nRWxlbWVudC5jbGFzcyA9ICdjb2xvcic7XG4gICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Nsb3RtYWNoaW5lJykuYXBwZW5kQ2hpbGQoaW1nRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgVHdlZW5MaXRlLnRvKCQoJyNzbG90bWFjaGluZScpLCAyLjUsIHsgZWFzZTogQm91bmNlLmVhc2VPdXQsIHk6IHRvcCAtIDMwMCB9KTtcbiAgICAgICAgJCgnLmNvbG9yUmVkJykucmVtb3ZlQ2xhc3MoJ2NvbG9yUmVkJyk7XG4gICAgICAgIC8vIGNvbnN0IG1heE51bSA9IGU7XG4gICAgICAgIC8vIGNvbnN0IG1pbk51bSA9IDA7XG4gICAgICAgIC8vIGNvbnN0IGluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heE51bSAtIG1pbk51bSArIDEpKSArIG1pbk51bTtcbiAgICAgICAgLy8gJCgnI3JlZWwnKVswXS5zcmMgPSBuYW1lTGlzdFtpbmRleCAlIG5hbWVMaXN0Lmxlbmd0aF0uc3JjO1xuXG4gICAgICAgIC8vICQoYCNjaXJjbGVfMCR7Y29sb3JzW2luZGV4XX1gKS5hZGRDbGFzcygnY29sb3JSZWQnKTtcbiAgICAgICAgJChgI2NpcmNsZV8wJHtlICUgMjB9YCkuYWRkQ2xhc3MoJ2NvbG9yUmVkJyk7XG4gICAgICB9LFxuICAgICAgY29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgJCgnI2FybScpLnJlbW92ZUNsYXNzKCdkaXNhYmxlZEJ1dHRvbicpO1xuICAgICAgICAvLyBUd2VlbkxpdGUudG8oJCgnI3Nsb3RtYWNoaW5lJyksIDIuNSwgeyBlYXNlOiBCb3VuY2UuZWFzZU91dCwgeTogdG9wIH0pO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGFsZXJ0KCQoJy5jb2xvclJlZCcpWzBdLm5hbWUpLCAyNTAwKTtcbiAgICAgIH0sXG4gICAgfSk7XG5zdGFydENsaWNrXG4gIC5tYXAoKCkgPT4ge1xuICAgICQoJyNhcm0nKS5hZGRDbGFzcygnY2xpY2tlZCcpO1xuICAgICQoJyNhcm0nKVswXS5kaXNhYmxlZCA9IHRydWU7XG4gICAgLy9zZXRUaW1lb3V0KCgpID0+IHsgYXJtLnJlbW92ZUNsYXNzOyB9LCA1MDApO1xuICAgIFR3ZWVuTGl0ZS50bygkKCcjc2xvdG1hY2hpbmUnKSwgMC41LCB7IGVhc2U6IFBvd2VyMC5lYXNlTm9uZSwgeTogMCB9KTtcbiAgICBjb25zdCBSYW5kb21OdW1iZXJzID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApICsgMzA7XG4gICAgcmV0dXJuIHNvdXJjZShSYW5kb21OdW1iZXJzKTtcbiAgfSlcbiAgLmRlbGF5KDEwMDApXG4gIC5jb25jYXRBbGwoKVxuICAuc3Vic2NyaWJlKHtcbiAgICBuZXh0OiAoKSA9PiB7XG4gICAgICAkKCcjYXJtJykucmVtb3ZlQ2xhc3MoJ2NsaWNrZWQnKTtcbiAgICAgICQoJyNhcm0nKS5hZGRDbGFzcygnZGlzYWJsZWRCdXR0b24nKTtcbiAgICB9LFxuICAgIGNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAkKCcjYXJtJykucmVtb3ZlQ2xhc3MoJ2Rpc2FibGVkQnV0dG9uJyk7XG4gICAgfSxcbiAgfSlcbjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2NsaWVudC9sb3R0ZXJ5LmpzIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9wcm9jZXNzL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi9PdXRlclN1YnNjcmliZXInO1xuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuZXhwb3J0IGNsYXNzIElubmVyU3Vic2NyaWJlcjxULCBSPiBleHRlbmRzIFN1YnNjcmliZXI8Uj4ge1xuICBwcml2YXRlIGluZGV4OiBudW1iZXIgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcGFyZW50OiBPdXRlclN1YnNjcmliZXI8VCwgUj4sIHByaXZhdGUgb3V0ZXJWYWx1ZTogVCwgcHJpdmF0ZSBvdXRlckluZGV4OiBudW1iZXIpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHZhbHVlOiBSKTogdm9pZCB7XG4gICAgdGhpcy5wYXJlbnQubm90aWZ5TmV4dCh0aGlzLm91dGVyVmFsdWUsIHZhbHVlLCB0aGlzLm91dGVySW5kZXgsIHRoaXMuaW5kZXgrKywgdGhpcyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2Vycm9yKGVycm9yOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLnBhcmVudC5ub3RpZnlFcnJvcihlcnJvciwgdGhpcyk7XG4gICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jb21wbGV0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLnBhcmVudC5ub3RpZnlDb21wbGV0ZSh0aGlzKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvSW5uZXJTdWJzY3JpYmVyLnRzIiwiLyogdHNsaW50OmRpc2FibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXG4vLyBTdWJqZWN0IGltcG9ydGVkIGJlZm9yZSBPYnNlcnZhYmxlIHRvIGJ5cGFzcyBjaXJjdWxhciBkZXBlbmRlbmN5IGlzc3VlIHNpbmNlXG4vLyBTdWJqZWN0IGV4dGVuZHMgT2JzZXJ2YWJsZSBhbmQgT2JzZXJ2YWJsZSByZWZlcmVuY2VzIFN1YmplY3QgaW4gaXQnc1xuLy8gZGVmaW5pdGlvblxuZXhwb3J0IHtTdWJqZWN0LCBBbm9ueW1vdXNTdWJqZWN0fSBmcm9tICcuL1N1YmplY3QnO1xuLyogdHNsaW50OmVuYWJsZTpuby11bnVzZWQtdmFyaWFibGUgKi9cbmV4cG9ydCB7T2JzZXJ2YWJsZX0gZnJvbSAnLi9PYnNlcnZhYmxlJztcblxuLy8gc3RhdGljc1xuLyogdHNsaW50OmRpc2FibGU6bm8tdXNlLWJlZm9yZS1kZWNsYXJlICovXG5pbXBvcnQgJy4vYWRkL29ic2VydmFibGUvYmluZENhbGxiYWNrJztcbmltcG9ydCAnLi9hZGQvb2JzZXJ2YWJsZS9iaW5kTm9kZUNhbGxiYWNrJztcbmltcG9ydCAnLi9hZGQvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0JztcbmltcG9ydCAnLi9hZGQvb2JzZXJ2YWJsZS9jb25jYXQnO1xuaW1wb3J0ICcuL2FkZC9vYnNlcnZhYmxlL2RlZmVyJztcbmltcG9ydCAnLi9hZGQvb2JzZXJ2YWJsZS9lbXB0eSc7XG5pbXBvcnQgJy4vYWRkL29ic2VydmFibGUvZm9ya0pvaW4nO1xuaW1wb3J0ICcuL2FkZC9vYnNlcnZhYmxlL2Zyb20nO1xuaW1wb3J0ICcuL2FkZC9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5pbXBvcnQgJy4vYWRkL29ic2VydmFibGUvZnJvbUV2ZW50UGF0dGVybic7XG5pbXBvcnQgJy4vYWRkL29ic2VydmFibGUvZnJvbVByb21pc2UnO1xuaW1wb3J0ICcuL2FkZC9vYnNlcnZhYmxlL2dlbmVyYXRlJztcbmltcG9ydCAnLi9hZGQvb2JzZXJ2YWJsZS9pZic7XG5pbXBvcnQgJy4vYWRkL29ic2VydmFibGUvaW50ZXJ2YWwnO1xuaW1wb3J0ICcuL2FkZC9vYnNlcnZhYmxlL21lcmdlJztcbmltcG9ydCAnLi9hZGQvb2JzZXJ2YWJsZS9yYWNlJztcbmltcG9ydCAnLi9hZGQvb2JzZXJ2YWJsZS9uZXZlcic7XG5pbXBvcnQgJy4vYWRkL29ic2VydmFibGUvb2YnO1xuaW1wb3J0ICcuL2FkZC9vYnNlcnZhYmxlL29uRXJyb3JSZXN1bWVOZXh0JztcbmltcG9ydCAnLi9hZGQvb2JzZXJ2YWJsZS9wYWlycyc7XG5pbXBvcnQgJy4vYWRkL29ic2VydmFibGUvcmFuZ2UnO1xuaW1wb3J0ICcuL2FkZC9vYnNlcnZhYmxlL3VzaW5nJztcbmltcG9ydCAnLi9hZGQvb2JzZXJ2YWJsZS90aHJvdyc7XG5pbXBvcnQgJy4vYWRkL29ic2VydmFibGUvdGltZXInO1xuaW1wb3J0ICcuL2FkZC9vYnNlcnZhYmxlL3ppcCc7XG5cbi8vZG9tXG5pbXBvcnQgJy4vYWRkL29ic2VydmFibGUvZG9tL2FqYXgnO1xuaW1wb3J0ICcuL2FkZC9vYnNlcnZhYmxlL2RvbS93ZWJTb2NrZXQnO1xuXG4vL29wZXJhdG9yc1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9idWZmZXInO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9idWZmZXJDb3VudCc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL2J1ZmZlclRpbWUnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9idWZmZXJUb2dnbGUnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9idWZmZXJXaGVuJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvY2F0Y2gnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9jb21iaW5lQWxsJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvY29tYmluZUxhdGVzdCc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL2NvbmNhdCc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL2NvbmNhdEFsbCc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL2NvbmNhdE1hcCc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL2NvbmNhdE1hcFRvJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvY291bnQnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9kZW1hdGVyaWFsaXplJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvZGVib3VuY2UnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9kZWJvdW5jZVRpbWUnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9kZWZhdWx0SWZFbXB0eSc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL2RlbGF5JztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvZGVsYXlXaGVuJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvZGlzdGluY3QnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9kaXN0aW5jdFVudGlsQ2hhbmdlZCc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxLZXlDaGFuZ2VkJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvZG8nO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9leGhhdXN0JztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvZXhoYXVzdE1hcCc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL2V4cGFuZCc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL2VsZW1lbnRBdCc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL2ZpbHRlcic7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL2ZpbmFsbHknO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9maW5kJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvZmluZEluZGV4JztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvZmlyc3QnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9ncm91cEJ5JztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvaWdub3JlRWxlbWVudHMnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9pc0VtcHR5JztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvYXVkaXQnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9hdWRpdFRpbWUnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9sYXN0JztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvbGV0JztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvZXZlcnknO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9tYXAnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9tYXBUbyc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL21hdGVyaWFsaXplJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvbWF4JztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvbWVyZ2UnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9tZXJnZUFsbCc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL21lcmdlTWFwJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvbWVyZ2VNYXBUbyc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL21lcmdlU2Nhbic7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL21pbic7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL211bHRpY2FzdCc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL29ic2VydmVPbic7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL29uRXJyb3JSZXN1bWVOZXh0JztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvcGFpcndpc2UnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9wYXJ0aXRpb24nO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9wbHVjayc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL3B1Ymxpc2gnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9wdWJsaXNoQmVoYXZpb3InO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9wdWJsaXNoUmVwbGF5JztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvcHVibGlzaExhc3QnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9yYWNlJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvcmVkdWNlJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvcmVwZWF0JztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvcmVwZWF0V2hlbic7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL3JldHJ5JztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvcmV0cnlXaGVuJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3Ivc2FtcGxlJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3Ivc2FtcGxlVGltZSc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL3NjYW4nO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9zZXF1ZW5jZUVxdWFsJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3Ivc2hhcmUnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9zaW5nbGUnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9za2lwJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3Ivc2tpcFVudGlsJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3Ivc2tpcFdoaWxlJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3Ivc3RhcnRXaXRoJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3Ivc3Vic2NyaWJlT24nO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9zd2l0Y2gnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9zd2l0Y2hNYXAnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci9zd2l0Y2hNYXBUbyc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL3Rha2UnO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci90YWtlTGFzdCc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL3Rha2VVbnRpbCc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL3Rha2VXaGlsZSc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL3Rocm90dGxlJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvdGhyb3R0bGVUaW1lJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvdGltZUludGVydmFsJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvdGltZW91dCc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL3RpbWVvdXRXaXRoJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvdGltZXN0YW1wJztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3IvdG9BcnJheSc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL3RvUHJvbWlzZSc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL3dpbmRvdyc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL3dpbmRvd0NvdW50JztcbmltcG9ydCAnLi9hZGQvb3BlcmF0b3Ivd2luZG93VGltZSc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL3dpbmRvd1RvZ2dsZSc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL3dpbmRvd1doZW4nO1xuaW1wb3J0ICcuL2FkZC9vcGVyYXRvci93aXRoTGF0ZXN0RnJvbSc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL3ppcCc7XG5pbXBvcnQgJy4vYWRkL29wZXJhdG9yL3ppcEFsbCc7XG5cbi8qIHRzbGludDpkaXNhYmxlOm5vLXVudXNlZC12YXJpYWJsZSAqL1xuZXhwb3J0IHtPcGVyYXRvcn0gZnJvbSAnLi9PcGVyYXRvcic7XG5leHBvcnQge09ic2VydmVyfSBmcm9tICcuL09ic2VydmVyJztcbmV4cG9ydCB7U3Vic2NyaXB0aW9ufSBmcm9tICcuL1N1YnNjcmlwdGlvbic7XG5leHBvcnQge1N1YnNjcmliZXJ9IGZyb20gJy4vU3Vic2NyaWJlcic7XG5leHBvcnQge0FzeW5jU3ViamVjdH0gZnJvbSAnLi9Bc3luY1N1YmplY3QnO1xuZXhwb3J0IHtSZXBsYXlTdWJqZWN0fSBmcm9tICcuL1JlcGxheVN1YmplY3QnO1xuZXhwb3J0IHtCZWhhdmlvclN1YmplY3R9IGZyb20gJy4vQmVoYXZpb3JTdWJqZWN0JztcbmV4cG9ydCB7Q29ubmVjdGFibGVPYnNlcnZhYmxlfSBmcm9tICcuL29ic2VydmFibGUvQ29ubmVjdGFibGVPYnNlcnZhYmxlJztcbmV4cG9ydCB7Tm90aWZpY2F0aW9ufSBmcm9tICcuL05vdGlmaWNhdGlvbic7XG5leHBvcnQge0VtcHR5RXJyb3J9IGZyb20gJy4vdXRpbC9FbXB0eUVycm9yJztcbmV4cG9ydCB7QXJndW1lbnRPdXRPZlJhbmdlRXJyb3J9IGZyb20gJy4vdXRpbC9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcic7XG5leHBvcnQge09iamVjdFVuc3Vic2NyaWJlZEVycm9yfSBmcm9tICcuL3V0aWwvT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3InO1xuZXhwb3J0IHtUaW1lb3V0RXJyb3J9IGZyb20gJy4vdXRpbC9UaW1lb3V0RXJyb3InO1xuZXhwb3J0IHtVbnN1YnNjcmlwdGlvbkVycm9yfSBmcm9tICcuL3V0aWwvVW5zdWJzY3JpcHRpb25FcnJvcic7XG5leHBvcnQge1RpbWVJbnRlcnZhbH0gZnJvbSAnLi9vcGVyYXRvci90aW1lSW50ZXJ2YWwnO1xuZXhwb3J0IHtUaW1lc3RhbXB9IGZyb20gJy4vb3BlcmF0b3IvdGltZXN0YW1wJztcbmV4cG9ydCB7VGVzdFNjaGVkdWxlcn0gZnJvbSAnLi90ZXN0aW5nL1Rlc3RTY2hlZHVsZXInO1xuZXhwb3J0IHtWaXJ0dWFsVGltZVNjaGVkdWxlcn0gZnJvbSAnLi9zY2hlZHVsZXIvVmlydHVhbFRpbWVTY2hlZHVsZXInO1xuZXhwb3J0IHtBamF4UmVxdWVzdCwgQWpheFJlc3BvbnNlLCBBamF4RXJyb3IsIEFqYXhUaW1lb3V0RXJyb3J9IGZyb20gJy4vb2JzZXJ2YWJsZS9kb20vQWpheE9ic2VydmFibGUnO1xuXG5pbXBvcnQgeyBhc2FwIH0gZnJvbSAnLi9zY2hlZHVsZXIvYXNhcCc7XG5pbXBvcnQgeyBhc3luYyB9IGZyb20gJy4vc2NoZWR1bGVyL2FzeW5jJztcbmltcG9ydCB7IHF1ZXVlIH0gZnJvbSAnLi9zY2hlZHVsZXIvcXVldWUnO1xuaW1wb3J0IHsgYW5pbWF0aW9uRnJhbWUgfSBmcm9tICcuL3NjaGVkdWxlci9hbmltYXRpb25GcmFtZSc7XG5pbXBvcnQgeyBBc2FwU2NoZWR1bGVyIH0gZnJvbSAnLi9zY2hlZHVsZXIvQXNhcFNjaGVkdWxlcic7XG5pbXBvcnQgeyBBc3luY1NjaGVkdWxlciB9IGZyb20gJy4vc2NoZWR1bGVyL0FzeW5jU2NoZWR1bGVyJztcbmltcG9ydCB7IFF1ZXVlU2NoZWR1bGVyIH0gZnJvbSAnLi9zY2hlZHVsZXIvUXVldWVTY2hlZHVsZXInO1xuaW1wb3J0IHsgQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIgfSBmcm9tICcuL3NjaGVkdWxlci9BbmltYXRpb25GcmFtZVNjaGVkdWxlcic7XG5pbXBvcnQgeyByeFN1YnNjcmliZXIgfSBmcm9tICcuL3N5bWJvbC9yeFN1YnNjcmliZXInO1xuaW1wb3J0IHsgaXRlcmF0b3IgfSBmcm9tICcuL3N5bWJvbC9pdGVyYXRvcic7XG5pbXBvcnQgeyBvYnNlcnZhYmxlIH0gZnJvbSAnLi9zeW1ib2wvb2JzZXJ2YWJsZSc7XG5cbi8qIHRzbGludDplbmFibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUnguU2NoZWR1bGVyXG4gKiBAcHJvcGVydHkge1NjaGVkdWxlcn0gcXVldWUgU2NoZWR1bGVzIG9uIGEgcXVldWUgaW4gdGhlIGN1cnJlbnQgZXZlbnQgZnJhbWVcbiAqICh0cmFtcG9saW5lIHNjaGVkdWxlcikuIFVzZSB0aGlzIGZvciBpdGVyYXRpb24gb3BlcmF0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7U2NoZWR1bGVyfSBhc2FwIFNjaGVkdWxlcyBvbiB0aGUgbWljcm8gdGFzayBxdWV1ZSwgd2hpY2ggdXNlcyB0aGVcbiAqIGZhc3Rlc3QgdHJhbnNwb3J0IG1lY2hhbmlzbSBhdmFpbGFibGUsIGVpdGhlciBOb2RlLmpzJyBgcHJvY2Vzcy5uZXh0VGljaygpYFxuICogb3IgV2ViIFdvcmtlciBNZXNzYWdlQ2hhbm5lbCBvciBzZXRUaW1lb3V0IG9yIG90aGVycy4gVXNlIHRoaXMgZm9yXG4gKiBhc3luY2hyb25vdXMgY29udmVyc2lvbnMuXG4gKiBAcHJvcGVydHkge1NjaGVkdWxlcn0gYXN5bmMgU2NoZWR1bGVzIHdvcmsgd2l0aCBgc2V0SW50ZXJ2YWxgLiBVc2UgdGhpcyBmb3JcbiAqIHRpbWUtYmFzZWQgb3BlcmF0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7U2NoZWR1bGVyfSBhbmltYXRpb25GcmFtZSBTY2hlZHVsZXMgd29yayB3aXRoIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLlxuICogVXNlIHRoaXMgZm9yIHN5bmNocm9uaXppbmcgd2l0aCB0aGUgcGxhdGZvcm0ncyBwYWludGluZ1xuICovXG5sZXQgU2NoZWR1bGVyID0ge1xuICBhc2FwLFxuICBxdWV1ZSxcbiAgYW5pbWF0aW9uRnJhbWUsXG4gIGFzeW5jXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFJ4LlN5bWJvbFxuICogQHByb3BlcnR5IHtTeW1ib2x8c3RyaW5nfSByeFN1YnNjcmliZXIgQSBzeW1ib2wgdG8gdXNlIGFzIGEgcHJvcGVydHkgbmFtZSB0b1xuICogcmV0cmlldmUgYW4gXCJSeCBzYWZlXCIgT2JzZXJ2ZXIgZnJvbSBhbiBvYmplY3QuIFwiUnggc2FmZXR5XCIgY2FuIGJlIGRlZmluZWQgYXNcbiAqIGFuIG9iamVjdCB0aGF0IGhhcyBhbGwgb2YgdGhlIHRyYWl0cyBvZiBhbiBSeCBTdWJzY3JpYmVyLCBpbmNsdWRpbmcgdGhlXG4gKiBhYmlsaXR5IHRvIGFkZCBhbmQgcmVtb3ZlIHN1YnNjcmlwdGlvbnMgdG8gdGhlIHN1YnNjcmlwdGlvbiBjaGFpbiBhbmRcbiAqIGd1YXJhbnRlZXMgaW52b2x2aW5nIGV2ZW50IHRyaWdnZXJpbmcgKGNhbid0IFwibmV4dFwiIGFmdGVyIHVuc3Vic2NyaXB0aW9uLFxuICogZXRjKS5cbiAqIEBwcm9wZXJ0eSB7U3ltYm9sfHN0cmluZ30gb2JzZXJ2YWJsZSBBIHN5bWJvbCB0byB1c2UgYXMgYSBwcm9wZXJ0eSBuYW1lIHRvXG4gKiByZXRyaWV2ZSBhbiBPYnNlcnZhYmxlIGFzIGRlZmluZWQgYnkgdGhlIFtFQ01BU2NyaXB0IFwiT2JzZXJ2YWJsZVwiIHNwZWNdKGh0dHBzOi8vZ2l0aHViLmNvbS96ZW5wYXJzaW5nL2VzLW9ic2VydmFibGUpLlxuICogQHByb3BlcnR5IHtTeW1ib2x8c3RyaW5nfSBpdGVyYXRvciBUaGUgRVM2IHN5bWJvbCB0byB1c2UgYXMgYSBwcm9wZXJ0eSBuYW1lXG4gKiB0byByZXRyaWV2ZSBhbiBpdGVyYXRvciBmcm9tIGFuIG9iamVjdC5cbiAqL1xubGV0IFN5bWJvbCA9IHtcbiAgcnhTdWJzY3JpYmVyLFxuICBvYnNlcnZhYmxlLFxuICBpdGVyYXRvclxufTtcblxuZXhwb3J0IHtcbiAgICBTY2hlZHVsZXIsXG4gICAgU3ltYm9sXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9SeC50cyIsImltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4vc2NoZWR1bGVyL0FjdGlvbic7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuL1N1YnNjcmlwdGlvbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVNjaGVkdWxlciB7XG4gIG5vdygpOiBudW1iZXI7XG4gIHNjaGVkdWxlPFQ+KHdvcms6ICh0aGlzOiBBY3Rpb248VD4sIHN0YXRlPzogVCkgPT4gdm9pZCwgZGVsYXk/OiBudW1iZXIsIHN0YXRlPzogVCk6IFN1YnNjcmlwdGlvbjtcbn1cbi8qKlxuICogQW4gZXhlY3V0aW9uIGNvbnRleHQgYW5kIGEgZGF0YSBzdHJ1Y3R1cmUgdG8gb3JkZXIgdGFza3MgYW5kIHNjaGVkdWxlIHRoZWlyXG4gKiBleGVjdXRpb24uIFByb3ZpZGVzIGEgbm90aW9uIG9mIChwb3RlbnRpYWxseSB2aXJ0dWFsKSB0aW1lLCB0aHJvdWdoIHRoZVxuICogYG5vdygpYCBnZXR0ZXIgbWV0aG9kLlxuICpcbiAqIEVhY2ggdW5pdCBvZiB3b3JrIGluIGEgU2NoZWR1bGVyIGlzIGNhbGxlZCBhbiB7QGxpbmsgQWN0aW9ufS5cbiAqXG4gKiBgYGB0c1xuICogY2xhc3MgU2NoZWR1bGVyIHtcbiAqICAgbm93KCk6IG51bWJlcjtcbiAqICAgc2NoZWR1bGUod29yaywgZGVsYXk/LCBzdGF0ZT8pOiBTdWJzY3JpcHRpb247XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAY2xhc3MgU2NoZWR1bGVyXG4gKi9cbmV4cG9ydCBjbGFzcyBTY2hlZHVsZXIgaW1wbGVtZW50cyBJU2NoZWR1bGVyIHtcblxuICBwdWJsaWMgc3RhdGljIG5vdzogKCkgPT4gbnVtYmVyID0gRGF0ZS5ub3cgPyBEYXRlLm5vdyA6ICgpID0+ICtuZXcgRGF0ZSgpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgU2NoZWR1bGVyQWN0aW9uOiB0eXBlb2YgQWN0aW9uLFxuICAgICAgICAgICAgICBub3c6ICgpID0+IG51bWJlciA9IFNjaGVkdWxlci5ub3cpIHtcbiAgICB0aGlzLm5vdyA9IG5vdztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIGdldHRlciBtZXRob2QgdGhhdCByZXR1cm5zIGEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCB0aW1lXG4gICAqIChhdCB0aGUgdGltZSB0aGlzIGZ1bmN0aW9uIHdhcyBjYWxsZWQpIGFjY29yZGluZyB0byB0aGUgc2NoZWR1bGVyJ3Mgb3duXG4gICAqIGludGVybmFsIGNsb2NrLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEEgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCB0aW1lLiBNYXkgb3IgbWF5IG5vdFxuICAgKiBoYXZlIGEgcmVsYXRpb24gdG8gd2FsbC1jbG9jayB0aW1lLiBNYXkgb3IgbWF5IG5vdCByZWZlciB0byBhIHRpbWUgdW5pdFxuICAgKiAoZS5nLiBtaWxsaXNlY29uZHMpLlxuICAgKi9cbiAgcHVibGljIG5vdzogKCkgPT4gbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgYSBmdW5jdGlvbiwgYHdvcmtgLCBmb3IgZXhlY3V0aW9uLiBNYXkgaGFwcGVuIGF0IHNvbWUgcG9pbnQgaW5cbiAgICogdGhlIGZ1dHVyZSwgYWNjb3JkaW5nIHRvIHRoZSBgZGVsYXlgIHBhcmFtZXRlciwgaWYgc3BlY2lmaWVkLiBNYXkgYmUgcGFzc2VkXG4gICAqIHNvbWUgY29udGV4dCBvYmplY3QsIGBzdGF0ZWAsIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBgd29ya2AgZnVuY3Rpb24uXG4gICAqXG4gICAqIFRoZSBnaXZlbiBhcmd1bWVudHMgd2lsbCBiZSBwcm9jZXNzZWQgYW4gc3RvcmVkIGFzIGFuIEFjdGlvbiBvYmplY3QgaW4gYVxuICAgKiBxdWV1ZSBvZiBhY3Rpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHN0YXRlOiA/VCk6ID9TdWJzY3JpcHRpb259IHdvcmsgQSBmdW5jdGlvbiByZXByZXNlbnRpbmcgYVxuICAgKiB0YXNrLCBvciBzb21lIHVuaXQgb2Ygd29yayB0byBiZSBleGVjdXRlZCBieSB0aGUgU2NoZWR1bGVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbGF5XSBUaW1lIHRvIHdhaXQgYmVmb3JlIGV4ZWN1dGluZyB0aGUgd29yaywgd2hlcmUgdGhlXG4gICAqIHRpbWUgdW5pdCBpcyBpbXBsaWNpdCBhbmQgZGVmaW5lZCBieSB0aGUgU2NoZWR1bGVyIGl0c2VsZi5cbiAgICogQHBhcmFtIHtUfSBbc3RhdGVdIFNvbWUgY29udGV4dHVhbCBkYXRhIHRoYXQgdGhlIGB3b3JrYCBmdW5jdGlvbiB1c2VzIHdoZW5cbiAgICogY2FsbGVkIGJ5IHRoZSBTY2hlZHVsZXIuXG4gICAqIEByZXR1cm4ge1N1YnNjcmlwdGlvbn0gQSBzdWJzY3JpcHRpb24gaW4gb3JkZXIgdG8gYmUgYWJsZSB0byB1bnN1YnNjcmliZVxuICAgKiB0aGUgc2NoZWR1bGVkIHdvcmsuXG4gICAqL1xuICBwdWJsaWMgc2NoZWR1bGU8VD4od29yazogKHRoaXM6IEFjdGlvbjxUPiwgc3RhdGU/OiBUKSA9PiB2b2lkLCBkZWxheTogbnVtYmVyID0gMCwgc3RhdGU/OiBUKTogU3Vic2NyaXB0aW9uIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuU2NoZWR1bGVyQWN0aW9uPFQ+KHRoaXMsIHdvcmspLnNjaGVkdWxlKHN0YXRlLCBkZWxheSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvU2NoZWR1bGVyLnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgYmluZENhbGxiYWNrIGFzIHN0YXRpY0JpbmRDYWxsYmFjayB9IGZyb20gJy4uLy4uL29ic2VydmFibGUvYmluZENhbGxiYWNrJztcblxuT2JzZXJ2YWJsZS5iaW5kQ2FsbGJhY2sgPSBzdGF0aWNCaW5kQ2FsbGJhY2s7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIG5hbWVzcGFjZSBPYnNlcnZhYmxlIHtcbiAgICBleHBvcnQgbGV0IGJpbmRDYWxsYmFjazogdHlwZW9mIHN0YXRpY0JpbmRDYWxsYmFjaztcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb2JzZXJ2YWJsZS9iaW5kQ2FsbGJhY2sudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBiaW5kTm9kZUNhbGxiYWNrIGFzIHN0YXRpY0JpbmROb2RlQ2FsbGJhY2sgfSBmcm9tICcuLi8uLi9vYnNlcnZhYmxlL2JpbmROb2RlQ2FsbGJhY2snO1xuXG5PYnNlcnZhYmxlLmJpbmROb2RlQ2FsbGJhY2sgPSBzdGF0aWNCaW5kTm9kZUNhbGxiYWNrO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBuYW1lc3BhY2UgT2JzZXJ2YWJsZSB7XG4gICAgZXhwb3J0IGxldCBiaW5kTm9kZUNhbGxiYWNrOiB0eXBlb2Ygc3RhdGljQmluZE5vZGVDYWxsYmFjaztcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29ic2VydmFibGUvYmluZE5vZGVDYWxsYmFjay50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGNvbWJpbmVMYXRlc3QgYXMgY29tYmluZUxhdGVzdFN0YXRpYyB9IGZyb20gJy4uLy4uL29ic2VydmFibGUvY29tYmluZUxhdGVzdCc7XG5cbk9ic2VydmFibGUuY29tYmluZUxhdGVzdCA9IGNvbWJpbmVMYXRlc3RTdGF0aWM7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIG5hbWVzcGFjZSBPYnNlcnZhYmxlIHtcbiAgICBleHBvcnQgbGV0IGNvbWJpbmVMYXRlc3Q6IHR5cGVvZiBjb21iaW5lTGF0ZXN0U3RhdGljO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0LnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgY29uY2F0IGFzIGNvbmNhdFN0YXRpYyB9IGZyb20gJy4uLy4uL29ic2VydmFibGUvY29uY2F0JztcblxuT2JzZXJ2YWJsZS5jb25jYXQgPSBjb25jYXRTdGF0aWM7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIG5hbWVzcGFjZSBPYnNlcnZhYmxlIHtcbiAgICBleHBvcnQgbGV0IGNvbmNhdDogdHlwZW9mIGNvbmNhdFN0YXRpYztcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29ic2VydmFibGUvY29uY2F0LnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZGVmZXIgYXMgc3RhdGljRGVmZXIgfSBmcm9tICcuLi8uLi9vYnNlcnZhYmxlL2RlZmVyJztcblxuT2JzZXJ2YWJsZS5kZWZlciA9IHN0YXRpY0RlZmVyO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBuYW1lc3BhY2UgT2JzZXJ2YWJsZSB7XG4gICAgZXhwb3J0IGxldCBkZWZlcjogdHlwZW9mIHN0YXRpY0RlZmVyO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb2JzZXJ2YWJsZS9kZWZlci50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGFqYXggYXMgc3RhdGljQWpheCB9IGZyb20gJy4uLy4uLy4uL29ic2VydmFibGUvZG9tL2FqYXgnO1xuaW1wb3J0IHsgQWpheENyZWF0aW9uTWV0aG9kIH0gZnJvbSAnLi4vLi4vLi4vb2JzZXJ2YWJsZS9kb20vQWpheE9ic2VydmFibGUnO1xuXG5PYnNlcnZhYmxlLmFqYXggPSBzdGF0aWNBamF4O1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vLi4vT2JzZXJ2YWJsZScge1xuICBuYW1lc3BhY2UgT2JzZXJ2YWJsZSB7XG4gICAgZXhwb3J0IGxldCBhamF4OiBBamF4Q3JlYXRpb25NZXRob2Q7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL2RvbS9hamF4LnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgd2ViU29ja2V0IGFzIHN0YXRpY1dlYlNvY2tldCB9IGZyb20gJy4uLy4uLy4uL29ic2VydmFibGUvZG9tL3dlYlNvY2tldCc7XG5cbk9ic2VydmFibGUud2ViU29ja2V0ID0gc3RhdGljV2ViU29ja2V0O1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vLi4vT2JzZXJ2YWJsZScge1xuICBuYW1lc3BhY2UgT2JzZXJ2YWJsZSB7XG4gICAgZXhwb3J0IGxldCB3ZWJTb2NrZXQ6IHR5cGVvZiBzdGF0aWNXZWJTb2NrZXQ7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL2RvbS93ZWJTb2NrZXQudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBlbXB0eSBhcyBzdGF0aWNFbXB0eSB9IGZyb20gJy4uLy4uL29ic2VydmFibGUvZW1wdHknO1xuXG5PYnNlcnZhYmxlLmVtcHR5ID0gc3RhdGljRW1wdHk7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIG5hbWVzcGFjZSBPYnNlcnZhYmxlIHtcbiAgICBleHBvcnQgbGV0IGVtcHR5OiB0eXBlb2Ygc3RhdGljRW1wdHk7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL2VtcHR5LnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZm9ya0pvaW4gYXMgc3RhdGljRm9ya0pvaW4gfSBmcm9tICcuLi8uLi9vYnNlcnZhYmxlL2ZvcmtKb2luJztcblxuT2JzZXJ2YWJsZS5mb3JrSm9pbiA9IHN0YXRpY0ZvcmtKb2luO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBuYW1lc3BhY2UgT2JzZXJ2YWJsZSB7XG4gICAgZXhwb3J0IGxldCBmb3JrSm9pbjogdHlwZW9mIHN0YXRpY0ZvcmtKb2luO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb2JzZXJ2YWJsZS9mb3JrSm9pbi50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGZyb20gYXMgc3RhdGljRnJvbSB9IGZyb20gJy4uLy4uL29ic2VydmFibGUvZnJvbSc7XG5cbk9ic2VydmFibGUuZnJvbSA9IHN0YXRpY0Zyb207XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIG5hbWVzcGFjZSBPYnNlcnZhYmxlIHtcbiAgICBleHBvcnQgbGV0IGZyb206IHR5cGVvZiBzdGF0aWNGcm9tO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb2JzZXJ2YWJsZS9mcm9tLnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50IGFzIHN0YXRpY0Zyb21FdmVudCB9IGZyb20gJy4uLy4uL29ic2VydmFibGUvZnJvbUV2ZW50JztcblxuT2JzZXJ2YWJsZS5mcm9tRXZlbnQgPSBzdGF0aWNGcm9tRXZlbnQ7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIG5hbWVzcGFjZSBPYnNlcnZhYmxlIHtcbiAgICBleHBvcnQgbGV0IGZyb21FdmVudDogdHlwZW9mIHN0YXRpY0Zyb21FdmVudDtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29ic2VydmFibGUvZnJvbUV2ZW50LnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50UGF0dGVybiBhcyBzdGF0aWNGcm9tRXZlbnRQYXR0ZXJuIH0gZnJvbSAnLi4vLi4vb2JzZXJ2YWJsZS9mcm9tRXZlbnRQYXR0ZXJuJztcblxuT2JzZXJ2YWJsZS5mcm9tRXZlbnRQYXR0ZXJuID0gc3RhdGljRnJvbUV2ZW50UGF0dGVybjtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgbmFtZXNwYWNlIE9ic2VydmFibGUge1xuICAgIGV4cG9ydCBsZXQgZnJvbUV2ZW50UGF0dGVybjogdHlwZW9mIHN0YXRpY0Zyb21FdmVudFBhdHRlcm47XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL2Zyb21FdmVudFBhdHRlcm4udHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBmcm9tUHJvbWlzZSBhcyBzdGF0aWNGcm9tUHJvbWlzZSB9IGZyb20gJy4uLy4uL29ic2VydmFibGUvZnJvbVByb21pc2UnO1xuXG5PYnNlcnZhYmxlLmZyb21Qcm9taXNlID0gc3RhdGljRnJvbVByb21pc2U7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIG5hbWVzcGFjZSBPYnNlcnZhYmxlIHtcbiAgICBleHBvcnQgbGV0IGZyb21Qcm9taXNlOiB0eXBlb2Ygc3RhdGljRnJvbVByb21pc2U7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL2Zyb21Qcm9taXNlLnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgR2VuZXJhdGVPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vb2JzZXJ2YWJsZS9HZW5lcmF0ZU9ic2VydmFibGUnO1xuXG5PYnNlcnZhYmxlLmdlbmVyYXRlID0gR2VuZXJhdGVPYnNlcnZhYmxlLmNyZWF0ZTtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgbmFtZXNwYWNlIE9ic2VydmFibGUge1xuICAgIGV4cG9ydCBsZXQgZ2VuZXJhdGU6IHR5cGVvZiBHZW5lcmF0ZU9ic2VydmFibGUuY3JlYXRlO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb2JzZXJ2YWJsZS9nZW5lcmF0ZS50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IF9pZiB9IGZyb20gJy4uLy4uL29ic2VydmFibGUvaWYnO1xuXG5PYnNlcnZhYmxlLmlmID0gX2lmO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29ic2VydmFibGUvaWYudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBpbnRlcnZhbCBhcyBzdGF0aWNJbnRlcnZhbCB9IGZyb20gJy4uLy4uL29ic2VydmFibGUvaW50ZXJ2YWwnO1xuXG5PYnNlcnZhYmxlLmludGVydmFsID0gc3RhdGljSW50ZXJ2YWw7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIG5hbWVzcGFjZSBPYnNlcnZhYmxlIHtcbiAgICBleHBvcnQgbGV0IGludGVydmFsOiB0eXBlb2Ygc3RhdGljSW50ZXJ2YWw7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL2ludGVydmFsLnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgbWVyZ2UgYXMgbWVyZ2VTdGF0aWMgfSBmcm9tICcuLi8uLi9vYnNlcnZhYmxlL21lcmdlJztcblxuT2JzZXJ2YWJsZS5tZXJnZSA9IG1lcmdlU3RhdGljO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBuYW1lc3BhY2UgT2JzZXJ2YWJsZSB7XG4gICAgZXhwb3J0IGxldCBtZXJnZTogdHlwZW9mIG1lcmdlU3RhdGljO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb2JzZXJ2YWJsZS9tZXJnZS50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IG5ldmVyIGFzIHN0YXRpY05ldmVyIH0gZnJvbSAnLi4vLi4vb2JzZXJ2YWJsZS9uZXZlcic7XG5cbk9ic2VydmFibGUubmV2ZXIgPSBzdGF0aWNOZXZlcjtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgbmFtZXNwYWNlIE9ic2VydmFibGUge1xuICAgIGV4cG9ydCBsZXQgbmV2ZXI6IHR5cGVvZiBzdGF0aWNOZXZlcjtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29ic2VydmFibGUvbmV2ZXIudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBvZiBhcyBzdGF0aWNPZiB9IGZyb20gJy4uLy4uL29ic2VydmFibGUvb2YnO1xuXG5PYnNlcnZhYmxlLm9mID0gc3RhdGljT2Y7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIG5hbWVzcGFjZSBPYnNlcnZhYmxlIHtcbiAgICBleHBvcnQgbGV0IG9mOiB0eXBlb2Ygc3RhdGljT2Y7IC8vZm9ybU9mIGFuIGljZWJlcmchXG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL29mLnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xyXG5pbXBvcnQgeyBvbkVycm9yUmVzdW1lTmV4dFN0YXRpYyB9IGZyb20gJy4uLy4uL29wZXJhdG9yL29uRXJyb3JSZXN1bWVOZXh0JztcclxuXHJcbk9ic2VydmFibGUub25FcnJvclJlc3VtZU5leHQgPSBvbkVycm9yUmVzdW1lTmV4dFN0YXRpYztcclxuXHJcbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XHJcbiAgbmFtZXNwYWNlIE9ic2VydmFibGUge1xyXG4gICAgZXhwb3J0IGxldCBvbkVycm9yUmVzdW1lTmV4dDogdHlwZW9mIG9uRXJyb3JSZXN1bWVOZXh0U3RhdGljO1xyXG4gIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29ic2VydmFibGUvb25FcnJvclJlc3VtZU5leHQudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XHJcbmltcG9ydCB7IHBhaXJzIGFzIHN0YXRpY1BhaXJzIH0gZnJvbSAnLi4vLi4vb2JzZXJ2YWJsZS9wYWlycyc7XHJcblxyXG5PYnNlcnZhYmxlLnBhaXJzID0gc3RhdGljUGFpcnM7XHJcblxyXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xyXG4gIG5hbWVzcGFjZSBPYnNlcnZhYmxlIHtcclxuICAgIGV4cG9ydCBsZXQgcGFpcnM6IHR5cGVvZiBzdGF0aWNQYWlycztcclxuICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL3BhaXJzLnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgcmFjZVN0YXRpYyB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3JhY2UnO1xuXG5PYnNlcnZhYmxlLnJhY2UgPSByYWNlU3RhdGljO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBuYW1lc3BhY2UgT2JzZXJ2YWJsZSB7XG4gICAgZXhwb3J0IGxldCByYWNlOiB0eXBlb2YgcmFjZVN0YXRpYztcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29ic2VydmFibGUvcmFjZS50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHJhbmdlIGFzIHN0YXRpY1JhbmdlIH0gZnJvbSAnLi4vLi4vb2JzZXJ2YWJsZS9yYW5nZSc7XG5cbk9ic2VydmFibGUucmFuZ2UgPSBzdGF0aWNSYW5nZTtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgbmFtZXNwYWNlIE9ic2VydmFibGUge1xuICAgIGV4cG9ydCBsZXQgcmFuZ2U6IHR5cGVvZiBzdGF0aWNSYW5nZTtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29ic2VydmFibGUvcmFuZ2UudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBfdGhyb3cgfSBmcm9tICcuLi8uLi9vYnNlcnZhYmxlL3Rocm93JztcblxuT2JzZXJ2YWJsZS50aHJvdyA9IF90aHJvdztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vYnNlcnZhYmxlL3Rocm93LnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgdGltZXIgYXMgc3RhdGljVGltZXIgfSBmcm9tICcuLi8uLi9vYnNlcnZhYmxlL3RpbWVyJztcblxuT2JzZXJ2YWJsZS50aW1lciA9IHN0YXRpY1RpbWVyO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBuYW1lc3BhY2UgT2JzZXJ2YWJsZSB7XG4gICAgZXhwb3J0IGxldCB0aW1lcjogdHlwZW9mIHN0YXRpY1RpbWVyO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb2JzZXJ2YWJsZS90aW1lci50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHVzaW5nIGFzIHN0YXRpY1VzaW5nIH0gZnJvbSAnLi4vLi4vb2JzZXJ2YWJsZS91c2luZyc7XG5cbk9ic2VydmFibGUudXNpbmcgPSBzdGF0aWNVc2luZztcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgbmFtZXNwYWNlIE9ic2VydmFibGUge1xuICAgIGV4cG9ydCBsZXQgdXNpbmc6IHR5cGVvZiBzdGF0aWNVc2luZztcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29ic2VydmFibGUvdXNpbmcudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyB6aXAgYXMgemlwU3RhdGljIH0gZnJvbSAnLi4vLi4vb2JzZXJ2YWJsZS96aXAnO1xuXG5PYnNlcnZhYmxlLnppcCA9IHppcFN0YXRpYztcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgbmFtZXNwYWNlIE9ic2VydmFibGUge1xuICAgIGV4cG9ydCBsZXQgemlwOiB0eXBlb2YgemlwU3RhdGljO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb2JzZXJ2YWJsZS96aXAudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBhdWRpdCB9IGZyb20gJy4uLy4uL29wZXJhdG9yL2F1ZGl0JztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuYXVkaXQgPSBhdWRpdDtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIGF1ZGl0OiB0eXBlb2YgYXVkaXQ7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9hdWRpdC50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGF1ZGl0VGltZSB9IGZyb20gJy4uLy4uL29wZXJhdG9yL2F1ZGl0VGltZSc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLmF1ZGl0VGltZSA9IGF1ZGl0VGltZTtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIGF1ZGl0VGltZTogdHlwZW9mIGF1ZGl0VGltZTtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2F1ZGl0VGltZS50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgYnVmZmVyIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvYnVmZmVyJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuYnVmZmVyID0gYnVmZmVyO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgYnVmZmVyOiB0eXBlb2YgYnVmZmVyO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvYnVmZmVyLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBidWZmZXJDb3VudCB9IGZyb20gJy4uLy4uL29wZXJhdG9yL2J1ZmZlckNvdW50JztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuYnVmZmVyQ291bnQgPSBidWZmZXJDb3VudDtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIGJ1ZmZlckNvdW50OiB0eXBlb2YgYnVmZmVyQ291bnQ7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9idWZmZXJDb3VudC50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgYnVmZmVyVGltZSB9IGZyb20gJy4uLy4uL29wZXJhdG9yL2J1ZmZlclRpbWUnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5idWZmZXJUaW1lID0gYnVmZmVyVGltZTtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIGJ1ZmZlclRpbWU6IHR5cGVvZiBidWZmZXJUaW1lO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvYnVmZmVyVGltZS50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgYnVmZmVyVG9nZ2xlIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvYnVmZmVyVG9nZ2xlJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuYnVmZmVyVG9nZ2xlID0gYnVmZmVyVG9nZ2xlO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgYnVmZmVyVG9nZ2xlOiB0eXBlb2YgYnVmZmVyVG9nZ2xlO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvYnVmZmVyVG9nZ2xlLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBidWZmZXJXaGVuIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvYnVmZmVyV2hlbic7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLmJ1ZmZlcldoZW4gPSBidWZmZXJXaGVuO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgYnVmZmVyV2hlbjogdHlwZW9mIGJ1ZmZlcldoZW47XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9idWZmZXJXaGVuLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBfY2F0Y2ggfSBmcm9tICcuLi8uLi9vcGVyYXRvci9jYXRjaCc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLmNhdGNoID0gX2NhdGNoO1xuT2JzZXJ2YWJsZS5wcm90b3R5cGUuX2NhdGNoID0gX2NhdGNoO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgY2F0Y2g6IHR5cGVvZiBfY2F0Y2g7XG4gICAgX2NhdGNoOiB0eXBlb2YgX2NhdGNoO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvY2F0Y2gudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGNvbWJpbmVBbGwgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9jb21iaW5lQWxsJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29tYmluZUFsbCA9IGNvbWJpbmVBbGw7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBjb21iaW5lQWxsOiB0eXBlb2YgY29tYmluZUFsbDtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2NvbWJpbmVBbGwudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGNvbWJpbmVMYXRlc3QgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9jb21iaW5lTGF0ZXN0JztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29tYmluZUxhdGVzdCA9IGNvbWJpbmVMYXRlc3Q7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBjb21iaW5lTGF0ZXN0OiB0eXBlb2YgY29tYmluZUxhdGVzdDtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2NvbWJpbmVMYXRlc3QudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGNvbmNhdCB9IGZyb20gJy4uLy4uL29wZXJhdG9yL2NvbmNhdCc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLmNvbmNhdCA9IGNvbmNhdDtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIGNvbmNhdDogdHlwZW9mIGNvbmNhdDtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2NvbmNhdC50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgY29uY2F0QWxsIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvY29uY2F0QWxsJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuY29uY2F0QWxsID0gY29uY2F0QWxsO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgY29uY2F0QWxsOiB0eXBlb2YgY29uY2F0QWxsO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvY29uY2F0QWxsLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBjb25jYXRNYXAgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9jb25jYXRNYXAnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5jb25jYXRNYXAgPSBjb25jYXRNYXA7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBjb25jYXRNYXA6IHR5cGVvZiBjb25jYXRNYXA7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9jb25jYXRNYXAudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGNvbmNhdE1hcFRvIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvY29uY2F0TWFwVG8nO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5jb25jYXRNYXBUbyA9IGNvbmNhdE1hcFRvO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgY29uY2F0TWFwVG86IHR5cGVvZiBjb25jYXRNYXBUbztcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2NvbmNhdE1hcFRvLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBjb3VudCB9IGZyb20gJy4uLy4uL29wZXJhdG9yL2NvdW50JztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuY291bnQgPSBjb3VudDtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIGNvdW50OiB0eXBlb2YgY291bnQ7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9jb3VudC50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZGVib3VuY2UgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9kZWJvdW5jZSc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLmRlYm91bmNlID0gZGVib3VuY2U7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBkZWJvdW5jZTogdHlwZW9mIGRlYm91bmNlO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZGVib3VuY2UudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSB9IGZyb20gJy4uLy4uL29wZXJhdG9yL2RlYm91bmNlVGltZSc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLmRlYm91bmNlVGltZSA9IGRlYm91bmNlVGltZTtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIGRlYm91bmNlVGltZTogdHlwZW9mIGRlYm91bmNlVGltZTtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2RlYm91bmNlVGltZS50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZGVmYXVsdElmRW1wdHkgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9kZWZhdWx0SWZFbXB0eSc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLmRlZmF1bHRJZkVtcHR5ID0gZGVmYXVsdElmRW1wdHk7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBkZWZhdWx0SWZFbXB0eTogdHlwZW9mIGRlZmF1bHRJZkVtcHR5O1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZGVmYXVsdElmRW1wdHkudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGRlbGF5IH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvZGVsYXknO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5kZWxheSA9IGRlbGF5O1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgZGVsYXk6IHR5cGVvZiBkZWxheTtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2RlbGF5LnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBkZWxheVdoZW4gfSBmcm9tICcuLi8uLi9vcGVyYXRvci9kZWxheVdoZW4nO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5kZWxheVdoZW4gPSBkZWxheVdoZW47XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBkZWxheVdoZW46IHR5cGVvZiBkZWxheVdoZW47XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9kZWxheVdoZW4udHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGRlbWF0ZXJpYWxpemUgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9kZW1hdGVyaWFsaXplJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGVtYXRlcmlhbGl6ZSA9IGRlbWF0ZXJpYWxpemU7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBkZW1hdGVyaWFsaXplOiB0eXBlb2YgZGVtYXRlcmlhbGl6ZTtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2RlbWF0ZXJpYWxpemUudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBkaXN0aW5jdCB9IGZyb20gJy4uLy4uL29wZXJhdG9yL2Rpc3RpbmN0JztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZGlzdGluY3QgPSBkaXN0aW5jdDtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIGRpc3RpbmN0OiB0eXBlb2YgZGlzdGluY3Q7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9kaXN0aW5jdC50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9kaXN0aW5jdFVudGlsQ2hhbmdlZCc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLmRpc3RpbmN0VW50aWxDaGFuZ2VkID0gZGlzdGluY3RVbnRpbENoYW5nZWQ7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZDogdHlwZW9mIGRpc3RpbmN0VW50aWxDaGFuZ2VkO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZGlzdGluY3RVbnRpbENoYW5nZWQudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvZGlzdGluY3RVbnRpbEtleUNoYW5nZWQnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCA9IGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgZGlzdGluY3RVbnRpbEtleUNoYW5nZWQ6IHR5cGVvZiBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZDtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2Rpc3RpbmN0VW50aWxLZXlDaGFuZ2VkLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBfZG8gfSBmcm9tICcuLi8uLi9vcGVyYXRvci9kbyc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLmRvID0gX2RvO1xuT2JzZXJ2YWJsZS5wcm90b3R5cGUuX2RvID0gX2RvO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgZG86IHR5cGVvZiBfZG87XG4gICAgX2RvOiB0eXBlb2YgX2RvO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZG8udHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGVsZW1lbnRBdCB9IGZyb20gJy4uLy4uL29wZXJhdG9yL2VsZW1lbnRBdCc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLmVsZW1lbnRBdCA9IGVsZW1lbnRBdDtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIGVsZW1lbnRBdDogdHlwZW9mIGVsZW1lbnRBdDtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2VsZW1lbnRBdC50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZXZlcnkgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9ldmVyeSc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLmV2ZXJ5ID0gZXZlcnk7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBldmVyeTogdHlwZW9mIGV2ZXJ5O1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZXZlcnkudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGV4aGF1c3QgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9leGhhdXN0JztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZXhoYXVzdCA9IGV4aGF1c3Q7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBleGhhdXN0OiB0eXBlb2YgZXhoYXVzdDtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2V4aGF1c3QudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGV4aGF1c3RNYXAgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9leGhhdXN0TWFwJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZXhoYXVzdE1hcCA9IGV4aGF1c3RNYXA7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBleGhhdXN0TWFwOiB0eXBlb2YgZXhoYXVzdE1hcDtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2V4aGF1c3RNYXAudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGV4cGFuZCB9IGZyb20gJy4uLy4uL29wZXJhdG9yL2V4cGFuZCc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLmV4cGFuZCA9IGV4cGFuZDtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIGV4cGFuZDogdHlwZW9mIGV4cGFuZDtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2V4cGFuZC50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvZmlsdGVyJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmlsdGVyID0gZmlsdGVyO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgZmlsdGVyOiB0eXBlb2YgZmlsdGVyO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZmlsdGVyLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBfZmluYWxseSB9IGZyb20gJy4uLy4uL29wZXJhdG9yL2ZpbmFsbHknO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5maW5hbGx5ID0gX2ZpbmFsbHk7XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5fZmluYWxseSA9IF9maW5hbGx5O1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgZmluYWxseTogdHlwZW9mIF9maW5hbGx5O1xuICAgIF9maW5hbGx5OiB0eXBlb2YgX2ZpbmFsbHk7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9maW5hbGx5LnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBmaW5kIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvZmluZCc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLmZpbmQgPSBmaW5kO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgZmluZDogdHlwZW9mIGZpbmQ7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9maW5kLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBmaW5kSW5kZXggfSBmcm9tICcuLi8uLi9vcGVyYXRvci9maW5kSW5kZXgnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5maW5kSW5kZXggPSBmaW5kSW5kZXg7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBmaW5kSW5kZXg6IHR5cGVvZiBmaW5kSW5kZXg7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9maW5kSW5kZXgudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGZpcnN0IH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvZmlyc3QnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5maXJzdCA9IDxhbnk+Zmlyc3Q7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBmaXJzdDogdHlwZW9mIGZpcnN0O1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZmlyc3QudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGdyb3VwQnkgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9ncm91cEJ5JztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZ3JvdXBCeSA9IDxhbnk+Z3JvdXBCeTtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIGdyb3VwQnk6IHR5cGVvZiBncm91cEJ5O1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvZ3JvdXBCeS50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgaWdub3JlRWxlbWVudHMgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9pZ25vcmVFbGVtZW50cyc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLmlnbm9yZUVsZW1lbnRzID0gaWdub3JlRWxlbWVudHM7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBpZ25vcmVFbGVtZW50czogdHlwZW9mIGlnbm9yZUVsZW1lbnRzO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvaWdub3JlRWxlbWVudHMudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGlzRW1wdHkgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9pc0VtcHR5JztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuaXNFbXB0eSA9IGlzRW1wdHk7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBpc0VtcHR5OiB0eXBlb2YgaXNFbXB0eTtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2lzRW1wdHkudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGxhc3QgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9sYXN0JztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUubGFzdCA9IDxhbnk+bGFzdDtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIGxhc3Q6IHR5cGVvZiBsYXN0O1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvbGFzdC50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgbGV0UHJvdG8gfSBmcm9tICcuLi8uLi9vcGVyYXRvci9sZXQnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5sZXQgPSBsZXRQcm90bztcbk9ic2VydmFibGUucHJvdG90eXBlLmxldEJpbmQgPSBsZXRQcm90bztcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIGxldDogdHlwZW9mIGxldFByb3RvO1xuICAgIGxldEJpbmQ6IHR5cGVvZiBsZXRQcm90bztcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL2xldC50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvbWFwJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWFwID0gbWFwO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgbWFwOiB0eXBlb2YgbWFwO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvbWFwLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBtYXBUbyB9IGZyb20gJy4uLy4uL29wZXJhdG9yL21hcFRvJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWFwVG8gPSBtYXBUbztcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIG1hcFRvOiB0eXBlb2YgbWFwVG87XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9tYXBUby50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgbWF0ZXJpYWxpemUgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9tYXRlcmlhbGl6ZSc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLm1hdGVyaWFsaXplID0gbWF0ZXJpYWxpemU7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBtYXRlcmlhbGl6ZTogdHlwZW9mIG1hdGVyaWFsaXplO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvbWF0ZXJpYWxpemUudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IG1heCB9IGZyb20gJy4uLy4uL29wZXJhdG9yL21heCc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLm1heCA9IG1heDtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIG1heDogdHlwZW9mIG1heDtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL21heC50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgbWVyZ2UgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9tZXJnZSc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLm1lcmdlID0gbWVyZ2U7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBtZXJnZTogdHlwZW9mIG1lcmdlO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvbWVyZ2UudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IG1lcmdlQWxsIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvbWVyZ2VBbGwnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5tZXJnZUFsbCA9IG1lcmdlQWxsO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgbWVyZ2VBbGw6IHR5cGVvZiBtZXJnZUFsbDtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL21lcmdlQWxsLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBtZXJnZU1hcCB9IGZyb20gJy4uLy4uL29wZXJhdG9yL21lcmdlTWFwJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWVyZ2VNYXAgPSA8YW55Pm1lcmdlTWFwO1xuT2JzZXJ2YWJsZS5wcm90b3R5cGUuZmxhdE1hcCA9IDxhbnk+bWVyZ2VNYXA7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBmbGF0TWFwOiB0eXBlb2YgbWVyZ2VNYXA7XG4gICAgbWVyZ2VNYXA6IHR5cGVvZiBtZXJnZU1hcDtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL21lcmdlTWFwLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBtZXJnZU1hcFRvIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvbWVyZ2VNYXBUbyc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLmZsYXRNYXBUbyA9IDxhbnk+bWVyZ2VNYXBUbztcbk9ic2VydmFibGUucHJvdG90eXBlLm1lcmdlTWFwVG8gPSA8YW55Pm1lcmdlTWFwVG87XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBmbGF0TWFwVG86IHR5cGVvZiBtZXJnZU1hcFRvO1xuICAgIG1lcmdlTWFwVG86IHR5cGVvZiBtZXJnZU1hcFRvO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvbWVyZ2VNYXBUby50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgbWVyZ2VTY2FuIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvbWVyZ2VTY2FuJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUubWVyZ2VTY2FuID0gbWVyZ2VTY2FuO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgbWVyZ2VTY2FuOiB0eXBlb2YgbWVyZ2VTY2FuO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvbWVyZ2VTY2FuLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBtaW4gfSBmcm9tICcuLi8uLi9vcGVyYXRvci9taW4nO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5taW4gPSBtaW47XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBtaW46IHR5cGVvZiBtaW47XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9taW4udHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IG11bHRpY2FzdCB9IGZyb20gJy4uLy4uL29wZXJhdG9yL211bHRpY2FzdCc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLm11bHRpY2FzdCA9IDxhbnk+bXVsdGljYXN0O1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgbXVsdGljYXN0OiB0eXBlb2YgbXVsdGljYXN0O1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvbXVsdGljYXN0LnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBvYnNlcnZlT24gfSBmcm9tICcuLi8uLi9vcGVyYXRvci9vYnNlcnZlT24nO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5vYnNlcnZlT24gPSBvYnNlcnZlT247XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBvYnNlcnZlT246IHR5cGVvZiBvYnNlcnZlT247XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9vYnNlcnZlT24udHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XHJcbmltcG9ydCB7IG9uRXJyb3JSZXN1bWVOZXh0IH0gZnJvbSAnLi4vLi4vb3BlcmF0b3Ivb25FcnJvclJlc3VtZU5leHQnO1xyXG5cclxuT2JzZXJ2YWJsZS5wcm90b3R5cGUub25FcnJvclJlc3VtZU5leHQgPSBvbkVycm9yUmVzdW1lTmV4dDtcclxuXHJcbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XHJcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xyXG4gICAgb25FcnJvclJlc3VtZU5leHQ6IHR5cGVvZiBvbkVycm9yUmVzdW1lTmV4dDtcclxuICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9vbkVycm9yUmVzdW1lTmV4dC50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgcGFpcndpc2UgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9wYWlyd2lzZSc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLnBhaXJ3aXNlID0gcGFpcndpc2U7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBwYWlyd2lzZTogdHlwZW9mIHBhaXJ3aXNlO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvcGFpcndpc2UudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHBhcnRpdGlvbiB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3BhcnRpdGlvbic7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHBhcnRpdGlvbjogdHlwZW9mIHBhcnRpdGlvbjtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3BhcnRpdGlvbi50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgcGx1Y2sgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9wbHVjayc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLnBsdWNrID0gcGx1Y2s7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBwbHVjazogdHlwZW9mIHBsdWNrO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvcGx1Y2sudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHB1Ymxpc2ggfSBmcm9tICcuLi8uLi9vcGVyYXRvci9wdWJsaXNoJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUucHVibGlzaCA9IDxhbnk+cHVibGlzaDtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHB1Ymxpc2g6IHR5cGVvZiBwdWJsaXNoO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvcHVibGlzaC50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgcHVibGlzaEJlaGF2aW9yIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvcHVibGlzaEJlaGF2aW9yJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUucHVibGlzaEJlaGF2aW9yID0gcHVibGlzaEJlaGF2aW9yO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgcHVibGlzaEJlaGF2aW9yOiB0eXBlb2YgcHVibGlzaEJlaGF2aW9yO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvcHVibGlzaEJlaGF2aW9yLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBwdWJsaXNoTGFzdCB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3B1Ymxpc2hMYXN0JztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUucHVibGlzaExhc3QgPSBwdWJsaXNoTGFzdDtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHB1Ymxpc2hMYXN0OiB0eXBlb2YgcHVibGlzaExhc3Q7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9wdWJsaXNoTGFzdC50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgcHVibGlzaFJlcGxheSB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3B1Ymxpc2hSZXBsYXknO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5wdWJsaXNoUmVwbGF5ID0gcHVibGlzaFJlcGxheTtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHB1Ymxpc2hSZXBsYXk6IHR5cGVvZiBwdWJsaXNoUmVwbGF5O1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvcHVibGlzaFJlcGxheS50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgcmFjZSB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3JhY2UnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5yYWNlID0gcmFjZTtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHJhY2U6IHR5cGVvZiByYWNlO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvcmFjZS50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgcmVkdWNlIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvcmVkdWNlJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUucmVkdWNlID0gcmVkdWNlO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgcmVkdWNlOiB0eXBlb2YgcmVkdWNlO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvcmVkdWNlLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyByZXBlYXQgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9yZXBlYXQnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5yZXBlYXQgPSByZXBlYXQ7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICByZXBlYXQ6IHR5cGVvZiByZXBlYXQ7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9yZXBlYXQudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHJlcGVhdFdoZW4gfSBmcm9tICcuLi8uLi9vcGVyYXRvci9yZXBlYXRXaGVuJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUucmVwZWF0V2hlbiA9IHJlcGVhdFdoZW47XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICByZXBlYXRXaGVuOiB0eXBlb2YgcmVwZWF0V2hlbjtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3JlcGVhdFdoZW4udHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHJldHJ5IH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvcmV0cnknO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5yZXRyeSA9IHJldHJ5O1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgcmV0cnk6IHR5cGVvZiByZXRyeTtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3JldHJ5LnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyByZXRyeVdoZW4gfSBmcm9tICcuLi8uLi9vcGVyYXRvci9yZXRyeVdoZW4nO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5yZXRyeVdoZW4gPSByZXRyeVdoZW47XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICByZXRyeVdoZW46IHR5cGVvZiByZXRyeVdoZW47XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9yZXRyeVdoZW4udHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHNhbXBsZSB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3NhbXBsZSc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLnNhbXBsZSA9IHNhbXBsZTtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHNhbXBsZTogdHlwZW9mIHNhbXBsZTtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3NhbXBsZS50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgc2FtcGxlVGltZSB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3NhbXBsZVRpbWUnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5zYW1wbGVUaW1lID0gc2FtcGxlVGltZTtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHNhbXBsZVRpbWU6IHR5cGVvZiBzYW1wbGVUaW1lO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3Ivc2FtcGxlVGltZS50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuXG5pbXBvcnQgeyBzY2FuIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3Ivc2Nhbic7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLnNjYW4gPSBzY2FuO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgc2NhbjogdHlwZW9mIHNjYW47XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9zY2FuLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBzZXF1ZW5jZUVxdWFsIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3Ivc2VxdWVuY2VFcXVhbCc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLnNlcXVlbmNlRXF1YWwgPSBzZXF1ZW5jZUVxdWFsO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgc2VxdWVuY2VFcXVhbDogdHlwZW9mIHNlcXVlbmNlRXF1YWw7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9zZXF1ZW5jZUVxdWFsLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBzaGFyZSB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3NoYXJlJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc2hhcmUgPSBzaGFyZTtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHNoYXJlOiB0eXBlb2Ygc2hhcmU7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9zaGFyZS50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgc2luZ2xlIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3Ivc2luZ2xlJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc2luZ2xlID0gc2luZ2xlO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgc2luZ2xlOiB0eXBlb2Ygc2luZ2xlO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3Ivc2luZ2xlLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBza2lwIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3Ivc2tpcCc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLnNraXAgPSBza2lwO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgc2tpcDogdHlwZW9mIHNraXA7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9za2lwLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBza2lwVW50aWwgfSBmcm9tICcuLi8uLi9vcGVyYXRvci9za2lwVW50aWwnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS5za2lwVW50aWwgPSBza2lwVW50aWw7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBza2lwVW50aWw6IHR5cGVvZiBza2lwVW50aWw7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9za2lwVW50aWwudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHNraXBXaGlsZSB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3NraXBXaGlsZSc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLnNraXBXaGlsZSA9IHNraXBXaGlsZTtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHNraXBXaGlsZTogdHlwZW9mIHNraXBXaGlsZTtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3NraXBXaGlsZS50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgc3RhcnRXaXRoIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3Ivc3RhcnRXaXRoJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3RhcnRXaXRoID0gc3RhcnRXaXRoO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgc3RhcnRXaXRoOiB0eXBlb2Ygc3RhcnRXaXRoO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3Ivc3RhcnRXaXRoLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBzdWJzY3JpYmVPbiB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3N1YnNjcmliZU9uJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUuc3Vic2NyaWJlT24gPSBzdWJzY3JpYmVPbjtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHN1YnNjcmliZU9uOiB0eXBlb2Ygc3Vic2NyaWJlT247XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9zdWJzY3JpYmVPbi50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgX3N3aXRjaCB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3N3aXRjaCc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLnN3aXRjaCA9IF9zd2l0Y2g7XG5PYnNlcnZhYmxlLnByb3RvdHlwZS5fc3dpdGNoID0gX3N3aXRjaDtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHN3aXRjaDogdHlwZW9mIF9zd2l0Y2g7XG4gICAgX3N3aXRjaDogdHlwZW9mIF9zd2l0Y2g7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci9zd2l0Y2gudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHN3aXRjaE1hcCB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3N3aXRjaE1hcCc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLnN3aXRjaE1hcCA9IHN3aXRjaE1hcDtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHN3aXRjaE1hcDogdHlwZW9mIHN3aXRjaE1hcDtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3N3aXRjaE1hcC50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgc3dpdGNoTWFwVG8gfSBmcm9tICcuLi8uLi9vcGVyYXRvci9zd2l0Y2hNYXBUbyc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLnN3aXRjaE1hcFRvID0gc3dpdGNoTWFwVG87XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICBzd2l0Y2hNYXBUbzogdHlwZW9mIHN3aXRjaE1hcFRvO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3Ivc3dpdGNoTWFwVG8udHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHRha2UgfSBmcm9tICcuLi8uLi9vcGVyYXRvci90YWtlJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGFrZSA9IHRha2U7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICB0YWtlOiB0eXBlb2YgdGFrZTtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3Rha2UudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyB0YWtlTGFzdCB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3Rha2VMYXN0JztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGFrZUxhc3QgPSB0YWtlTGFzdDtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHRha2VMYXN0OiB0eXBlb2YgdGFrZUxhc3Q7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci90YWtlTGFzdC50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvdGFrZVVudGlsJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUudGFrZVVudGlsID0gdGFrZVVudGlsO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgdGFrZVVudGlsOiB0eXBlb2YgdGFrZVVudGlsO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvdGFrZVVudGlsLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyB0YWtlV2hpbGUgfSBmcm9tICcuLi8uLi9vcGVyYXRvci90YWtlV2hpbGUnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS50YWtlV2hpbGUgPSB0YWtlV2hpbGU7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICB0YWtlV2hpbGU6IHR5cGVvZiB0YWtlV2hpbGU7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci90YWtlV2hpbGUudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHRocm90dGxlIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3IvdGhyb3R0bGUnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS50aHJvdHRsZSA9IHRocm90dGxlO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgdGhyb3R0bGU6IHR5cGVvZiB0aHJvdHRsZTtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3Rocm90dGxlLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyB0aHJvdHRsZVRpbWUgfSBmcm9tICcuLi8uLi9vcGVyYXRvci90aHJvdHRsZVRpbWUnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS50aHJvdHRsZVRpbWUgPSB0aHJvdHRsZVRpbWU7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICB0aHJvdHRsZVRpbWU6IHR5cGVvZiB0aHJvdHRsZVRpbWU7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci90aHJvdHRsZVRpbWUudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHRpbWVJbnRlcnZhbCB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3RpbWVJbnRlcnZhbCc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLnRpbWVJbnRlcnZhbCA9IHRpbWVJbnRlcnZhbDtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHRpbWVJbnRlcnZhbDogdHlwZW9mIHRpbWVJbnRlcnZhbDtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3RpbWVJbnRlcnZhbC50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgdGltZW91dCB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3RpbWVvdXQnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS50aW1lb3V0ID0gdGltZW91dDtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHRpbWVvdXQ6IHR5cGVvZiB0aW1lb3V0O1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvdGltZW91dC50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgdGltZW91dFdpdGggfSBmcm9tICcuLi8uLi9vcGVyYXRvci90aW1lb3V0V2l0aCc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLnRpbWVvdXRXaXRoID0gdGltZW91dFdpdGg7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICB0aW1lb3V0V2l0aDogdHlwZW9mIHRpbWVvdXRXaXRoO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvdGltZW91dFdpdGgudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XHJcbmltcG9ydCB7IHRpbWVzdGFtcCB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3RpbWVzdGFtcCc7XHJcblxyXG5PYnNlcnZhYmxlLnByb3RvdHlwZS50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XHJcblxyXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xyXG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcclxuICAgIHRpbWVzdGFtcDogdHlwZW9mIHRpbWVzdGFtcDtcclxuICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci90aW1lc3RhbXAudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHRvQXJyYXkgfSBmcm9tICcuLi8uLi9vcGVyYXRvci90b0FycmF5JztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUudG9BcnJheSA9IHRvQXJyYXk7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICB0b0FycmF5OiB0eXBlb2YgdG9BcnJheTtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3RvQXJyYXkudHMiLCJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi8uLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHRvUHJvbWlzZSB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3RvUHJvbWlzZSc7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLnRvUHJvbWlzZSA9IHRvUHJvbWlzZTtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHRvUHJvbWlzZTogdHlwZW9mIHRvUHJvbWlzZTtcbiAgfVxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvYWRkL29wZXJhdG9yL3RvUHJvbWlzZS50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgd2luZG93IH0gZnJvbSAnLi4vLi4vb3BlcmF0b3Ivd2luZG93JztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUud2luZG93ID0gd2luZG93O1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgd2luZG93OiB0eXBlb2Ygd2luZG93O1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3Ivd2luZG93LnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyB3aW5kb3dDb3VudCB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3dpbmRvd0NvdW50JztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUud2luZG93Q291bnQgPSB3aW5kb3dDb3VudDtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHdpbmRvd0NvdW50OiB0eXBlb2Ygd2luZG93Q291bnQ7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci93aW5kb3dDb3VudC50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgd2luZG93VGltZSB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3dpbmRvd1RpbWUnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS53aW5kb3dUaW1lID0gd2luZG93VGltZTtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHdpbmRvd1RpbWU6IHR5cGVvZiB3aW5kb3dUaW1lO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3Ivd2luZG93VGltZS50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgd2luZG93VG9nZ2xlIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3Ivd2luZG93VG9nZ2xlJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUud2luZG93VG9nZ2xlID0gd2luZG93VG9nZ2xlO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgd2luZG93VG9nZ2xlOiB0eXBlb2Ygd2luZG93VG9nZ2xlO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3Ivd2luZG93VG9nZ2xlLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyB3aW5kb3dXaGVuIH0gZnJvbSAnLi4vLi4vb3BlcmF0b3Ivd2luZG93V2hlbic7XG5cbk9ic2VydmFibGUucHJvdG90eXBlLndpbmRvd1doZW4gPSB3aW5kb3dXaGVuO1xuXG5kZWNsYXJlIG1vZHVsZSAnLi4vLi4vT2JzZXJ2YWJsZScge1xuICBpbnRlcmZhY2UgT2JzZXJ2YWJsZTxUPiB7XG4gICAgd2luZG93V2hlbjogdHlwZW9mIHdpbmRvd1doZW47XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci93aW5kb3dXaGVuLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyB3aXRoTGF0ZXN0RnJvbSB9IGZyb20gJy4uLy4uL29wZXJhdG9yL3dpdGhMYXRlc3RGcm9tJztcblxuT2JzZXJ2YWJsZS5wcm90b3R5cGUud2l0aExhdGVzdEZyb20gPSB3aXRoTGF0ZXN0RnJvbTtcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHdpdGhMYXRlc3RGcm9tOiB0eXBlb2Ygd2l0aExhdGVzdEZyb207XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci93aXRoTGF0ZXN0RnJvbS50cyIsIlxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgemlwUHJvdG8gfSBmcm9tICcuLi8uLi9vcGVyYXRvci96aXAnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS56aXAgPSB6aXBQcm90bztcblxuZGVjbGFyZSBtb2R1bGUgJy4uLy4uL09ic2VydmFibGUnIHtcbiAgaW50ZXJmYWNlIE9ic2VydmFibGU8VD4ge1xuICAgIHppcDogdHlwZW9mIHppcFByb3RvO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9hZGQvb3BlcmF0b3IvemlwLnRzIiwiXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyB6aXBBbGwgfSBmcm9tICcuLi8uLi9vcGVyYXRvci96aXBBbGwnO1xuXG5PYnNlcnZhYmxlLnByb3RvdHlwZS56aXBBbGwgPSB6aXBBbGw7XG5cbmRlY2xhcmUgbW9kdWxlICcuLi8uLi9PYnNlcnZhYmxlJyB7XG4gIGludGVyZmFjZSBPYnNlcnZhYmxlPFQ+IHtcbiAgICB6aXBBbGw6IHR5cGVvZiB6aXBBbGw7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL2FkZC9vcGVyYXRvci96aXBBbGwudHMiLCJpbXBvcnQgeyBJU2NoZWR1bGVyIH0gZnJvbSAnLi4vU2NoZWR1bGVyJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFNjYWxhck9ic2VydmFibGUgfSBmcm9tICcuL1NjYWxhck9ic2VydmFibGUnO1xuaW1wb3J0IHsgRW1wdHlPYnNlcnZhYmxlIH0gZnJvbSAnLi9FbXB0eU9ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG5leHBvcnQgY2xhc3MgQXJyYXlMaWtlT2JzZXJ2YWJsZTxUPiBleHRlbmRzIE9ic2VydmFibGU8VD4ge1xuXG4gIHN0YXRpYyBjcmVhdGU8VD4oYXJyYXlMaWtlOiBBcnJheUxpa2U8VD4sIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheUxpa2UubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBuZXcgRW1wdHlPYnNlcnZhYmxlPFQ+KCk7XG4gICAgfSBlbHNlIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBuZXcgU2NhbGFyT2JzZXJ2YWJsZTxUPig8YW55PmFycmF5TGlrZVswXSwgc2NoZWR1bGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBBcnJheUxpa2VPYnNlcnZhYmxlKGFycmF5TGlrZSwgc2NoZWR1bGVyKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZGlzcGF0Y2goc3RhdGU6IGFueSkge1xuICAgIGNvbnN0IHsgYXJyYXlMaWtlLCBpbmRleCwgbGVuZ3RoLCBzdWJzY3JpYmVyIH0gPSBzdGF0ZTtcblxuICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA+PSBsZW5ndGgpIHtcbiAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdWJzY3JpYmVyLm5leHQoYXJyYXlMaWtlW2luZGV4XSk7XG5cbiAgICBzdGF0ZS5pbmRleCA9IGluZGV4ICsgMTtcblxuICAgICg8YW55PiB0aGlzKS5zY2hlZHVsZShzdGF0ZSk7XG4gIH1cblxuICAvLyB2YWx1ZSB1c2VkIGlmIEFycmF5IGhhcyBvbmUgdmFsdWUgYW5kIF9pc1NjYWxhclxuICBwcml2YXRlIHZhbHVlOiBhbnk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBhcnJheUxpa2U6IEFycmF5TGlrZTxUPiwgcHJpdmF0ZSBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAoIXNjaGVkdWxlciAmJiBhcnJheUxpa2UubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLl9pc1NjYWxhciA9IHRydWU7XG4gICAgICB0aGlzLnZhbHVlID0gYXJyYXlMaWtlWzBdO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4pOiBUZWFyZG93bkxvZ2ljIHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IHsgYXJyYXlMaWtlLCBzY2hlZHVsZXIgfSA9IHRoaXM7XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlMaWtlLmxlbmd0aDtcblxuICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoQXJyYXlMaWtlT2JzZXJ2YWJsZS5kaXNwYXRjaCwgMCwge1xuICAgICAgICBhcnJheUxpa2UsIGluZGV4LCBsZW5ndGgsIHN1YnNjcmliZXJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aCAmJiAhc3Vic2NyaWJlci5jbG9zZWQ7IGkrKykge1xuICAgICAgICBzdWJzY3JpYmVyLm5leHQoYXJyYXlMaWtlW2ldKTtcbiAgICAgIH1cbiAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9BcnJheUxpa2VPYnNlcnZhYmxlLnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IElTY2hlZHVsZXIgfSBmcm9tICcuLi9TY2hlZHVsZXInO1xuaW1wb3J0IHsgdHJ5Q2F0Y2ggfSBmcm9tICcuLi91dGlsL3RyeUNhdGNoJztcbmltcG9ydCB7IGVycm9yT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9lcnJvck9iamVjdCc7XG5pbXBvcnQgeyBBc3luY1N1YmplY3QgfSBmcm9tICcuLi9Bc3luY1N1YmplY3QnO1xuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xuZXhwb3J0IGNsYXNzIEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlPFQ+IGV4dGVuZHMgT2JzZXJ2YWJsZTxUPiB7XG4gIHN1YmplY3Q6IEFzeW5jU3ViamVjdDxUPjtcblxuICAvKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbiAgc3RhdGljIGNyZWF0ZShjYWxsYmFja0Z1bmM6IChjYWxsYmFjazogKCkgPT4gYW55KSA9PiBhbnksIHNlbGVjdG9yPzogdm9pZCwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6ICgpID0+IE9ic2VydmFibGU8dm9pZD47XG4gIHN0YXRpYyBjcmVhdGU8Uj4oY2FsbGJhY2tGdW5jOiAoY2FsbGJhY2s6IChyZXN1bHQ6IFIpID0+IGFueSkgPT4gYW55LCBzZWxlY3Rvcj86IHZvaWQsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiAoKSA9PiBPYnNlcnZhYmxlPFI+O1xuICBzdGF0aWMgY3JlYXRlPFQsIFI+KGNhbGxiYWNrRnVuYzogKHYxOiBULCBjYWxsYmFjazogKHJlc3VsdDogUikgPT4gYW55KSA9PiBhbnksIHNlbGVjdG9yPzogdm9pZCwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6ICh2MTogVCkgPT4gT2JzZXJ2YWJsZTxSPjtcbiAgc3RhdGljIGNyZWF0ZTxULCBUMiwgUj4oY2FsbGJhY2tGdW5jOiAodjE6IFQsIHYyOiBUMiwgY2FsbGJhY2s6IChyZXN1bHQ6IFIpID0+IGFueSkgPT4gYW55LCBzZWxlY3Rvcj86IHZvaWQsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiAodjE6IFQsIHYyOiBUMikgPT4gT2JzZXJ2YWJsZTxSPjtcbiAgc3RhdGljIGNyZWF0ZTxULCBUMiwgVDMsIFI+KGNhbGxiYWNrRnVuYzogKHYxOiBULCB2MjogVDIsIHYzOiBUMywgY2FsbGJhY2s6IChyZXN1bHQ6IFIpID0+IGFueSkgPT4gYW55LCBzZWxlY3Rvcj86IHZvaWQsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiAodjE6IFQsIHYyOiBUMiwgdjM6IFQzKSA9PiBPYnNlcnZhYmxlPFI+O1xuICBzdGF0aWMgY3JlYXRlPFQsIFQyLCBUMywgVDQsIFI+KGNhbGxiYWNrRnVuYzogKHYxOiBULCB2MjogVDIsIHYzOiBUMywgdjQ6IFQ0LCBjYWxsYmFjazogKHJlc3VsdDogUikgPT4gYW55KSA9PiBhbnksIHNlbGVjdG9yPzogdm9pZCwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6ICh2MTogVCwgdjI6IFQyLCB2MzogVDMsIHY0OiBUNCkgPT4gT2JzZXJ2YWJsZTxSPjtcbiAgc3RhdGljIGNyZWF0ZTxULCBUMiwgVDMsIFQ0LCBUNSwgUj4oY2FsbGJhY2tGdW5jOiAodjE6IFQsIHYyOiBUMiwgdjM6IFQzLCB2NDogVDQsIHY1OiBUNSwgY2FsbGJhY2s6IChyZXN1bHQ6IFIpID0+IGFueSkgPT4gYW55LCBzZWxlY3Rvcj86IHZvaWQsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiAodjE6IFQsIHYyOiBUMiwgdjM6IFQzLCB2NDogVDQsIHY1OiBUNSkgPT4gT2JzZXJ2YWJsZTxSPjtcbiAgc3RhdGljIGNyZWF0ZTxULCBUMiwgVDMsIFQ0LCBUNSwgVDYsIFI+KGNhbGxiYWNrRnVuYzogKHYxOiBULCB2MjogVDIsIHYzOiBUMywgdjQ6IFQ0LCB2NTogVDUsIHY2OiBUNiwgY2FsbGJhY2s6IChyZXN1bHQ6IFIpID0+IGFueSkgPT4gYW55LCBzZWxlY3Rvcj86IHZvaWQsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiAodjE6IFQsIHYyOiBUMiwgdjM6IFQzLCB2NDogVDQsIHY1OiBUNSwgdjY6IFQ2KSA9PiBPYnNlcnZhYmxlPFI+O1xuICBzdGF0aWMgY3JlYXRlPFI+KGNhbGxiYWNrRnVuYzogKGNhbGxiYWNrOiAoLi4uYXJnczogYW55W10pID0+IGFueSkgPT4gYW55LCBzZWxlY3RvcjogKC4uLmFyZ3M6IGFueVtdKSA9PiBSLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogKCkgPT4gT2JzZXJ2YWJsZTxSPjtcbiAgc3RhdGljIGNyZWF0ZTxULCBSPihjYWxsYmFja0Z1bmM6ICh2MTogVCwgY2FsbGJhY2s6ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA9PiBhbnksIHNlbGVjdG9yOiAoLi4uYXJnczogYW55W10pID0+IFIsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiAodjE6IFQpID0+IE9ic2VydmFibGU8Uj47XG4gIHN0YXRpYyBjcmVhdGU8VCwgVDIsIFI+KGNhbGxiYWNrRnVuYzogKHYxOiBULCB2MjogVDIsIGNhbGxiYWNrOiAoLi4uYXJnczogYW55W10pID0+IGFueSkgPT4gYW55LCBzZWxlY3RvcjogKC4uLmFyZ3M6IGFueVtdKSA9PiBSLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogKHYxOiBULCB2MjogVDIpID0+IE9ic2VydmFibGU8Uj47XG4gIHN0YXRpYyBjcmVhdGU8VCwgVDIsIFQzLCBSPihjYWxsYmFja0Z1bmM6ICh2MTogVCwgdjI6IFQyLCB2MzogVDMsIGNhbGxiYWNrOiAoLi4uYXJnczogYW55W10pID0+IGFueSkgPT4gYW55LCBzZWxlY3RvcjogKC4uLmFyZ3M6IGFueVtdKSA9PiBSLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogKHYxOiBULCB2MjogVDIsIHYzOiBUMykgPT4gT2JzZXJ2YWJsZTxSPjtcbiAgc3RhdGljIGNyZWF0ZTxULCBUMiwgVDMsIFQ0LCBSPihjYWxsYmFja0Z1bmM6ICh2MTogVCwgdjI6IFQyLCB2MzogVDMsIHY0OiBUNCwgY2FsbGJhY2s6ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA9PiBhbnksIHNlbGVjdG9yOiAoLi4uYXJnczogYW55W10pID0+IFIsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiAodjE6IFQsIHYyOiBUMiwgdjM6IFQzLCB2NDogVDQpID0+IE9ic2VydmFibGU8Uj47XG4gIHN0YXRpYyBjcmVhdGU8VCwgVDIsIFQzLCBUNCwgVDUsIFI+KGNhbGxiYWNrRnVuYzogKHYxOiBULCB2MjogVDIsIHYzOiBUMywgdjQ6IFQ0LCB2NTogVDUsIGNhbGxiYWNrOiAoLi4uYXJnczogYW55W10pID0+IGFueSkgPT4gYW55LCBzZWxlY3RvcjogKC4uLmFyZ3M6IGFueVtdKSA9PiBSLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogKHYxOiBULCB2MjogVDIsIHYzOiBUMywgdjQ6IFQ0LCB2NTogVDUpID0+IE9ic2VydmFibGU8Uj47XG4gIHN0YXRpYyBjcmVhdGU8VCwgVDIsIFQzLCBUNCwgVDUsIFQ2LCBSPihjYWxsYmFja0Z1bmM6ICh2MTogVCwgdjI6IFQyLCB2MzogVDMsIHY0OiBUNCwgdjU6IFQ1LCB2NjogVDYsIGNhbGxiYWNrOiAoLi4uYXJnczogYW55W10pID0+IGFueSkgPT4gYW55LCBzZWxlY3RvcjogKC4uLmFyZ3M6IGFueVtdKSA9PiBSLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogKHYxOiBULCB2MjogVDIsIHYzOiBUMywgdjQ6IFQ0LCB2NTogVDUsIHY2OiBUNikgPT4gT2JzZXJ2YWJsZTxSPjtcbiAgc3RhdGljIGNyZWF0ZTxUPihjYWxsYmFja0Z1bmM6IEZ1bmN0aW9uLCBzZWxlY3Rvcj86IHZvaWQsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiAoLi4uYXJnczogYW55W10pID0+IE9ic2VydmFibGU8VD47XG4gIHN0YXRpYyBjcmVhdGU8VD4oY2FsbGJhY2tGdW5jOiBGdW5jdGlvbiwgc2VsZWN0b3I/OiAoLi4uYXJnczogYW55W10pID0+IFQsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiAoLi4uYXJnczogYW55W10pID0+IE9ic2VydmFibGU8VD47XG4gIC8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgY2FsbGJhY2sgQVBJIHRvIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIE9ic2VydmFibGUuXG4gICAqXG4gICAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5HaXZlIGl0IGEgZnVuY3Rpb24gYGZgIG9mIHR5cGUgYGYoeCwgY2FsbGJhY2spYCBhbmRcbiAgICogaXQgd2lsbCByZXR1cm4gYSBmdW5jdGlvbiBgZ2AgdGhhdCB3aGVuIGNhbGxlZCBhcyBgZyh4KWAgd2lsbCBvdXRwdXQgYW5cbiAgICogT2JzZXJ2YWJsZS48L3NwYW4+XG4gICAqXG4gICAqIGBiaW5kQ2FsbGJhY2tgIGlzIG5vdCBhbiBvcGVyYXRvciBiZWNhdXNlIGl0cyBpbnB1dCBhbmQgb3V0cHV0IGFyZSBub3RcbiAgICogT2JzZXJ2YWJsZXMuIFRoZSBpbnB1dCBpcyBhIGZ1bmN0aW9uIGBmdW5jYCB3aXRoIHNvbWUgcGFyYW1ldGVycywgYnV0IHRoZVxuICAgKiBsYXN0IHBhcmFtZXRlciBtdXN0IGJlIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBgZnVuY2AgY2FsbHMgd2hlbiBpdCBpc1xuICAgKiBkb25lLlxuICAgKlxuICAgKiBUaGUgb3V0cHV0IG9mIGBiaW5kQ2FsbGJhY2tgIGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0aGUgc2FtZSBwYXJhbWV0ZXJzXG4gICAqIGFzIGBmdW5jYCwgZXhjZXB0IHRoZSBsYXN0IG9uZSAodGhlIGNhbGxiYWNrKS4gV2hlbiB0aGUgb3V0cHV0IGZ1bmN0aW9uXG4gICAqIGlzIGNhbGxlZCB3aXRoIGFyZ3VtZW50cywgaXQgd2lsbCByZXR1cm4gYW4gT2JzZXJ2YWJsZS4gSWYgYGZ1bmNgIGZ1bmN0aW9uXG4gICAqIGNhbGxzIGl0cyBjYWxsYmFjayB3aXRoIG9uZSBhcmd1bWVudCwgdGhlIE9ic2VydmFibGUgd2lsbCBlbWl0IHRoYXQgdmFsdWUuXG4gICAqIElmIG9uIHRoZSBvdGhlciBoYW5kIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRoIG11bHRpcGxlIHZhbHVlcywgcmVzdWx0aW5nXG4gICAqIE9ic2VydmFibGUgd2lsbCBlbWl0IGFuIGFycmF5IHdpdGggdGhlc2UgYXJndW1lbnRzLlxuICAgKlxuICAgKiBJdCBpcyB2ZXJ5IGltcG9ydGFudCB0byByZW1lbWJlciwgdGhhdCBpbnB1dCBmdW5jdGlvbiBgZnVuY2AgaXMgbm90IGNhbGxlZFxuICAgKiB3aGVuIG91dHB1dCBmdW5jdGlvbiBpcywgYnV0IHJhdGhlciB3aGVuIE9ic2VydmFibGUgcmV0dXJuZWQgYnkgb3V0cHV0XG4gICAqIGZ1bmN0aW9uIGlzIHN1YnNjcmliZWQuIFRoaXMgbWVhbnMgaWYgYGZ1bmNgIG1ha2VzIEFKQVggcmVxdWVzdCwgdGhhdCByZXF1ZXN0XG4gICAqIHdpbGwgYmUgbWFkZSBldmVyeSB0aW1lIHNvbWVvbmUgc3Vic2NyaWJlcyB0byByZXN1bHRpbmcgT2JzZXJ2YWJsZSwgYnV0IG5vdCBiZWZvcmUuXG4gICAqXG4gICAqIE9wdGlvbmFsbHksIHNlbGVjdG9yIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgdG8gYGJpbmRPYnNlcnZhYmxlYC4gVGhhdCBmdW5jdGlvblxuICAgKiB0YWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgY2FsbGJhY2ssIGFuZCByZXR1cm5zIHZhbHVlXG4gICAqIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IE9ic2VydmFibGUgaW5zdGVhZCBvZiBjYWxsYmFjayBwYXJhbWV0ZXJzIHRoZW1zZWx2ZXMuXG4gICAqIEV2ZW4gdGhvdWdoIGJ5IGRlZmF1bHQgbXVsdGlwbGUgYXJndW1lbnRzIHBhc3NlZCB0byBjYWxsYmFjayBhcHBlYXIgaW4gdGhlIHN0cmVhbSBhcyBhcnJheSxcbiAgICogc2VsZWN0b3IgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCBhcmd1bWVudHMgZGlyZWN0bHksIGp1c3QgYXMgY2FsbGJhY2sgd291bGQuXG4gICAqIFRoaXMgbWVhbnMgeW91IGNhbiBpbWFnaW5lIGRlZmF1bHQgc2VsZWN0b3IgKHdoZW4gb25lIGlzIG5vdCBwcm92aWRlZCBleHBsaWNpdGx5KVxuICAgKiBhcyBmdW5jdGlvbiB0aGF0IGFnZ3JlZ2F0ZXMgYWxsIGl0cyBhcmd1bWVudHMgaW50byBhcnJheSwgb3Igc2ltcGx5IHJldHVybnMgZmlyc3QgYXJndW1lbnQsXG4gICAqIGlmIHRoZXJlIGlzIG9ubHkgb25lLlxuICAgKlxuICAgKiBMYXN0IG9wdGlvbmFsIHBhcmFtZXRlciAtIHtAbGluayBTY2hlZHVsZXJ9IC0gY2FuIGJlIHVzZWQgdG8gY29udHJvbCB3aGVuIGNhbGxcbiAgICogdG8gYGZ1bmNgIGhhcHBlbnMgYWZ0ZXIgc29tZW9uZSBzdWJzY3JpYmVzIHRvIE9ic2VydmFibGUsIGFzIHdlbGwgYXMgd2hlbiByZXN1bHRzXG4gICAqIHBhc3NlZCB0byBjYWxsYmFjayB3aWxsIGJlIGVtaXR0ZWQuIEJ5IGRlZmF1bHQgc3Vic2NyaXB0aW9uIHRvIE9ic2VydmFibGUgY2FsbHMgYGZ1bmNgXG4gICAqIHN5bmNocm9ub3VzbHksIGJ1dCB1c2luZyBgU2NoZWR1bGVyLmFzeW5jYCBhcyBsYXN0IHBhcmFtZXRlciB3aWxsIGRlZmVyIGNhbGwgdG8gaW5wdXQgZnVuY3Rpb24sXG4gICAqIGp1c3QgbGlrZSB3cmFwcGluZyB0aGF0IGNhbGwgaW4gYHNldFRpbWVvdXRgIHdpdGggdGltZSBgMGAgd291bGQuIFNvIGlmIHlvdSB1c2UgYXN5bmMgU2NoZWR1bGVyXG4gICAqIGFuZCBjYWxsIGBzdWJzY3JpYmVgIG9uIG91dHB1dCBPYnNlcnZhYmxlLCBhbGwgZnVuY3Rpb24gY2FsbHMgdGhhdCBhcmUgY3VycmVudGx5IGV4ZWN1dGluZyxcbiAgICogd2lsbCBlbmQgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBXaGVuIGl0IGNvbWVzIHRvIGVtaXR0aW5nIHJlc3VsdHMgcGFzc2VkIHRvIGNhbGxiYWNrLCBieSBkZWZhdWx0IHRoZXkgYXJlIGVtaXR0ZWRcbiAgICogaW1tZWRpYXRlbHkgYWZ0ZXIgYGZ1bmNgIGludm9rZXMgY2FsbGJhY2suIEluIHBhcnRpY3VsYXIsIGlmIGNhbGxiYWNrIGlzIGNhbGxlZCBzeW5jaHJvbm91c2x5LFxuICAgKiB0aGVuIHN1YnNjcmlwdGlvbiB0byByZXN1bHRpbmcgT2JzZXJ2YWJsZSB3aWxsIGNhbGwgYG5leHRgIGZ1bmN0aW9uIHN5bmNocm9ub3VzbHkgYXMgd2VsbC5cbiAgICogSWYgeW91IHdhbnQgdG8gZGVmZXIgdGhhdCBjYWxsLCB1c2luZyBgU2NoZWR1bGVyLmFzeW5jYCB3aWxsLCBhZ2FpbiwgZG8gdGhlIGpvYi5cbiAgICogVGhpcyBtZWFucyB0aGF0IGJ5IHVzaW5nIGBTY2hlZHVsZXIuYXN5bmNgIHlvdSBjYW4sIGluIGEgc2Vuc2UsIGVuc3VyZSB0aGF0IGBmdW5jYFxuICAgKiBhbHdheXMgY2FsbHMgaXRzIGNhbGxiYWNrIGFzeW5jaHJvbm91c2x5LCB0aHVzIGF2b2lkaW5nIHRlcnJpZnlpbmcgWmFsZ28uXG4gICAqXG4gICAqIE5vdGUgdGhhdCBPYnNlcnZhYmxlIGNyZWF0ZWQgYnkgb3V0cHV0IGZ1bmN0aW9uIHdpbGwgYWx3YXlzIGVtaXQgb25seSBvbmUgdmFsdWVcbiAgICogYW5kIHRoZW4gY29tcGxldGUgcmlnaHQgYWZ0ZXIuIEV2ZW4gaWYgYGZ1bmNgIGNhbGxzIGNhbGxiYWNrIG11bHRpcGxlIHRpbWVzLCB2YWx1ZXMgZnJvbVxuICAgKiBzZWNvbmQgYW5kIGZvbGxvd2luZyBjYWxscyB3aWxsIG5ldmVyIGFwcGVhciBpbiB0aGUgc3RyZWFtLiBJZiB5b3UgbmVlZCB0b1xuICAgKiBsaXN0ZW4gZm9yIG11bHRpcGxlIGNhbGxzLCB5b3UgcHJvYmFibHkgd2FudCB0byB1c2Uge0BsaW5rIGZyb21FdmVudH0gb3JcbiAgICoge0BsaW5rIGZyb21FdmVudFBhdHRlcm59IGluc3RlYWQuXG4gICAqXG4gICAqIElmIGBmdW5jYCBkZXBlbmRzIG9uIHNvbWUgY29udGV4dCAoYHRoaXNgIHByb3BlcnR5KSwgdGhhdCBjb250ZXh0IHdpbGwgYmUgc2V0XG4gICAqIHRvIHRoZSBzYW1lIGNvbnRleHQgdGhhdCBvdXRwdXQgZnVuY3Rpb24gaGFzIGF0IGNhbGwgdGltZS4gSW4gcGFydGljdWxhciwgaWYgYGZ1bmNgXG4gICAqIGlzIGNhbGxlZCBhcyBtZXRob2Qgb2Ygc29tZSBvYmplY3QsIGluIG9yZGVyIHRvIHByZXNlcnZlIHByb3BlciBiZWhhdmlvdXIsXG4gICAqIGl0IGlzIHJlY29tbWVuZGVkIHRvIHNldCBjb250ZXh0IG9mIG91dHB1dCBmdW5jdGlvbiB0byB0aGF0IG9iamVjdCBhcyB3ZWxsLFxuICAgKiBwcm92aWRlZCBgZnVuY2AgaXMgbm90IGFscmVhZHkgYm91bmQuXG4gICAqXG4gICAqIElmIGlucHV0IGZ1bmN0aW9uIGNhbGxzIGl0cyBjYWxsYmFjayBpbiBcIm5vZGUgc3R5bGVcIiAoaS5lLiBmaXJzdCBhcmd1bWVudCB0byBjYWxsYmFjayBpc1xuICAgKiBvcHRpb25hbCBlcnJvciBwYXJhbWV0ZXIgc2lnbmFsaW5nIHdoZXRoZXIgY2FsbCBmYWlsZWQgb3Igbm90KSwge0BsaW5rIGJpbmROb2RlQ2FsbGJhY2t9XG4gICAqIHByb3ZpZGVzIGNvbnZlbmllbnQgZXJyb3IgaGFuZGxpbmcgYW5kIHByb2JhYmx5IGlzIGEgYmV0dGVyIGNob2ljZS5cbiAgICogYGJpbmRDYWxsYmFja2Agd2lsbCB0cmVhdCBzdWNoIGZ1bmN0aW9ucyB3aXRob3V0IGFueSBkaWZmZXJlbmNlIGFuZCBlcnJvciBwYXJhbWV0ZXJcbiAgICogKHdoZXRoZXIgcGFzc2VkIG9yIG5vdCkgd2lsbCBhbHdheXMgYmUgaW50ZXJwcmV0ZWQgYXMgcmVndWxhciBjYWxsYmFjayBhcmd1bWVudC5cbiAgICpcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+Q29udmVydCBqUXVlcnkncyBnZXRKU09OIHRvIGFuIE9ic2VydmFibGUgQVBJPC9jYXB0aW9uPlxuICAgKiAvLyBTdXBwb3NlIHdlIGhhdmUgalF1ZXJ5LmdldEpTT04oJy9teS91cmwnLCBjYWxsYmFjaylcbiAgICogdmFyIGdldEpTT05Bc09ic2VydmFibGUgPSBSeC5PYnNlcnZhYmxlLmJpbmRDYWxsYmFjayhqUXVlcnkuZ2V0SlNPTik7XG4gICAqIHZhciByZXN1bHQgPSBnZXRKU09OQXNPYnNlcnZhYmxlKCcvbXkvdXJsJyk7XG4gICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSwgZSA9PiBjb25zb2xlLmVycm9yKGUpKTtcbiAgICpcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+UmVjZWl2ZSBhcnJheSBvZiBhcmd1bWVudHMgcGFzc2VkIHRvIGNhbGxiYWNrPC9jYXB0aW9uPlxuICAgKiBzb21lRnVuY3Rpb24oKGEsIGIsIGMpID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhhKTsgLy8gNVxuICAgKiAgIGNvbnNvbGUubG9nKGIpOyAvLyAnc29tZSBzdHJpbmcnXG4gICAqICAgY29uc29sZS5sb2coYyk7IC8vIHtzb21lUHJvcGVydHk6ICdzb21lVmFsdWUnfVxuICAgKiB9KTtcbiAgICpcbiAgICogY29uc3QgYm91bmRTb21lRnVuY3Rpb24gPSBSeC5PYnNlcnZhYmxlLmJpbmRDYWxsYmFjayhzb21lRnVuY3Rpb24pO1xuICAgKiBib3VuZFNvbWVGdW5jdGlvbigpLnN1YnNjcmliZSh2YWx1ZXMgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlcykgLy8gWzUsICdzb21lIHN0cmluZycsIHtzb21lUHJvcGVydHk6ICdzb21lVmFsdWUnfV1cbiAgICogfSk7XG4gICAqXG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPlVzZSBiaW5kQ2FsbGJhY2sgd2l0aCBzZWxlY3RvciBmdW5jdGlvbjwvY2FwdGlvbj5cbiAgICogc29tZUZ1bmN0aW9uKChhLCBiLCBjKSA9PiB7XG4gICAqICAgY29uc29sZS5sb2coYSk7IC8vICdhJ1xuICAgKiAgIGNvbnNvbGUubG9nKGIpOyAvLyAnYidcbiAgICogICBjb25zb2xlLmxvZyhjKTsgLy8gJ2MnXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCBib3VuZFNvbWVGdW5jdGlvbiA9IFJ4Lk9ic2VydmFibGUuYmluZENhbGxiYWNrKHNvbWVGdW5jdGlvbiwgKGEsIGIsIGMpID0+IGEgKyBiICsgYyk7XG4gICAqIGJvdW5kU29tZUZ1bmN0aW9uKCkuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICogICBjb25zb2xlLmxvZyh2YWx1ZSkgLy8gJ2FiYydcbiAgICogfSk7XG4gICAqXG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbXBhcmUgYmVoYXZpb3VyIHdpdGggYW5kIHdpdGhvdXQgYXN5bmMgU2NoZWR1bGVyPC9jYXB0aW9uPlxuICAgKiBmdW5jdGlvbiBpQ2FsbE15Q2FsbGJhY2tTeW5jaHJvbm91c2x5KGNiKSB7XG4gICAqICAgY2IoKTtcbiAgICogfVxuICAgKlxuICAgKiBjb25zdCBib3VuZFN5bmNGbiA9IFJ4Lk9ic2VydmFibGUuYmluZENhbGxiYWNrKGlDYWxsTXlDYWxsYmFja1N5bmNocm9ub3VzbHkpO1xuICAgKiBjb25zdCBib3VuZEFzeW5jRm4gPSBSeC5PYnNlcnZhYmxlLmJpbmRDYWxsYmFjayhpQ2FsbE15Q2FsbGJhY2tTeW5jaHJvbm91c2x5LCBudWxsLCBSeC5TY2hlZHVsZXIuYXN5bmMpO1xuICAgKlxuICAgKiBib3VuZFN5bmNGbigpLnN1YnNjcmliZSgoKSA9PiBjb25zb2xlLmxvZygnSSB3YXMgc3luYyEnKSk7XG4gICAqIGJvdW5kQXN5bmNGbigpLnN1YnNjcmliZSgoKSA9PiBjb25zb2xlLmxvZygnSSB3YXMgYXN5bmMhJykpO1xuICAgKiBjb25zb2xlLmxvZygnVGhpcyBoYXBwZW5lZC4uLicpO1xuICAgKlxuICAgKiAvLyBMb2dzOlxuICAgKiAvLyBJIHdhcyBzeW5jIVxuICAgKiAvLyBUaGlzIGhhcHBlbmVkLi4uXG4gICAqIC8vIEkgd2FzIGFzeW5jIVxuICAgKlxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2UgYmluZENhbGxiYWNrIG9uIG9iamVjdCBtZXRob2Q8L2NhcHRpb24+XG4gICAqIGNvbnN0IGJvdW5kTWV0aG9kID0gUnguT2JzZXJ2YWJsZS5iaW5kQ2FsbGJhY2soc29tZU9iamVjdC5tZXRob2RXaXRoQ2FsbGJhY2spO1xuICAgKiBib3VuZE1ldGhvZC5jYWxsKHNvbWVPYmplY3QpIC8vIG1ha2Ugc3VyZSBtZXRob2RXaXRoQ2FsbGJhY2sgaGFzIGFjY2VzcyB0byBzb21lT2JqZWN0XG4gICAqIC5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAqXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGJpbmROb2RlQ2FsbGJhY2t9XG4gICAqIEBzZWUge0BsaW5rIGZyb219XG4gICAqIEBzZWUge0BsaW5rIGZyb21Qcm9taXNlfVxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIEZ1bmN0aW9uIHdpdGggYSBjYWxsYmFjayBhcyB0aGUgbGFzdCBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtzZWxlY3Rvcl0gQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlXG4gICAqIGNhbGxiYWNrIGFuZCBtYXBzIHRob3NlIHRvIGEgdmFsdWUgdG8gZW1pdCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBUaGUgc2NoZWR1bGVyIG9uIHdoaWNoIHRvIHNjaGVkdWxlIHRoZVxuICAgKiBjYWxsYmFja3MuXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLnBhcmFtczogKik6IE9ic2VydmFibGV9IEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGVcbiAgICogT2JzZXJ2YWJsZSB0aGF0IGRlbGl2ZXJzIHRoZSBzYW1lIHZhbHVlcyB0aGUgY2FsbGJhY2sgd291bGQgZGVsaXZlci5cbiAgICogQHN0YXRpYyB0cnVlXG4gICAqIEBuYW1lIGJpbmRDYWxsYmFja1xuICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZTxUPihmdW5jOiBGdW5jdGlvbixcbiAgICAgICAgICAgICAgICAgICBzZWxlY3RvcjogRnVuY3Rpb24gfCB2b2lkID0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiAoLi4uYXJnczogYW55W10pID0+IE9ic2VydmFibGU8VD4ge1xuICAgIHJldHVybiBmdW5jdGlvbih0aGlzOiBhbnksIC4uLmFyZ3M6IGFueVtdKTogT2JzZXJ2YWJsZTxUPiB7XG4gICAgICByZXR1cm4gbmV3IEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlPFQ+KGZ1bmMsIDxhbnk+c2VsZWN0b3IsIGFyZ3MsIHRoaXMsIHNjaGVkdWxlcik7XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY2FsbGJhY2tGdW5jOiBGdW5jdGlvbixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBzZWxlY3RvcjogRnVuY3Rpb24sXG4gICAgICAgICAgICAgIHByaXZhdGUgYXJnczogYW55W10sXG4gICAgICAgICAgICAgIHByaXZhdGUgY29udGV4dDogYW55LFxuICAgICAgICAgICAgICBwcml2YXRlIHNjaGVkdWxlcjogSVNjaGVkdWxlcikge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3N1YnNjcmliZShzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQgfCBUW10+KTogU3Vic2NyaXB0aW9uIHtcbiAgICBjb25zdCBjYWxsYmFja0Z1bmMgPSB0aGlzLmNhbGxiYWNrRnVuYztcbiAgICBjb25zdCBhcmdzID0gdGhpcy5hcmdzO1xuICAgIGNvbnN0IHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgIGxldCBzdWJqZWN0ID0gdGhpcy5zdWJqZWN0O1xuXG4gICAgaWYgKCFzY2hlZHVsZXIpIHtcbiAgICAgIGlmICghc3ViamVjdCkge1xuICAgICAgICBzdWJqZWN0ID0gdGhpcy5zdWJqZWN0ID0gbmV3IEFzeW5jU3ViamVjdDxUPigpO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlckZuKHRoaXM6IGFueSwgLi4uaW5uZXJBcmdzOiBhbnlbXSkge1xuICAgICAgICAgIGNvbnN0IHNvdXJjZSA9ICg8YW55PmhhbmRsZXJGbikuc291cmNlO1xuICAgICAgICAgIGNvbnN0IHsgc2VsZWN0b3IsIHN1YmplY3QgfSA9IHNvdXJjZTtcbiAgICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRyeUNhdGNoKHNlbGVjdG9yKS5hcHBseSh0aGlzLCBpbm5lckFyZ3MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICAgICAgc3ViamVjdC5lcnJvcihlcnJvck9iamVjdC5lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdWJqZWN0Lm5leHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgc3ViamVjdC5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdWJqZWN0Lm5leHQoaW5uZXJBcmdzLmxlbmd0aCA8PSAxID8gaW5uZXJBcmdzWzBdIDogaW5uZXJBcmdzKTtcbiAgICAgICAgICAgIHN1YmplY3QuY29tcGxldGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIHVzZSBuYW1lZCBmdW5jdGlvbiBpbnN0YW5jZSB0byBhdm9pZCBjbG9zdXJlLlxuICAgICAgICAoPGFueT5oYW5kbGVyKS5zb3VyY2UgPSB0aGlzO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRyeUNhdGNoKGNhbGxiYWNrRnVuYykuYXBwbHkodGhpcy5jb250ZXh0LCBhcmdzLmNvbmNhdChoYW5kbGVyKSk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgc3ViamVjdC5lcnJvcihlcnJvck9iamVjdC5lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN1YmplY3Quc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlKEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7IHNvdXJjZTogdGhpcywgc3Vic2NyaWJlciwgY29udGV4dDogdGhpcy5jb250ZXh0IH0pO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBkaXNwYXRjaDxUPihzdGF0ZTogeyBzb3VyY2U6IEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlPFQ+LCBzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+LCBjb250ZXh0OiBhbnkgfSkge1xuICAgIGNvbnN0IHNlbGYgPSAoPFN1YnNjcmlwdGlvbj48YW55PnRoaXMpO1xuICAgIGNvbnN0IHsgc291cmNlLCBzdWJzY3JpYmVyLCBjb250ZXh0IH0gPSBzdGF0ZTtcbiAgICBjb25zdCB7IGNhbGxiYWNrRnVuYywgYXJncywgc2NoZWR1bGVyIH0gPSBzb3VyY2U7XG4gICAgbGV0IHN1YmplY3QgPSBzb3VyY2Uuc3ViamVjdDtcblxuICAgIGlmICghc3ViamVjdCkge1xuICAgICAgc3ViamVjdCA9IHNvdXJjZS5zdWJqZWN0ID0gbmV3IEFzeW5jU3ViamVjdDxUPigpO1xuXG4gICAgICBjb25zdCBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlckZuKHRoaXM6IGFueSwgLi4uaW5uZXJBcmdzOiBhbnlbXSkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSAoPGFueT5oYW5kbGVyRm4pLnNvdXJjZTtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rvciwgc3ViamVjdCB9ID0gc291cmNlO1xuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB0cnlDYXRjaChzZWxlY3RvcikuYXBwbHkodGhpcywgaW5uZXJBcmdzKTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdCkge1xuICAgICAgICAgICAgc2VsZi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoRXJyb3IsIDAsIHsgZXJyOiBlcnJvck9iamVjdC5lLCBzdWJqZWN0IH0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgMCwgeyB2YWx1ZTogcmVzdWx0LCBzdWJqZWN0IH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBpbm5lckFyZ3MubGVuZ3RoIDw9IDEgPyBpbm5lckFyZ3NbMF0gOiBpbm5lckFyZ3M7XG4gICAgICAgICAgc2VsZi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgMCwgeyB2YWx1ZSwgc3ViamVjdCB9KSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICAvLyB1c2UgbmFtZWQgZnVuY3Rpb24gdG8gcGFzcyB2YWx1ZXMgaW4gd2l0aG91dCBjbG9zdXJlXG4gICAgICAoPGFueT5oYW5kbGVyKS5zb3VyY2UgPSBzb3VyY2U7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRyeUNhdGNoKGNhbGxiYWNrRnVuYykuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoaGFuZGxlcikpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3QpIHtcbiAgICAgICAgc3ViamVjdC5lcnJvcihlcnJvck9iamVjdC5lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxmLmFkZChzdWJqZWN0LnN1YnNjcmliZShzdWJzY3JpYmVyKSk7XG4gIH1cbn1cblxuaW50ZXJmYWNlIERpc3BhdGNoTmV4dEFyZzxUPiB7XG4gIHN1YmplY3Q6IEFzeW5jU3ViamVjdDxUPjtcbiAgdmFsdWU6IFQ7XG59XG5mdW5jdGlvbiBkaXNwYXRjaE5leHQ8VD4oYXJnOiBEaXNwYXRjaE5leHRBcmc8VD4pIHtcbiAgY29uc3QgeyB2YWx1ZSwgc3ViamVjdCB9ID0gYXJnO1xuICBzdWJqZWN0Lm5leHQodmFsdWUpO1xuICBzdWJqZWN0LmNvbXBsZXRlKCk7XG59XG5cbmludGVyZmFjZSBEaXNwYXRjaEVycm9yQXJnPFQ+IHtcbiAgc3ViamVjdDogQXN5bmNTdWJqZWN0PFQ+O1xuICBlcnI6IGFueTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoRXJyb3I8VD4oYXJnOiBEaXNwYXRjaEVycm9yQXJnPFQ+KSB7XG4gIGNvbnN0IHsgZXJyLCBzdWJqZWN0IH0gPSBhcmc7XG4gIHN1YmplY3QuZXJyb3IoZXJyKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9Cb3VuZENhbGxiYWNrT2JzZXJ2YWJsZS50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBJU2NoZWR1bGVyIH0gZnJvbSAnLi4vU2NoZWR1bGVyJztcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4uL3NjaGVkdWxlci9BY3Rpb24nO1xuaW1wb3J0IHsgdHJ5Q2F0Y2ggfSBmcm9tICcuLi91dGlsL3RyeUNhdGNoJztcbmltcG9ydCB7IGVycm9yT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9lcnJvck9iamVjdCc7XG5pbXBvcnQgeyBBc3luY1N1YmplY3QgfSBmcm9tICcuLi9Bc3luY1N1YmplY3QnO1xuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xuZXhwb3J0IGNsYXNzIEJvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZTxUPiBleHRlbmRzIE9ic2VydmFibGU8VD4ge1xuICBzdWJqZWN0OiBBc3luY1N1YmplY3Q8VD47XG5cbiAgLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4gIHN0YXRpYyBjcmVhdGU8Uj4oY2FsbGJhY2tGdW5jOiAoY2FsbGJhY2s6IChlcnI6IGFueSwgcmVzdWx0OiBSKSA9PiBhbnkpID0+IGFueSwgc2VsZWN0b3I/OiB2b2lkLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogKCkgPT4gT2JzZXJ2YWJsZTxSPjtcbiAgc3RhdGljIGNyZWF0ZTxULCBSPihjYWxsYmFja0Z1bmM6ICh2MTogVCwgY2FsbGJhY2s6IChlcnI6IGFueSwgcmVzdWx0OiBSKSA9PiBhbnkpID0+IGFueSwgc2VsZWN0b3I/OiB2b2lkLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogKHYxOiBUKSA9PiBPYnNlcnZhYmxlPFI+O1xuICBzdGF0aWMgY3JlYXRlPFQsIFQyLCBSPihjYWxsYmFja0Z1bmM6ICh2MTogVCwgdjI6IFQyLCBjYWxsYmFjazogKGVycjogYW55LCByZXN1bHQ6IFIpID0+IGFueSkgPT4gYW55LCBzZWxlY3Rvcj86IHZvaWQsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiAodjE6IFQsIHYyOiBUMikgPT4gT2JzZXJ2YWJsZTxSPjtcbiAgc3RhdGljIGNyZWF0ZTxULCBUMiwgVDMsIFI+KGNhbGxiYWNrRnVuYzogKHYxOiBULCB2MjogVDIsIHYzOiBUMywgY2FsbGJhY2s6IChlcnI6IGFueSwgcmVzdWx0OiBSKSA9PiBhbnkpID0+IGFueSwgc2VsZWN0b3I/OiB2b2lkLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogKHYxOiBULCB2MjogVDIsIHYzOiBUMykgPT4gT2JzZXJ2YWJsZTxSPjtcbiAgc3RhdGljIGNyZWF0ZTxULCBUMiwgVDMsIFQ0LCBSPihjYWxsYmFja0Z1bmM6ICh2MTogVCwgdjI6IFQyLCB2MzogVDMsIHY0OiBUNCwgY2FsbGJhY2s6IChlcnI6IGFueSwgcmVzdWx0OiBSKSA9PiBhbnkpID0+IGFueSwgc2VsZWN0b3I/OiB2b2lkLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogKHYxOiBULCB2MjogVDIsIHYzOiBUMywgdjQ6IFQ0KSA9PiBPYnNlcnZhYmxlPFI+O1xuICBzdGF0aWMgY3JlYXRlPFQsIFQyLCBUMywgVDQsIFQ1LCBSPihjYWxsYmFja0Z1bmM6ICh2MTogVCwgdjI6IFQyLCB2MzogVDMsIHY0OiBUNCwgdjU6IFQ1LCBjYWxsYmFjazogKGVycjogYW55LCByZXN1bHQ6IFIpID0+IGFueSkgPT4gYW55LCBzZWxlY3Rvcj86IHZvaWQsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiAodjE6IFQsIHYyOiBUMiwgdjM6IFQzLCB2NDogVDQsIHY1OiBUNSkgPT4gT2JzZXJ2YWJsZTxSPjtcbiAgc3RhdGljIGNyZWF0ZTxULCBUMiwgVDMsIFQ0LCBUNSwgVDYsIFI+KGNhbGxiYWNrRnVuYzogKHYxOiBULCB2MjogVDIsIHYzOiBUMywgdjQ6IFQ0LCB2NTogVDUsIHY2OiBUNiwgY2FsbGJhY2s6IChlcnI6IGFueSwgcmVzdWx0OiBSKSA9PiBhbnkpID0+IGFueSwgc2VsZWN0b3I/OiB2b2lkLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogKHYxOiBULCB2MjogVDIsIHYzOiBUMywgdjQ6IFQ0LCB2NTogVDUsIHY2OiBUNikgPT4gT2JzZXJ2YWJsZTxSPjtcbiAgc3RhdGljIGNyZWF0ZTxUPihjYWxsYmFja0Z1bmM6IEZ1bmN0aW9uLCBzZWxlY3Rvcj86IHZvaWQsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiAoLi4uYXJnczogYW55W10pID0+IE9ic2VydmFibGU8VD47XG4gIHN0YXRpYyBjcmVhdGU8VD4oY2FsbGJhY2tGdW5jOiBGdW5jdGlvbiwgc2VsZWN0b3I/OiAoLi4uYXJnczogYW55W10pID0+IFQsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiAoLi4uYXJnczogYW55W10pID0+IE9ic2VydmFibGU8VD47XG4gIC8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgTm9kZS5qcy1zdHlsZSBjYWxsYmFjayBBUEkgdG8gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW5cbiAgICogT2JzZXJ2YWJsZS5cbiAgICpcbiAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MganVzdCBsaWtlIHtAbGluayBiaW5kQ2FsbGJhY2t9LCBidXQgdGhlXG4gICAqIGNhbGxiYWNrIGlzIGV4cGVjdGVkIHRvIGJlIG9mIHR5cGUgYGNhbGxiYWNrKGVycm9yLCByZXN1bHQpYC48L3NwYW4+XG4gICAqXG4gICAqIGBiaW5kTm9kZUNhbGxiYWNrYCBpcyBub3QgYW4gb3BlcmF0b3IgYmVjYXVzZSBpdHMgaW5wdXQgYW5kIG91dHB1dCBhcmUgbm90XG4gICAqIE9ic2VydmFibGVzLiBUaGUgaW5wdXQgaXMgYSBmdW5jdGlvbiBgZnVuY2Agd2l0aCBzb21lIHBhcmFtZXRlcnMsIGJ1dCB0aGVcbiAgICogbGFzdCBwYXJhbWV0ZXIgbXVzdCBiZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgYGZ1bmNgIGNhbGxzIHdoZW4gaXQgaXNcbiAgICogZG9uZS4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIGZvbGxvdyBOb2RlLmpzIGNvbnZlbnRpb25zLFxuICAgKiB3aGVyZSB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGNhbGxiYWNrIGlzIGFuIGVycm9yIG9iamVjdCwgc2lnbmFsaW5nXG4gICAqIHdoZXRoZXIgY2FsbCB3YXMgc3VjY2Vzc2Z1bC4gSWYgdGhhdCBvYmplY3QgaXMgcGFzc2VkIHRvIGNhbGxiYWNrLCBpdCBtZWFuc1xuICAgKiBzb21ldGhpbmcgd2VudCB3cm9uZy5cbiAgICpcbiAgICogVGhlIG91dHB1dCBvZiBgYmluZE5vZGVDYWxsYmFja2AgaXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHRoZSBzYW1lXG4gICAqIHBhcmFtZXRlcnMgYXMgYGZ1bmNgLCBleGNlcHQgdGhlIGxhc3Qgb25lICh0aGUgY2FsbGJhY2spLiBXaGVuIHRoZSBvdXRwdXRcbiAgICogZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYXJndW1lbnRzLCBpdCB3aWxsIHJldHVybiBhbiBPYnNlcnZhYmxlLlxuICAgKiBJZiBgZnVuY2AgY2FsbHMgaXRzIGNhbGxiYWNrIHdpdGggZXJyb3IgcGFyYW1ldGVyIHByZXNlbnQsIE9ic2VydmFibGUgd2lsbFxuICAgKiBlcnJvciB3aXRoIHRoYXQgdmFsdWUgYXMgd2VsbC4gSWYgZXJyb3IgcGFyYW1ldGVyIGlzIG5vdCBwYXNzZWQsIE9ic2VydmFibGUgd2lsbCBlbWl0XG4gICAqIHNlY29uZCBwYXJhbWV0ZXIuIElmIHRoZXJlIGFyZSBtb3JlIHBhcmFtZXRlcnMgKHRoaXJkIGFuZCBzbyBvbiksXG4gICAqIE9ic2VydmFibGUgd2lsbCBlbWl0IGFuIGFycmF5IHdpdGggYWxsIGFyZ3VtZW50cywgZXhjZXB0IGZpcnN0IGVycm9yIGFyZ3VtZW50LlxuICAgKlxuICAgKiBPcHRpb25hbGx5IGBiaW5kTm9kZUNhbGxiYWNrYCBhY2NlcHRzIHNlbGVjdG9yIGZ1bmN0aW9uLCB3aGljaCBhbGxvd3MgeW91IHRvXG4gICAqIG1ha2UgcmVzdWx0aW5nIE9ic2VydmFibGUgZW1pdCB2YWx1ZSBjb21wdXRlZCBieSBzZWxlY3RvciwgaW5zdGVhZCBvZiByZWd1bGFyXG4gICAqIGNhbGxiYWNrIGFyZ3VtZW50cy4gSXQgd29ya3Mgc2ltaWxhcmx5IHRvIHtAbGluayBiaW5kQ2FsbGJhY2t9IHNlbGVjdG9yLCBidXRcbiAgICogTm9kZS5qcy1zdHlsZSBlcnJvciBhcmd1bWVudCB3aWxsIG5ldmVyIGJlIHBhc3NlZCB0byB0aGF0IGZ1bmN0aW9uLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgYGZ1bmNgIHdpbGwgbm90IGJlIGNhbGxlZCBhdCB0aGUgc2FtZSB0aW1lIG91dHB1dCBmdW5jdGlvbiBpcyxcbiAgICogYnV0IHJhdGhlciB3aGVuZXZlciByZXN1bHRpbmcgT2JzZXJ2YWJsZSBpcyBzdWJzY3JpYmVkLiBCeSBkZWZhdWx0IGNhbGwgdG9cbiAgICogYGZ1bmNgIHdpbGwgaGFwcGVuIHN5bmNocm9ub3VzbHkgYWZ0ZXIgc3Vic2NyaXB0aW9uLCBidXQgdGhhdCBjYW4gYmUgY2hhbmdlZFxuICAgKiB3aXRoIHByb3BlciB7QGxpbmsgU2NoZWR1bGVyfSBwcm92aWRlZCBhcyBvcHRpb25hbCB0aGlyZCBwYXJhbWV0ZXIuIFNjaGVkdWxlclxuICAgKiBjYW4gYWxzbyBjb250cm9sIHdoZW4gdmFsdWVzIGZyb20gY2FsbGJhY2sgd2lsbCBiZSBlbWl0dGVkIGJ5IE9ic2VydmFibGUuXG4gICAqIFRvIGZpbmQgb3V0IG1vcmUsIGNoZWNrIG91dCBkb2N1bWVudGF0aW9uIGZvciB7QGxpbmsgYmluZENhbGxiYWNrfSwgd2hlcmVcbiAgICogU2NoZWR1bGVyIHdvcmtzIGV4YWN0bHkgdGhlIHNhbWUuXG4gICAqXG4gICAqIEFzIGluIHtAbGluayBiaW5kQ2FsbGJhY2t9LCBjb250ZXh0IChgdGhpc2AgcHJvcGVydHkpIG9mIGlucHV0IGZ1bmN0aW9uIHdpbGwgYmUgc2V0IHRvIGNvbnRleHRcbiAgICogb2YgcmV0dXJuZWQgZnVuY3Rpb24sIHdoZW4gaXQgaXMgY2FsbGVkLlxuICAgKlxuICAgKiBBZnRlciBPYnNlcnZhYmxlIGVtaXRzIHZhbHVlLCBpdCB3aWxsIGNvbXBsZXRlIGltbWVkaWF0ZWx5LiBUaGlzIG1lYW5zXG4gICAqIGV2ZW4gaWYgYGZ1bmNgIGNhbGxzIGNhbGxiYWNrIGFnYWluLCB2YWx1ZXMgZnJvbSBzZWNvbmQgYW5kIGNvbnNlY3V0aXZlXG4gICAqIGNhbGxzIHdpbGwgbmV2ZXIgYXBwZWFyIG9uIHRoZSBzdHJlYW0uIElmIHlvdSBuZWVkIHRvIGhhbmRsZSBmdW5jdGlvbnNcbiAgICogdGhhdCBjYWxsIGNhbGxiYWNrcyBtdWx0aXBsZSB0aW1lcywgY2hlY2sgb3V0IHtAbGluayBmcm9tRXZlbnR9IG9yXG4gICAqIHtAbGluayBmcm9tRXZlbnRQYXR0ZXJufSBpbnN0ZWFkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgYGJpbmROb2RlQ2FsbGJhY2tgIGNhbiBiZSB1c2VkIGluIG5vbi1Ob2RlLmpzIGVudmlyb25tZW50cyBhcyB3ZWxsLlxuICAgKiBcIk5vZGUuanMtc3R5bGVcIiBjYWxsYmFja3MgYXJlIGp1c3QgYSBjb252ZW50aW9uLCBzbyBpZiB5b3Ugd3JpdGUgZm9yXG4gICAqIGJyb3dzZXJzIG9yIGFueSBvdGhlciBlbnZpcm9ubWVudCBhbmQgQVBJIHlvdSB1c2UgaW1wbGVtZW50cyB0aGF0IGNhbGxiYWNrIHN0eWxlLFxuICAgKiBgYmluZE5vZGVDYWxsYmFja2AgY2FuIGJlIHNhZmVseSB1c2VkIG9uIHRoYXQgQVBJIGZ1bmN0aW9ucyBhcyB3ZWxsLlxuICAgKlxuICAgKiBSZW1lbWJlciB0aGF0IEVycm9yIG9iamVjdCBwYXNzZWQgdG8gY2FsbGJhY2sgZG9lcyBub3QgaGF2ZSB0byBiZSBhbiBpbnN0YW5jZVxuICAgKiBvZiBKYXZhU2NyaXB0IGJ1aWx0LWluIGBFcnJvcmAgb2JqZWN0LiBJbiBmYWN0LCBpdCBkb2VzIG5vdCBldmVuIGhhdmUgdG8gYW4gb2JqZWN0LlxuICAgKiBFcnJvciBwYXJhbWV0ZXIgb2YgY2FsbGJhY2sgZnVuY3Rpb24gaXMgaW50ZXJwcmV0ZWQgYXMgXCJwcmVzZW50XCIsIHdoZW4gdmFsdWVcbiAgICogb2YgdGhhdCBwYXJhbWV0ZXIgaXMgdHJ1dGh5LiBJdCBjb3VsZCBiZSwgZm9yIGV4YW1wbGUsIG5vbi16ZXJvIG51bWJlciwgbm9uLWVtcHR5XG4gICAqIHN0cmluZyBvciBib29sZWFuIGB0cnVlYC4gSW4gYWxsIG9mIHRoZXNlIGNhc2VzIHJlc3VsdGluZyBPYnNlcnZhYmxlIHdvdWxkIGVycm9yXG4gICAqIHdpdGggdGhhdCB2YWx1ZS4gVGhpcyBtZWFucyB1c3VhbGx5IHJlZ3VsYXIgc3R5bGUgY2FsbGJhY2tzIHdpbGwgZmFpbCB2ZXJ5IG9mdGVuIHdoZW5cbiAgICogYGJpbmROb2RlQ2FsbGJhY2tgIGlzIHVzZWQuIElmIHlvdXIgT2JzZXJ2YWJsZSBlcnJvcnMgbXVjaCBtb3JlIG9mdGVuIHRoZW4geW91XG4gICAqIHdvdWxkIGV4cGVjdCwgY2hlY2sgaWYgY2FsbGJhY2sgcmVhbGx5IGlzIGNhbGxlZCBpbiBOb2RlLmpzLXN0eWxlIGFuZCwgaWYgbm90LFxuICAgKiBzd2l0Y2ggdG8ge0BsaW5rIGJpbmRDYWxsYmFja30gaW5zdGVhZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGV2ZW4gaWYgZXJyb3IgcGFyYW1ldGVyIGlzIHRlY2huaWNhbGx5IHByZXNlbnQgaW4gY2FsbGJhY2ssIGJ1dCBpdHMgdmFsdWVcbiAgICogaXMgZmFsc3ksIGl0IHN0aWxsIHdvbid0IGFwcGVhciBpbiBhcnJheSBlbWl0dGVkIGJ5IE9ic2VydmFibGUgb3IgaW4gc2VsZWN0b3IgZnVuY3Rpb24uXG4gICAqXG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPlJlYWQgYSBmaWxlIGZyb20gdGhlIGZpbGVzeXN0ZW0gYW5kIGdldCB0aGUgZGF0YSBhcyBhbiBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICAgKiBpbXBvcnQgKiBhcyBmcyBmcm9tICdmcyc7XG4gICAqIHZhciByZWFkRmlsZUFzT2JzZXJ2YWJsZSA9IFJ4Lk9ic2VydmFibGUuYmluZE5vZGVDYWxsYmFjayhmcy5yZWFkRmlsZSk7XG4gICAqIHZhciByZXN1bHQgPSByZWFkRmlsZUFzT2JzZXJ2YWJsZSgnLi9yb2FkTmFtZXMudHh0JywgJ3V0ZjgnKTtcbiAgICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpLCBlID0+IGNvbnNvbGUuZXJyb3IoZSkpO1xuICAgKlxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2Ugb24gZnVuY3Rpb24gY2FsbGluZyBjYWxsYmFjayB3aXRoIG11bHRpcGxlIGFyZ3VtZW50czwvY2FwdGlvbj5cbiAgICogc29tZUZ1bmN0aW9uKChlcnIsIGEsIGIpID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhlcnIpOyAvLyBudWxsXG4gICAqICAgY29uc29sZS5sb2coYSk7IC8vIDVcbiAgICogICBjb25zb2xlLmxvZyhiKTsgLy8gXCJzb21lIHN0cmluZ1wiXG4gICAqIH0pO1xuICAgKiB2YXIgYm91bmRTb21lRnVuY3Rpb24gPSBSeC5PYnNlcnZhYmxlLmJpbmROb2RlQ2FsbGJhY2soc29tZUZ1bmN0aW9uKTtcbiAgICogYm91bmRTb21lRnVuY3Rpb24oKVxuICAgKiAuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7IC8vIFs1LCBcInNvbWUgc3RyaW5nXCJdXG4gICAqIH0pO1xuICAgKlxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2Ugd2l0aCBzZWxlY3RvciBmdW5jdGlvbjwvY2FwdGlvbj5cbiAgICogc29tZUZ1bmN0aW9uKChlcnIsIGEsIGIpID0+IHtcbiAgICogICBjb25zb2xlLmxvZyhlcnIpOyAvLyB1bmRlZmluZWRcbiAgICogICBjb25zb2xlLmxvZyhhKTsgLy8gXCJhYmNcIlxuICAgKiAgIGNvbnNvbGUubG9nKGIpOyAvLyBcIkRFRlwiXG4gICAqIH0pO1xuICAgKiB2YXIgYm91bmRTb21lRnVuY3Rpb24gPSBSeC5PYnNlcnZhYmxlLmJpbmROb2RlQ2FsbGJhY2soc29tZUZ1bmN0aW9uLCAoYSwgYikgPT4gYSArIGIpO1xuICAgKiBib3VuZFNvbWVGdW5jdGlvbigpXG4gICAqIC5zdWJzY3JpYmUodmFsdWUgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTsgLy8gXCJhYmNERUZcIlxuICAgKiB9KTtcbiAgICpcbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+VXNlIG9uIGZ1bmN0aW9uIGNhbGxpbmcgY2FsbGJhY2sgaW4gcmVndWxhciBzdHlsZTwvY2FwdGlvbj5cbiAgICogc29tZUZ1bmN0aW9uKGEgPT4ge1xuICAgKiAgIGNvbnNvbGUubG9nKGEpOyAvLyA1XG4gICAqIH0pO1xuICAgKiB2YXIgYm91bmRTb21lRnVuY3Rpb24gPSBSeC5PYnNlcnZhYmxlLmJpbmROb2RlQ2FsbGJhY2soc29tZUZ1bmN0aW9uKTtcbiAgICogYm91bmRTb21lRnVuY3Rpb24oKVxuICAgKiAuc3Vic2NyaWJlKFxuICAgKiAgIHZhbHVlID0+IHt9ICAgICAgICAgICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAqICAgZXJyID0+IGNvbnNvbGUubG9nKGVycikgLy8gNVxuICAgKik7XG4gICAqXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGJpbmRDYWxsYmFja31cbiAgICogQHNlZSB7QGxpbmsgZnJvbX1cbiAgICogQHNlZSB7QGxpbmsgZnJvbVByb21pc2V9XG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgRnVuY3Rpb24gd2l0aCBhIE5vZGUuanMtc3R5bGUgY2FsbGJhY2sgYXMgdGhlIGxhc3QgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbc2VsZWN0b3JdIEEgZnVuY3Rpb24gd2hpY2ggdGFrZXMgdGhlIGFyZ3VtZW50cyBmcm9tIHRoZVxuICAgKiBjYWxsYmFjayBhbmQgbWFwcyB0aG9zZSB0byBhIHZhbHVlIHRvIGVtaXQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gVGhlIHNjaGVkdWxlciBvbiB3aGljaCB0byBzY2hlZHVsZSB0aGVcbiAgICogY2FsbGJhY2tzLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbiguLi5wYXJhbXM6ICopOiBPYnNlcnZhYmxlfSBBIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlXG4gICAqIE9ic2VydmFibGUgdGhhdCBkZWxpdmVycyB0aGUgc2FtZSB2YWx1ZXMgdGhlIE5vZGUuanMgY2FsbGJhY2sgd291bGRcbiAgICogZGVsaXZlci5cbiAgICogQHN0YXRpYyB0cnVlXG4gICAqIEBuYW1lIGJpbmROb2RlQ2FsbGJhY2tcbiAgICogQG93bmVyIE9ic2VydmFibGVcbiAgICovXG4gIHN0YXRpYyBjcmVhdGU8VD4oZnVuYzogRnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IEZ1bmN0aW9uIHwgdm9pZCA9IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogKC4uLmFyZ3M6IGFueVtdKSA9PiBPYnNlcnZhYmxlPFQ+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24odGhpczogYW55LCAuLi5hcmdzOiBhbnlbXSk6IE9ic2VydmFibGU8VD4ge1xuICAgICAgcmV0dXJuIG5ldyBCb3VuZE5vZGVDYWxsYmFja09ic2VydmFibGU8VD4oZnVuYywgPGFueT5zZWxlY3RvciwgYXJncywgdGhpcywgc2NoZWR1bGVyKTtcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjYWxsYmFja0Z1bmM6IEZ1bmN0aW9uLFxuICAgICAgICAgICAgICBwcml2YXRlIHNlbGVjdG9yOiBGdW5jdGlvbixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBhcmdzOiBhbnlbXSxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBjb250ZXh0OiBhbnksXG4gICAgICAgICAgICAgIHB1YmxpYyBzY2hlZHVsZXI6IElTY2hlZHVsZXIpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9zdWJzY3JpYmUoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUIHwgVFtdPik6IFN1YnNjcmlwdGlvbiB7XG4gICAgY29uc3QgY2FsbGJhY2tGdW5jID0gdGhpcy5jYWxsYmFja0Z1bmM7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuYXJncztcbiAgICBjb25zdCBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcbiAgICBsZXQgc3ViamVjdCA9IHRoaXMuc3ViamVjdDtcblxuICAgIGlmICghc2NoZWR1bGVyKSB7XG4gICAgICBpZiAoIXN1YmplY3QpIHtcbiAgICAgICAgc3ViamVjdCA9IHRoaXMuc3ViamVjdCA9IG5ldyBBc3luY1N1YmplY3Q8VD4oKTtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IGZ1bmN0aW9uIGhhbmRsZXJGbih0aGlzOiBhbnksIC4uLmlubmVyQXJnczogYW55W10pIHtcbiAgICAgICAgICBjb25zdCBzb3VyY2UgPSAoPGFueT5oYW5kbGVyRm4pLnNvdXJjZTtcbiAgICAgICAgICBjb25zdCB7IHNlbGVjdG9yLCBzdWJqZWN0IH0gPSBzb3VyY2U7XG4gICAgICAgICAgY29uc3QgZXJyID0gaW5uZXJBcmdzLnNoaWZ0KCk7XG5cbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBzdWJqZWN0LmVycm9yKGVycik7XG4gICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdHJ5Q2F0Y2goc2VsZWN0b3IpLmFwcGx5KHRoaXMsIGlubmVyQXJncyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdCkge1xuICAgICAgICAgICAgICBzdWJqZWN0LmVycm9yKGVycm9yT2JqZWN0LmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3ViamVjdC5uZXh0KHJlc3VsdCk7XG4gICAgICAgICAgICAgIHN1YmplY3QuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ViamVjdC5uZXh0KGlubmVyQXJncy5sZW5ndGggPD0gMSA/IGlubmVyQXJnc1swXSA6IGlubmVyQXJncyk7XG4gICAgICAgICAgICBzdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyB1c2UgbmFtZWQgZnVuY3Rpb24gaW5zdGFuY2UgdG8gYXZvaWQgY2xvc3VyZS5cbiAgICAgICAgKDxhbnk+aGFuZGxlcikuc291cmNlID0gdGhpcztcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0cnlDYXRjaChjYWxsYmFja0Z1bmMpLmFwcGx5KHRoaXMuY29udGV4dCwgYXJncy5jb25jYXQoaGFuZGxlcikpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdCkge1xuICAgICAgICAgIHN1YmplY3QuZXJyb3IoZXJyb3JPYmplY3QuZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdWJqZWN0LnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaCwgMCwgeyBzb3VyY2U6IHRoaXMsIHN1YnNjcmliZXIsIGNvbnRleHQ6IHRoaXMuY29udGV4dCB9KTtcbiAgICB9XG4gIH1cbn1cblxuaW50ZXJmYWNlIERpc3BhdGNoU3RhdGU8VD4ge1xuICBzb3VyY2U6IEJvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZTxUPjtcbiAgc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPjtcbiAgY29udGV4dDogYW55O1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaDxUPih0aGlzOiBBY3Rpb248RGlzcGF0Y2hTdGF0ZTxUPj4sIHN0YXRlOiBEaXNwYXRjaFN0YXRlPFQ+KSB7XG4gIGNvbnN0IHNlbGYgPSAoPFN1YnNjcmlwdGlvbj4gdGhpcyk7XG4gIGNvbnN0IHsgc291cmNlLCBzdWJzY3JpYmVyLCBjb250ZXh0IH0gPSBzdGF0ZTtcbiAgLy8gWFhYOiBjYXN0IHRvIGBhbnlgIHRvIGFjY2VzcyB0byB0aGUgcHJpdmF0ZSBmaWVsZCBpbiBgc291cmNlYC5cbiAgY29uc3QgeyBjYWxsYmFja0Z1bmMsIGFyZ3MsIHNjaGVkdWxlciB9ID0gc291cmNlIGFzIGFueTtcbiAgbGV0IHN1YmplY3QgPSBzb3VyY2Uuc3ViamVjdDtcblxuICBpZiAoIXN1YmplY3QpIHtcbiAgICBzdWJqZWN0ID0gc291cmNlLnN1YmplY3QgPSBuZXcgQXN5bmNTdWJqZWN0PFQ+KCk7XG5cbiAgICBjb25zdCBoYW5kbGVyID0gZnVuY3Rpb24gaGFuZGxlckZuKHRoaXM6IGFueSwgLi4uaW5uZXJBcmdzOiBhbnlbXSkge1xuICAgICAgY29uc3Qgc291cmNlID0gKDxhbnk+aGFuZGxlckZuKS5zb3VyY2U7XG4gICAgICBjb25zdCB7IHNlbGVjdG9yLCBzdWJqZWN0IH0gPSBzb3VyY2U7XG4gICAgICBjb25zdCBlcnIgPSBpbm5lckFyZ3Muc2hpZnQoKTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICBzZWxmLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hFcnJvciwgMCwgeyBlcnIsIHN1YmplY3QgfSkpO1xuICAgICAgfSBlbHNlIGlmIChzZWxlY3Rvcikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0cnlDYXRjaChzZWxlY3RvcikuYXBwbHkodGhpcywgaW5uZXJBcmdzKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICBzZWxmLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hFcnJvciwgMCwgeyBlcnI6IGVycm9yT2JqZWN0LmUsIHN1YmplY3QgfSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaE5leHQsIDAsIHsgdmFsdWU6IHJlc3VsdCwgc3ViamVjdCB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaW5uZXJBcmdzLmxlbmd0aCA8PSAxID8gaW5uZXJBcmdzWzBdIDogaW5uZXJBcmdzO1xuICAgICAgICBzZWxmLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hOZXh0LCAwLCB7IHZhbHVlLCBzdWJqZWN0IH0pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIC8vIHVzZSBuYW1lZCBmdW5jdGlvbiB0byBwYXNzIHZhbHVlcyBpbiB3aXRob3V0IGNsb3N1cmVcbiAgICAoPGFueT5oYW5kbGVyKS5zb3VyY2UgPSBzb3VyY2U7XG5cbiAgICBjb25zdCByZXN1bHQgPSB0cnlDYXRjaChjYWxsYmFja0Z1bmMpLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KGhhbmRsZXIpKTtcbiAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdCkge1xuICAgICAgc2VsZi5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoRXJyb3IsIDAsIHsgZXJyOiBlcnJvck9iamVjdC5lLCBzdWJqZWN0IH0pKTtcbiAgICB9XG4gIH1cblxuICBzZWxmLmFkZChzdWJqZWN0LnN1YnNjcmliZShzdWJzY3JpYmVyKSk7XG59XG5cbmludGVyZmFjZSBEaXNwYXRjaE5leHRBcmc8VD4ge1xuICBzdWJqZWN0OiBBc3luY1N1YmplY3Q8VD47XG4gIHZhbHVlOiBUO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hOZXh0PFQ+KGFyZzogRGlzcGF0Y2hOZXh0QXJnPFQ+KSB7XG4gIGNvbnN0IHsgdmFsdWUsIHN1YmplY3QgfSA9IGFyZztcbiAgc3ViamVjdC5uZXh0KHZhbHVlKTtcbiAgc3ViamVjdC5jb21wbGV0ZSgpO1xufVxuXG5pbnRlcmZhY2UgRGlzcGF0Y2hFcnJvckFyZzxUPiB7XG4gIHN1YmplY3Q6IEFzeW5jU3ViamVjdDxUPjtcbiAgZXJyOiBhbnk7XG59XG5mdW5jdGlvbiBkaXNwYXRjaEVycm9yPFQ+KGFyZzogRGlzcGF0Y2hFcnJvckFyZzxUPikge1xuICBjb25zdCB7IGVyciwgc3ViamVjdCB9ID0gYXJnO1xuICBzdWJqZWN0LmVycm9yKGVycik7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29ic2VydmFibGUvQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlLnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3Vic2NyaWJhYmxlT3JQcm9taXNlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuXG5pbXBvcnQgeyBzdWJzY3JpYmVUb1Jlc3VsdCB9IGZyb20gJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnO1xuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vT3V0ZXJTdWJzY3JpYmVyJztcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG5leHBvcnQgY2xhc3MgRGVmZXJPYnNlcnZhYmxlPFQ+IGV4dGVuZHMgT2JzZXJ2YWJsZTxUPiB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0LCBvbiBzdWJzY3JpYmUsIGNhbGxzIGFuIE9ic2VydmFibGUgZmFjdG9yeSB0b1xuICAgKiBtYWtlIGFuIE9ic2VydmFibGUgZm9yIGVhY2ggbmV3IE9ic2VydmVyLlxuICAgKlxuICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q3JlYXRlcyB0aGUgT2JzZXJ2YWJsZSBsYXppbHksIHRoYXQgaXMsIG9ubHkgd2hlbiBpdFxuICAgKiBpcyBzdWJzY3JpYmVkLlxuICAgKiA8L3NwYW4+XG4gICAqXG4gICAqIDxpbWcgc3JjPVwiLi9pbWcvZGVmZXIucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAqXG4gICAqIGBkZWZlcmAgYWxsb3dzIHlvdSB0byBjcmVhdGUgdGhlIE9ic2VydmFibGUgb25seSB3aGVuIHRoZSBPYnNlcnZlclxuICAgKiBzdWJzY3JpYmVzLCBhbmQgY3JlYXRlIGEgZnJlc2ggT2JzZXJ2YWJsZSBmb3IgZWFjaCBPYnNlcnZlci4gSXQgd2FpdHMgdW50aWxcbiAgICogYW4gT2JzZXJ2ZXIgc3Vic2NyaWJlcyB0byBpdCwgYW5kIHRoZW4gaXQgZ2VuZXJhdGVzIGFuIE9ic2VydmFibGUsXG4gICAqIHR5cGljYWxseSB3aXRoIGFuIE9ic2VydmFibGUgZmFjdG9yeSBmdW5jdGlvbi4gSXQgZG9lcyB0aGlzIGFmcmVzaCBmb3IgZWFjaFxuICAgKiBzdWJzY3JpYmVyLCBzbyBhbHRob3VnaCBlYWNoIHN1YnNjcmliZXIgbWF5IHRoaW5rIGl0IGlzIHN1YnNjcmliaW5nIHRvIHRoZVxuICAgKiBzYW1lIE9ic2VydmFibGUsIGluIGZhY3QgZWFjaCBzdWJzY3JpYmVyIGdldHMgaXRzIG93biBpbmRpdmlkdWFsXG4gICAqIE9ic2VydmFibGUuXG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPlN1YnNjcmliZSB0byBlaXRoZXIgYW4gT2JzZXJ2YWJsZSBvZiBjbGlja3Mgb3IgYW4gT2JzZXJ2YWJsZSBvZiBpbnRlcnZhbCwgYXQgcmFuZG9tPC9jYXB0aW9uPlxuICAgKiB2YXIgY2xpY2tzT3JJbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgKiAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XG4gICAqICAgICByZXR1cm4gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICAgKiAgIH0gZWxzZSB7XG4gICAqICAgICByZXR1cm4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAgICogICB9XG4gICAqIH0pO1xuICAgKiBjbGlja3NPckludGVydmFsLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICpcbiAgICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nIGJlaGF2aW9yOlxuICAgKiAvLyBJZiB0aGUgcmVzdWx0IG9mIE1hdGgucmFuZG9tKCkgaXMgZ3JlYXRlciB0aGFuIDAuNSBpdCB3aWxsIGxpc3RlblxuICAgKiAvLyBmb3IgY2xpY2tzIGFueXdoZXJlIG9uIHRoZSBcImRvY3VtZW50XCI7IHdoZW4gZG9jdW1lbnQgaXMgY2xpY2tlZCBpdFxuICAgKiAvLyB3aWxsIGxvZyBhIE1vdXNlRXZlbnQgb2JqZWN0IHRvIHRoZSBjb25zb2xlLiBJZiB0aGUgcmVzdWx0IGlzIGxlc3NcbiAgICogLy8gdGhhbiAwLjUgaXQgd2lsbCBlbWl0IGFzY2VuZGluZyBudW1iZXJzLCBvbmUgZXZlcnkgc2Vjb25kKDEwMDBtcykuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGNyZWF0ZX1cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbigpOiBTdWJzY3JpYmFibGVPclByb21pc2V9IG9ic2VydmFibGVGYWN0b3J5IFRoZSBPYnNlcnZhYmxlXG4gICAqIGZhY3RvcnkgZnVuY3Rpb24gdG8gaW52b2tlIGZvciBlYWNoIE9ic2VydmVyIHRoYXQgc3Vic2NyaWJlcyB0byB0aGUgb3V0cHV0XG4gICAqIE9ic2VydmFibGUuIE1heSBhbHNvIHJldHVybiBhIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgY29udmVydGVkIG9uIHRoZSBmbHlcbiAgICogdG8gYW4gT2JzZXJ2YWJsZS5cbiAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB3aG9zZSBPYnNlcnZlcnMnIHN1YnNjcmlwdGlvbnMgdHJpZ2dlclxuICAgKiBhbiBpbnZvY2F0aW9uIG9mIHRoZSBnaXZlbiBPYnNlcnZhYmxlIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAqIEBzdGF0aWMgdHJ1ZVxuICAgKiBAbmFtZSBkZWZlclxuICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZTxUPihvYnNlcnZhYmxlRmFjdG9yeTogKCkgPT4gU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQ+IHwgdm9pZCk6IE9ic2VydmFibGU8VD4ge1xuICAgIHJldHVybiBuZXcgRGVmZXJPYnNlcnZhYmxlKG9ic2VydmFibGVGYWN0b3J5KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgb2JzZXJ2YWJsZUZhY3Rvcnk6ICgpID0+IFN1YnNjcmliYWJsZU9yUHJvbWlzZTxUPiB8IHZvaWQpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9zdWJzY3JpYmUoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPik6IFN1YnNjcmlwdGlvbiB7XG4gICAgcmV0dXJuIG5ldyBEZWZlclN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5vYnNlcnZhYmxlRmFjdG9yeSk7XG4gIH1cbn1cblxuY2xhc3MgRGVmZXJTdWJzY3JpYmVyPFQ+IGV4dGVuZHMgT3V0ZXJTdWJzY3JpYmVyPFQsIFQ+IHtcbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8VD4sXG4gICAgICAgICAgICAgIHByaXZhdGUgZmFjdG9yeTogKCkgPT4gU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQ+IHwgdm9pZCkge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgICB0aGlzLnRyeURlZmVyKCk7XG4gIH1cblxuICBwcml2YXRlIHRyeURlZmVyKCk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLl9jYWxsRmFjdG9yeSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9jYWxsRmFjdG9yeSgpOiB2b2lkIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmZhY3RvcnkoKTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXN1bHQpKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9EZWZlck9ic2VydmFibGUudHMiLCJpbXBvcnQgeyBJU2NoZWR1bGVyIH0gZnJvbSAnLi4vU2NoZWR1bGVyJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFRlYXJkb3duTG9naWMgfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuXG5leHBvcnQgaW50ZXJmYWNlIERpc3BhdGNoQXJnIHtcbiAgZXJyb3I6IGFueTtcbiAgc3Vic2NyaWJlcjogYW55O1xufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xuZXhwb3J0IGNsYXNzIEVycm9yT2JzZXJ2YWJsZSBleHRlbmRzIE9ic2VydmFibGU8YW55PiB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG5vIGl0ZW1zIHRvIHRoZSBPYnNlcnZlciBhbmQgaW1tZWRpYXRlbHlcbiAgICogZW1pdHMgYW4gZXJyb3Igbm90aWZpY2F0aW9uLlxuICAgKlxuICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SnVzdCBlbWl0cyAnZXJyb3InLCBhbmQgbm90aGluZyBlbHNlLlxuICAgKiA8L3NwYW4+XG4gICAqXG4gICAqIDxpbWcgc3JjPVwiLi9pbWcvdGhyb3cucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAqXG4gICAqIFRoaXMgc3RhdGljIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgY3JlYXRpbmcgYSBzaW1wbGUgT2JzZXJ2YWJsZSB0aGF0IG9ubHlcbiAgICogZW1pdHMgdGhlIGVycm9yIG5vdGlmaWNhdGlvbi4gSXQgY2FuIGJlIHVzZWQgZm9yIGNvbXBvc2luZyB3aXRoIG90aGVyXG4gICAqIE9ic2VydmFibGVzLCBzdWNoIGFzIGluIGEge0BsaW5rIG1lcmdlTWFwfS5cbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbnVtYmVyIDcsIHRoZW4gZW1pdCBhbiBlcnJvci48L2NhcHRpb24+XG4gICAqIHZhciByZXN1bHQgPSBSeC5PYnNlcnZhYmxlLnRocm93KG5ldyBFcnJvcignb29wcyEnKSkuc3RhcnRXaXRoKDcpO1xuICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCksIGUgPT4gY29uc29sZS5lcnJvcihlKSk7XG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBhbmQgZmxhdHRlbiBudW1iZXJzIHRvIHRoZSBzZXF1ZW5jZSAnYScsICdiJywgJ2MnLCBidXQgdGhyb3cgYW4gZXJyb3IgZm9yIDEzPC9jYXB0aW9uPlxuICAgKiB2YXIgaW50ZXJ2YWwgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICAgKiB2YXIgcmVzdWx0ID0gaW50ZXJ2YWwubWVyZ2VNYXAoeCA9PlxuICAgKiAgIHggPT09IDEzID9cbiAgICogICAgIFJ4Lk9ic2VydmFibGUudGhyb3coJ1RoaXJ0ZWVucyBhcmUgYmFkJykgOlxuICAgKiAgICAgUnguT2JzZXJ2YWJsZS5vZignYScsICdiJywgJ2MnKVxuICAgKiApO1xuICAgKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCksIGUgPT4gY29uc29sZS5lcnJvcihlKSk7XG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGNyZWF0ZX1cbiAgICogQHNlZSB7QGxpbmsgZW1wdHl9XG4gICAqIEBzZWUge0BsaW5rIG5ldmVyfVxuICAgKiBAc2VlIHtAbGluayBvZn1cbiAgICpcbiAgICogQHBhcmFtIHthbnl9IGVycm9yIFRoZSBwYXJ0aWN1bGFyIEVycm9yIHRvIHBhc3MgdG8gdGhlIGVycm9yIG5vdGlmaWNhdGlvbi5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXJdIEEge0BsaW5rIElTY2hlZHVsZXJ9IHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgKiB0aGUgZW1pc3Npb24gb2YgdGhlIGVycm9yIG5vdGlmaWNhdGlvbi5cbiAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gZXJyb3IgT2JzZXJ2YWJsZTogZW1pdHMgb25seSB0aGUgZXJyb3Igbm90aWZpY2F0aW9uXG4gICAqIHVzaW5nIHRoZSBnaXZlbiBlcnJvciBhcmd1bWVudC5cbiAgICogQHN0YXRpYyB0cnVlXG4gICAqIEBuYW1lIHRocm93XG4gICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKGVycm9yOiBhbnksIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBFcnJvck9ic2VydmFibGUge1xuICAgIHJldHVybiBuZXcgRXJyb3JPYnNlcnZhYmxlKGVycm9yLCBzY2hlZHVsZXIpO1xuICB9XG5cbiAgc3RhdGljIGRpc3BhdGNoKGFyZzogRGlzcGF0Y2hBcmcpIHtcbiAgICBjb25zdCB7IGVycm9yLCBzdWJzY3JpYmVyIH0gPSBhcmc7XG4gICAgc3Vic2NyaWJlci5lcnJvcihlcnJvcik7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgZXJyb3I6IGFueSwgcHJpdmF0ZSBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlKHN1YnNjcmliZXI6IGFueSk6IFRlYXJkb3duTG9naWMge1xuICAgIGNvbnN0IGVycm9yID0gdGhpcy5lcnJvcjtcbiAgICBjb25zdCBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcblxuICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoRXJyb3JPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7XG4gICAgICAgIGVycm9yLCBzdWJzY3JpYmVyXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29ic2VydmFibGUvRXJyb3JPYnNlcnZhYmxlLnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3Vic2NyaWJhYmxlT3JQcm9taXNlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgRW1wdHlPYnNlcnZhYmxlIH0gZnJvbSAnLi9FbXB0eU9ic2VydmFibGUnO1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJy4uL3V0aWwvaXNBcnJheSc7XG5cbmltcG9ydCB7IHN1YnNjcmliZVRvUmVzdWx0IH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCc7XG5pbXBvcnQgeyBPdXRlclN1YnNjcmliZXIgfSBmcm9tICcuLi9PdXRlclN1YnNjcmliZXInO1xuaW1wb3J0IHsgSW5uZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vSW5uZXJTdWJzY3JpYmVyJztcblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbmV4cG9ydCBjbGFzcyBGb3JrSm9pbk9ic2VydmFibGU8VD4gZXh0ZW5kcyBPYnNlcnZhYmxlPFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzb3VyY2VzOiBBcnJheTxTdWJzY3JpYmFibGVPclByb21pc2U8YW55Pj4sXG4gICAgICAgICAgICAgIHByaXZhdGUgcmVzdWx0U2VsZWN0b3I/OiAoLi4udmFsdWVzOiBBcnJheTxhbnk+KSA9PiBUKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIC8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuICBzdGF0aWMgY3JlYXRlPFQsIFQyPih2MTogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQ+LCB2MjogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQyPik6IE9ic2VydmFibGU8W1QsIFQyXT47XG4gIHN0YXRpYyBjcmVhdGU8VCwgVDIsIFQzPih2MTogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQ+LCB2MjogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQyPiwgdjM6IFN1YnNjcmliYWJsZU9yUHJvbWlzZTxUMz4pOiBPYnNlcnZhYmxlPFtULCBUMiwgVDNdPjtcbiAgc3RhdGljIGNyZWF0ZTxULCBUMiwgVDMsIFQ0Pih2MTogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQ+LCB2MjogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQyPiwgdjM6IFN1YnNjcmliYWJsZU9yUHJvbWlzZTxUMz4sIHY0OiBTdWJzY3JpYmFibGVPclByb21pc2U8VDQ+KTogT2JzZXJ2YWJsZTxbVCwgVDIsIFQzLCBUNF0+O1xuICBzdGF0aWMgY3JlYXRlPFQsIFQyLCBUMywgVDQsIFQ1Pih2MTogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQ+LCB2MjogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQyPiwgdjM6IFN1YnNjcmliYWJsZU9yUHJvbWlzZTxUMz4sIHY0OiBTdWJzY3JpYmFibGVPclByb21pc2U8VDQ+LCB2NTogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQ1Pik6IE9ic2VydmFibGU8W1QsIFQyLCBUMywgVDQsIFQ1XT47XG4gIHN0YXRpYyBjcmVhdGU8VCwgVDIsIFQzLCBUNCwgVDUsIFQ2Pih2MTogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQ+LCB2MjogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQyPiwgdjM6IFN1YnNjcmliYWJsZU9yUHJvbWlzZTxUMz4sIHY0OiBTdWJzY3JpYmFibGVPclByb21pc2U8VDQ+LCB2NTogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQ1PiwgdjY6IFN1YnNjcmliYWJsZU9yUHJvbWlzZTxUNj4pOiBPYnNlcnZhYmxlPFtULCBUMiwgVDMsIFQ0LCBUNSwgVDZdPjtcbiAgc3RhdGljIGNyZWF0ZTxULCBSPih2MTogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQ+LCBwcm9qZWN0OiAodjE6IFQpID0+IFIpOiBPYnNlcnZhYmxlPFI+O1xuICBzdGF0aWMgY3JlYXRlPFQsIFQyLCBSPih2MTogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQ+LCB2MjogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQyPiwgcHJvamVjdDogKHYxOiBULCB2MjogVDIpID0+IFIpOiBPYnNlcnZhYmxlPFI+O1xuICBzdGF0aWMgY3JlYXRlPFQsIFQyLCBUMywgUj4odjE6IFN1YnNjcmliYWJsZU9yUHJvbWlzZTxUPiwgdjI6IFN1YnNjcmliYWJsZU9yUHJvbWlzZTxUMj4sIHYzOiBTdWJzY3JpYmFibGVPclByb21pc2U8VDM+LCBwcm9qZWN0OiAodjE6IFQsIHYyOiBUMiwgdjM6IFQzKSA9PiBSKTogT2JzZXJ2YWJsZTxSPjtcbiAgc3RhdGljIGNyZWF0ZTxULCBUMiwgVDMsIFQ0LCBSPih2MTogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQ+LCB2MjogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQyPiwgdjM6IFN1YnNjcmliYWJsZU9yUHJvbWlzZTxUMz4sIHY0OiBTdWJzY3JpYmFibGVPclByb21pc2U8VDQ+LCBwcm9qZWN0OiAodjE6IFQsIHYyOiBUMiwgdjM6IFQzLCB2NDogVDQpID0+IFIpOiBPYnNlcnZhYmxlPFI+O1xuICBzdGF0aWMgY3JlYXRlPFQsIFQyLCBUMywgVDQsIFQ1LCBSPih2MTogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQ+LCB2MjogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQyPiwgdjM6IFN1YnNjcmliYWJsZU9yUHJvbWlzZTxUMz4sIHY0OiBTdWJzY3JpYmFibGVPclByb21pc2U8VDQ+LCB2NTogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQ1PiwgcHJvamVjdDogKHYxOiBULCB2MjogVDIsIHYzOiBUMywgdjQ6IFQ0LCB2NTogVDUpID0+IFIpOiBPYnNlcnZhYmxlPFI+O1xuICBzdGF0aWMgY3JlYXRlPFQsIFQyLCBUMywgVDQsIFQ1LCBUNiwgUj4odjE6IFN1YnNjcmliYWJsZU9yUHJvbWlzZTxUPiwgdjI6IFN1YnNjcmliYWJsZU9yUHJvbWlzZTxUMj4sIHYzOiBTdWJzY3JpYmFibGVPclByb21pc2U8VDM+LCB2NDogU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQ0PiwgdjU6IFN1YnNjcmliYWJsZU9yUHJvbWlzZTxUNT4sIHY2OiBTdWJzY3JpYmFibGVPclByb21pc2U8VDY+LCBwcm9qZWN0OiAodjE6IFQsIHYyOiBUMiwgdjM6IFQzLCB2NDogVDQsIHY1OiBUNSwgdjY6IFQ2KSA9PiBSKTogT2JzZXJ2YWJsZTxSPjtcbiAgc3RhdGljIGNyZWF0ZTxUPihzb3VyY2VzOiBTdWJzY3JpYmFibGVPclByb21pc2U8VD5bXSk6IE9ic2VydmFibGU8VFtdPjtcbiAgc3RhdGljIGNyZWF0ZTxSPihzb3VyY2VzOiBTdWJzY3JpYmFibGVPclByb21pc2U8YW55PltdKTogT2JzZXJ2YWJsZTxSPjtcbiAgc3RhdGljIGNyZWF0ZTxULCBSPihzb3VyY2VzOiBTdWJzY3JpYmFibGVPclByb21pc2U8VD5bXSwgcHJvamVjdDogKC4uLnZhbHVlczogQXJyYXk8VD4pID0+IFIpOiBPYnNlcnZhYmxlPFI+O1xuICBzdGF0aWMgY3JlYXRlPFI+KHNvdXJjZXM6IFN1YnNjcmliYWJsZU9yUHJvbWlzZTxhbnk+W10sIHByb2plY3Q6ICguLi52YWx1ZXM6IEFycmF5PGFueT4pID0+IFIpOiBPYnNlcnZhYmxlPFI+O1xuICBzdGF0aWMgY3JlYXRlPFQ+KC4uLnNvdXJjZXM6IFN1YnNjcmliYWJsZU9yUHJvbWlzZTxUPltdKTogT2JzZXJ2YWJsZTxUW10+O1xuICBzdGF0aWMgY3JlYXRlPFI+KC4uLnNvdXJjZXM6IFN1YnNjcmliYWJsZU9yUHJvbWlzZTxhbnk+W10pOiBPYnNlcnZhYmxlPFI+O1xuICAvKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuXG4gIC8qKlxuICAgKiBAcGFyYW0gc291cmNlc1xuICAgKiBAcmV0dXJuIHthbnl9XG4gICAqIEBzdGF0aWMgdHJ1ZVxuICAgKiBAbmFtZSBmb3JrSm9pblxuICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZTxUPiguLi5zb3VyY2VzOiBBcnJheTxTdWJzY3JpYmFibGVPclByb21pc2U8YW55PiB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXk8U3Vic2NyaWJhYmxlT3JQcm9taXNlPGFueT4+IHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKC4uLnZhbHVlczogQXJyYXk8YW55PikgPT4gYW55KT4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICBpZiAoc291cmNlcyA9PT0gbnVsbCB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZTxUPigpO1xuICAgIH1cblxuICAgIGxldCByZXN1bHRTZWxlY3RvcjogKC4uLnZhbHVlczogQXJyYXk8YW55PikgPT4gYW55ID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIHNvdXJjZXNbc291cmNlcy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVzdWx0U2VsZWN0b3IgPSA8KC4uLnZhbHVlczogQXJyYXk8YW55PikgPT4gYW55PnNvdXJjZXMucG9wKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGZpcnN0IGFuZCBvbmx5IG90aGVyIGFyZ3VtZW50IGJlc2lkZXMgdGhlIHJlc3VsdFNlbGVjdG9yIGlzIGFuIGFycmF5XG4gICAgLy8gYXNzdW1lIGl0J3MgYmVlbiBjYWxsZWQgd2l0aCBgZm9ya0pvaW4oW29iczEsIG9iczIsIG9iczNdLCByZXN1bHRTZWxlY3RvcilgXG4gICAgaWYgKHNvdXJjZXMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkoc291cmNlc1swXSkpIHtcbiAgICAgIHNvdXJjZXMgPSA8QXJyYXk8U3Vic2NyaWJhYmxlT3JQcm9taXNlPGFueT4+PnNvdXJjZXNbMF07XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IEVtcHR5T2JzZXJ2YWJsZTxUPigpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRm9ya0pvaW5PYnNlcnZhYmxlKDxBcnJheTxTdWJzY3JpYmFibGVPclByb21pc2U8YW55Pj4+c291cmNlcywgcmVzdWx0U2VsZWN0b3IpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9zdWJzY3JpYmUoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxhbnk+KTogU3Vic2NyaXB0aW9uIHtcbiAgICByZXR1cm4gbmV3IEZvcmtKb2luU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnNvdXJjZXMsIHRoaXMucmVzdWx0U2VsZWN0b3IpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBGb3JrSm9pblN1YnNjcmliZXI8VD4gZXh0ZW5kcyBPdXRlclN1YnNjcmliZXI8VCwgVD4ge1xuICBwcml2YXRlIGNvbXBsZXRlZCA9IDA7XG4gIHByaXZhdGUgdG90YWw6IG51bWJlcjtcbiAgcHJpdmF0ZSB2YWx1ZXM6IGFueVtdO1xuICBwcml2YXRlIGhhdmVWYWx1ZXMgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFQ+LFxuICAgICAgICAgICAgICBwcml2YXRlIHNvdXJjZXM6IEFycmF5PFN1YnNjcmliYWJsZU9yUHJvbWlzZTxhbnk+PixcbiAgICAgICAgICAgICAgcHJpdmF0ZSByZXN1bHRTZWxlY3Rvcj86ICguLi52YWx1ZXM6IEFycmF5PGFueT4pID0+IFQpIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG5cbiAgICBjb25zdCBsZW4gPSBzb3VyY2VzLmxlbmd0aDtcbiAgICB0aGlzLnRvdGFsID0gbGVuO1xuICAgIHRoaXMudmFsdWVzID0gbmV3IEFycmF5KGxlbik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgY29uc3QgaW5uZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBzb3VyY2UsIG51bGwsIGkpO1xuXG4gICAgICBpZiAoaW5uZXJTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgKDxhbnk+IGlubmVyU3Vic2NyaXB0aW9uKS5vdXRlckluZGV4ID0gaTtcbiAgICAgICAgdGhpcy5hZGQoaW5uZXJTdWJzY3JpcHRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5vdGlmeU5leHQob3V0ZXJWYWx1ZTogYW55LCBpbm5lclZhbHVlOiBULFxuICAgICAgICAgICAgIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgIGlubmVyU3ViOiBJbm5lclN1YnNjcmliZXI8VCwgVD4pOiB2b2lkIHtcbiAgICB0aGlzLnZhbHVlc1tvdXRlckluZGV4XSA9IGlubmVyVmFsdWU7XG4gICAgaWYgKCEoPGFueT5pbm5lclN1YikuX2hhc1ZhbHVlKSB7XG4gICAgICAoPGFueT5pbm5lclN1YikuX2hhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgIHRoaXMuaGF2ZVZhbHVlcysrO1xuICAgIH1cbiAgfVxuXG4gIG5vdGlmeUNvbXBsZXRlKGlubmVyU3ViOiBJbm5lclN1YnNjcmliZXI8VCwgVD4pOiB2b2lkIHtcbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgY29uc3QgeyBoYXZlVmFsdWVzLCByZXN1bHRTZWxlY3RvciwgdmFsdWVzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxlbiA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICBpZiAoISg8YW55PmlubmVyU3ViKS5faGFzVmFsdWUpIHtcbiAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jb21wbGV0ZWQrKztcblxuICAgIGlmICh0aGlzLmNvbXBsZXRlZCAhPT0gbGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGhhdmVWYWx1ZXMgPT09IGxlbikge1xuICAgICAgY29uc3QgdmFsdWUgPSByZXN1bHRTZWxlY3RvciA/IHJlc3VsdFNlbGVjdG9yLmFwcGx5KHRoaXMsIHZhbHVlcykgOiB2YWx1ZXM7XG4gICAgICBkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL0ZvcmtKb2luT2JzZXJ2YWJsZS50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHRyeUNhdGNoIH0gZnJvbSAnLi4vdXRpbC90cnlDYXRjaCc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbC9pc0Z1bmN0aW9uJztcbmltcG9ydCB7IGVycm9yT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9lcnJvck9iamVjdCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuXG5jb25zdCB0b1N0cmluZzogRnVuY3Rpb24gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5leHBvcnQgdHlwZSBOb2RlU3R5bGVFdmVudEVtaXR0ZXIgPSB7XG4gIGFkZExpc3RlbmVyOiAoZXZlbnROYW1lOiBzdHJpbmcsIGhhbmRsZXI6IEZ1bmN0aW9uKSA9PiB2b2lkO1xuICByZW1vdmVMaXN0ZW5lcjogKGV2ZW50TmFtZTogc3RyaW5nLCBoYW5kbGVyOiBGdW5jdGlvbikgPT4gdm9pZDtcbn07XG5mdW5jdGlvbiBpc05vZGVTdHlsZUV2ZW50RW1pdHRlcihzb3VyY2VPYmo6IGFueSk6IHNvdXJjZU9iaiBpcyBOb2RlU3R5bGVFdmVudEVtaXR0ZXIge1xuICByZXR1cm4gISFzb3VyY2VPYmogJiYgdHlwZW9mIHNvdXJjZU9iai5hZGRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc291cmNlT2JqLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgdHlwZSBKUXVlcnlTdHlsZUV2ZW50RW1pdHRlciA9IHtcbiAgb246IChldmVudE5hbWU6IHN0cmluZywgaGFuZGxlcjogRnVuY3Rpb24pID0+IHZvaWQ7XG4gIG9mZjogKGV2ZW50TmFtZTogc3RyaW5nLCBoYW5kbGVyOiBGdW5jdGlvbikgPT4gdm9pZDtcbn07XG5mdW5jdGlvbiBpc0pRdWVyeVN0eWxlRXZlbnRFbWl0dGVyKHNvdXJjZU9iajogYW55KTogc291cmNlT2JqIGlzIEpRdWVyeVN0eWxlRXZlbnRFbWl0dGVyIHtcbiAgcmV0dXJuICEhc291cmNlT2JqICYmIHR5cGVvZiBzb3VyY2VPYmoub24gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNvdXJjZU9iai5vZmYgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZUxpc3Qoc291cmNlT2JqOiBhbnkpOiBzb3VyY2VPYmogaXMgTm9kZUxpc3Qge1xuICByZXR1cm4gISFzb3VyY2VPYmogJiYgdG9TdHJpbmcuY2FsbChzb3VyY2VPYmopID09PSAnW29iamVjdCBOb2RlTGlzdF0nO1xufVxuXG5mdW5jdGlvbiBpc0hUTUxDb2xsZWN0aW9uKHNvdXJjZU9iajogYW55KTogc291cmNlT2JqIGlzIEhUTUxDb2xsZWN0aW9uIHtcbiAgcmV0dXJuICEhc291cmNlT2JqICYmIHRvU3RyaW5nLmNhbGwoc291cmNlT2JqKSA9PT0gJ1tvYmplY3QgSFRNTENvbGxlY3Rpb25dJztcbn1cblxuZnVuY3Rpb24gaXNFdmVudFRhcmdldChzb3VyY2VPYmo6IGFueSk6IHNvdXJjZU9iaiBpcyBFdmVudFRhcmdldCB7XG4gIHJldHVybiAhIXNvdXJjZU9iaiAmJiB0eXBlb2Ygc291cmNlT2JqLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNvdXJjZU9iai5yZW1vdmVFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgdHlwZSBFdmVudFRhcmdldExpa2UgPSBFdmVudFRhcmdldCB8IE5vZGVTdHlsZUV2ZW50RW1pdHRlciB8IEpRdWVyeVN0eWxlRXZlbnRFbWl0dGVyIHwgTm9kZUxpc3QgfCBIVE1MQ29sbGVjdGlvbjtcblxuZXhwb3J0IHR5cGUgRXZlbnRMaXN0ZW5lck9wdGlvbnMgPSB7XG4gIGNhcHR1cmU/OiBib29sZWFuO1xuICBwYXNzaXZlPzogYm9vbGVhbjtcbiAgb25jZT86IGJvb2xlYW47XG59IHwgYm9vbGVhbjtcblxuZXhwb3J0IHR5cGUgU2VsZWN0b3JNZXRob2RTaWduYXR1cmU8VD4gPSAoLi4uYXJnczogQXJyYXk8YW55PikgPT4gVDtcblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbmV4cG9ydCBjbGFzcyBGcm9tRXZlbnRPYnNlcnZhYmxlPFQ+IGV4dGVuZHMgT2JzZXJ2YWJsZTxUPiB7XG5cbiAgLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG4gIHN0YXRpYyBjcmVhdGU8VD4odGFyZ2V0OiBFdmVudFRhcmdldExpa2UsIGV2ZW50TmFtZTogc3RyaW5nKTogT2JzZXJ2YWJsZTxUPjtcbiAgc3RhdGljIGNyZWF0ZTxUPih0YXJnZXQ6IEV2ZW50VGFyZ2V0TGlrZSwgZXZlbnROYW1lOiBzdHJpbmcsIHNlbGVjdG9yOiBTZWxlY3Rvck1ldGhvZFNpZ25hdHVyZTxUPik6IE9ic2VydmFibGU8VD47XG4gIHN0YXRpYyBjcmVhdGU8VD4odGFyZ2V0OiBFdmVudFRhcmdldExpa2UsIGV2ZW50TmFtZTogc3RyaW5nLCBvcHRpb25zOiBFdmVudExpc3RlbmVyT3B0aW9ucyk6IE9ic2VydmFibGU8VD47XG4gIHN0YXRpYyBjcmVhdGU8VD4odGFyZ2V0OiBFdmVudFRhcmdldExpa2UsIGV2ZW50TmFtZTogc3RyaW5nLCBvcHRpb25zOiBFdmVudExpc3RlbmVyT3B0aW9ucywgc2VsZWN0b3I6IFNlbGVjdG9yTWV0aG9kU2lnbmF0dXJlPFQ+KTogT2JzZXJ2YWJsZTxUPjtcbiAgLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgZXZlbnRzIG9mIGEgc3BlY2lmaWMgdHlwZSBjb21pbmcgZnJvbSB0aGVcbiAgICogZ2l2ZW4gZXZlbnQgdGFyZ2V0LlxuICAgKlxuICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q3JlYXRlcyBhbiBPYnNlcnZhYmxlIGZyb20gRE9NIGV2ZW50cywgb3IgTm9kZVxuICAgKiBFdmVudEVtaXR0ZXIgZXZlbnRzIG9yIG90aGVycy48L3NwYW4+XG4gICAqXG4gICAqIDxpbWcgc3JjPVwiLi9pbWcvZnJvbUV2ZW50LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgKlxuICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgYnkgYXR0YWNoaW5nIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGFuIFwiZXZlbnQgdGFyZ2V0XCIsXG4gICAqIHdoaWNoIG1heSBiZSBhbiBvYmplY3Qgd2l0aCBgYWRkRXZlbnRMaXN0ZW5lcmAgYW5kIGByZW1vdmVFdmVudExpc3RlbmVyYCxcbiAgICogYSBOb2RlLmpzIEV2ZW50RW1pdHRlciwgYSBqUXVlcnkgc3R5bGUgRXZlbnRFbWl0dGVyLCBhIE5vZGVMaXN0IGZyb20gdGhlXG4gICAqIERPTSwgb3IgYW4gSFRNTENvbGxlY3Rpb24gZnJvbSB0aGUgRE9NLiBUaGUgZXZlbnQgaGFuZGxlciBpcyBhdHRhY2hlZCB3aGVuXG4gICAqIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBpcyBzdWJzY3JpYmVkLCBhbmQgcmVtb3ZlZCB3aGVuIHRoZSBTdWJzY3JpcHRpb24gaXNcbiAgICogdW5zdWJzY3JpYmVkLlxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0cyBjbGlja3MgaGFwcGVuaW5nIG9uIHRoZSBET00gZG9jdW1lbnQ8L2NhcHRpb24+XG4gICAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gICAqIGNsaWNrcy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAqXG4gICAqIC8vIFJlc3VsdHMgaW46XG4gICAqIC8vIE1vdXNlRXZlbnQgb2JqZWN0IGxvZ2dlZCB0byBjb25zb2xlIGV2ZXJ5dGltZSBhIGNsaWNrXG4gICAqIC8vIG9jY3VycyBvbiB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGZyb219XG4gICAqIEBzZWUge0BsaW5rIGZyb21FdmVudFBhdHRlcm59XG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXRMaWtlfSB0YXJnZXQgVGhlIERPTUVsZW1lbnQsIGV2ZW50IHRhcmdldCwgTm9kZS5qc1xuICAgKiBFdmVudEVtaXR0ZXIsIE5vZGVMaXN0IG9yIEhUTUxDb2xsZWN0aW9uIHRvIGF0dGFjaCB0aGUgZXZlbnQgaGFuZGxlciB0by5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBUaGUgZXZlbnQgbmFtZSBvZiBpbnRlcmVzdCwgYmVpbmcgZW1pdHRlZCBieSB0aGVcbiAgICogYHRhcmdldGAuXG4gICAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lck9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdGhyb3VnaCB0byBhZGRFdmVudExpc3RlbmVyXG4gICAqIEBwYXJhbSB7U2VsZWN0b3JNZXRob2RTaWduYXR1cmU8VD59IFtzZWxlY3Rvcl0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG9cbiAgICogcG9zdC1wcm9jZXNzIHJlc3VsdHMuIEl0IHRha2VzIHRoZSBhcmd1bWVudHMgZnJvbSB0aGUgZXZlbnQgaGFuZGxlciBhbmRcbiAgICogc2hvdWxkIHJldHVybiBhIHNpbmdsZSB2YWx1ZS5cbiAgICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn1cbiAgICogQHN0YXRpYyB0cnVlXG4gICAqIEBuYW1lIGZyb21FdmVudFxuICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZTxUPih0YXJnZXQ6IEV2ZW50VGFyZ2V0TGlrZSxcbiAgICAgICAgICAgICAgICAgICBldmVudE5hbWU6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICBvcHRpb25zPzogRXZlbnRMaXN0ZW5lck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgc2VsZWN0b3I/OiBTZWxlY3Rvck1ldGhvZFNpZ25hdHVyZTxUPik6IE9ic2VydmFibGU8VD4ge1xuICAgIGlmIChpc0Z1bmN0aW9uKG9wdGlvbnMpKSB7XG4gICAgICBzZWxlY3RvciA9IDxhbnk+b3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRnJvbUV2ZW50T2JzZXJ2YWJsZSh0YXJnZXQsIGV2ZW50TmFtZSwgc2VsZWN0b3IsIG9wdGlvbnMpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzb3VyY2VPYmo6IEV2ZW50VGFyZ2V0TGlrZSxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBldmVudE5hbWU6IHN0cmluZyxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBzZWxlY3Rvcj86IFNlbGVjdG9yTWV0aG9kU2lnbmF0dXJlPFQ+LFxuICAgICAgICAgICAgICBwcml2YXRlIG9wdGlvbnM/OiBFdmVudExpc3RlbmVyT3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBzZXR1cFN1YnNjcmlwdGlvbjxUPihzb3VyY2VPYmo6IEV2ZW50VGFyZ2V0TGlrZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IEZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zPzogRXZlbnRMaXN0ZW5lck9wdGlvbnMpIHtcbiAgICBsZXQgdW5zdWJzY3JpYmU6ICgpID0+IHZvaWQ7XG4gICAgaWYgKGlzTm9kZUxpc3Qoc291cmNlT2JqKSB8fCBpc0hUTUxDb2xsZWN0aW9uKHNvdXJjZU9iaikpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzb3VyY2VPYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgRnJvbUV2ZW50T2JzZXJ2YWJsZS5zZXR1cFN1YnNjcmlwdGlvbihzb3VyY2VPYmpbaV0sIGV2ZW50TmFtZSwgaGFuZGxlciwgc3Vic2NyaWJlciwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0V2ZW50VGFyZ2V0KHNvdXJjZU9iaikpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZU9iajtcbiAgICAgIHNvdXJjZU9iai5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgPEV2ZW50TGlzdGVuZXI+aGFuZGxlciwgPGJvb2xlYW4+b3B0aW9ucyk7XG4gICAgICB1bnN1YnNjcmliZSA9ICgpID0+IHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgPEV2ZW50TGlzdGVuZXI+aGFuZGxlcik7XG4gICAgfSBlbHNlIGlmIChpc0pRdWVyeVN0eWxlRXZlbnRFbWl0dGVyKHNvdXJjZU9iaikpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHNvdXJjZU9iajtcbiAgICAgIHNvdXJjZU9iai5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgdW5zdWJzY3JpYmUgPSAoKSA9PiBzb3VyY2Uub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfSBlbHNlIGlmIChpc05vZGVTdHlsZUV2ZW50RW1pdHRlcihzb3VyY2VPYmopKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VPYmo7XG4gICAgICBzb3VyY2VPYmouYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgIHVuc3Vic2NyaWJlID0gKCkgPT4gc291cmNlLnJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgZXZlbnQgdGFyZ2V0Jyk7XG4gICAgfVxuXG4gICAgc3Vic2NyaWJlci5hZGQobmV3IFN1YnNjcmlwdGlvbih1bnN1YnNjcmliZSkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9zdWJzY3JpYmUoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPikge1xuICAgIGNvbnN0IHNvdXJjZU9iaiA9IHRoaXMuc291cmNlT2JqO1xuICAgIGNvbnN0IGV2ZW50TmFtZSA9IHRoaXMuZXZlbnROYW1lO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuICAgIGxldCBoYW5kbGVyID0gc2VsZWN0b3IgPyAoLi4uYXJnczogYW55W10pID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSB0cnlDYXRjaChzZWxlY3RvcikoLi4uYXJncyk7XG4gICAgICBpZiAocmVzdWx0ID09PSBlcnJvck9iamVjdCkge1xuICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycm9yT2JqZWN0LmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3Vic2NyaWJlci5uZXh0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSA6IChlOiBhbnkpID0+IHN1YnNjcmliZXIubmV4dChlKTtcblxuICAgIEZyb21FdmVudE9ic2VydmFibGUuc2V0dXBTdWJzY3JpcHRpb24oc291cmNlT2JqLCBldmVudE5hbWUsIGhhbmRsZXIsIHN1YnNjcmliZXIsIG9wdGlvbnMpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29ic2VydmFibGUvRnJvbUV2ZW50T2JzZXJ2YWJsZS50cyIsImltcG9ydCB7IGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlsL2lzRnVuY3Rpb24nO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbmV4cG9ydCBjbGFzcyBGcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZTxUPiBleHRlbmRzIE9ic2VydmFibGU8VD4ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgZnJvbSBhbiBBUEkgYmFzZWQgb24gYWRkSGFuZGxlci9yZW1vdmVIYW5kbGVyXG4gICAqIGZ1bmN0aW9ucy5cbiAgICpcbiAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbnZlcnRzIGFueSBhZGRIYW5kbGVyL3JlbW92ZUhhbmRsZXIgQVBJIHRvIGFuXG4gICAqIE9ic2VydmFibGUuPC9zcGFuPlxuICAgKlxuICAgKiA8aW1nIHNyYz1cIi4vaW1nL2Zyb21FdmVudFBhdHRlcm4ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAqXG4gICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSBieSB1c2luZyB0aGUgYGFkZEhhbmRsZXJgIGFuZCBgcmVtb3ZlSGFuZGxlcmBcbiAgICogZnVuY3Rpb25zIHRvIGFkZCBhbmQgcmVtb3ZlIHRoZSBoYW5kbGVycywgd2l0aCBhbiBvcHRpb25hbCBzZWxlY3RvclxuICAgKiBmdW5jdGlvbiB0byBwcm9qZWN0IHRoZSBldmVudCBhcmd1bWVudHMgdG8gYSByZXN1bHQuIFRoZSBgYWRkSGFuZGxlcmAgaXNcbiAgICogY2FsbGVkIHdoZW4gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGlzIHN1YnNjcmliZWQsIGFuZCBgcmVtb3ZlSGFuZGxlcmAgaXNcbiAgICogY2FsbGVkIHdoZW4gdGhlIFN1YnNjcmlwdGlvbiBpcyB1bnN1YnNjcmliZWQuXG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIGNsaWNrcyBoYXBwZW5pbmcgb24gdGhlIERPTSBkb2N1bWVudDwvY2FwdGlvbj5cbiAgICogZnVuY3Rpb24gYWRkQ2xpY2tIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICogICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpO1xuICAgKiB9XG4gICAqXG4gICAqIGZ1bmN0aW9uIHJlbW92ZUNsaWNrSGFuZGxlcihoYW5kbGVyKSB7XG4gICAqICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVyKTtcbiAgICogfVxuICAgKlxuICAgKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnRQYXR0ZXJuKFxuICAgKiAgIGFkZENsaWNrSGFuZGxlcixcbiAgICogICByZW1vdmVDbGlja0hhbmRsZXJcbiAgICogKTtcbiAgICogY2xpY2tzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgZnJvbX1cbiAgICogQHNlZSB7QGxpbmsgZnJvbUV2ZW50fVxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKGhhbmRsZXI6IEZ1bmN0aW9uKTogYW55fSBhZGRIYW5kbGVyIEEgZnVuY3Rpb24gdGhhdCB0YWtlc1xuICAgKiBhIGBoYW5kbGVyYCBmdW5jdGlvbiBhcyBhcmd1bWVudCBhbmQgYXR0YWNoZXMgaXQgc29tZWhvdyB0byB0aGUgYWN0dWFsXG4gICAqIHNvdXJjZSBvZiBldmVudHMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oaGFuZGxlcjogRnVuY3Rpb24sIHNpZ25hbD86IGFueSk6IHZvaWR9IFtyZW1vdmVIYW5kbGVyXSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0aGF0XG4gICAqIHRha2VzIGEgYGhhbmRsZXJgIGZ1bmN0aW9uIGFzIGFyZ3VtZW50IGFuZCByZW1vdmVzIGl0IGluIGNhc2UgaXQgd2FzXG4gICAqIHByZXZpb3VzbHkgYXR0YWNoZWQgdXNpbmcgYGFkZEhhbmRsZXJgLiBpZiBhZGRIYW5kbGVyIHJldHVybnMgc2lnbmFsIHRvIHRlYXJkb3duIHdoZW4gcmVtb3ZlLFxuICAgKiByZW1vdmVIYW5kbGVyIGZ1bmN0aW9uIHdpbGwgZm9yd2FyZCBpdC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbiguLi5hcmdzOiBhbnkpOiBUfSBbc2VsZWN0b3JdIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRvXG4gICAqIHBvc3QtcHJvY2VzcyByZXN1bHRzLiBJdCB0YWtlcyB0aGUgYXJndW1lbnRzIGZyb20gdGhlIGV2ZW50IGhhbmRsZXIgYW5kXG4gICAqIHNob3VsZCByZXR1cm4gYSBzaW5nbGUgdmFsdWUuXG4gICAqIEByZXR1cm4ge09ic2VydmFibGU8VD59XG4gICAqIEBzdGF0aWMgdHJ1ZVxuICAgKiBAbmFtZSBmcm9tRXZlbnRQYXR0ZXJuXG4gICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlPFQ+KGFkZEhhbmRsZXI6IChoYW5kbGVyOiBGdW5jdGlvbikgPT4gYW55LFxuICAgICAgICAgICAgICAgICAgIHJlbW92ZUhhbmRsZXI/OiAoaGFuZGxlcjogRnVuY3Rpb24sIHNpZ25hbD86IGFueSkgPT4gdm9pZCxcbiAgICAgICAgICAgICAgICAgICBzZWxlY3Rvcj86ICguLi5hcmdzOiBBcnJheTxhbnk+KSA9PiBUKSB7XG4gICAgcmV0dXJuIG5ldyBGcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZShhZGRIYW5kbGVyLCByZW1vdmVIYW5kbGVyLCBzZWxlY3Rvcik7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFkZEhhbmRsZXI6IChoYW5kbGVyOiBGdW5jdGlvbikgPT4gYW55LFxuICAgICAgICAgICAgICBwcml2YXRlIHJlbW92ZUhhbmRsZXI/OiAoaGFuZGxlcjogRnVuY3Rpb24sIHNpZ25hbD86IGFueSkgPT4gdm9pZCxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBzZWxlY3Rvcj86ICguLi5hcmdzOiBBcnJheTxhbnk+KSA9PiBUKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4pIHtcbiAgICBjb25zdCByZW1vdmVIYW5kbGVyID0gdGhpcy5yZW1vdmVIYW5kbGVyO1xuXG4gICAgY29uc3QgaGFuZGxlciA9ICEhdGhpcy5zZWxlY3RvciA/ICguLi5hcmdzOiBBcnJheTxhbnk+KSA9PiB7XG4gICAgICB0aGlzLl9jYWxsU2VsZWN0b3Ioc3Vic2NyaWJlciwgYXJncyk7XG4gICAgfSA6IGZ1bmN0aW9uKGU6IGFueSkgeyBzdWJzY3JpYmVyLm5leHQoZSk7IH07XG5cbiAgICBjb25zdCByZXRWYWx1ZSA9IHRoaXMuX2NhbGxBZGRIYW5kbGVyKGhhbmRsZXIsIHN1YnNjcmliZXIpO1xuXG4gICAgaWYgKCFpc0Z1bmN0aW9uKHJlbW92ZUhhbmRsZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3Vic2NyaWJlci5hZGQobmV3IFN1YnNjcmlwdGlvbigoKSA9PiB7XG4gICAgICAvL1RPRE86IGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0byBmb3J3YXJkIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgIHJlbW92ZUhhbmRsZXIoaGFuZGxlciwgcmV0VmFsdWUpIDtcbiAgICB9KSk7XG4gIH1cblxuICBwcml2YXRlIF9jYWxsU2VsZWN0b3Ioc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPiwgYXJnczogQXJyYXk8YW55Pik6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQ6IFQgPSB0aGlzLnNlbGVjdG9yKC4uLmFyZ3MpO1xuICAgICAgc3Vic2NyaWJlci5uZXh0KHJlc3VsdCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICBzdWJzY3JpYmVyLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2NhbGxBZGRIYW5kbGVyKGhhbmRsZXI6IChlOiBhbnkpID0+IHZvaWQsIGVycm9yU3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPik6IGFueSB8IG51bGwge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGRIYW5kbGVyKGhhbmRsZXIpIHx8IG51bGw7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICBlcnJvclN1YnNjcmliZXIuZXJyb3IoZSk7XG4gICAgfVxuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL0Zyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlLnRzIiwiaW1wb3J0IHsgSVNjaGVkdWxlciB9IGZyb20gJy4uL1NjaGVkdWxlcic7XG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuLi9zY2hlZHVsZXIvQWN0aW9uJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJyA7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgaXNTY2hlZHVsZXIgfSBmcm9tICcuLi91dGlsL2lzU2NoZWR1bGVyJztcblxuY29uc3Qgc2VsZlNlbGVjdG9yID0gPFQ+KHZhbHVlOiBUKSA9PiB2YWx1ZTtcblxuZXhwb3J0IHR5cGUgQ29uZGl0aW9uRnVuYzxTPiA9IChzdGF0ZTogUykgPT4gYm9vbGVhbjtcbmV4cG9ydCB0eXBlIEl0ZXJhdGVGdW5jPFM+ID0gKHN0YXRlOiBTKSA9PiBTO1xuZXhwb3J0IHR5cGUgUmVzdWx0RnVuYzxTLCBUPiA9IChzdGF0ZTogUykgPT4gVDtcblxuaW50ZXJmYWNlIFNjaGVkdWxlclN0YXRlPFQsIFM+IHtcbiAgbmVlZEl0ZXJhdGU/OiBib29sZWFuO1xuICBzdGF0ZTogUztcbiAgc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPjtcbiAgY29uZGl0aW9uPzogQ29uZGl0aW9uRnVuYzxTPjtcbiAgaXRlcmF0ZTogSXRlcmF0ZUZ1bmM8Uz47XG4gIHJlc3VsdFNlbGVjdG9yOiBSZXN1bHRGdW5jPFMsIFQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdlbmVyYXRlQmFzZU9wdGlvbnM8Uz4ge1xuICAvKipcbiAgICogSW5pdGlhbCBzdGF0ZS5cbiAgKi9cbiAgaW5pdGlhbFN0YXRlOiBTO1xuICAvKipcbiAgICogQ29uZGl0aW9uIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBzdGF0ZSBhbmQgcmV0dXJucyBib29sZWFuLlxuICAgKiBXaGVuIGl0IHJldHVybnMgZmFsc2UsIHRoZSBnZW5lcmF0b3Igc3RvcHMuXG4gICAqIElmIG5vdCBzcGVjaWZpZWQsIGEgZ2VuZXJhdG9yIG5ldmVyIHN0b3BzLlxuICAqL1xuICBjb25kaXRpb24/OiBDb25kaXRpb25GdW5jPFM+O1xuICAvKipcbiAgICogSXRlcmF0ZSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgc3RhdGUgYW5kIHJldHVybnMgbmV3IHN0YXRlLlxuICAgKi9cbiAgaXRlcmF0ZTogSXRlcmF0ZUZ1bmM8Uz47XG4gIC8qKlxuICAgKiBJU2NoZWR1bGVyIHRvIHVzZSBmb3IgZ2VuZXJhdGlvbiBwcm9jZXNzLlxuICAgKiBCeSBkZWZhdWx0LCBhIGdlbmVyYXRvciBzdGFydHMgaW1tZWRpYXRlbHkuXG4gICovXG4gIHNjaGVkdWxlcj86IElTY2hlZHVsZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2VuZXJhdGVPcHRpb25zPFQsIFM+IGV4dGVuZHMgR2VuZXJhdGVCYXNlT3B0aW9uczxTPiB7XG4gIC8qKlxuICAgKiBSZXN1bHQgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBzdGF0ZSBhbmQgcmV0dXJucyBhIHZhbHVlIHRvIGVtaXQuXG4gICAqL1xuICByZXN1bHRTZWxlY3RvcjogUmVzdWx0RnVuYzxTLCBUPjtcbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbmV4cG9ydCBjbGFzcyBHZW5lcmF0ZU9ic2VydmFibGU8VCwgUz4gZXh0ZW5kcyBPYnNlcnZhYmxlPFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpbml0aWFsU3RhdGU6IFMsXG4gICAgICAgICAgICAgIHByaXZhdGUgY29uZGl0aW9uOiBDb25kaXRpb25GdW5jPFM+LFxuICAgICAgICAgICAgICBwcml2YXRlIGl0ZXJhdGU6IEl0ZXJhdGVGdW5jPFM+LFxuICAgICAgICAgICAgICBwcml2YXRlIHJlc3VsdFNlbGVjdG9yOiBSZXN1bHRGdW5jPFMsIFQ+LFxuICAgICAgICAgICAgICBwcml2YXRlIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpIHtcbiAgICAgIHN1cGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIG9ic2VydmFibGUgc2VxdWVuY2UgYnkgcnVubmluZyBhIHN0YXRlLWRyaXZlbiBsb29wXG4gICAqIHByb2R1Y2luZyB0aGUgc2VxdWVuY2UncyBlbGVtZW50cywgdXNpbmcgdGhlIHNwZWNpZmllZCBzY2hlZHVsZXJcbiAgICogdG8gc2VuZCBvdXQgb2JzZXJ2ZXIgbWVzc2FnZXMuXG4gICAqXG4gICAqIDxpbWcgc3JjPVwiLi9pbWcvZ2VuZXJhdGUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPlByb2R1Y2VzIHNlcXVlbmNlIG9mIDAsIDEsIDIsIC4uLiA5LCB0aGVuIGNvbXBsZXRlcy48L2NhcHRpb24+XG4gICAqIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLmdlbmVyYXRlKDAsIHggPT4geCA8IDEwLCB4ID0+IHggKyAxLCB4ID0+IHgpO1xuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Vc2luZyBhc2FwIHNjaGVkdWxlciwgcHJvZHVjZXMgc2VxdWVuY2Ugb2YgMiwgMywgNSwgdGhlbiBjb21wbGV0ZXMuPC9jYXB0aW9uPlxuICAgKiB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5nZW5lcmF0ZSgxLCB4ID0+IHggPCA1LCB4ID0+IHggKiAyLCB4ID0+IHggKyAxLCBSeC5TY2hlZHVsZXIuYXNhcCk7XG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGZyb219XG4gICAqIEBzZWUge0BsaW5rIGNyZWF0ZX1cbiAgICpcbiAgICogQHBhcmFtIHtTfSBpbml0aWFsU3RhdGUgSW5pdGlhbCBzdGF0ZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbiAoc3RhdGU6IFMpOiBib29sZWFufSBjb25kaXRpb24gQ29uZGl0aW9uIHRvIHRlcm1pbmF0ZSBnZW5lcmF0aW9uICh1cG9uIHJldHVybmluZyBmYWxzZSkuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24gKHN0YXRlOiBTKTogU30gaXRlcmF0ZSBJdGVyYXRpb24gc3RlcCBmdW5jdGlvbi5cbiAgICogQHBhcmFtIHtmdW5jdGlvbiAoc3RhdGU6IFMpOiBUfSByZXN1bHRTZWxlY3RvciBTZWxlY3RvciBmdW5jdGlvbiBmb3IgcmVzdWx0cyBwcm9kdWNlZCBpbiB0aGUgc2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBBIHtAbGluayBJU2NoZWR1bGVyfSBvbiB3aGljaCB0byBydW4gdGhlIGdlbmVyYXRvciBsb29wLiBJZiBub3QgcHJvdmlkZWQsIGRlZmF1bHRzIHRvIGVtaXQgaW1tZWRpYXRlbHkuXG4gICAqIEByZXR1cm5zIHtPYnNlcnZhYmxlPFQ+fSBUaGUgZ2VuZXJhdGVkIHNlcXVlbmNlLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZTxULCBTPihpbml0aWFsU3RhdGU6IFMsXG4gICAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uOiBDb25kaXRpb25GdW5jPFM+LFxuICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGU6IEl0ZXJhdGVGdW5jPFM+LFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFNlbGVjdG9yOiBSZXN1bHRGdW5jPFMsIFQ+LFxuICAgICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQ+XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IHJ1bm5pbmcgYSBzdGF0ZS1kcml2ZW4gbG9vcFxuICAgKiBwcm9kdWNpbmcgdGhlIHNlcXVlbmNlJ3MgZWxlbWVudHMsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyXG4gICAqIHRvIHNlbmQgb3V0IG9ic2VydmVyIG1lc3NhZ2VzLlxuICAgKiBUaGUgb3ZlcmxvYWQgdXNlcyBzdGF0ZSBhcyBhbiBlbWl0dGVkIHZhbHVlLlxuICAgKlxuICAgKiA8aW1nIHNyYz1cIi4vaW1nL2dlbmVyYXRlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Qcm9kdWNlcyBzZXF1ZW5jZSBvZiAwLCAxLCAyLCAuLi4gOSwgdGhlbiBjb21wbGV0ZXMuPC9jYXB0aW9uPlxuICAgKiB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5nZW5lcmF0ZSgwLCB4ID0+IHggPCAxMCwgeCA9PiB4ICsgMSk7XG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPlVzaW5nIGFzYXAgc2NoZWR1bGVyLCBwcm9kdWNlcyBzZXF1ZW5jZSBvZiAxLCAyLCA0LCB0aGVuIGNvbXBsZXRlcy48L2NhcHRpb24+XG4gICAqIHZhciByZXMgPSBSeC5PYnNlcnZhYmxlLmdlbmVyYXRlKDEsIHggPT4geCA8IDUsIHggPT4geCAqIDIsIFJ4LlNjaGVkdWxlci5hc2FwKTtcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgZnJvbX1cbiAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgKlxuICAgKiBAcGFyYW0ge1N9IGluaXRpYWxTdGF0ZSBJbml0aWFsIHN0YXRlLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uIChzdGF0ZTogUyk6IGJvb2xlYW59IGNvbmRpdGlvbiBDb25kaXRpb24gdG8gdGVybWluYXRlIGdlbmVyYXRpb24gKHVwb24gcmV0dXJuaW5nIGZhbHNlKS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbiAoc3RhdGU6IFMpOiBTfSBpdGVyYXRlIEl0ZXJhdGlvbiBzdGVwIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gQSB7QGxpbmsgSVNjaGVkdWxlcn0gb24gd2hpY2ggdG8gcnVuIHRoZSBnZW5lcmF0b3IgbG9vcC4gSWYgbm90IHByb3ZpZGVkLCBkZWZhdWx0cyB0byBlbWl0IGltbWVkaWF0ZWx5LlxuICAgKiBAcmV0dXJucyB7T2JzZXJ2YWJsZTxTPn0gVGhlIGdlbmVyYXRlZCBzZXF1ZW5jZS5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGU8Uz4oaW5pdGlhbFN0YXRlOiBTLFxuICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbjogQ29uZGl0aW9uRnVuYzxTPixcbiAgICAgICAgICAgICAgICAgICBpdGVyYXRlOiBJdGVyYXRlRnVuYzxTPixcbiAgICAgICAgICAgICAgICAgICBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxTPlxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYW4gb2JzZXJ2YWJsZSBzZXF1ZW5jZSBieSBydW5uaW5nIGEgc3RhdGUtZHJpdmVuIGxvb3BcbiAgICogcHJvZHVjaW5nIHRoZSBzZXF1ZW5jZSdzIGVsZW1lbnRzLCB1c2luZyB0aGUgc3BlY2lmaWVkIHNjaGVkdWxlclxuICAgKiB0byBzZW5kIG91dCBvYnNlcnZlciBtZXNzYWdlcy5cbiAgICogVGhlIG92ZXJsb2FkIGFjY2VwdHMgb3B0aW9ucyBvYmplY3QgdGhhdCBtaWdodCBjb250YWluIGluaXRpYWwgc3RhdGUsIGl0ZXJhdGUsXG4gICAqIGNvbmRpdGlvbiBhbmQgc2NoZWR1bGVyLlxuICAgKlxuICAgKiA8aW1nIHNyYz1cIi4vaW1nL2dlbmVyYXRlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Qcm9kdWNlcyBzZXF1ZW5jZSBvZiAwLCAxLCAyLCAuLi4gOSwgdGhlbiBjb21wbGV0ZXMuPC9jYXB0aW9uPlxuICAgKiB2YXIgcmVzID0gUnguT2JzZXJ2YWJsZS5nZW5lcmF0ZSh7XG4gICAqICAgaW5pdGlhbFN0YXRlOiAwLFxuICAgKiAgIGNvbmRpdGlvbjogeCA9PiB4IDwgMTAsXG4gICAqICAgaXRlcmF0ZTogeCA9PiB4ICsgMVxuICAgKiB9KTtcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgZnJvbX1cbiAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgKlxuICAgKiBAcGFyYW0ge0dlbmVyYXRlQmFzZU9wdGlvbnM8Uz59IG9wdGlvbnMgT2JqZWN0IHRoYXQgbXVzdCBjb250YWluIGluaXRpYWxTdGF0ZSwgaXRlcmF0ZSBhbmQgbWlnaHQgY29udGFpbiBjb25kaXRpb24gYW5kIHNjaGVkdWxlci5cbiAgICogQHJldHVybnMge09ic2VydmFibGU8Uz59IFRoZSBnZW5lcmF0ZWQgc2VxdWVuY2UuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlPFM+KG9wdGlvbnM6IEdlbmVyYXRlQmFzZU9wdGlvbnM8Uz4pOiBPYnNlcnZhYmxlPFM+XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIGJ5IHJ1bm5pbmcgYSBzdGF0ZS1kcml2ZW4gbG9vcFxuICAgKiBwcm9kdWNpbmcgdGhlIHNlcXVlbmNlJ3MgZWxlbWVudHMsIHVzaW5nIHRoZSBzcGVjaWZpZWQgc2NoZWR1bGVyXG4gICAqIHRvIHNlbmQgb3V0IG9ic2VydmVyIG1lc3NhZ2VzLlxuICAgKiBUaGUgb3ZlcmxvYWQgYWNjZXB0cyBvcHRpb25zIG9iamVjdCB0aGF0IG1pZ2h0IGNvbnRhaW4gaW5pdGlhbCBzdGF0ZSwgaXRlcmF0ZSxcbiAgICogY29uZGl0aW9uLCByZXN1bHQgc2VsZWN0b3IgYW5kIHNjaGVkdWxlci5cbiAgICpcbiAgICogPGltZyBzcmM9XCIuL2ltZy9nZW5lcmF0ZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICpcbiAgICogQGV4YW1wbGUgPGNhcHRpb24+UHJvZHVjZXMgc2VxdWVuY2Ugb2YgMCwgMSwgMiwgLi4uIDksIHRoZW4gY29tcGxldGVzLjwvY2FwdGlvbj5cbiAgICogdmFyIHJlcyA9IFJ4Lk9ic2VydmFibGUuZ2VuZXJhdGUoe1xuICAgKiAgIGluaXRpYWxTdGF0ZTogMCxcbiAgICogICBjb25kaXRpb246IHggPT4geCA8IDEwLFxuICAgKiAgIGl0ZXJhdGU6IHggPT4geCArIDEsXG4gICAqICAgcmVzdWx0U2VsZWN0b3I6IHggPT4geFxuICAgKiB9KTtcbiAgICpcbiAgICogQHNlZSB7QGxpbmsgZnJvbX1cbiAgICogQHNlZSB7QGxpbmsgY3JlYXRlfVxuICAgKlxuICAgKiBAcGFyYW0ge0dlbmVyYXRlT3B0aW9uczxULCBTPn0gb3B0aW9ucyBPYmplY3QgdGhhdCBtdXN0IGNvbnRhaW4gaW5pdGlhbFN0YXRlLCBpdGVyYXRlLCByZXN1bHRTZWxlY3RvciBhbmQgbWlnaHQgY29udGFpbiBjb25kaXRpb24gYW5kIHNjaGVkdWxlci5cbiAgICogQHJldHVybnMge09ic2VydmFibGU8VD59IFRoZSBnZW5lcmF0ZWQgc2VxdWVuY2UuXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlPFQsIFM+KG9wdGlvbnM6IEdlbmVyYXRlT3B0aW9uczxULCBTPik6IE9ic2VydmFibGU8VD5cblxuICBzdGF0aWMgY3JlYXRlPFQsIFM+KGluaXRpYWxTdGF0ZU9yT3B0aW9uczogUyB8IEdlbmVyYXRlT3B0aW9uczxULCBTPixcbiAgICAgICAgICAgICAgICAgICAgICBjb25kaXRpb24/OiBDb25kaXRpb25GdW5jPFM+LFxuICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGU/OiBJdGVyYXRlRnVuYzxTPixcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTZWxlY3Rvck9yT2JzZXJ2YWJsZT86IChSZXN1bHRGdW5jPFMsIFQ+KSB8IElTY2hlZHVsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VD4ge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgIHJldHVybiBuZXcgR2VuZXJhdGVPYnNlcnZhYmxlPFQsIFM+KFxuICAgICAgICAoPEdlbmVyYXRlT3B0aW9uczxULCBTPj5pbml0aWFsU3RhdGVPck9wdGlvbnMpLmluaXRpYWxTdGF0ZSxcbiAgICAgICAgKDxHZW5lcmF0ZU9wdGlvbnM8VCwgUz4+aW5pdGlhbFN0YXRlT3JPcHRpb25zKS5jb25kaXRpb24sXG4gICAgICAgICg8R2VuZXJhdGVPcHRpb25zPFQsIFM+PmluaXRpYWxTdGF0ZU9yT3B0aW9ucykuaXRlcmF0ZSxcbiAgICAgICAgKDxHZW5lcmF0ZU9wdGlvbnM8VCwgUz4+aW5pdGlhbFN0YXRlT3JPcHRpb25zKS5yZXN1bHRTZWxlY3RvciB8fCBzZWxmU2VsZWN0b3IsXG4gICAgICAgICg8R2VuZXJhdGVPcHRpb25zPFQsIFM+PmluaXRpYWxTdGF0ZU9yT3B0aW9ucykuc2NoZWR1bGVyKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0U2VsZWN0b3JPck9ic2VydmFibGUgPT09IHVuZGVmaW5lZCB8fCBpc1NjaGVkdWxlcihyZXN1bHRTZWxlY3Rvck9yT2JzZXJ2YWJsZSkpIHtcbiAgICAgIHJldHVybiBuZXcgR2VuZXJhdGVPYnNlcnZhYmxlPFQsIFM+KFxuICAgICAgICA8Uz5pbml0aWFsU3RhdGVPck9wdGlvbnMsXG4gICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgaXRlcmF0ZSxcbiAgICAgICAgc2VsZlNlbGVjdG9yLFxuICAgICAgICA8SVNjaGVkdWxlcj5yZXN1bHRTZWxlY3Rvck9yT2JzZXJ2YWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBHZW5lcmF0ZU9ic2VydmFibGU8VCwgUz4oXG4gICAgICA8Uz5pbml0aWFsU3RhdGVPck9wdGlvbnMsXG4gICAgICBjb25kaXRpb24sXG4gICAgICBpdGVyYXRlLFxuICAgICAgPFJlc3VsdEZ1bmM8UywgVD4+cmVzdWx0U2VsZWN0b3JPck9ic2VydmFibGUsXG4gICAgICA8SVNjaGVkdWxlcj5zY2hlZHVsZXIpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9zdWJzY3JpYmUoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxhbnk+KTogU3Vic2NyaXB0aW9uIHwgRnVuY3Rpb24gfCB2b2lkIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLmluaXRpYWxTdGF0ZTtcbiAgICBpZiAodGhpcy5zY2hlZHVsZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZTxTY2hlZHVsZXJTdGF0ZTxULCBTPj4oR2VuZXJhdGVPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7XG4gICAgICAgIHN1YnNjcmliZXIsXG4gICAgICAgIGl0ZXJhdGU6IHRoaXMuaXRlcmF0ZSxcbiAgICAgICAgY29uZGl0aW9uOiB0aGlzLmNvbmRpdGlvbixcbiAgICAgICAgcmVzdWx0U2VsZWN0b3I6IHRoaXMucmVzdWx0U2VsZWN0b3IsXG4gICAgICAgIHN0YXRlIH0pO1xuICAgIH1cbiAgICBjb25zdCB7IGNvbmRpdGlvbiwgcmVzdWx0U2VsZWN0b3IsIGl0ZXJhdGUgfSA9IHRoaXM7XG4gICAgZG8ge1xuICAgICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgICBsZXQgY29uZGl0aW9uUmVzdWx0OiBib29sZWFuO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbmRpdGlvblJlc3VsdCA9IGNvbmRpdGlvbihzdGF0ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25kaXRpb25SZXN1bHQpIHtcbiAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxldCB2YWx1ZTogVDtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlID0gcmVzdWx0U2VsZWN0b3Ioc3RhdGUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3Vic2NyaWJlci5uZXh0KHZhbHVlKTtcbiAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXRlID0gaXRlcmF0ZShzdGF0ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBkaXNwYXRjaDxULCBTPihzdGF0ZTogU2NoZWR1bGVyU3RhdGU8VCwgUz4pOiBTdWJzY3JpcHRpb24gfCB2b2lkIHtcbiAgICBjb25zdCB7IHN1YnNjcmliZXIsIGNvbmRpdGlvbiB9ID0gc3RhdGU7XG4gICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzdGF0ZS5uZWVkSXRlcmF0ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3RhdGUuc3RhdGUgPSBzdGF0ZS5pdGVyYXRlKHN0YXRlLnN0YXRlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUubmVlZEl0ZXJhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICBsZXQgY29uZGl0aW9uUmVzdWx0OiBib29sZWFuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uZGl0aW9uUmVzdWx0ID0gY29uZGl0aW9uKHN0YXRlLnN0YXRlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzdWJzY3JpYmVyLmVycm9yKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghY29uZGl0aW9uUmVzdWx0KSB7XG4gICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHZhbHVlOiBUO1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IHN0YXRlLnJlc3VsdFNlbGVjdG9yKHN0YXRlLnN0YXRlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiAoPEFjdGlvbjxTY2hlZHVsZXJTdGF0ZTxULCBTPj4+PGFueT50aGlzKS5zY2hlZHVsZShzdGF0ZSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9HZW5lcmF0ZU9ic2VydmFibGUudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJzY3JpYmFibGVPclByb21pc2UgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IFRlYXJkb3duTG9naWMgfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuXG5pbXBvcnQgeyBzdWJzY3JpYmVUb1Jlc3VsdCB9IGZyb20gJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnO1xuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vT3V0ZXJTdWJzY3JpYmVyJztcbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG5leHBvcnQgY2xhc3MgSWZPYnNlcnZhYmxlPFQsIFI+IGV4dGVuZHMgT2JzZXJ2YWJsZTxUPiB7XG5cbiAgc3RhdGljIGNyZWF0ZTxULCBSPihjb25kaXRpb246ICgpID0+IGJvb2xlYW4gfCB2b2lkLFxuICAgICAgICAgICAgICAgICAgICAgIHRoZW5Tb3VyY2U/OiBTdWJzY3JpYmFibGVPclByb21pc2U8VD4gfCB2b2lkLFxuICAgICAgICAgICAgICAgICAgICAgIGVsc2VTb3VyY2U/OiBTdWJzY3JpYmFibGVPclByb21pc2U8Uj4gfCB2b2lkKTogT2JzZXJ2YWJsZTxUfFI+IHtcbiAgICByZXR1cm4gbmV3IElmT2JzZXJ2YWJsZShjb25kaXRpb24sIHRoZW5Tb3VyY2UsIGVsc2VTb3VyY2UpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjb25kaXRpb246ICgpID0+IGJvb2xlYW4gfCB2b2lkLFxuICAgICAgICAgICAgICBwcml2YXRlIHRoZW5Tb3VyY2U/OiBTdWJzY3JpYmFibGVPclByb21pc2U8VD4gfCB2b2lkLFxuICAgICAgICAgICAgICBwcml2YXRlIGVsc2VTb3VyY2U/OiBTdWJzY3JpYmFibGVPclByb21pc2U8Uj4gfCB2b2lkKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VHxSPik6IFRlYXJkb3duTG9naWMge1xuICAgIGNvbnN0IHsgY29uZGl0aW9uLCB0aGVuU291cmNlLCBlbHNlU291cmNlIH0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIG5ldyBJZlN1YnNjcmliZXIoc3Vic2NyaWJlciwgY29uZGl0aW9uLCB0aGVuU291cmNlLCBlbHNlU291cmNlKTtcbiAgfVxufVxuXG5jbGFzcyBJZlN1YnNjcmliZXI8VCwgUj4gZXh0ZW5kcyBPdXRlclN1YnNjcmliZXI8VCwgVD4ge1xuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxUPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBjb25kaXRpb246ICgpID0+IGJvb2xlYW4gfCB2b2lkLFxuICAgICAgICAgICAgICBwcml2YXRlIHRoZW5Tb3VyY2U/OiBTdWJzY3JpYmFibGVPclByb21pc2U8VD4gfCB2b2lkLFxuICAgICAgICAgICAgICBwcml2YXRlIGVsc2VTb3VyY2U/OiBTdWJzY3JpYmFibGVPclByb21pc2U8Uj4gfCB2b2lkKSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICAgIHRoaXMudHJ5SWYoKTtcbiAgfVxuXG4gIHByaXZhdGUgdHJ5SWYoKTogdm9pZCB7XG4gICAgY29uc3QgeyBjb25kaXRpb24sIHRoZW5Tb3VyY2UsIGVsc2VTb3VyY2UgfSA9IHRoaXM7XG5cbiAgICBsZXQgcmVzdWx0OiBib29sZWFuO1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSA8Ym9vbGVhbj5jb25kaXRpb24oKTtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHJlc3VsdCA/IHRoZW5Tb3VyY2UgOiBlbHNlU291cmNlO1xuXG4gICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHNvdXJjZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29ic2VydmFibGUvSWZPYnNlcnZhYmxlLnRzIiwiaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgaXNOdW1lcmljIH0gZnJvbSAnLi4vdXRpbC9pc051bWVyaWMnO1xuaW1wb3J0IHsgSVNjaGVkdWxlciB9IGZyb20gJy4uL1NjaGVkdWxlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBhc3luYyB9IGZyb20gJy4uL3NjaGVkdWxlci9hc3luYyc7XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG5leHBvcnQgY2xhc3MgSW50ZXJ2YWxPYnNlcnZhYmxlIGV4dGVuZHMgT2JzZXJ2YWJsZTxudW1iZXI+IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHNlcXVlbnRpYWwgbnVtYmVycyBldmVyeSBzcGVjaWZpZWRcbiAgICogaW50ZXJ2YWwgb2YgdGltZSwgb24gYSBzcGVjaWZpZWQgSVNjaGVkdWxlci5cbiAgICpcbiAgICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkVtaXRzIGluY3JlbWVudGFsIG51bWJlcnMgcGVyaW9kaWNhbGx5IGluIHRpbWUuXG4gICAqIDwvc3Bhbj5cbiAgICpcbiAgICogPGltZyBzcmM9XCIuL2ltZy9pbnRlcnZhbC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICpcbiAgICogYGludGVydmFsYCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbiBpbmZpbml0ZSBzZXF1ZW5jZSBvZlxuICAgKiBhc2NlbmRpbmcgaW50ZWdlcnMsIHdpdGggYSBjb25zdGFudCBpbnRlcnZhbCBvZiB0aW1lIG9mIHlvdXIgY2hvb3NpbmdcbiAgICogYmV0d2VlbiB0aG9zZSBlbWlzc2lvbnMuIFRoZSBmaXJzdCBlbWlzc2lvbiBpcyBub3Qgc2VudCBpbW1lZGlhdGVseSwgYnV0XG4gICAqIG9ubHkgYWZ0ZXIgdGhlIGZpcnN0IHBlcmlvZCBoYXMgcGFzc2VkLiBCeSBkZWZhdWx0LCB0aGlzIG9wZXJhdG9yIHVzZXMgdGhlXG4gICAqIGBhc3luY2AgSVNjaGVkdWxlciB0byBwcm92aWRlIGEgbm90aW9uIG9mIHRpbWUsIGJ1dCB5b3UgbWF5IHBhc3MgYW55XG4gICAqIElTY2hlZHVsZXIgdG8gaXQuXG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIGFzY2VuZGluZyBudW1iZXJzLCBvbmUgZXZlcnkgc2Vjb25kICgxMDAwbXMpPC9jYXB0aW9uPlxuICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gICAqIG51bWJlcnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgKlxuICAgKiBAc2VlIHtAbGluayB0aW1lcn1cbiAgICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcGVyaW9kPTBdIFRoZSBpbnRlcnZhbCBzaXplIGluIG1pbGxpc2Vjb25kcyAoYnkgZGVmYXVsdClcbiAgICogb3IgdGhlIHRpbWUgdW5pdCBkZXRlcm1pbmVkIGJ5IHRoZSBzY2hlZHVsZXIncyBjbG9jay5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSBJU2NoZWR1bGVyIHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgKiB0aGUgZW1pc3Npb24gb2YgdmFsdWVzLCBhbmQgcHJvdmlkaW5nIGEgbm90aW9uIG9mIFwidGltZVwiLlxuICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYSBzZXF1ZW50aWFsIG51bWJlciBlYWNoIHRpbWVcbiAgICogaW50ZXJ2YWwuXG4gICAqIEBzdGF0aWMgdHJ1ZVxuICAgKiBAbmFtZSBpbnRlcnZhbFxuICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZShwZXJpb2Q6IG51bWJlciA9IDAsXG4gICAgICAgICAgICAgICAgc2NoZWR1bGVyOiBJU2NoZWR1bGVyID0gYXN5bmMpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuICAgIHJldHVybiBuZXcgSW50ZXJ2YWxPYnNlcnZhYmxlKHBlcmlvZCwgc2NoZWR1bGVyKTtcbiAgfVxuXG4gIHN0YXRpYyBkaXNwYXRjaChzdGF0ZTogYW55KTogdm9pZCB7XG4gICAgY29uc3QgeyBpbmRleCwgc3Vic2NyaWJlciwgcGVyaW9kIH0gPSBzdGF0ZTtcblxuICAgIHN1YnNjcmliZXIubmV4dChpbmRleCk7XG5cbiAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdGF0ZS5pbmRleCArPSAxO1xuXG4gICAgKDxhbnk+IHRoaXMpLnNjaGVkdWxlKHN0YXRlLCBwZXJpb2QpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwZXJpb2Q6IG51bWJlciA9IDAsXG4gICAgICAgICAgICAgIHByaXZhdGUgc2NoZWR1bGVyOiBJU2NoZWR1bGVyID0gYXN5bmMpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmICghaXNOdW1lcmljKHBlcmlvZCkgfHwgcGVyaW9kIDwgMCkge1xuICAgICAgdGhpcy5wZXJpb2QgPSAwO1xuICAgIH1cbiAgICBpZiAoIXNjaGVkdWxlciB8fCB0eXBlb2Ygc2NoZWR1bGVyLnNjaGVkdWxlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlciA9IGFzeW5jO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8bnVtYmVyPikge1xuICAgIGNvbnN0IGluZGV4ID0gMDtcbiAgICBjb25zdCBwZXJpb2QgPSB0aGlzLnBlcmlvZDtcbiAgICBjb25zdCBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcblxuICAgIHN1YnNjcmliZXIuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShJbnRlcnZhbE9ic2VydmFibGUuZGlzcGF0Y2gsIHBlcmlvZCwge1xuICAgICAgaW5kZXgsIHN1YnNjcmliZXIsIHBlcmlvZFxuICAgIH0pKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL0ludGVydmFsT2JzZXJ2YWJsZS50cyIsImltcG9ydCB7IHJvb3QgfSBmcm9tICcuLi91dGlsL3Jvb3QnO1xuaW1wb3J0IHsgSVNjaGVkdWxlciB9IGZyb20gJy4uL1NjaGVkdWxlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBpdGVyYXRvciBhcyBTeW1ib2xfaXRlcmF0b3IgfSBmcm9tICcuLi9zeW1ib2wvaXRlcmF0b3InO1xuaW1wb3J0IHsgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG5leHBvcnQgY2xhc3MgSXRlcmF0b3JPYnNlcnZhYmxlPFQ+IGV4dGVuZHMgT2JzZXJ2YWJsZTxUPiB7XG4gIHByaXZhdGUgaXRlcmF0b3I6IGFueTtcblxuICBzdGF0aWMgY3JlYXRlPFQ+KGl0ZXJhdG9yOiBhbnksIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBJdGVyYXRvck9ic2VydmFibGU8VD4ge1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3JPYnNlcnZhYmxlKGl0ZXJhdG9yLCBzY2hlZHVsZXIpO1xuICB9XG5cbiAgc3RhdGljIGRpc3BhdGNoKHN0YXRlOiBhbnkpIHtcblxuICAgIGNvbnN0IHsgaW5kZXgsIGhhc0Vycm9yLCBpdGVyYXRvciwgc3Vic2NyaWJlciB9ID0gc3RhdGU7XG5cbiAgICBpZiAoaGFzRXJyb3IpIHtcbiAgICAgIHN1YnNjcmliZXIuZXJyb3Ioc3RhdGUuZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgaWYgKHJlc3VsdC5kb25lKSB7XG4gICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3Vic2NyaWJlci5uZXh0KHJlc3VsdC52YWx1ZSk7XG4gICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG5cbiAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3IucmV0dXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGl0ZXJhdG9yLnJldHVybigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgICg8YW55PiB0aGlzKS5zY2hlZHVsZShzdGF0ZSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihpdGVyYXRvcjogYW55LCBwcml2YXRlIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgaWYgKGl0ZXJhdG9yID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaXRlcmF0b3IgY2Fubm90IGJlIG51bGwuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5pdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhdG9yKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4pOiBUZWFyZG93bkxvZ2ljIHtcblxuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgeyBpdGVyYXRvciwgc2NoZWR1bGVyIH0gPSB0aGlzO1xuXG4gICAgaWYgKHNjaGVkdWxlcikge1xuICAgICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShJdGVyYXRvck9ic2VydmFibGUuZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgaW5kZXgsIGl0ZXJhdG9yLCBzdWJzY3JpYmVyXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZG8ge1xuICAgICAgICBsZXQgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3Vic2NyaWJlci5uZXh0KHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvci5yZXR1cm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGl0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFN0cmluZ0l0ZXJhdG9yIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBzdHI6IHN0cmluZyxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBpZHg6IG51bWJlciA9IDAsXG4gICAgICAgICAgICAgIHByaXZhdGUgbGVuOiBudW1iZXIgPSBzdHIubGVuZ3RoKSB7XG4gIH1cbiAgW1N5bWJvbF9pdGVyYXRvcl0oKSB7IHJldHVybiAodGhpcyk7IH1cbiAgbmV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5pZHggPCB0aGlzLmxlbiA/IHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiB0aGlzLnN0ci5jaGFyQXQodGhpcy5pZHgrKylcbiAgICB9IDoge1xuICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxufVxuXG5jbGFzcyBBcnJheUl0ZXJhdG9yIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBhcnI6IEFycmF5PGFueT4sXG4gICAgICAgICAgICAgIHByaXZhdGUgaWR4OiBudW1iZXIgPSAwLFxuICAgICAgICAgICAgICBwcml2YXRlIGxlbjogbnVtYmVyID0gdG9MZW5ndGgoYXJyKSkge1xuICB9XG4gIFtTeW1ib2xfaXRlcmF0b3JdKCkgeyByZXR1cm4gdGhpczsgfVxuICBuZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmlkeCA8IHRoaXMubGVuID8ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHRoaXMuYXJyW3RoaXMuaWR4KytdXG4gICAgfSA6IHtcbiAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3Iob2JqOiBhbnkpIHtcbiAgY29uc3QgaSA9IG9ialtTeW1ib2xfaXRlcmF0b3JdO1xuICBpZiAoIWkgJiYgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbmV3IFN0cmluZ0l0ZXJhdG9yKG9iaik7XG4gIH1cbiAgaWYgKCFpICYmIG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgQXJyYXlJdGVyYXRvcihvYmopO1xuICB9XG4gIGlmICghaSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29iamVjdCBpcyBub3QgaXRlcmFibGUnKTtcbiAgfVxuICByZXR1cm4gb2JqW1N5bWJvbF9pdGVyYXRvcl0oKTtcbn1cblxuY29uc3QgbWF4U2FmZUludGVnZXIgPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuXG5mdW5jdGlvbiB0b0xlbmd0aChvOiBhbnkpIHtcbiAgbGV0IGxlbiA9ICtvLmxlbmd0aDtcbiAgaWYgKGlzTmFOKGxlbikpIHtcbiAgICAgIHJldHVybiAwO1xuICB9XG4gIGlmIChsZW4gPT09IDAgfHwgIW51bWJlcklzRmluaXRlKGxlbikpIHtcbiAgICAgIHJldHVybiBsZW47XG4gIH1cbiAgbGVuID0gc2lnbihsZW4pICogTWF0aC5mbG9vcihNYXRoLmFicyhsZW4pKTtcbiAgaWYgKGxlbiA8PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAobGVuID4gbWF4U2FmZUludGVnZXIpIHtcbiAgICAgIHJldHVybiBtYXhTYWZlSW50ZWdlcjtcbiAgfVxuICByZXR1cm4gbGVuO1xufVxuXG5mdW5jdGlvbiBudW1iZXJJc0Zpbml0ZSh2YWx1ZTogYW55KSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHJvb3QuaXNGaW5pdGUodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBzaWduKHZhbHVlOiBhbnkpIHtcbiAgbGV0IHZhbHVlQXNOdW1iZXIgPSArdmFsdWU7XG4gIGlmICh2YWx1ZUFzTnVtYmVyID09PSAwKSB7XG4gICAgcmV0dXJuIHZhbHVlQXNOdW1iZXI7XG4gIH1cbiAgaWYgKGlzTmFOKHZhbHVlQXNOdW1iZXIpKSB7XG4gICAgcmV0dXJuIHZhbHVlQXNOdW1iZXI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlQXNOdW1iZXIgPCAwID8gLTEgOiAxO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL0l0ZXJhdG9yT2JzZXJ2YWJsZS50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi91dGlsL25vb3AnO1xuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xuZXhwb3J0IGNsYXNzIE5ldmVyT2JzZXJ2YWJsZTxUPiBleHRlbmRzIE9ic2VydmFibGU8VD4ge1xuICAvKipcbiAgICogQ3JlYXRlcyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgbm8gaXRlbXMgdG8gdGhlIE9ic2VydmVyLlxuICAgKlxuICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+QW4gT2JzZXJ2YWJsZSB0aGF0IG5ldmVyIGVtaXRzIGFueXRoaW5nLjwvc3Bhbj5cbiAgICpcbiAgICogPGltZyBzcmM9XCIuL2ltZy9uZXZlci5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICpcbiAgICogVGhpcyBzdGF0aWMgb3BlcmF0b3IgaXMgdXNlZnVsIGZvciBjcmVhdGluZyBhIHNpbXBsZSBPYnNlcnZhYmxlIHRoYXQgZW1pdHNcbiAgICogbmVpdGhlciB2YWx1ZXMgbm9yIGVycm9ycyBub3IgdGhlIGNvbXBsZXRpb24gbm90aWZpY2F0aW9uLiBJdCBjYW4gYmUgdXNlZFxuICAgKiBmb3IgdGVzdGluZyBwdXJwb3NlcyBvciBmb3IgY29tcG9zaW5nIHdpdGggb3RoZXIgT2JzZXJ2YWJsZXMuIFBsZWFzZSBub3RcbiAgICogdGhhdCBieSBuZXZlciBlbWl0dGluZyBhIGNvbXBsZXRlIG5vdGlmaWNhdGlvbiwgdGhpcyBPYnNlcnZhYmxlIGtlZXBzIHRoZVxuICAgKiBzdWJzY3JpcHRpb24gZnJvbSBiZWluZyBkaXNwb3NlZCBhdXRvbWF0aWNhbGx5LiBTdWJzY3JpcHRpb25zIG5lZWQgdG8gYmVcbiAgICogbWFudWFsbHkgZGlzcG9zZWQuXG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgdGhlIG51bWJlciA3LCB0aGVuIG5ldmVyIGVtaXQgYW55dGhpbmcgZWxzZSAobm90IGV2ZW4gY29tcGxldGUpLjwvY2FwdGlvbj5cbiAgICogZnVuY3Rpb24gaW5mbygpIHtcbiAgICogICBjb25zb2xlLmxvZygnV2lsbCBub3QgYmUgY2FsbGVkJyk7XG4gICAqIH1cbiAgICogdmFyIHJlc3VsdCA9IFJ4Lk9ic2VydmFibGUubmV2ZXIoKS5zdGFydFdpdGgoNyk7XG4gICAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSwgaW5mbywgaW5mbyk7XG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGNyZWF0ZX1cbiAgICogQHNlZSB7QGxpbmsgZW1wdHl9XG4gICAqIEBzZWUge0BsaW5rIG9mfVxuICAgKiBAc2VlIHtAbGluayB0aHJvd31cbiAgICpcbiAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQSBcIm5ldmVyXCIgT2JzZXJ2YWJsZTogbmV2ZXIgZW1pdHMgYW55dGhpbmcuXG4gICAqIEBzdGF0aWMgdHJ1ZVxuICAgKiBAbmFtZSBuZXZlclxuICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZTxUPigpIHtcbiAgICByZXR1cm4gbmV3IE5ldmVyT2JzZXJ2YWJsZTxUPigpO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4pOiB2b2lkIHtcbiAgICBub29wKCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9OZXZlck9ic2VydmFibGUudHMiLCJpbXBvcnQgeyBJU2NoZWR1bGVyIH0gZnJvbSAnLi4vU2NoZWR1bGVyJztcclxuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi4vc2NoZWR1bGVyL0FjdGlvbic7XHJcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcclxuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xyXG5pbXBvcnQgeyBUZWFyZG93bkxvZ2ljIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcclxuXHJcbmludGVyZmFjZSBQYWlyc0NvbnRleHQ8VD4ge1xyXG4gIG9iajogT2JqZWN0O1xyXG4gIGtleXM6IEFycmF5PHN0cmluZz47XHJcbiAgbGVuZ3RoOiBudW1iZXI7XHJcbiAgaW5kZXg6IG51bWJlcjtcclxuICBzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPEFycmF5PHN0cmluZyB8IFQ+PjtcclxufVxyXG5cclxuZnVuY3Rpb24gZGlzcGF0Y2g8VD4odGhpczogQWN0aW9uPFBhaXJzQ29udGV4dDxUPj4sIHN0YXRlOiBQYWlyc0NvbnRleHQ8VD4pIHtcclxuICBjb25zdCB7b2JqLCBrZXlzLCBsZW5ndGgsIGluZGV4LCBzdWJzY3JpYmVyfSA9IHN0YXRlO1xyXG5cclxuICBpZiAoaW5kZXggPT09IGxlbmd0aCkge1xyXG4gICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuXHJcbiAgY29uc3Qga2V5ID0ga2V5c1tpbmRleF07XHJcbiAgc3Vic2NyaWJlci5uZXh0KFtrZXksIG9ialtrZXldXSk7XHJcblxyXG4gIHN0YXRlLmluZGV4ID0gaW5kZXggKyAxO1xyXG5cclxuICB0aGlzLnNjaGVkdWxlKHN0YXRlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXHJcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxyXG4gKiBAaGlkZSB0cnVlXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgUGFpcnNPYnNlcnZhYmxlPFQ+IGV4dGVuZHMgT2JzZXJ2YWJsZTxBcnJheTxzdHJpbmcgfCBUPj4ge1xyXG4gIHByaXZhdGUga2V5czogQXJyYXk8c3RyaW5nPjtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydCBhbiBvYmplY3QgaW50byBhbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mIFtrZXksIHZhbHVlXSBwYWlyc1xyXG4gICAqIHVzaW5nIGFuIG9wdGlvbmFsIElTY2hlZHVsZXIgdG8gZW51bWVyYXRlIHRoZSBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db252ZXJ0cyBhIGphdmFzY3JpcHQgb2JqZWN0IHRvIGFuIE9ic2VydmFibGU8L2NhcHRpb24+XHJcbiAgICogdmFyIG9iaiA9IHtcclxuICAgKiAgIGZvbzogNDIsXHJcbiAgICogICBiYXI6IDU2LFxyXG4gICAqICAgYmF6OiA3OFxyXG4gICAqIH07XHJcbiAgICpcclxuICAgKiB2YXIgc291cmNlID0gUnguT2JzZXJ2YWJsZS5wYWlycyhvYmopO1xyXG4gICAqXHJcbiAgICogdmFyIHN1YnNjcmlwdGlvbiA9IHNvdXJjZS5zdWJzY3JpYmUoXHJcbiAgICogICBmdW5jdGlvbiAoeCkge1xyXG4gICAqICAgICBjb25zb2xlLmxvZygnTmV4dDogJXMnLCB4KTtcclxuICAgKiAgIH0sXHJcbiAgICogICBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICogICAgIGNvbnNvbGUubG9nKCdFcnJvcjogJXMnLCBlcnIpO1xyXG4gICAqICAgfSxcclxuICAgKiAgIGZ1bmN0aW9uICgpIHtcclxuICAgKiAgICAgY29uc29sZS5sb2coJ0NvbXBsZXRlZCcpO1xyXG4gICAqICAgfSk7XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gaW5zcGVjdCBhbmQgdHVybiBpbnRvIGFuXHJcbiAgICogT2JzZXJ2YWJsZSBzZXF1ZW5jZS5cclxuICAgKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gQW4gb3B0aW9uYWwgSVNjaGVkdWxlciB0byBydW4gdGhlXHJcbiAgICogZW51bWVyYXRpb24gb2YgdGhlIGlucHV0IHNlcXVlbmNlIG9uLlxyXG4gICAqIEByZXR1cm5zIHsoT2JzZXJ2YWJsZTxBcnJheTxzdHJpbmcgfCBUPj4pfSBBbiBvYnNlcnZhYmxlIHNlcXVlbmNlIG9mXHJcbiAgICogW2tleSwgdmFsdWVdIHBhaXJzIGZyb20gdGhlIG9iamVjdC5cclxuICAgKi9cclxuICBzdGF0aWMgY3JlYXRlPFQ+KG9iajogT2JqZWN0LCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxBcnJheTxzdHJpbmcgfCBUPj4ge1xyXG4gICAgcmV0dXJuIG5ldyBQYWlyc09ic2VydmFibGU8VD4ob2JqLCBzY2hlZHVsZXIpO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBvYmo6IE9iamVjdCwgcHJpdmF0ZSBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5rZXlzID0gT2JqZWN0LmtleXMob2JqKTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8QXJyYXk8c3RyaW5nIHwgVD4+KTogVGVhcmRvd25Mb2dpYyB7XHJcbiAgICBjb25zdCB7a2V5cywgc2NoZWR1bGVyfSA9IHRoaXM7XHJcbiAgICBjb25zdCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcclxuXHJcbiAgICBpZiAoc2NoZWR1bGVyKSB7XHJcbiAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2gsIDAsIHtcclxuICAgICAgICBvYmo6IHRoaXMub2JqLCBrZXlzLCBsZW5ndGgsIGluZGV4OiAwLCBzdWJzY3JpYmVyXHJcbiAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xyXG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaWR4XTtcclxuICAgICAgICBzdWJzY3JpYmVyLm5leHQoW2tleSwgdGhpcy5vYmpba2V5XV0pO1xyXG4gICAgICB9XHJcbiAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcclxuICAgIH1cclxuICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29ic2VydmFibGUvUGFpcnNPYnNlcnZhYmxlLnRzIiwiaW1wb3J0IHsgSVNjaGVkdWxlciB9IGZyb20gJy4uL1NjaGVkdWxlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBUZWFyZG93bkxvZ2ljIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbmV4cG9ydCBjbGFzcyBSYW5nZU9ic2VydmFibGUgZXh0ZW5kcyBPYnNlcnZhYmxlPG51bWJlcj4ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhIHNlcXVlbmNlIG9mIG51bWJlcnMgd2l0aGluIGEgc3BlY2lmaWVkXG4gICAqIHJhbmdlLlxuICAgKlxuICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RW1pdHMgYSBzZXF1ZW5jZSBvZiBudW1iZXJzIGluIGEgcmFuZ2UuPC9zcGFuPlxuICAgKlxuICAgKiA8aW1nIHNyYz1cIi4vaW1nL3JhbmdlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICAgKlxuICAgKiBgcmFuZ2VgIG9wZXJhdG9yIGVtaXRzIGEgcmFuZ2Ugb2Ygc2VxdWVudGlhbCBpbnRlZ2VycywgaW4gb3JkZXIsIHdoZXJlIHlvdVxuICAgKiBzZWxlY3QgdGhlIGBzdGFydGAgb2YgdGhlIHJhbmdlIGFuZCBpdHMgYGxlbmd0aGAuIEJ5IGRlZmF1bHQsIHVzZXMgbm9cbiAgICogSVNjaGVkdWxlciBhbmQganVzdCBkZWxpdmVycyB0aGUgbm90aWZpY2F0aW9ucyBzeW5jaHJvbm91c2x5LCBidXQgbWF5IHVzZVxuICAgKiBhbiBvcHRpb25hbCBJU2NoZWR1bGVyIHRvIHJlZ3VsYXRlIHRob3NlIGRlbGl2ZXJpZXMuXG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIHRoZSBudW1iZXJzIDEgdG8gMTA8L2NhcHRpb24+XG4gICAqIHZhciBudW1iZXJzID0gUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAxMCk7XG4gICAqIG51bWJlcnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgKlxuICAgKiBAc2VlIHtAbGluayB0aW1lcn1cbiAgICogQHNlZSB7QGxpbmsgaW50ZXJ2YWx9XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBpbnRlZ2VyIGluIHRoZSBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudD0wXSBUaGUgbnVtYmVyIG9mIHNlcXVlbnRpYWwgaW50ZWdlcnMgdG8gZ2VuZXJhdGUuXG4gICAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyXSBBIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAgICogdGhlIGVtaXNzaW9ucyBvZiB0aGUgbm90aWZpY2F0aW9ucy5cbiAgICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiBudW1iZXJzIHRoYXQgZW1pdHMgYSBmaW5pdGUgcmFuZ2Ugb2ZcbiAgICogc2VxdWVudGlhbCBpbnRlZ2Vycy5cbiAgICogQHN0YXRpYyB0cnVlXG4gICAqIEBuYW1lIHJhbmdlXG4gICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKHN0YXJ0OiBudW1iZXIgPSAwLFxuICAgICAgICAgICAgICAgIGNvdW50OiBudW1iZXIgPSAwLFxuICAgICAgICAgICAgICAgIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuICAgIHJldHVybiBuZXcgUmFuZ2VPYnNlcnZhYmxlKHN0YXJ0LCBjb3VudCwgc2NoZWR1bGVyKTtcbiAgfVxuXG4gIHN0YXRpYyBkaXNwYXRjaChzdGF0ZTogYW55KSB7XG5cbiAgICBjb25zdCB7IHN0YXJ0LCBpbmRleCwgY291bnQsIHN1YnNjcmliZXIgfSA9IHN0YXRlO1xuXG4gICAgaWYgKGluZGV4ID49IGNvdW50KSB7XG4gICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3Vic2NyaWJlci5uZXh0KHN0YXJ0KTtcblxuICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN0YXRlLmluZGV4ID0gaW5kZXggKyAxO1xuICAgIHN0YXRlLnN0YXJ0ID0gc3RhcnQgKyAxO1xuXG4gICAgKDxhbnk+IHRoaXMpLnNjaGVkdWxlKHN0YXRlKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhcnQ6IG51bWJlcjtcbiAgcHJpdmF0ZSBfY291bnQ6IG51bWJlcjtcbiAgcHJpdmF0ZSBzY2hlZHVsZXI6IElTY2hlZHVsZXI7XG5cbiAgY29uc3RydWN0b3Ioc3RhcnQ6IG51bWJlcixcbiAgICAgICAgICAgICAgY291bnQ6IG51bWJlcixcbiAgICAgICAgICAgICAgc2NoZWR1bGVyPzogSVNjaGVkdWxlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuX2NvdW50ID0gY291bnQ7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3N1YnNjcmliZShzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPG51bWJlcj4pOiBUZWFyZG93bkxvZ2ljIHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGxldCBzdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLl9jb3VudDtcbiAgICBjb25zdCBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcblxuICAgIGlmIChzY2hlZHVsZXIpIHtcbiAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoUmFuZ2VPYnNlcnZhYmxlLmRpc3BhdGNoLCAwLCB7XG4gICAgICAgIGluZGV4LCBjb3VudCwgc3RhcnQsIHN1YnNjcmliZXJcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChpbmRleCsrID49IGNvdW50KSB7XG4gICAgICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN1YnNjcmliZXIubmV4dChzdGFydCsrKTtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL1JhbmdlT2JzZXJ2YWJsZS50cyIsImltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4uL3NjaGVkdWxlci9BY3Rpb24nO1xuaW1wb3J0IHsgSVNjaGVkdWxlciB9IGZyb20gJy4uL1NjaGVkdWxlcic7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgYXNhcCB9IGZyb20gJy4uL3NjaGVkdWxlci9hc2FwJztcbmltcG9ydCB7IGlzTnVtZXJpYyB9IGZyb20gJy4uL3V0aWwvaXNOdW1lcmljJztcblxuZXhwb3J0IGludGVyZmFjZSBEaXNwYXRjaEFyZzxUPiB7XG4gIHNvdXJjZTogT2JzZXJ2YWJsZTxUPjtcbiAgc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPjtcbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbmV4cG9ydCBjbGFzcyBTdWJzY3JpYmVPbk9ic2VydmFibGU8VD4gZXh0ZW5kcyBPYnNlcnZhYmxlPFQ+IHtcbiAgc3RhdGljIGNyZWF0ZTxUPihzb3VyY2U6IE9ic2VydmFibGU8VD4sIGRlbGF5OiBudW1iZXIgPSAwLCBzY2hlZHVsZXI6IElTY2hlZHVsZXIgPSBhc2FwKTogT2JzZXJ2YWJsZTxUPiB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVPbk9ic2VydmFibGUoc291cmNlLCBkZWxheSwgc2NoZWR1bGVyKTtcbiAgfVxuXG4gIHN0YXRpYyBkaXNwYXRjaDxUPih0aGlzOiBBY3Rpb248VD4sIGFyZzogRGlzcGF0Y2hBcmc8VD4pOiBTdWJzY3JpcHRpb24ge1xuICAgIGNvbnN0IHsgc291cmNlLCBzdWJzY3JpYmVyIH0gPSBhcmc7XG4gICAgcmV0dXJuIHRoaXMuYWRkKHNvdXJjZS5zdWJzY3JpYmUoc3Vic2NyaWJlcikpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHVibGljIHNvdXJjZTogT2JzZXJ2YWJsZTxUPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBkZWxheVRpbWU6IG51bWJlciA9IDAsXG4gICAgICAgICAgICAgIHByaXZhdGUgc2NoZWR1bGVyOiBJU2NoZWR1bGVyID0gYXNhcCkge1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKCFpc051bWVyaWMoZGVsYXlUaW1lKSB8fCBkZWxheVRpbWUgPCAwKSB7XG4gICAgICB0aGlzLmRlbGF5VGltZSA9IDA7XG4gICAgfVxuICAgIGlmICghc2NoZWR1bGVyIHx8IHR5cGVvZiBzY2hlZHVsZXIuc2NoZWR1bGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVyID0gYXNhcDtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX3N1YnNjcmliZShzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+KSB7XG4gICAgY29uc3QgZGVsYXkgPSB0aGlzLmRlbGF5VGltZTtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICBjb25zdCBzY2hlZHVsZXIgPSB0aGlzLnNjaGVkdWxlcjtcblxuICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoU3Vic2NyaWJlT25PYnNlcnZhYmxlLmRpc3BhdGNoLCBkZWxheSwge1xuICAgICAgc291cmNlLCBzdWJzY3JpYmVyXG4gICAgfSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9TdWJzY3JpYmVPbk9ic2VydmFibGUudHMiLCJpbXBvcnQgeyBpc051bWVyaWMgfSBmcm9tICcuLi91dGlsL2lzTnVtZXJpYyc7XG5pbXBvcnQgeyBJU2NoZWR1bGVyIH0gZnJvbSAnLi4vU2NoZWR1bGVyJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGFzeW5jIH0gZnJvbSAnLi4vc2NoZWR1bGVyL2FzeW5jJztcbmltcG9ydCB7IGlzU2NoZWR1bGVyIH0gZnJvbSAnLi4vdXRpbC9pc1NjaGVkdWxlcic7XG5pbXBvcnQgeyBpc0RhdGUgfSBmcm9tICcuLi91dGlsL2lzRGF0ZSc7XG5pbXBvcnQgeyBUZWFyZG93bkxvZ2ljIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKiBAaGlkZSB0cnVlXG4gKi9cbmV4cG9ydCBjbGFzcyBUaW1lck9ic2VydmFibGUgZXh0ZW5kcyBPYnNlcnZhYmxlPG51bWJlcj4ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIE9ic2VydmFibGUgdGhhdCBzdGFydHMgZW1pdHRpbmcgYWZ0ZXIgYW4gYGluaXRpYWxEZWxheWAgYW5kXG4gICAqIGVtaXRzIGV2ZXIgaW5jcmVhc2luZyBudW1iZXJzIGFmdGVyIGVhY2ggYHBlcmlvZGAgb2YgdGltZSB0aGVyZWFmdGVyLlxuICAgKlxuICAgKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXRzIGxpa2Uge0BsaW5rIGludGVydmFsfSwgYnV0IHlvdSBjYW4gc3BlY2lmeSB3aGVuXG4gICAqIHNob3VsZCB0aGUgZW1pc3Npb25zIHN0YXJ0Ljwvc3Bhbj5cbiAgICpcbiAgICogPGltZyBzcmM9XCIuL2ltZy90aW1lci5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAgICpcbiAgICogYHRpbWVyYCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbiBpbmZpbml0ZSBzZXF1ZW5jZSBvZiBhc2NlbmRpbmdcbiAgICogaW50ZWdlcnMsIHdpdGggYSBjb25zdGFudCBpbnRlcnZhbCBvZiB0aW1lLCBgcGVyaW9kYCBvZiB5b3VyIGNob29zaW5nXG4gICAqIGJldHdlZW4gdGhvc2UgZW1pc3Npb25zLiBUaGUgZmlyc3QgZW1pc3Npb24gaGFwcGVucyBhZnRlciB0aGUgc3BlY2lmaWVkXG4gICAqIGBpbml0aWFsRGVsYXlgLiBUaGUgaW5pdGlhbCBkZWxheSBtYXkgYmUgYSB7QGxpbmsgRGF0ZX0uIEJ5IGRlZmF1bHQsIHRoaXNcbiAgICogb3BlcmF0b3IgdXNlcyB0aGUgYGFzeW5jYCBJU2NoZWR1bGVyIHRvIHByb3ZpZGUgYSBub3Rpb24gb2YgdGltZSwgYnV0IHlvdVxuICAgKiBtYXkgcGFzcyBhbnkgSVNjaGVkdWxlciB0byBpdC4gSWYgYHBlcmlvZGAgaXMgbm90IHNwZWNpZmllZCwgdGhlIG91dHB1dFxuICAgKiBPYnNlcnZhYmxlIGVtaXRzIG9ubHkgb25lIHZhbHVlLCBgMGAuIE90aGVyd2lzZSwgaXQgZW1pdHMgYW4gaW5maW5pdGVcbiAgICogc2VxdWVuY2UuXG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIGFzY2VuZGluZyBudW1iZXJzLCBvbmUgZXZlcnkgc2Vjb25kICgxMDAwbXMpLCBzdGFydGluZyBhZnRlciAzIHNlY29uZHM8L2NhcHRpb24+XG4gICAqIHZhciBudW1iZXJzID0gUnguT2JzZXJ2YWJsZS50aW1lcigzMDAwLCAxMDAwKTtcbiAgICogbnVtYmVycy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gICAqXG4gICAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXRzIG9uZSBudW1iZXIgYWZ0ZXIgZml2ZSBzZWNvbmRzPC9jYXB0aW9uPlxuICAgKiB2YXIgbnVtYmVycyA9IFJ4Lk9ic2VydmFibGUudGltZXIoNTAwMCk7XG4gICAqIG51bWJlcnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICAgKlxuICAgKiBAc2VlIHtAbGluayBpbnRlcnZhbH1cbiAgICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfERhdGV9IGluaXRpYWxEZWxheSBUaGUgaW5pdGlhbCBkZWxheSB0aW1lIHRvIHdhaXQgYmVmb3JlXG4gICAqIGVtaXR0aW5nIHRoZSBmaXJzdCB2YWx1ZSBvZiBgMGAuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcGVyaW9kXSBUaGUgcGVyaW9kIG9mIHRpbWUgYmV0d2VlbiBlbWlzc2lvbnMgb2YgdGhlXG4gICAqIHN1YnNlcXVlbnQgbnVtYmVycy5cbiAgICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSBJU2NoZWR1bGVyIHRvIHVzZSBmb3Igc2NoZWR1bGluZ1xuICAgKiB0aGUgZW1pc3Npb24gb2YgdmFsdWVzLCBhbmQgcHJvdmlkaW5nIGEgbm90aW9uIG9mIFwidGltZVwiLlxuICAgKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYSBgMGAgYWZ0ZXIgdGhlXG4gICAqIGBpbml0aWFsRGVsYXlgIGFuZCBldmVyIGluY3JlYXNpbmcgbnVtYmVycyBhZnRlciBlYWNoIGBwZXJpb2RgIG9mIHRpbWVcbiAgICogdGhlcmVhZnRlci5cbiAgICogQHN0YXRpYyB0cnVlXG4gICAqIEBuYW1lIHRpbWVyXG4gICAqIEBvd25lciBPYnNlcnZhYmxlXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKGluaXRpYWxEZWxheTogbnVtYmVyIHwgRGF0ZSA9IDAsXG4gICAgICAgICAgICAgICAgcGVyaW9kPzogbnVtYmVyIHwgSVNjaGVkdWxlcixcbiAgICAgICAgICAgICAgICBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcbiAgICByZXR1cm4gbmV3IFRpbWVyT2JzZXJ2YWJsZShpbml0aWFsRGVsYXksIHBlcmlvZCwgc2NoZWR1bGVyKTtcbiAgfVxuXG4gIHN0YXRpYyBkaXNwYXRjaChzdGF0ZTogYW55KSB7XG5cbiAgICBjb25zdCB7IGluZGV4LCBwZXJpb2QsIHN1YnNjcmliZXIgfSA9IHN0YXRlO1xuICAgIGNvbnN0IGFjdGlvbiA9ICg8YW55PiB0aGlzKTtcblxuICAgIHN1YnNjcmliZXIubmV4dChpbmRleCk7XG5cbiAgICBpZiAoc3Vic2NyaWJlci5jbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHBlcmlvZCA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgc3RhdGUuaW5kZXggPSBpbmRleCArIDE7XG4gICAgYWN0aW9uLnNjaGVkdWxlKHN0YXRlLCBwZXJpb2QpO1xuICB9XG5cbiAgcHJpdmF0ZSBwZXJpb2Q6IG51bWJlciA9IC0xO1xuICBwcml2YXRlIGR1ZVRpbWU6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgc2NoZWR1bGVyOiBJU2NoZWR1bGVyO1xuXG4gIGNvbnN0cnVjdG9yKGR1ZVRpbWU6IG51bWJlciB8IERhdGUgPSAwLFxuICAgICAgICAgICAgICBwZXJpb2Q/OiBudW1iZXIgfCBJU2NoZWR1bGVyLFxuICAgICAgICAgICAgICBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmIChpc051bWVyaWMocGVyaW9kKSkge1xuICAgICAgdGhpcy5wZXJpb2QgPSBOdW1iZXIocGVyaW9kKSA8IDEgJiYgMSB8fCBOdW1iZXIocGVyaW9kKTtcbiAgICB9IGVsc2UgaWYgKGlzU2NoZWR1bGVyKHBlcmlvZCkpIHtcbiAgICAgIHNjaGVkdWxlciA9IDxJU2NoZWR1bGVyPiBwZXJpb2Q7XG4gICAgfVxuXG4gICAgaWYgKCFpc1NjaGVkdWxlcihzY2hlZHVsZXIpKSB7XG4gICAgICBzY2hlZHVsZXIgPSBhc3luYztcbiAgICB9XG5cbiAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgICB0aGlzLmR1ZVRpbWUgPSBpc0RhdGUoZHVlVGltZSkgP1xuICAgICAgKCtkdWVUaW1lIC0gdGhpcy5zY2hlZHVsZXIubm93KCkpIDpcbiAgICAgICg8bnVtYmVyPiBkdWVUaW1lKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8bnVtYmVyPik6IFRlYXJkb3duTG9naWMge1xuICAgIGNvbnN0IGluZGV4ID0gMDtcbiAgICBjb25zdCB7IHBlcmlvZCwgZHVlVGltZSwgc2NoZWR1bGVyIH0gPSB0aGlzO1xuXG4gICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShUaW1lck9ic2VydmFibGUuZGlzcGF0Y2gsIGR1ZVRpbWUsIHtcbiAgICAgIGluZGV4LCBwZXJpb2QsIHN1YnNjcmliZXJcbiAgICB9KTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL1RpbWVyT2JzZXJ2YWJsZS50cyIsImltcG9ydCB7IE9ic2VydmFibGUsIFN1YnNjcmliYWJsZU9yUHJvbWlzZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgQW5vbnltb3VzU3Vic2NyaXB0aW9uLCBUZWFyZG93bkxvZ2ljIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcblxuaW1wb3J0IHsgc3Vic2NyaWJlVG9SZXN1bHQgfSBmcm9tICcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0JztcbmltcG9ydCB7IE91dGVyU3Vic2NyaWJlciB9IGZyb20gJy4uL091dGVyU3Vic2NyaWJlcic7XG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqIEBoaWRlIHRydWVcbiAqL1xuZXhwb3J0IGNsYXNzIFVzaW5nT2JzZXJ2YWJsZTxUPiBleHRlbmRzIE9ic2VydmFibGU8VD4ge1xuXG4gIHN0YXRpYyBjcmVhdGU8VD4ocmVzb3VyY2VGYWN0b3J5OiAoKSA9PiBBbm9ueW1vdXNTdWJzY3JpcHRpb24gfCB2b2lkLFxuICAgICAgICAgICAgICAgICAgIG9ic2VydmFibGVGYWN0b3J5OiAocmVzb3VyY2U6IEFub255bW91c1N1YnNjcmlwdGlvbikgPT4gU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQ+IHwgdm9pZCk6IE9ic2VydmFibGU8VD4ge1xuICAgIHJldHVybiBuZXcgVXNpbmdPYnNlcnZhYmxlPFQ+KHJlc291cmNlRmFjdG9yeSwgb2JzZXJ2YWJsZUZhY3RvcnkpO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZXNvdXJjZUZhY3Rvcnk6ICgpID0+IEFub255bW91c1N1YnNjcmlwdGlvbiB8IHZvaWQsXG4gICAgICAgICAgICAgIHByaXZhdGUgb2JzZXJ2YWJsZUZhY3Rvcnk6IChyZXNvdXJjZTogQW5vbnltb3VzU3Vic2NyaXB0aW9uKSA9PiBTdWJzY3JpYmFibGVPclByb21pc2U8VD4gfCB2b2lkKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4pOiBUZWFyZG93bkxvZ2ljIHtcbiAgICBjb25zdCB7IHJlc291cmNlRmFjdG9yeSwgb2JzZXJ2YWJsZUZhY3RvcnkgfSA9IHRoaXM7XG5cbiAgICBsZXQgcmVzb3VyY2U6IEFub255bW91c1N1YnNjcmlwdGlvbjtcblxuICAgIHRyeSB7XG4gICAgICByZXNvdXJjZSA9IDxBbm9ueW1vdXNTdWJzY3JpcHRpb24+cmVzb3VyY2VGYWN0b3J5KCk7XG4gICAgICByZXR1cm4gbmV3IFVzaW5nU3Vic2NyaWJlcihzdWJzY3JpYmVyLCByZXNvdXJjZSwgb2JzZXJ2YWJsZUZhY3RvcnkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBVc2luZ1N1YnNjcmliZXI8VD4gZXh0ZW5kcyBPdXRlclN1YnNjcmliZXI8VCwgVD4ge1xuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxUPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSByZXNvdXJjZTogQW5vbnltb3VzU3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICBwcml2YXRlIG9ic2VydmFibGVGYWN0b3J5OiAocmVzb3VyY2U6IEFub255bW91c1N1YnNjcmlwdGlvbikgPT4gU3Vic2NyaWJhYmxlT3JQcm9taXNlPFQ+IHwgdm9pZCkge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgICBkZXN0aW5hdGlvbi5hZGQocmVzb3VyY2UpO1xuICAgIHRoaXMudHJ5VXNlKCk7XG4gIH1cblxuICBwcml2YXRlIHRyeVVzZSgpOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5vYnNlcnZhYmxlRmFjdG9yeS5jYWxsKHRoaXMsIHRoaXMucmVzb3VyY2UpO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBzb3VyY2UpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgfVxuICB9XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL1VzaW5nT2JzZXJ2YWJsZS50cyIsImltcG9ydCB7ICBCb3VuZENhbGxiYWNrT2JzZXJ2YWJsZSAgfSBmcm9tICcuL0JvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlJztcblxuZXhwb3J0IGNvbnN0IGJpbmRDYWxsYmFjayA9IEJvdW5kQ2FsbGJhY2tPYnNlcnZhYmxlLmNyZWF0ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29ic2VydmFibGUvYmluZENhbGxiYWNrLnRzIiwiaW1wb3J0IHsgIEJvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZSAgfSBmcm9tICcuL0JvdW5kTm9kZUNhbGxiYWNrT2JzZXJ2YWJsZSc7XG5cbmV4cG9ydCBjb25zdCBiaW5kTm9kZUNhbGxiYWNrID0gQm91bmROb2RlQ2FsbGJhY2tPYnNlcnZhYmxlLmNyZWF0ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29ic2VydmFibGUvYmluZE5vZGVDYWxsYmFjay50cyIsImltcG9ydCB7ICBPYnNlcnZhYmxlLCBPYnNlcnZhYmxlSW5wdXQgIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyAgSVNjaGVkdWxlciAgfSBmcm9tICcuLi9TY2hlZHVsZXInO1xuaW1wb3J0IHsgIGlzU2NoZWR1bGVyICB9IGZyb20gJy4uL3V0aWwvaXNTY2hlZHVsZXInO1xuaW1wb3J0IHsgIGlzQXJyYXkgIH0gZnJvbSAnLi4vdXRpbC9pc0FycmF5JztcbmltcG9ydCB7ICBBcnJheU9ic2VydmFibGUgIH0gZnJvbSAnLi9BcnJheU9ic2VydmFibGUnO1xuaW1wb3J0IHsgIENvbWJpbmVMYXRlc3RPcGVyYXRvciAgfSBmcm9tICcuLi9vcGVyYXRvci9jb21iaW5lTGF0ZXN0JztcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZUxhdGVzdDxULCBUMj4odjE6IE9ic2VydmFibGVJbnB1dDxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFtULCBUMl0+O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVMYXRlc3Q8VCwgVDIsIFQzPih2MTogT2JzZXJ2YWJsZUlucHV0PFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFtULCBUMiwgVDNdPjtcbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lTGF0ZXN0PFQsIFQyLCBUMywgVDQ+KHYxOiBPYnNlcnZhYmxlSW5wdXQ8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4sIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFtULCBUMiwgVDMsIFQ0XT47XG5leHBvcnQgZnVuY3Rpb24gY29tYmluZUxhdGVzdDxULCBUMiwgVDMsIFQ0LCBUNT4odjE6IE9ic2VydmFibGVJbnB1dDxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCB2NDogT2JzZXJ2YWJsZUlucHV0PFQ0PiwgdjU6IE9ic2VydmFibGVJbnB1dDxUNT4sIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFtULCBUMiwgVDMsIFQ0LCBUNV0+O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVMYXRlc3Q8VCwgVDIsIFQzLCBUNCwgVDUsIFQ2Pih2MTogT2JzZXJ2YWJsZUlucHV0PFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCB2NTogT2JzZXJ2YWJsZUlucHV0PFQ1PiwgdjY6IE9ic2VydmFibGVJbnB1dDxUNj4sIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFtULCBUMiwgVDMsIFQ0LCBUNSwgVDZdPjtcblxuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVMYXRlc3Q8VCwgUj4odjE6IE9ic2VydmFibGVJbnB1dDxUPiwgcHJvamVjdDogKHYxOiBUKSA9PiBSLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lTGF0ZXN0PFQsIFQyLCBSPih2MTogT2JzZXJ2YWJsZUlucHV0PFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgcHJvamVjdDogKHYxOiBULCB2MjogVDIpID0+IFIsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVMYXRlc3Q8VCwgVDIsIFQzLCBSPih2MTogT2JzZXJ2YWJsZUlucHV0PFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHByb2plY3Q6ICh2MTogVCwgdjI6IFQyLCB2MzogVDMpID0+IFIsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVMYXRlc3Q8VCwgVDIsIFQzLCBUNCwgUj4odjE6IE9ic2VydmFibGVJbnB1dDxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCB2NDogT2JzZXJ2YWJsZUlucHV0PFQ0PiwgcHJvamVjdDogKHYxOiBULCB2MjogVDIsIHYzOiBUMywgdjQ6IFQ0KSA9PiBSLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lTGF0ZXN0PFQsIFQyLCBUMywgVDQsIFQ1LCBSPih2MTogT2JzZXJ2YWJsZUlucHV0PFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCB2NTogT2JzZXJ2YWJsZUlucHV0PFQ1PiwgcHJvamVjdDogKHYxOiBULCB2MjogVDIsIHYzOiBUMywgdjQ6IFQ0LCB2NTogVDUpID0+IFIsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVMYXRlc3Q8VCwgVDIsIFQzLCBUNCwgVDUsIFQ2LCBSPih2MTogT2JzZXJ2YWJsZUlucHV0PFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCB2NTogT2JzZXJ2YWJsZUlucHV0PFQ1PiwgdjY6IE9ic2VydmFibGVJbnB1dDxUNj4sIHByb2plY3Q6ICh2MTogVCwgdjI6IFQyLCB2MzogVDMsIHY0OiBUNCwgdjU6IFQ1LCB2NjogVDYpID0+IFIsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFI+O1xuXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZUxhdGVzdDxUPihhcnJheTogT2JzZXJ2YWJsZUlucHV0PFQ+W10sIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFRbXT47XG5leHBvcnQgZnVuY3Rpb24gY29tYmluZUxhdGVzdDxSPihhcnJheTogT2JzZXJ2YWJsZUlucHV0PGFueT5bXSwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gY29tYmluZUxhdGVzdDxULCBSPihhcnJheTogT2JzZXJ2YWJsZUlucHV0PFQ+W10sIHByb2plY3Q6ICguLi52YWx1ZXM6IEFycmF5PFQ+KSA9PiBSLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lTGF0ZXN0PFI+KGFycmF5OiBPYnNlcnZhYmxlSW5wdXQ8YW55PltdLCBwcm9qZWN0OiAoLi4udmFsdWVzOiBBcnJheTxhbnk+KSA9PiBSLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lTGF0ZXN0PFQ+KC4uLm9ic2VydmFibGVzOiBBcnJheTxPYnNlcnZhYmxlSW5wdXQ8VD4gfCBJU2NoZWR1bGVyPik6IE9ic2VydmFibGU8VFtdPjtcbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lTGF0ZXN0PFQsIFI+KC4uLm9ic2VydmFibGVzOiBBcnJheTxPYnNlcnZhYmxlSW5wdXQ8VD4gfCAoKC4uLnZhbHVlczogQXJyYXk8VD4pID0+IFIpIHwgSVNjaGVkdWxlcj4pOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbWJpbmVMYXRlc3Q8Uj4oLi4ub2JzZXJ2YWJsZXM6IEFycmF5PE9ic2VydmFibGVJbnB1dDxhbnk+IHwgKCguLi52YWx1ZXM6IEFycmF5PGFueT4pID0+IFIpIHwgSVNjaGVkdWxlcj4pOiBPYnNlcnZhYmxlPFI+O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cblxuLyoqXG4gKiBDb21iaW5lcyBtdWx0aXBsZSBPYnNlcnZhYmxlcyB0byBjcmVhdGUgYW4gT2JzZXJ2YWJsZSB3aG9zZSB2YWx1ZXMgYXJlXG4gKiBjYWxjdWxhdGVkIGZyb20gdGhlIGxhdGVzdCB2YWx1ZXMgb2YgZWFjaCBvZiBpdHMgaW5wdXQgT2JzZXJ2YWJsZXMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPldoZW5ldmVyIGFueSBpbnB1dCBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUsIGl0XG4gKiBjb21wdXRlcyBhIGZvcm11bGEgdXNpbmcgdGhlIGxhdGVzdCB2YWx1ZXMgZnJvbSBhbGwgdGhlIGlucHV0cywgdGhlbiBlbWl0c1xuICogdGhlIG91dHB1dCBvZiB0aGF0IGZvcm11bGEuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29tYmluZUxhdGVzdC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgY29tYmluZUxhdGVzdGAgY29tYmluZXMgdGhlIHZhbHVlcyBmcm9tIGFsbCB0aGUgT2JzZXJ2YWJsZXMgcGFzc2VkIGFzXG4gKiBhcmd1bWVudHMuIFRoaXMgaXMgZG9uZSBieSBzdWJzY3JpYmluZyB0byBlYWNoIE9ic2VydmFibGUgaW4gb3JkZXIgYW5kLFxuICogd2hlbmV2ZXIgYW55IE9ic2VydmFibGUgZW1pdHMsIGNvbGxlY3RpbmcgYW4gYXJyYXkgb2YgdGhlIG1vc3QgcmVjZW50XG4gKiB2YWx1ZXMgZnJvbSBlYWNoIE9ic2VydmFibGUuIFNvIGlmIHlvdSBwYXNzIGBuYCBPYnNlcnZhYmxlcyB0byBvcGVyYXRvcixcbiAqIHJldHVybmVkIE9ic2VydmFibGUgd2lsbCBhbHdheXMgZW1pdCBhbiBhcnJheSBvZiBgbmAgdmFsdWVzLCBpbiBvcmRlclxuICogY29ycmVzcG9uZGluZyB0byBvcmRlciBvZiBwYXNzZWQgT2JzZXJ2YWJsZXMgKHZhbHVlIGZyb20gdGhlIGZpcnN0IE9ic2VydmFibGVcbiAqIG9uIHRoZSBmaXJzdCBwbGFjZSBhbmQgc28gb24pLlxuICpcbiAqIFN0YXRpYyB2ZXJzaW9uIG9mIGBjb21iaW5lTGF0ZXN0YCBhY2NlcHRzIGVpdGhlciBhbiBhcnJheSBvZiBPYnNlcnZhYmxlc1xuICogb3IgZWFjaCBPYnNlcnZhYmxlIGNhbiBiZSBwdXQgZGlyZWN0bHkgYXMgYW4gYXJndW1lbnQuIE5vdGUgdGhhdCBhcnJheSBvZlxuICogT2JzZXJ2YWJsZXMgaXMgZ29vZCBjaG9pY2UsIGlmIHlvdSBkb24ndCBrbm93IGJlZm9yZWhhbmQgaG93IG1hbnkgT2JzZXJ2YWJsZXNcbiAqIHlvdSB3aWxsIGNvbWJpbmUuIFBhc3NpbmcgZW1wdHkgYXJyYXkgd2lsbCByZXN1bHQgaW4gT2JzZXJ2YWJsZSB0aGF0XG4gKiBjb21wbGV0ZXMgaW1tZWRpYXRlbHkuXG4gKlxuICogVG8gZW5zdXJlIG91dHB1dCBhcnJheSBoYXMgYWx3YXlzIHRoZSBzYW1lIGxlbmd0aCwgYGNvbWJpbmVMYXRlc3RgIHdpbGxcbiAqIGFjdHVhbGx5IHdhaXQgZm9yIGFsbCBpbnB1dCBPYnNlcnZhYmxlcyB0byBlbWl0IGF0IGxlYXN0IG9uY2UsXG4gKiBiZWZvcmUgaXQgc3RhcnRzIGVtaXR0aW5nIHJlc3VsdHMuIFRoaXMgbWVhbnMgaWYgc29tZSBPYnNlcnZhYmxlIGVtaXRzXG4gKiB2YWx1ZXMgYmVmb3JlIG90aGVyIE9ic2VydmFibGVzIHN0YXJ0ZWQgZW1pdHRpbmcsIGFsbCB0aGF0IHZhbHVlcyBidXQgbGFzdFxuICogd2lsbCBiZSBsb3N0LiBPbiB0aGUgb3RoZXIgaGFuZCwgaXMgc29tZSBPYnNlcnZhYmxlIGRvZXMgbm90IGVtaXQgdmFsdWUgYnV0XG4gKiBjb21wbGV0ZXMsIHJlc3VsdGluZyBPYnNlcnZhYmxlIHdpbGwgY29tcGxldGUgYXQgdGhlIHNhbWUgbW9tZW50IHdpdGhvdXRcbiAqIGVtaXR0aW5nIGFueXRoaW5nLCBzaW5jZSBpdCB3aWxsIGJlIG5vdyBpbXBvc3NpYmxlIHRvIGluY2x1ZGUgdmFsdWUgZnJvbVxuICogY29tcGxldGVkIE9ic2VydmFibGUgaW4gcmVzdWx0aW5nIGFycmF5LiBBbHNvLCBpZiBzb21lIGlucHV0IE9ic2VydmFibGUgZG9lc1xuICogbm90IGVtaXQgYW55IHZhbHVlIGFuZCBuZXZlciBjb21wbGV0ZXMsIGBjb21iaW5lTGF0ZXN0YCB3aWxsIGFsc28gbmV2ZXIgZW1pdFxuICogYW5kIG5ldmVyIGNvbXBsZXRlLCBzaW5jZSwgYWdhaW4sIGl0IHdpbGwgd2FpdCBmb3IgYWxsIHN0cmVhbXMgdG8gZW1pdCBzb21lXG4gKiB2YWx1ZS5cbiAqXG4gKiBJZiBhdCBsZWFzdCBvbmUgT2JzZXJ2YWJsZSB3YXMgcGFzc2VkIHRvIGBjb21iaW5lTGF0ZXN0YCBhbmQgYWxsIHBhc3NlZCBPYnNlcnZhYmxlc1xuICogZW1pdHRlZCBzb21ldGhpbmcsIHJlc3VsdGluZyBPYnNlcnZhYmxlIHdpbGwgY29tcGxldGUgd2hlbiBhbGwgY29tYmluZWRcbiAqIHN0cmVhbXMgY29tcGxldGUuIFNvIGV2ZW4gaWYgc29tZSBPYnNlcnZhYmxlIGNvbXBsZXRlcywgcmVzdWx0IG9mXG4gKiBgY29tYmluZUxhdGVzdGAgd2lsbCBzdGlsbCBlbWl0IHZhbHVlcyB3aGVuIG90aGVyIE9ic2VydmFibGVzIGRvLiBJbiBjYXNlXG4gKiBvZiBjb21wbGV0ZWQgT2JzZXJ2YWJsZSwgaXRzIHZhbHVlIGZyb20gbm93IG9uIHdpbGwgYWx3YXlzIGJlIHRoZSBsYXN0XG4gKiBlbWl0dGVkIHZhbHVlLiBPbiB0aGUgb3RoZXIgaGFuZCwgaWYgYW55IE9ic2VydmFibGUgZXJyb3JzLCBgY29tYmluZUxhdGVzdGBcbiAqIHdpbGwgZXJyb3IgaW1tZWRpYXRlbHkgYXMgd2VsbCwgYW5kIGFsbCBvdGhlciBPYnNlcnZhYmxlcyB3aWxsIGJlIHVuc3Vic2NyaWJlZC5cbiAqXG4gKiBgY29tYmluZUxhdGVzdGAgYWNjZXB0cyBhcyBvcHRpb25hbCBwYXJhbWV0ZXIgYHByb2plY3RgIGZ1bmN0aW9uLCB3aGljaCB0YWtlc1xuICogYXMgYXJndW1lbnRzIGFsbCB2YWx1ZXMgdGhhdCB3b3VsZCBub3JtYWxseSBiZSBlbWl0dGVkIGJ5IHJlc3VsdGluZyBPYnNlcnZhYmxlLlxuICogYHByb2plY3RgIGNhbiByZXR1cm4gYW55IGtpbmQgb2YgdmFsdWUsIHdoaWNoIHdpbGwgYmUgdGhlbiBlbWl0dGVkIGJ5IE9ic2VydmFibGVcbiAqIGluc3RlYWQgb2YgZGVmYXVsdCBhcnJheS4gTm90ZSB0aGF0IGBwcm9qZWN0YCBkb2VzIG5vdCB0YWtlIGFzIGFyZ3VtZW50IHRoYXQgYXJyYXlcbiAqIG9mIHZhbHVlcywgYnV0IHZhbHVlcyB0aGVtc2VsdmVzLiBUaGF0IG1lYW5zIGRlZmF1bHQgYHByb2plY3RgIGNhbiBiZSBpbWFnaW5lZFxuICogYXMgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbGwgaXRzIGFyZ3VtZW50cyBhbmQgcHV0cyB0aGVtIGludG8gYW4gYXJyYXkuXG4gKlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbWJpbmUgdHdvIHRpbWVyIE9ic2VydmFibGVzPC9jYXB0aW9uPlxuICogY29uc3QgZmlyc3RUaW1lciA9IFJ4Lk9ic2VydmFibGUudGltZXIoMCwgMTAwMCk7IC8vIGVtaXQgMCwgMSwgMi4uLiBhZnRlciBldmVyeSBzZWNvbmQsIHN0YXJ0aW5nIGZyb20gbm93XG4gKiBjb25zdCBzZWNvbmRUaW1lciA9IFJ4Lk9ic2VydmFibGUudGltZXIoNTAwLCAxMDAwKTsgLy8gZW1pdCAwLCAxLCAyLi4uIGFmdGVyIGV2ZXJ5IHNlY29uZCwgc3RhcnRpbmcgMCw1cyBmcm9tIG5vd1xuICogY29uc3QgY29tYmluZWRUaW1lcnMgPSBSeC5PYnNlcnZhYmxlLmNvbWJpbmVMYXRlc3QoZmlyc3RUaW1lciwgc2Vjb25kVGltZXIpO1xuICogY29tYmluZWRUaW1lcnMuc3Vic2NyaWJlKHZhbHVlID0+IGNvbnNvbGUubG9nKHZhbHVlKSk7XG4gKiAvLyBMb2dzXG4gKiAvLyBbMCwgMF0gYWZ0ZXIgMC41c1xuICogLy8gWzEsIDBdIGFmdGVyIDFzXG4gKiAvLyBbMSwgMV0gYWZ0ZXIgMS41c1xuICogLy8gWzIsIDFdIGFmdGVyIDJzXG4gKlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbWJpbmUgYW4gYXJyYXkgb2YgT2JzZXJ2YWJsZXM8L2NhcHRpb24+XG4gKiBjb25zdCBvYnNlcnZhYmxlcyA9IFsxLCA1LCAxMF0ubWFwKFxuICogICBuID0+IFJ4Lk9ic2VydmFibGUub2YobikuZGVsYXkobiAqIDEwMDApLnN0YXJ0V2l0aCgwKSAvLyBlbWl0IDAgYW5kIHRoZW4gZW1pdCBuIGFmdGVyIG4gc2Vjb25kc1xuICogKTtcbiAqIGNvbnN0IGNvbWJpbmVkID0gUnguT2JzZXJ2YWJsZS5jb21iaW5lTGF0ZXN0KG9ic2VydmFibGVzKTtcbiAqIGNvbWJpbmVkLnN1YnNjcmliZSh2YWx1ZSA9PiBjb25zb2xlLmxvZyh2YWx1ZSkpO1xuICogLy8gTG9nc1xuICogLy8gWzAsIDAsIDBdIGltbWVkaWF0ZWx5XG4gKiAvLyBbMSwgMCwgMF0gYWZ0ZXIgMXNcbiAqIC8vIFsxLCA1LCAwXSBhZnRlciA1c1xuICogLy8gWzEsIDUsIDEwXSBhZnRlciAxMHNcbiAqXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+VXNlIHByb2plY3QgZnVuY3Rpb24gdG8gZHluYW1pY2FsbHkgY2FsY3VsYXRlIHRoZSBCb2R5LU1hc3MgSW5kZXg8L2NhcHRpb24+XG4gKiB2YXIgd2VpZ2h0ID0gUnguT2JzZXJ2YWJsZS5vZig3MCwgNzIsIDc2LCA3OSwgNzUpO1xuICogdmFyIGhlaWdodCA9IFJ4Lk9ic2VydmFibGUub2YoMS43NiwgMS43NywgMS43OCk7XG4gKiB2YXIgYm1pID0gUnguT2JzZXJ2YWJsZS5jb21iaW5lTGF0ZXN0KHdlaWdodCwgaGVpZ2h0LCAodywgaCkgPT4gdyAvIChoICogaCkpO1xuICogYm1pLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKCdCTUkgaXMgJyArIHgpKTtcbiAqXG4gKiAvLyBXaXRoIG91dHB1dCB0byBjb25zb2xlOlxuICogLy8gQk1JIGlzIDI0LjIxMjI5MzM4ODQyOTc1M1xuICogLy8gQk1JIGlzIDIzLjkzOTQ4MDk5MjA1MjA5XG4gKiAvLyBCTUkgaXMgMjMuNjcxMjUzNjI5NTkyMjIyXG4gKlxuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVBbGx9XG4gKiBAc2VlIHtAbGluayBtZXJnZX1cbiAqIEBzZWUge0BsaW5rIHdpdGhMYXRlc3RGcm9tfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBvYnNlcnZhYmxlMSBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbWJpbmUgd2l0aCBvdGhlciBPYnNlcnZhYmxlcy5cbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBvYnNlcnZhYmxlMiBBbiBpbnB1dCBPYnNlcnZhYmxlIHRvIGNvbWJpbmUgd2l0aCBvdGhlciBPYnNlcnZhYmxlcy5cbiAqIE1vcmUgdGhhbiBvbmUgaW5wdXQgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIGFyZ3VtZW50c1xuICogb3IgYW4gYXJyYXkgb2YgT2JzZXJ2YWJsZXMgbWF5IGJlIGdpdmVuIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcm9qZWN0XSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byBwcm9qZWN0IHRoZSB2YWx1ZXMgZnJvbVxuICogdGhlIGNvbWJpbmVkIGxhdGVzdCB2YWx1ZXMgaW50byBhIG5ldyB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1udWxsXSBUaGUgSVNjaGVkdWxlciB0byB1c2UgZm9yIHN1YnNjcmliaW5nIHRvXG4gKiBlYWNoIGlucHV0IE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIG9mIHByb2plY3RlZCB2YWx1ZXMgZnJvbSB0aGUgbW9zdCByZWNlbnRcbiAqIHZhbHVlcyBmcm9tIGVhY2ggaW5wdXQgT2JzZXJ2YWJsZSwgb3IgYW4gYXJyYXkgb2YgdGhlIG1vc3QgcmVjZW50IHZhbHVlcyBmcm9tXG4gKiBlYWNoIGlucHV0IE9ic2VydmFibGUuXG4gKiBAc3RhdGljIHRydWVcbiAqIEBuYW1lIGNvbWJpbmVMYXRlc3RcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lTGF0ZXN0PFQsIFI+KC4uLm9ic2VydmFibGVzOiBBcnJheTxhbnkgfCBPYnNlcnZhYmxlSW5wdXQ8YW55PiB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXk8T2JzZXJ2YWJsZUlucHV0PGFueT4+IHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKCguLi52YWx1ZXM6IEFycmF5PGFueT4pID0+IFIpKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSVNjaGVkdWxlcj4pOiBPYnNlcnZhYmxlPFI+IHtcbiAgbGV0IHByb2plY3Q6ICguLi52YWx1ZXM6IEFycmF5PGFueT4pID0+IFIgPSAgbnVsbDtcbiAgbGV0IHNjaGVkdWxlcjogSVNjaGVkdWxlciA9IG51bGw7XG5cbiAgaWYgKGlzU2NoZWR1bGVyKG9ic2VydmFibGVzW29ic2VydmFibGVzLmxlbmd0aCAtIDFdKSkge1xuICAgIHNjaGVkdWxlciA9IDxJU2NoZWR1bGVyPm9ic2VydmFibGVzLnBvcCgpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYnNlcnZhYmxlc1tvYnNlcnZhYmxlcy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2plY3QgPSA8KC4uLnZhbHVlczogQXJyYXk8YW55PikgPT4gUj5vYnNlcnZhYmxlcy5wb3AoKTtcbiAgfVxuXG4gIC8vIGlmIHRoZSBmaXJzdCBhbmQgb25seSBvdGhlciBhcmd1bWVudCBiZXNpZGVzIHRoZSByZXN1bHRTZWxlY3RvciBpcyBhbiBhcnJheVxuICAvLyBhc3N1bWUgaXQncyBiZWVuIGNhbGxlZCB3aXRoIGBjb21iaW5lTGF0ZXN0KFtvYnMxLCBvYnMyLCBvYnMzXSwgcHJvamVjdClgXG4gIGlmIChvYnNlcnZhYmxlcy5sZW5ndGggPT09IDEgJiYgaXNBcnJheShvYnNlcnZhYmxlc1swXSkpIHtcbiAgICBvYnNlcnZhYmxlcyA9IDxBcnJheTxPYnNlcnZhYmxlPGFueT4+Pm9ic2VydmFibGVzWzBdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBBcnJheU9ic2VydmFibGUob2JzZXJ2YWJsZXMsIHNjaGVkdWxlcikubGlmdChuZXcgQ29tYmluZUxhdGVzdE9wZXJhdG9yPFQsIFI+KHByb2plY3QpKTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29ic2VydmFibGUvY29tYmluZUxhdGVzdC50cyIsImltcG9ydCB7ICBjb25jYXRTdGF0aWMgIH0gZnJvbSAnLi4vb3BlcmF0b3IvY29uY2F0JztcblxuZXhwb3J0IGNvbnN0IGNvbmNhdCA9IGNvbmNhdFN0YXRpYztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29ic2VydmFibGUvY29uY2F0LnRzIiwiaW1wb3J0IHsgIERlZmVyT2JzZXJ2YWJsZSAgfSBmcm9tICcuL0RlZmVyT2JzZXJ2YWJsZSc7XG5cbmV4cG9ydCBjb25zdCBkZWZlciA9IERlZmVyT2JzZXJ2YWJsZS5jcmVhdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL2RlZmVyLnRzIiwiaW1wb3J0IHsgU3ViamVjdCwgQW5vbnltb3VzU3ViamVjdCB9IGZyb20gJy4uLy4uL1N1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uLy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uLy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgcm9vdCB9IGZyb20gJy4uLy4uL3V0aWwvcm9vdCc7XG5pbXBvcnQgeyBSZXBsYXlTdWJqZWN0IH0gZnJvbSAnLi4vLi4vUmVwbGF5U3ViamVjdCc7XG5pbXBvcnQgeyBPYnNlcnZlciwgTmV4dE9ic2VydmVyIH0gZnJvbSAnLi4vLi4vT2JzZXJ2ZXInO1xuaW1wb3J0IHsgdHJ5Q2F0Y2ggfSBmcm9tICcuLi8uLi91dGlsL3RyeUNhdGNoJztcbmltcG9ydCB7IGVycm9yT2JqZWN0IH0gZnJvbSAnLi4vLi4vdXRpbC9lcnJvck9iamVjdCc7XG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuLi8uLi91dGlsL2Fzc2lnbic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgV2ViU29ja2V0U3ViamVjdENvbmZpZyB7XG4gIHVybDogc3RyaW5nO1xuICBwcm90b2NvbD86IHN0cmluZyB8IEFycmF5PHN0cmluZz47XG4gIHJlc3VsdFNlbGVjdG9yPzogPFQ+KGU6IE1lc3NhZ2VFdmVudCkgPT4gVDtcbiAgb3Blbk9ic2VydmVyPzogTmV4dE9ic2VydmVyPEV2ZW50PjtcbiAgY2xvc2VPYnNlcnZlcj86IE5leHRPYnNlcnZlcjxDbG9zZUV2ZW50PjtcbiAgY2xvc2luZ09ic2VydmVyPzogTmV4dE9ic2VydmVyPHZvaWQ+O1xuICBXZWJTb2NrZXRDdG9yPzogeyBuZXcodXJsOiBzdHJpbmcsIHByb3RvY29sPzogc3RyaW5nfEFycmF5PHN0cmluZz4pOiBXZWJTb2NrZXQgfTtcbiAgYmluYXJ5VHlwZT86ICdibG9iJyB8ICdhcnJheWJ1ZmZlcic7XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICogQGhpZGUgdHJ1ZVxuICovXG5leHBvcnQgY2xhc3MgV2ViU29ja2V0U3ViamVjdDxUPiBleHRlbmRzIEFub255bW91c1N1YmplY3Q8VD4ge1xuXG4gIHVybDogc3RyaW5nO1xuICBwcm90b2NvbDogc3RyaW5nfEFycmF5PHN0cmluZz47XG4gIHNvY2tldDogV2ViU29ja2V0O1xuICBvcGVuT2JzZXJ2ZXI6IE5leHRPYnNlcnZlcjxFdmVudD47XG4gIGNsb3NlT2JzZXJ2ZXI6IE5leHRPYnNlcnZlcjxDbG9zZUV2ZW50PjtcbiAgY2xvc2luZ09ic2VydmVyOiBOZXh0T2JzZXJ2ZXI8dm9pZD47XG4gIFdlYlNvY2tldEN0b3I6IHsgbmV3KHVybDogc3RyaW5nLCBwcm90b2NvbD86IHN0cmluZ3xBcnJheTxzdHJpbmc+KTogV2ViU29ja2V0IH07XG4gIGJpbmFyeVR5cGU/OiAnYmxvYicgfCAnYXJyYXlidWZmZXInO1xuXG4gIHByaXZhdGUgX291dHB1dDogU3ViamVjdDxUPjtcblxuICByZXN1bHRTZWxlY3RvcihlOiBNZXNzYWdlRXZlbnQpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShlLmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBwZXIgYXJvdW5kIHRoZSB3M2MtY29tcGF0aWJsZSBXZWJTb2NrZXQgb2JqZWN0IHByb3ZpZGVkIGJ5IHRoZSBicm93c2VyLlxuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5XcmFwcyBicm93c2VyIFdlYlNvY2tldDwvY2FwdGlvbj5cbiAgICpcbiAgICogbGV0IHNvY2tldCQgPSBPYnNlcnZhYmxlLndlYlNvY2tldCgnd3M6Ly9sb2NhbGhvc3Q6ODA4MScpO1xuICAgKlxuICAgKiBzb2NrZXQkLnN1YnNjcmliZShcbiAgICogICAgKG1zZykgPT4gY29uc29sZS5sb2coJ21lc3NhZ2UgcmVjZWl2ZWQ6ICcgKyBtc2cpLFxuICAgKiAgICAoZXJyKSA9PiBjb25zb2xlLmxvZyhlcnIpLFxuICAgKiAgICAoKSA9PiBjb25zb2xlLmxvZygnY29tcGxldGUnKVxuICAgKiAgKTtcbiAgICpcbiAgICogc29ja2V0JC5uZXh0KEpTT04uc3RyaW5naWZ5KHsgb3A6ICdoZWxsbycgfSkpO1xuICAgKlxuICAgKiBAZXhhbXBsZSA8Y2FwdGlvbj5XcmFwcyBXZWJTb2NrZXQgZnJvbSBub2RlanMtd2Vic29ja2V0ICh1c2luZyBub2RlLmpzKTwvY2FwdGlvbj5cbiAgICpcbiAgICogaW1wb3J0IHsgdzNjd2Vic29ja2V0IH0gZnJvbSAnd2Vic29ja2V0JztcbiAgICpcbiAgICogbGV0IHNvY2tldCQgPSBPYnNlcnZhYmxlLndlYlNvY2tldCh7XG4gICAqICAgdXJsOiAnd3M6Ly9sb2NhbGhvc3Q6ODA4MScsXG4gICAqICAgV2ViU29ja2V0Q3RvcjogdzNjd2Vic29ja2V0XG4gICAqIH0pO1xuICAgKlxuICAgKiBzb2NrZXQkLnN1YnNjcmliZShcbiAgICogICAgKG1zZykgPT4gY29uc29sZS5sb2coJ21lc3NhZ2UgcmVjZWl2ZWQ6ICcgKyBtc2cpLFxuICAgKiAgICAoZXJyKSA9PiBjb25zb2xlLmxvZyhlcnIpLFxuICAgKiAgICAoKSA9PiBjb25zb2xlLmxvZygnY29tcGxldGUnKVxuICAgKiAgKTtcbiAgICpcbiAgICogc29ja2V0JC5uZXh0KEpTT04uc3RyaW5naWZ5KHsgb3A6ICdoZWxsbycgfSkpO1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFdlYlNvY2tldFN1YmplY3RDb25maWd9IHVybENvbmZpZ09yU291cmNlIHRoZSBzb3VyY2Ugb2YgdGhlIHdlYnNvY2tldCBhcyBhbiB1cmwgb3IgYSBzdHJ1Y3R1cmUgZGVmaW5pbmcgdGhlIHdlYnNvY2tldCBvYmplY3RcbiAgICogQHJldHVybiB7V2ViU29ja2V0U3ViamVjdH1cbiAgICogQHN0YXRpYyB0cnVlXG4gICAqIEBuYW1lIHdlYlNvY2tldFxuICAgKiBAb3duZXIgT2JzZXJ2YWJsZVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZTxUPih1cmxDb25maWdPclNvdXJjZTogc3RyaW5nIHwgV2ViU29ja2V0U3ViamVjdENvbmZpZyk6IFdlYlNvY2tldFN1YmplY3Q8VD4ge1xuICAgIHJldHVybiBuZXcgV2ViU29ja2V0U3ViamVjdDxUPih1cmxDb25maWdPclNvdXJjZSk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih1cmxDb25maWdPclNvdXJjZTogc3RyaW5nIHwgV2ViU29ja2V0U3ViamVjdENvbmZpZyB8IE9ic2VydmFibGU8VD4sIGRlc3RpbmF0aW9uPzogT2JzZXJ2ZXI8VD4pIHtcbiAgICBpZiAodXJsQ29uZmlnT3JTb3VyY2UgaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XG4gICAgICBzdXBlcihkZXN0aW5hdGlvbiwgPE9ic2VydmFibGU8VD4+IHVybENvbmZpZ09yU291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuV2ViU29ja2V0Q3RvciA9IHJvb3QuV2ViU29ja2V0O1xuICAgICAgdGhpcy5fb3V0cHV0ID0gbmV3IFN1YmplY3Q8VD4oKTtcbiAgICAgIGlmICh0eXBlb2YgdXJsQ29uZmlnT3JTb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsQ29uZmlnT3JTb3VyY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXQVJOSU5HOiBjb25maWcgb2JqZWN0IGNvdWxkIG92ZXJyaWRlIGltcG9ydGFudCBtZW1iZXJzIGhlcmUuXG4gICAgICAgIGFzc2lnbih0aGlzLCB1cmxDb25maWdPclNvdXJjZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuV2ViU29ja2V0Q3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIFdlYlNvY2tldCBjb25zdHJ1Y3RvciBjYW4gYmUgZm91bmQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgUmVwbGF5U3ViamVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIGxpZnQ8Uj4ob3BlcmF0b3I6IE9wZXJhdG9yPFQsIFI+KTogV2ViU29ja2V0U3ViamVjdDxSPiB7XG4gICAgY29uc3Qgc29jayA9IG5ldyBXZWJTb2NrZXRTdWJqZWN0PFI+KHRoaXMsIDxhbnk+IHRoaXMuZGVzdGluYXRpb24pO1xuICAgIHNvY2sub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICByZXR1cm4gc29jaztcbiAgfVxuXG4gIHByaXZhdGUgX3Jlc2V0U3RhdGUoKSB7XG4gICAgdGhpcy5zb2NrZXQgPSBudWxsO1xuICAgIGlmICghdGhpcy5zb3VyY2UpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24gPSBuZXcgUmVwbGF5U3ViamVjdCgpO1xuICAgIH1cbiAgICB0aGlzLl9vdXRwdXQgPSBuZXcgU3ViamVjdDxUPigpO1xuICB9XG5cbiAgLy8gVE9ETzogZmFjdG9yIHRoaXMgb3V0IHRvIGJlIGEgcHJvcGVyIE9wZXJhdG9yL1N1YnNjcmliZXIgaW1wbGVtZW50YXRpb24gYW5kIGVsaW1pbmF0ZSBjbG9zdXJlc1xuICBtdWx0aXBsZXgoc3ViTXNnOiAoKSA9PiBhbnksIHVuc3ViTXNnOiAoKSA9PiBhbnksIG1lc3NhZ2VGaWx0ZXI6ICh2YWx1ZTogVCkgPT4gYm9vbGVhbikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZSgob2JzZXJ2ZXI6IE9ic2VydmVyPGFueT4pID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRyeUNhdGNoKHN1Yk1zZykoKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqZWN0KSB7XG4gICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yT2JqZWN0LmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5uZXh0KHJlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBzdWJzY3JpcHRpb24gPSBzZWxmLnN1YnNjcmliZSh4ID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdHJ5Q2F0Y2gobWVzc2FnZUZpbHRlcikoeCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZXJyb3JPYmplY3QuZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgb2JzZXJ2ZXIubmV4dCh4KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICAgZXJyID0+IG9ic2VydmVyLmVycm9yKGVyciksXG4gICAgICAgICgpID0+IG9ic2VydmVyLmNvbXBsZXRlKCkpO1xuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0cnlDYXRjaCh1bnN1Yk1zZykoKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZXJyb3JPYmplY3QpIHtcbiAgICAgICAgICBvYnNlcnZlci5lcnJvcihlcnJvck9iamVjdC5lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLm5leHQocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIF9jb25uZWN0U29ja2V0KCkge1xuICAgIGNvbnN0IHsgV2ViU29ja2V0Q3RvciB9ID0gdGhpcztcbiAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMuX291dHB1dDtcblxuICAgIGxldCBzb2NrZXQ6IFdlYlNvY2tldCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIHNvY2tldCA9IHRoaXMucHJvdG9jb2wgP1xuICAgICAgICBuZXcgV2ViU29ja2V0Q3Rvcih0aGlzLnVybCwgdGhpcy5wcm90b2NvbCkgOlxuICAgICAgICBuZXcgV2ViU29ja2V0Q3Rvcih0aGlzLnVybCk7XG4gICAgICB0aGlzLnNvY2tldCA9IHNvY2tldDtcbiAgICAgIGlmICh0aGlzLmJpbmFyeVR5cGUpIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSA9IHRoaXMuYmluYXJ5VHlwZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBvYnNlcnZlci5lcnJvcihlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMuc29ja2V0ID0gbnVsbDtcbiAgICAgIGlmIChzb2NrZXQgJiYgc29ja2V0LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzb2NrZXQub25vcGVuID0gKGU6IEV2ZW50KSA9PiB7XG4gICAgICBjb25zdCBvcGVuT2JzZXJ2ZXIgPSB0aGlzLm9wZW5PYnNlcnZlcjtcbiAgICAgIGlmIChvcGVuT2JzZXJ2ZXIpIHtcbiAgICAgICAgb3Blbk9ic2VydmVyLm5leHQoZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHF1ZXVlID0gdGhpcy5kZXN0aW5hdGlvbjtcblxuICAgICAgdGhpcy5kZXN0aW5hdGlvbiA9IFN1YnNjcmliZXIuY3JlYXRlKFxuICAgICAgICAoeCkgPT4gc29ja2V0LnJlYWR5U3RhdGUgPT09IDEgJiYgc29ja2V0LnNlbmQoeCksXG4gICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2xvc2luZ09ic2VydmVyID0gdGhpcy5jbG9zaW5nT2JzZXJ2ZXI7XG4gICAgICAgICAgaWYgKGNsb3NpbmdPYnNlcnZlcikge1xuICAgICAgICAgICAgY2xvc2luZ09ic2VydmVyLm5leHQodW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGUgJiYgZS5jb2RlKSB7XG4gICAgICAgICAgICBzb2NrZXQuY2xvc2UoZS5jb2RlLCBlLnJlYXNvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmVycm9yKG5ldyBUeXBlRXJyb3IoJ1dlYlNvY2tldFN1YmplY3QuZXJyb3IgbXVzdCBiZSBjYWxsZWQgd2l0aCBhbiBvYmplY3Qgd2l0aCBhbiBlcnJvciBjb2RlLCAnICtcbiAgICAgICAgICAgICAgJ2FuZCBhbiBvcHRpb25hbCByZWFzb246IHsgY29kZTogbnVtYmVyLCByZWFzb246IHN0cmluZyB9JykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9yZXNldFN0YXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgICggKSA9PiB7XG4gICAgICAgICAgY29uc3QgY2xvc2luZ09ic2VydmVyID0gdGhpcy5jbG9zaW5nT2JzZXJ2ZXI7XG4gICAgICAgICAgaWYgKGNsb3NpbmdPYnNlcnZlcikge1xuICAgICAgICAgICAgY2xvc2luZ09ic2VydmVyLm5leHQodW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgdGhpcy5fcmVzZXRTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgICBpZiAocXVldWUgJiYgcXVldWUgaW5zdGFuY2VvZiBSZXBsYXlTdWJqZWN0KSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbi5hZGQoKDxSZXBsYXlTdWJqZWN0PFQ+PnF1ZXVlKS5zdWJzY3JpYmUodGhpcy5kZXN0aW5hdGlvbikpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzb2NrZXQub25lcnJvciA9IChlOiBFdmVudCkgPT4ge1xuICAgICAgdGhpcy5fcmVzZXRTdGF0ZSgpO1xuICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgfTtcblxuICAgIHNvY2tldC5vbmNsb3NlID0gKGU6IENsb3NlRXZlbnQpID0+IHtcbiAgICAgIHRoaXMuX3Jlc2V0U3RhdGUoKTtcbiAgICAgIGNvbnN0IGNsb3NlT2JzZXJ2ZXIgPSB0aGlzLmNsb3NlT2JzZXJ2ZXI7XG4gICAgICBpZiAoY2xvc2VPYnNlcnZlcikge1xuICAgICAgICBjbG9zZU9ic2VydmVyLm5leHQoZSk7XG4gICAgICB9XG4gICAgICBpZiAoZS53YXNDbGVhbikge1xuICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JzZXJ2ZXIuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHNvY2tldC5vbm1lc3NhZ2UgPSAoZTogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0cnlDYXRjaCh0aGlzLnJlc3VsdFNlbGVjdG9yKShlKTtcbiAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqZWN0KSB7XG4gICAgICAgIG9ic2VydmVyLmVycm9yKGVycm9yT2JqZWN0LmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JzZXJ2ZXIubmV4dChyZXN1bHQpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgX3N1YnNjcmliZShzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+KTogU3Vic2NyaXB0aW9uIHtcbiAgICBjb25zdCB7IHNvdXJjZSB9ID0gdGhpcztcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnNvY2tldCkge1xuICAgICAgdGhpcy5fY29ubmVjdFNvY2tldCgpO1xuICAgIH1cbiAgICBsZXQgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgIHN1YnNjcmlwdGlvbi5hZGQodGhpcy5fb3V0cHV0LnN1YnNjcmliZShzdWJzY3JpYmVyKSk7XG4gICAgc3Vic2NyaXB0aW9uLmFkZCgoKSA9PiB7XG4gICAgICBjb25zdCB7IHNvY2tldCB9ID0gdGhpcztcbiAgICAgIGlmICh0aGlzLl9vdXRwdXQub2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAoc29ja2V0ICYmIHNvY2tldC5yZWFkeVN0YXRlID09PSAxKSB7XG4gICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzZXRTdGF0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cblxuICB1bnN1YnNjcmliZSgpIHtcbiAgICBjb25zdCB7IHNvdXJjZSwgc29ja2V0IH0gPSB0aGlzO1xuICAgIGlmIChzb2NrZXQgJiYgc29ja2V0LnJlYWR5U3RhdGUgPT09IDEpIHtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgdGhpcy5fcmVzZXRTdGF0ZSgpO1xuICAgIH1cbiAgICBzdXBlci51bnN1YnNjcmliZSgpO1xuICAgIGlmICghc291cmNlKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uID0gbmV3IFJlcGxheVN1YmplY3QoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9kb20vV2ViU29ja2V0U3ViamVjdC50cyIsImltcG9ydCB7ICBBamF4T2JzZXJ2YWJsZSwgQWpheENyZWF0aW9uTWV0aG9kICB9IGZyb20gJy4vQWpheE9ic2VydmFibGUnO1xuXG5leHBvcnQgY29uc3QgYWpheDogQWpheENyZWF0aW9uTWV0aG9kID0gQWpheE9ic2VydmFibGUuY3JlYXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9kb20vYWpheC50cyIsImltcG9ydCB7ICBXZWJTb2NrZXRTdWJqZWN0ICB9IGZyb20gJy4vV2ViU29ja2V0U3ViamVjdCc7XG5cbmV4cG9ydCBjb25zdCB3ZWJTb2NrZXQgPSBXZWJTb2NrZXRTdWJqZWN0LmNyZWF0ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29ic2VydmFibGUvZG9tL3dlYlNvY2tldC50cyIsImltcG9ydCB7ICBFbXB0eU9ic2VydmFibGUgIH0gZnJvbSAnLi9FbXB0eU9ic2VydmFibGUnO1xuXG5leHBvcnQgY29uc3QgZW1wdHkgPSBFbXB0eU9ic2VydmFibGUuY3JlYXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9lbXB0eS50cyIsImltcG9ydCB7ICBGb3JrSm9pbk9ic2VydmFibGUgIH0gZnJvbSAnLi9Gb3JrSm9pbk9ic2VydmFibGUnO1xuXG5leHBvcnQgY29uc3QgZm9ya0pvaW4gPSBGb3JrSm9pbk9ic2VydmFibGUuY3JlYXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS9mb3JrSm9pbi50cyIsImltcG9ydCB7ICBGcm9tT2JzZXJ2YWJsZSAgfSBmcm9tICcuL0Zyb21PYnNlcnZhYmxlJztcblxuZXhwb3J0IGNvbnN0IGZyb20gPSBGcm9tT2JzZXJ2YWJsZS5jcmVhdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL2Zyb20udHMiLCJpbXBvcnQgeyAgRnJvbUV2ZW50T2JzZXJ2YWJsZSAgfSBmcm9tICcuL0Zyb21FdmVudE9ic2VydmFibGUnO1xuXG5leHBvcnQgY29uc3QgZnJvbUV2ZW50ID0gRnJvbUV2ZW50T2JzZXJ2YWJsZS5jcmVhdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL2Zyb21FdmVudC50cyIsImltcG9ydCB7ICBGcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZSAgfSBmcm9tICcuL0Zyb21FdmVudFBhdHRlcm5PYnNlcnZhYmxlJztcblxuZXhwb3J0IGNvbnN0IGZyb21FdmVudFBhdHRlcm4gPSBGcm9tRXZlbnRQYXR0ZXJuT2JzZXJ2YWJsZS5jcmVhdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL2Zyb21FdmVudFBhdHRlcm4udHMiLCJpbXBvcnQgeyAgUHJvbWlzZU9ic2VydmFibGUgIH0gZnJvbSAnLi9Qcm9taXNlT2JzZXJ2YWJsZSc7XG5cbmV4cG9ydCBjb25zdCBmcm9tUHJvbWlzZSA9IFByb21pc2VPYnNlcnZhYmxlLmNyZWF0ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29ic2VydmFibGUvZnJvbVByb21pc2UudHMiLCJpbXBvcnQgeyAgSWZPYnNlcnZhYmxlICB9IGZyb20gJy4vSWZPYnNlcnZhYmxlJztcblxuZXhwb3J0IGNvbnN0IF9pZiA9IElmT2JzZXJ2YWJsZS5jcmVhdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL2lmLnRzIiwiaW1wb3J0IHsgIEludGVydmFsT2JzZXJ2YWJsZSAgfSBmcm9tICcuL0ludGVydmFsT2JzZXJ2YWJsZSc7XG5cbmV4cG9ydCBjb25zdCBpbnRlcnZhbCA9IEludGVydmFsT2JzZXJ2YWJsZS5jcmVhdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL2ludGVydmFsLnRzIiwiaW1wb3J0IHsgIG1lcmdlU3RhdGljICB9IGZyb20gJy4uL29wZXJhdG9yL21lcmdlJztcblxuZXhwb3J0IGNvbnN0IG1lcmdlID0gbWVyZ2VTdGF0aWM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL21lcmdlLnRzIiwiaW1wb3J0IHsgIE5ldmVyT2JzZXJ2YWJsZSAgfSBmcm9tICcuL05ldmVyT2JzZXJ2YWJsZSc7XG5cbmV4cG9ydCBjb25zdCBuZXZlciA9IE5ldmVyT2JzZXJ2YWJsZS5jcmVhdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL25ldmVyLnRzIiwiaW1wb3J0IHsgIEFycmF5T2JzZXJ2YWJsZSAgfSBmcm9tICcuL0FycmF5T2JzZXJ2YWJsZSc7XG5cbmV4cG9ydCBjb25zdCBvZiA9IEFycmF5T2JzZXJ2YWJsZS5vZjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29ic2VydmFibGUvb2YudHMiLCJpbXBvcnQgeyAgUGFpcnNPYnNlcnZhYmxlICB9IGZyb20gJy4vUGFpcnNPYnNlcnZhYmxlJztcclxuXHJcbmV4cG9ydCBjb25zdCBwYWlycyA9IFBhaXJzT2JzZXJ2YWJsZS5jcmVhdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL3BhaXJzLnRzIiwiaW1wb3J0IHsgIFJhbmdlT2JzZXJ2YWJsZSAgfSBmcm9tICcuL1JhbmdlT2JzZXJ2YWJsZSc7XG5cbmV4cG9ydCBjb25zdCByYW5nZSA9IFJhbmdlT2JzZXJ2YWJsZS5jcmVhdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vYnNlcnZhYmxlL3JhbmdlLnRzIiwiaW1wb3J0IHsgIEVycm9yT2JzZXJ2YWJsZSAgfSBmcm9tICcuL0Vycm9yT2JzZXJ2YWJsZSc7XG5cbmV4cG9ydCBjb25zdCBfdGhyb3cgPSBFcnJvck9ic2VydmFibGUuY3JlYXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS90aHJvdy50cyIsImltcG9ydCB7ICBUaW1lck9ic2VydmFibGUgIH0gZnJvbSAnLi9UaW1lck9ic2VydmFibGUnO1xuXG5leHBvcnQgY29uc3QgdGltZXIgPSBUaW1lck9ic2VydmFibGUuY3JlYXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS90aW1lci50cyIsImltcG9ydCB7ICBVc2luZ09ic2VydmFibGUgIH0gZnJvbSAnLi9Vc2luZ09ic2VydmFibGUnO1xuXG5leHBvcnQgY29uc3QgdXNpbmcgPSBVc2luZ09ic2VydmFibGUuY3JlYXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb2JzZXJ2YWJsZS91c2luZy50cyIsImltcG9ydCB7ICB6aXBTdGF0aWMgIH0gZnJvbSAnLi4vb3BlcmF0b3IvemlwJztcblxuZXhwb3J0IGNvbnN0IHppcCA9IHppcFN0YXRpYztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29ic2VydmFibGUvemlwLnRzIiwiaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJzY3JpYmFibGVPclByb21pc2UgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiwgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5cbmltcG9ydCB7IHRyeUNhdGNoIH0gZnJvbSAnLi4vdXRpbC90cnlDYXRjaCc7XG5pbXBvcnQgeyBlcnJvck9iamVjdCB9IGZyb20gJy4uL3V0aWwvZXJyb3JPYmplY3QnO1xuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vT3V0ZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IHN1YnNjcmliZVRvUmVzdWx0IH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCc7XG5cbi8qKlxuICogSWdub3JlcyBzb3VyY2UgdmFsdWVzIGZvciBhIGR1cmF0aW9uIGRldGVybWluZWQgYnkgYW5vdGhlciBPYnNlcnZhYmxlLCB0aGVuXG4gKiBlbWl0cyB0aGUgbW9zdCByZWNlbnQgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIHRoZW4gcmVwZWF0cyB0aGlzXG4gKiBwcm9jZXNzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGF1ZGl0VGltZX0sIGJ1dCB0aGUgc2lsZW5jaW5nXG4gKiBkdXJhdGlvbiBpcyBkZXRlcm1pbmVkIGJ5IGEgc2Vjb25kIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYXVkaXQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGF1ZGl0YCBpcyBzaW1pbGFyIHRvIGB0aHJvdHRsZWAsIGJ1dCBlbWl0cyB0aGUgbGFzdCB2YWx1ZSBmcm9tIHRoZSBzaWxlbmNlZFxuICogdGltZSB3aW5kb3csIGluc3RlYWQgb2YgdGhlIGZpcnN0IHZhbHVlLiBgYXVkaXRgIGVtaXRzIHRoZSBtb3N0IHJlY2VudCB2YWx1ZVxuICogZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGFzIHNvb24gYXMgaXRzIGludGVybmFsXG4gKiB0aW1lciBiZWNvbWVzIGRpc2FibGVkLCBhbmQgaWdub3JlcyBzb3VyY2UgdmFsdWVzIHdoaWxlIHRoZSB0aW1lciBpcyBlbmFibGVkLlxuICogSW5pdGlhbGx5LCB0aGUgdGltZXIgaXMgZGlzYWJsZWQuIEFzIHNvb24gYXMgdGhlIGZpcnN0IHNvdXJjZSB2YWx1ZSBhcnJpdmVzLFxuICogdGhlIHRpbWVyIGlzIGVuYWJsZWQgYnkgY2FsbGluZyB0aGUgYGR1cmF0aW9uU2VsZWN0b3JgIGZ1bmN0aW9uIHdpdGggdGhlXG4gKiBzb3VyY2UgdmFsdWUsIHdoaWNoIHJldHVybnMgdGhlIFwiZHVyYXRpb25cIiBPYnNlcnZhYmxlLiBXaGVuIHRoZSBkdXJhdGlvblxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlIG9yIGNvbXBsZXRlcywgdGhlIHRpbWVyIGlzIGRpc2FibGVkLCB0aGVuIHRoZSBtb3N0XG4gKiByZWNlbnQgc291cmNlIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLCBhbmQgdGhpcyBwcm9jZXNzXG4gKiByZXBlYXRzIGZvciB0aGUgbmV4dCBzb3VyY2UgdmFsdWUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBjbGlja3MgYXQgYSByYXRlIG9mIGF0IG1vc3Qgb25lIGNsaWNrIHBlciBzZWNvbmQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5hdWRpdChldiA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXRUaW1lfVxuICogQHNlZSB7QGxpbmsgZGVib3VuY2V9XG4gKiBAc2VlIHtAbGluayBkZWxheVdoZW59XG4gKiBAc2VlIHtAbGluayBzYW1wbGV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZX1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBUKTogU3Vic2NyaWJhYmxlT3JQcm9taXNlfSBkdXJhdGlvblNlbGVjdG9yIEEgZnVuY3Rpb25cbiAqIHRoYXQgcmVjZWl2ZXMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgZm9yIGNvbXB1dGluZyB0aGUgc2lsZW5jaW5nXG4gKiBkdXJhdGlvbiwgcmV0dXJuZWQgYXMgYW4gT2JzZXJ2YWJsZSBvciBhIFByb21pc2UuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgcGVyZm9ybXMgcmF0ZS1saW1pdGluZyBvZlxuICogZW1pc3Npb25zIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBhdWRpdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF1ZGl0PFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIGR1cmF0aW9uU2VsZWN0b3I6ICh2YWx1ZTogVCkgPT4gU3Vic2NyaWJhYmxlT3JQcm9taXNlPGFueT4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgQXVkaXRPcGVyYXRvcihkdXJhdGlvblNlbGVjdG9yKSk7XG59XG5cbmNsYXNzIEF1ZGl0T3BlcmF0b3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZHVyYXRpb25TZWxlY3RvcjogKHZhbHVlOiBUKSA9PiBTdWJzY3JpYmFibGVPclByb21pc2U8YW55Pikge1xuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+LCBzb3VyY2U6IGFueSk6IFRlYXJkb3duTG9naWMge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBBdWRpdFN1YnNjcmliZXI8VCwgVD4oc3Vic2NyaWJlciwgdGhpcy5kdXJhdGlvblNlbGVjdG9yKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIEF1ZGl0U3Vic2NyaWJlcjxULCBSPiBleHRlbmRzIE91dGVyU3Vic2NyaWJlcjxULCBSPiB7XG5cbiAgcHJpdmF0ZSB2YWx1ZTogVDtcbiAgcHJpdmF0ZSBoYXNWYWx1ZTogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIHRocm90dGxlZDogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFQ+LFxuICAgICAgICAgICAgICBwcml2YXRlIGR1cmF0aW9uU2VsZWN0b3I6ICh2YWx1ZTogVCkgPT4gU3Vic2NyaWJhYmxlT3JQcm9taXNlPGFueT4pIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpOiB2b2lkIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgaWYgKCF0aGlzLnRocm90dGxlZCkge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSB0cnlDYXRjaCh0aGlzLmR1cmF0aW9uU2VsZWN0b3IpKHZhbHVlKTtcbiAgICAgIGlmIChkdXJhdGlvbiA9PT0gZXJyb3JPYmplY3QpIHtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvck9iamVjdC5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkKHRoaXMudGhyb3R0bGVkID0gc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgZHVyYXRpb24pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjbGVhclRocm90dGxlKCkge1xuICAgIGNvbnN0IHsgdmFsdWUsIGhhc1ZhbHVlLCB0aHJvdHRsZWQgfSA9IHRoaXM7XG4gICAgaWYgKHRocm90dGxlZCkge1xuICAgICAgdGhpcy5yZW1vdmUodGhyb3R0bGVkKTtcbiAgICAgIHRoaXMudGhyb3R0bGVkID0gbnVsbDtcbiAgICAgIHRocm90dGxlZC51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBpZiAoaGFzVmFsdWUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBub3RpZnlOZXh0KG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IFIsIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5jbGVhclRocm90dGxlKCk7XG4gIH1cblxuICBub3RpZnlDb21wbGV0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLmNsZWFyVGhyb3R0bGUoKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9hdWRpdC50cyIsImltcG9ydCB7IGFzeW5jIH0gZnJvbSAnLi4vc2NoZWR1bGVyL2FzeW5jJztcbmltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgSVNjaGVkdWxlciB9IGZyb20gJy4uL1NjaGVkdWxlcic7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24sIFRlYXJkb3duTG9naWMgfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuXG4vKipcbiAqIElnbm9yZXMgc291cmNlIHZhbHVlcyBmb3IgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHMsIHRoZW4gZW1pdHMgdGhlIG1vc3QgcmVjZW50XG4gKiB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgdGhlbiByZXBlYXRzIHRoaXMgcHJvY2Vzcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+V2hlbiBpdCBzZWVzIGEgc291cmNlIHZhbHVlcywgaXQgaWdub3JlcyB0aGF0IHBsdXNcbiAqIHRoZSBuZXh0IG9uZXMgZm9yIGBkdXJhdGlvbmAgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBpdCBlbWl0cyB0aGUgbW9zdCByZWNlbnRcbiAqIHZhbHVlIGZyb20gdGhlIHNvdXJjZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9hdWRpdFRpbWUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGF1ZGl0VGltZWAgaXMgc2ltaWxhciB0byBgdGhyb3R0bGVUaW1lYCwgYnV0IGVtaXRzIHRoZSBsYXN0IHZhbHVlIGZyb20gdGhlXG4gKiBzaWxlbmNlZCB0aW1lIHdpbmRvdywgaW5zdGVhZCBvZiB0aGUgZmlyc3QgdmFsdWUuIGBhdWRpdFRpbWVgIGVtaXRzIHRoZSBtb3N0XG4gKiByZWNlbnQgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGFzIHNvb24gYXNcbiAqIGl0cyBpbnRlcm5hbCB0aW1lciBiZWNvbWVzIGRpc2FibGVkLCBhbmQgaWdub3JlcyBzb3VyY2UgdmFsdWVzIHdoaWxlIHRoZVxuICogdGltZXIgaXMgZW5hYmxlZC4gSW5pdGlhbGx5LCB0aGUgdGltZXIgaXMgZGlzYWJsZWQuIEFzIHNvb24gYXMgdGhlIGZpcnN0XG4gKiBzb3VyY2UgdmFsdWUgYXJyaXZlcywgdGhlIHRpbWVyIGlzIGVuYWJsZWQuIEFmdGVyIGBkdXJhdGlvbmAgbWlsbGlzZWNvbmRzIChvclxuICogdGhlIHRpbWUgdW5pdCBkZXRlcm1pbmVkIGludGVybmFsbHkgYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgKSBoYXMgcGFzc2VkLFxuICogdGhlIHRpbWVyIGlzIGRpc2FibGVkLCB0aGVuIHRoZSBtb3N0IHJlY2VudCBzb3VyY2UgdmFsdWUgaXMgZW1pdHRlZCBvbiB0aGVcbiAqIG91dHB1dCBPYnNlcnZhYmxlLCBhbmQgdGhpcyBwcm9jZXNzIHJlcGVhdHMgZm9yIHRoZSBuZXh0IHNvdXJjZSB2YWx1ZS5cbiAqIE9wdGlvbmFsbHkgdGFrZXMgYSB7QGxpbmsgSVNjaGVkdWxlcn0gZm9yIG1hbmFnaW5nIHRpbWVycy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IGNsaWNrcyBhdCBhIHJhdGUgb2YgYXQgbW9zdCBvbmUgY2xpY2sgcGVyIHNlY29uZDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmF1ZGl0VGltZSgxMDAwKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXR9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZVRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWxheX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZVRpbWV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZVRpbWV9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIFRpbWUgdG8gd2FpdCBiZWZvcmUgZW1pdHRpbmcgdGhlIG1vc3QgcmVjZW50IHNvdXJjZVxuICogdmFsdWUsIG1lYXN1cmVkIGluIG1pbGxpc2Vjb25kcyBvciB0aGUgdGltZSB1bml0IGRldGVybWluZWQgaW50ZXJuYWxseVxuICogYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvclxuICogbWFuYWdpbmcgdGhlIHRpbWVycyB0aGF0IGhhbmRsZSB0aGUgcmF0ZS1saW1pdGluZyBiZWhhdmlvci5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBwZXJmb3JtcyByYXRlLWxpbWl0aW5nIG9mXG4gKiBlbWlzc2lvbnMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIGF1ZGl0VGltZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGF1ZGl0VGltZTxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBkdXJhdGlvbjogbnVtYmVyLCBzY2hlZHVsZXI6IElTY2hlZHVsZXIgPSBhc3luYyk6IE9ic2VydmFibGU8VD4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBBdWRpdFRpbWVPcGVyYXRvcihkdXJhdGlvbiwgc2NoZWR1bGVyKSk7XG59XG5cbmNsYXNzIEF1ZGl0VGltZU9wZXJhdG9yPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGR1cmF0aW9uOiBudW1iZXIsXG4gICAgICAgICAgICAgIHByaXZhdGUgc2NoZWR1bGVyOiBJU2NoZWR1bGVyKSB7XG4gIH1cblxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4sIHNvdXJjZTogYW55KTogVGVhcmRvd25Mb2dpYyB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEF1ZGl0VGltZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kdXJhdGlvbiwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgQXVkaXRUaW1lU3Vic2NyaWJlcjxUPiBleHRlbmRzIFN1YnNjcmliZXI8VD4ge1xuXG4gIHByaXZhdGUgdmFsdWU6IFQ7XG4gIHByaXZhdGUgaGFzVmFsdWU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSB0aHJvdHRsZWQ6IFN1YnNjcmlwdGlvbjtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxUPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBkdXJhdGlvbjogbnVtYmVyLFxuICAgICAgICAgICAgICBwcml2YXRlIHNjaGVkdWxlcjogSVNjaGVkdWxlcikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICBpZiAoIXRoaXMudGhyb3R0bGVkKSB7XG4gICAgICB0aGlzLmFkZCh0aGlzLnRocm90dGxlZCA9IHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTmV4dCwgdGhpcy5kdXJhdGlvbiwgdGhpcykpO1xuICAgIH1cbiAgfVxuXG4gIGNsZWFyVGhyb3R0bGUoKTogdm9pZCB7XG4gICAgY29uc3QgeyB2YWx1ZSwgaGFzVmFsdWUsIHRocm90dGxlZCB9ID0gdGhpcztcbiAgICBpZiAodGhyb3R0bGVkKSB7XG4gICAgICB0aGlzLnJlbW92ZSh0aHJvdHRsZWQpO1xuICAgICAgdGhpcy50aHJvdHRsZWQgPSBudWxsO1xuICAgICAgdGhyb3R0bGVkLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGlmIChoYXNWYWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaE5leHQ8VD4oc3Vic2NyaWJlcjogQXVkaXRUaW1lU3Vic2NyaWJlcjxUPik6IHZvaWQge1xuICBzdWJzY3JpYmVyLmNsZWFyVGhyb3R0bGUoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvYXVkaXRUaW1lLnRzIiwiaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5cbmltcG9ydCB7IE91dGVyU3Vic2NyaWJlciB9IGZyb20gJy4uL091dGVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBJbm5lclN1YnNjcmliZXIgfSBmcm9tICcuLi9Jbm5lclN1YnNjcmliZXInO1xuaW1wb3J0IHsgc3Vic2NyaWJlVG9SZXN1bHQgfSBmcm9tICcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0JztcblxuLyoqXG4gKiBCdWZmZXJzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgdW50aWwgYGNsb3NpbmdOb3RpZmllcmAgZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbGxlY3RzIHZhbHVlcyBmcm9tIHRoZSBwYXN0IGFzIGFuIGFycmF5LCBhbmQgZW1pdHNcbiAqIHRoYXQgYXJyYXkgb25seSB3aGVuIGFub3RoZXIgT2JzZXJ2YWJsZSBlbWl0cy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9idWZmZXIucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQnVmZmVycyB0aGUgaW5jb21pbmcgT2JzZXJ2YWJsZSB2YWx1ZXMgdW50aWwgdGhlIGdpdmVuIGBjbG9zaW5nTm90aWZpZXJgXG4gKiBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUsIGF0IHdoaWNoIHBvaW50IGl0IGVtaXRzIHRoZSBidWZmZXIgb24gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSBhbmQgc3RhcnRzIGEgbmV3IGJ1ZmZlciBpbnRlcm5hbGx5LCBhd2FpdGluZyB0aGUgbmV4dCB0aW1lXG4gKiBgY2xvc2luZ05vdGlmaWVyYCBlbWl0cy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5PbiBldmVyeSBjbGljaywgZW1pdCBhcnJheSBvZiBtb3N0IHJlY2VudCBpbnRlcnZhbCBldmVudHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciBidWZmZXJlZCA9IGludGVydmFsLmJ1ZmZlcihjbGlja3MpO1xuICogYnVmZmVyZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGJ1ZmZlckNvdW50fVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVGltZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlclRvZ2dsZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcldoZW59XG4gKiBAc2VlIHtAbGluayB3aW5kb3d9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlPGFueT59IGNsb3NpbmdOb3RpZmllciBBbiBPYnNlcnZhYmxlIHRoYXQgc2lnbmFscyB0aGVcbiAqIGJ1ZmZlciB0byBiZSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VFtdPn0gQW4gT2JzZXJ2YWJsZSBvZiBidWZmZXJzLCB3aGljaCBhcmUgYXJyYXlzIG9mXG4gKiB2YWx1ZXMuXG4gKiBAbWV0aG9kIGJ1ZmZlclxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlcjxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBjbG9zaW5nTm90aWZpZXI6IE9ic2VydmFibGU8YW55Pik6IE9ic2VydmFibGU8VFtdPiB7XG4gIHJldHVybiB0aGlzLmxpZnQobmV3IEJ1ZmZlck9wZXJhdG9yPFQ+KGNsb3NpbmdOb3RpZmllcikpO1xufVxuXG5jbGFzcyBCdWZmZXJPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFRbXT4ge1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY2xvc2luZ05vdGlmaWVyOiBPYnNlcnZhYmxlPGFueT4pIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUW10+LCBzb3VyY2U6IGFueSk6IGFueSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEJ1ZmZlclN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jbG9zaW5nTm90aWZpZXIpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgQnVmZmVyU3Vic2NyaWJlcjxUPiBleHRlbmRzIE91dGVyU3Vic2NyaWJlcjxULCBhbnk+IHtcbiAgcHJpdmF0ZSBidWZmZXI6IFRbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFRbXT4sIGNsb3NpbmdOb3RpZmllcjogT2JzZXJ2YWJsZTxhbnk+KSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGNsb3NpbmdOb3RpZmllcikpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHZhbHVlOiBUKSB7XG4gICAgdGhpcy5idWZmZXIucHVzaCh2YWx1ZSk7XG4gIH1cblxuICBub3RpZnlOZXh0KG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IGFueSxcbiAgICAgICAgICAgICBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgICBpbm5lclN1YjogSW5uZXJTdWJzY3JpYmVyPFQsIGFueT4pOiB2b2lkIHtcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL2J1ZmZlci50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5cbi8qKlxuICogQnVmZmVycyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIHVudGlsIHRoZSBzaXplIGhpdHMgdGhlIG1heGltdW1cbiAqIGBidWZmZXJTaXplYCBnaXZlbi5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q29sbGVjdHMgdmFsdWVzIGZyb20gdGhlIHBhc3QgYXMgYW4gYXJyYXksIGFuZCBlbWl0c1xuICogdGhhdCBhcnJheSBvbmx5IHdoZW4gaXRzIHNpemUgcmVhY2hlcyBgYnVmZmVyU2l6ZWAuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYnVmZmVyQ291bnQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQnVmZmVycyBhIG51bWJlciBvZiB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgYGJ1ZmZlclNpemVgIHRoZW5cbiAqIGVtaXRzIHRoZSBidWZmZXIgYW5kIGNsZWFycyBpdCwgYW5kIHN0YXJ0cyBhIG5ldyBidWZmZXIgZWFjaFxuICogYHN0YXJ0QnVmZmVyRXZlcnlgIHZhbHVlcy4gSWYgYHN0YXJ0QnVmZmVyRXZlcnlgIGlzIG5vdCBwcm92aWRlZCBvciBpc1xuICogYG51bGxgLCB0aGVuIG5ldyBidWZmZXJzIGFyZSBzdGFydGVkIGltbWVkaWF0ZWx5IGF0IHRoZSBzdGFydCBvZiB0aGUgc291cmNlXG4gKiBhbmQgd2hlbiBlYWNoIGJ1ZmZlciBjbG9zZXMgYW5kIGlzIGVtaXR0ZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbGFzdCB0d28gY2xpY2sgZXZlbnRzIGFzIGFuIGFycmF5PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBidWZmZXJlZCA9IGNsaWNrcy5idWZmZXJDb3VudCgyKTtcbiAqIGJ1ZmZlcmVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5PbiBldmVyeSBjbGljaywgZW1pdCB0aGUgbGFzdCB0d28gY2xpY2sgZXZlbnRzIGFzIGFuIGFycmF5PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBidWZmZXJlZCA9IGNsaWNrcy5idWZmZXJDb3VudCgyLCAxKTtcbiAqIGJ1ZmZlcmVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBidWZmZXJ9XG4gKiBAc2VlIHtAbGluayBidWZmZXJUaW1lfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyV2hlbn1cbiAqIEBzZWUge0BsaW5rIHBhaXJ3aXNlfVxuICogQHNlZSB7QGxpbmsgd2luZG93Q291bnR9XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGJ1ZmZlclNpemUgVGhlIG1heGltdW0gc2l6ZSBvZiB0aGUgYnVmZmVyIGVtaXR0ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0QnVmZmVyRXZlcnldIEludGVydmFsIGF0IHdoaWNoIHRvIHN0YXJ0IGEgbmV3IGJ1ZmZlci5cbiAqIEZvciBleGFtcGxlIGlmIGBzdGFydEJ1ZmZlckV2ZXJ5YCBpcyBgMmAsIHRoZW4gYSBuZXcgYnVmZmVyIHdpbGwgYmUgc3RhcnRlZFxuICogb24gZXZlcnkgb3RoZXIgdmFsdWUgZnJvbSB0aGUgc291cmNlLiBBIG5ldyBidWZmZXIgaXMgc3RhcnRlZCBhdCB0aGVcbiAqIGJlZ2lubmluZyBvZiB0aGUgc291cmNlIGJ5IGRlZmF1bHQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRbXT59IEFuIE9ic2VydmFibGUgb2YgYXJyYXlzIG9mIGJ1ZmZlcmVkIHZhbHVlcy5cbiAqIEBtZXRob2QgYnVmZmVyQ291bnRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXJDb3VudDxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBidWZmZXJTaXplOiBudW1iZXIsIHN0YXJ0QnVmZmVyRXZlcnk6IG51bWJlciA9IG51bGwpOiBPYnNlcnZhYmxlPFRbXT4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBCdWZmZXJDb3VudE9wZXJhdG9yPFQ+KGJ1ZmZlclNpemUsIHN0YXJ0QnVmZmVyRXZlcnkpKTtcbn1cblxuY2xhc3MgQnVmZmVyQ291bnRPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFRbXT4ge1xuICBwcml2YXRlIHN1YnNjcmliZXJDbGFzczogYW55O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYnVmZmVyU2l6ZTogbnVtYmVyLCBwcml2YXRlIHN0YXJ0QnVmZmVyRXZlcnk6IG51bWJlcikge1xuICAgIGlmICghc3RhcnRCdWZmZXJFdmVyeSB8fCBidWZmZXJTaXplID09PSBzdGFydEJ1ZmZlckV2ZXJ5KSB7XG4gICAgICB0aGlzLnN1YnNjcmliZXJDbGFzcyA9IEJ1ZmZlckNvdW50U3Vic2NyaWJlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdWJzY3JpYmVyQ2xhc3MgPSBCdWZmZXJTa2lwQ291bnRTdWJzY3JpYmVyO1xuICAgIH1cbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUW10+LCBzb3VyY2U6IGFueSk6IFRlYXJkb3duTG9naWMge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyB0aGlzLnN1YnNjcmliZXJDbGFzcyhzdWJzY3JpYmVyLCB0aGlzLmJ1ZmZlclNpemUsIHRoaXMuc3RhcnRCdWZmZXJFdmVyeSkpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBCdWZmZXJDb3VudFN1YnNjcmliZXI8VD4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgcHJpdmF0ZSBidWZmZXI6IFRbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFRbXT4sIHByaXZhdGUgYnVmZmVyU2l6ZTogbnVtYmVyKSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHZhbHVlOiBUKTogdm9pZCB7XG4gICAgY29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXI7XG5cbiAgICBidWZmZXIucHVzaCh2YWx1ZSk7XG5cbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PSB0aGlzLmJ1ZmZlclNpemUpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICAgICAgdGhpcy5idWZmZXIgPSBbXTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbXBsZXRlKCk6IHZvaWQge1xuICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xuICAgIGlmIChidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGJ1ZmZlcik7XG4gICAgfVxuICAgIHN1cGVyLl9jb21wbGV0ZSgpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBCdWZmZXJTa2lwQ291bnRTdWJzY3JpYmVyPFQ+IGV4dGVuZHMgU3Vic2NyaWJlcjxUPiB7XG4gIHByaXZhdGUgYnVmZmVyczogQXJyYXk8VFtdPiA9IFtdO1xuICBwcml2YXRlIGNvdW50OiBudW1iZXIgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFRbXT4sIHByaXZhdGUgYnVmZmVyU2l6ZTogbnVtYmVyLCBwcml2YXRlIHN0YXJ0QnVmZmVyRXZlcnk6IG51bWJlcikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIGNvbnN0IHsgYnVmZmVyU2l6ZSwgc3RhcnRCdWZmZXJFdmVyeSwgYnVmZmVycywgY291bnQgfSA9IHRoaXM7XG5cbiAgICB0aGlzLmNvdW50Kys7XG4gICAgaWYgKGNvdW50ICUgc3RhcnRCdWZmZXJFdmVyeSA9PT0gMCkge1xuICAgICAgYnVmZmVycy5wdXNoKFtdKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gYnVmZmVycy5sZW5ndGg7IGktLTsgKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBidWZmZXJzW2ldO1xuICAgICAgYnVmZmVyLnB1c2godmFsdWUpO1xuICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IGJ1ZmZlclNpemUpIHtcbiAgICAgICAgYnVmZmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKTogdm9pZCB7XG4gICAgY29uc3QgeyBidWZmZXJzLCBkZXN0aW5hdGlvbiB9ID0gdGhpcztcblxuICAgIHdoaWxlIChidWZmZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBidWZmZXIgPSBidWZmZXJzLnNoaWZ0KCk7XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5fY29tcGxldGUoKTtcbiAgfVxuXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL2J1ZmZlckNvdW50LnRzIiwiaW1wb3J0IHsgSVNjaGVkdWxlciB9IGZyb20gJy4uL1NjaGVkdWxlcic7XG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuLi9zY2hlZHVsZXIvQWN0aW9uJztcbmltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgYXN5bmMgfSBmcm9tICcuLi9zY2hlZHVsZXIvYXN5bmMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGlzU2NoZWR1bGVyIH0gZnJvbSAnLi4vdXRpbC9pc1NjaGVkdWxlcic7XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlclRpbWU8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgYnVmZmVyVGltZVNwYW46IG51bWJlciwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VFtdPjtcbmV4cG9ydCBmdW5jdGlvbiBidWZmZXJUaW1lPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIGJ1ZmZlclRpbWVTcGFuOiBudW1iZXIsIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWw6IG51bWJlciwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VFtdPjtcbmV4cG9ydCBmdW5jdGlvbiBidWZmZXJUaW1lPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIGJ1ZmZlclRpbWVTcGFuOiBudW1iZXIsIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWw6IG51bWJlciwgbWF4QnVmZmVyU2l6ZTogbnVtYmVyLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxUW10+O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cblxuLyoqXG4gKiBCdWZmZXJzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgZm9yIGEgc3BlY2lmaWMgdGltZSBwZXJpb2QuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbGxlY3RzIHZhbHVlcyBmcm9tIHRoZSBwYXN0IGFzIGFuIGFycmF5LCBhbmQgZW1pdHNcbiAqIHRob3NlIGFycmF5cyBwZXJpb2RpY2FsbHkgaW4gdGltZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9idWZmZXJUaW1lLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEJ1ZmZlcnMgdmFsdWVzIGZyb20gdGhlIHNvdXJjZSBmb3IgYSBzcGVjaWZpYyB0aW1lIGR1cmF0aW9uIGBidWZmZXJUaW1lU3BhbmAuXG4gKiBVbmxlc3MgdGhlIG9wdGlvbmFsIGFyZ3VtZW50IGBidWZmZXJDcmVhdGlvbkludGVydmFsYCBpcyBnaXZlbiwgaXQgZW1pdHMgYW5kXG4gKiByZXNldHMgdGhlIGJ1ZmZlciBldmVyeSBgYnVmZmVyVGltZVNwYW5gIG1pbGxpc2Vjb25kcy4gSWZcbiAqIGBidWZmZXJDcmVhdGlvbkludGVydmFsYCBpcyBnaXZlbiwgdGhpcyBvcGVyYXRvciBvcGVucyB0aGUgYnVmZmVyIGV2ZXJ5XG4gKiBgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbGAgbWlsbGlzZWNvbmRzIGFuZCBjbG9zZXMgKGVtaXRzIGFuZCByZXNldHMpIHRoZVxuICogYnVmZmVyIGV2ZXJ5IGBidWZmZXJUaW1lU3BhbmAgbWlsbGlzZWNvbmRzLiBXaGVuIHRoZSBvcHRpb25hbCBhcmd1bWVudFxuICogYG1heEJ1ZmZlclNpemVgIGlzIHNwZWNpZmllZCwgdGhlIGJ1ZmZlciB3aWxsIGJlIGNsb3NlZCBlaXRoZXIgYWZ0ZXJcbiAqIGBidWZmZXJUaW1lU3BhbmAgbWlsbGlzZWNvbmRzIG9yIHdoZW4gaXQgY29udGFpbnMgYG1heEJ1ZmZlclNpemVgIGVsZW1lbnRzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkV2ZXJ5IHNlY29uZCwgZW1pdCBhbiBhcnJheSBvZiB0aGUgcmVjZW50IGNsaWNrIGV2ZW50czwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgYnVmZmVyZWQgPSBjbGlja3MuYnVmZmVyVGltZSgxMDAwKTtcbiAqIGJ1ZmZlcmVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FdmVyeSA1IHNlY29uZHMsIGVtaXQgdGhlIGNsaWNrIGV2ZW50cyBmcm9tIHRoZSBuZXh0IDIgc2Vjb25kczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgYnVmZmVyZWQgPSBjbGlja3MuYnVmZmVyVGltZSgyMDAwLCA1MDAwKTtcbiAqIGJ1ZmZlcmVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBidWZmZXJ9XG4gKiBAc2VlIHtAbGluayBidWZmZXJDb3VudH1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlclRvZ2dsZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcldoZW59XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUaW1lfVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBidWZmZXJUaW1lU3BhbiBUaGUgYW1vdW50IG9mIHRpbWUgdG8gZmlsbCBlYWNoIGJ1ZmZlciBhcnJheS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYnVmZmVyQ3JlYXRpb25JbnRlcnZhbF0gVGhlIGludGVydmFsIGF0IHdoaWNoIHRvIHN0YXJ0IG5ld1xuICogYnVmZmVycy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4QnVmZmVyU2l6ZV0gVGhlIG1heGltdW0gYnVmZmVyIHNpemUuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIHNjaGVkdWxlciBvbiB3aGljaCB0byBzY2hlZHVsZSB0aGVcbiAqIGludGVydmFscyB0aGF0IGRldGVybWluZSBidWZmZXIgYm91bmRhcmllcy5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VFtdPn0gQW4gb2JzZXJ2YWJsZSBvZiBhcnJheXMgb2YgYnVmZmVyZWQgdmFsdWVzLlxuICogQG1ldGhvZCBidWZmZXJUaW1lXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyVGltZTxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBidWZmZXJUaW1lU3BhbjogbnVtYmVyKTogT2JzZXJ2YWJsZTxUW10+IHtcbiAgbGV0IGxlbmd0aDogbnVtYmVyID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICBsZXQgc2NoZWR1bGVyOiBJU2NoZWR1bGVyID0gYXN5bmM7XG4gIGlmIChpc1NjaGVkdWxlcihhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aCAtIDFdKSkge1xuICAgIHNjaGVkdWxlciA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgbGVuZ3RoLS07XG4gIH1cblxuICBsZXQgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbDogbnVtYmVyID0gbnVsbDtcbiAgaWYgKGxlbmd0aCA+PSAyKSB7XG4gICAgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCA9IGFyZ3VtZW50c1sxXTtcbiAgfVxuXG4gIGxldCBtYXhCdWZmZXJTaXplOiBudW1iZXIgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGlmIChsZW5ndGggPj0gMykge1xuICAgIG1heEJ1ZmZlclNpemUgPSBhcmd1bWVudHNbMl07XG4gIH1cblxuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBCdWZmZXJUaW1lT3BlcmF0b3I8VD4oYnVmZmVyVGltZVNwYW4sIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwsIG1heEJ1ZmZlclNpemUsIHNjaGVkdWxlcikpO1xufVxuXG5jbGFzcyBCdWZmZXJUaW1lT3BlcmF0b3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUW10+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBidWZmZXJUaW1lU3BhbjogbnVtYmVyLFxuICAgICAgICAgICAgICBwcml2YXRlIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWw6IG51bWJlcixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBtYXhCdWZmZXJTaXplOiBudW1iZXIsXG4gICAgICAgICAgICAgIHByaXZhdGUgc2NoZWR1bGVyOiBJU2NoZWR1bGVyKSB7XG4gIH1cblxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VFtdPiwgc291cmNlOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBCdWZmZXJUaW1lU3Vic2NyaWJlcihcbiAgICAgIHN1YnNjcmliZXIsIHRoaXMuYnVmZmVyVGltZVNwYW4sIHRoaXMuYnVmZmVyQ3JlYXRpb25JbnRlcnZhbCwgdGhpcy5tYXhCdWZmZXJTaXplLCB0aGlzLnNjaGVkdWxlclxuICAgICkpO1xuICB9XG59XG5cbmNsYXNzIENvbnRleHQ8VD4ge1xuICBidWZmZXI6IFRbXSA9IFtdO1xuICBjbG9zZUFjdGlvbjogU3Vic2NyaXB0aW9uO1xufVxuXG50eXBlIENyZWF0aW9uU3RhdGU8VD4gPSB7XG4gIGJ1ZmZlclRpbWVTcGFuOiBudW1iZXI7XG4gIGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWw6IG51bWJlcixcbiAgc3Vic2NyaWJlcjogQnVmZmVyVGltZVN1YnNjcmliZXI8VD47XG4gIHNjaGVkdWxlcjogSVNjaGVkdWxlcjtcbn07XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBCdWZmZXJUaW1lU3Vic2NyaWJlcjxUPiBleHRlbmRzIFN1YnNjcmliZXI8VD4ge1xuICBwcml2YXRlIGNvbnRleHRzOiBBcnJheTxDb250ZXh0PFQ+PiA9IFtdO1xuICBwcml2YXRlIHRpbWVzcGFuT25seTogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxUW10+LFxuICAgICAgICAgICAgICBwcml2YXRlIGJ1ZmZlclRpbWVTcGFuOiBudW1iZXIsXG4gICAgICAgICAgICAgIHByaXZhdGUgYnVmZmVyQ3JlYXRpb25JbnRlcnZhbDogbnVtYmVyLFxuICAgICAgICAgICAgICBwcml2YXRlIG1heEJ1ZmZlclNpemU6IG51bWJlcixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBzY2hlZHVsZXI6IElTY2hlZHVsZXIpIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMub3BlbkNvbnRleHQoKTtcbiAgICB0aGlzLnRpbWVzcGFuT25seSA9IGJ1ZmZlckNyZWF0aW9uSW50ZXJ2YWwgPT0gbnVsbCB8fCBidWZmZXJDcmVhdGlvbkludGVydmFsIDwgMDtcbiAgICBpZiAodGhpcy50aW1lc3Bhbk9ubHkpIHtcbiAgICAgIGNvbnN0IHRpbWVTcGFuT25seVN0YXRlID0geyBzdWJzY3JpYmVyOiB0aGlzLCBjb250ZXh0LCBidWZmZXJUaW1lU3BhbiB9O1xuICAgICAgdGhpcy5hZGQoY29udGV4dC5jbG9zZUFjdGlvbiA9IHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaEJ1ZmZlclRpbWVTcGFuT25seSwgYnVmZmVyVGltZVNwYW4sIHRpbWVTcGFuT25seVN0YXRlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNsb3NlU3RhdGUgPSB7IHN1YnNjcmliZXI6IHRoaXMsIGNvbnRleHQgfTtcbiAgICAgIGNvbnN0IGNyZWF0aW9uU3RhdGU6IENyZWF0aW9uU3RhdGU8VD4gPSB7IGJ1ZmZlclRpbWVTcGFuLCBidWZmZXJDcmVhdGlvbkludGVydmFsLCBzdWJzY3JpYmVyOiB0aGlzLCBzY2hlZHVsZXIgfTtcbiAgICAgIHRoaXMuYWRkKGNvbnRleHQuY2xvc2VBY3Rpb24gPSBzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hCdWZmZXJDbG9zZSwgYnVmZmVyVGltZVNwYW4sIGNsb3NlU3RhdGUpKTtcbiAgICAgIHRoaXMuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaEJ1ZmZlckNyZWF0aW9uLCBidWZmZXJDcmVhdGlvbkludGVydmFsLCBjcmVhdGlvblN0YXRlKSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHZhbHVlOiBUKSB7XG4gICAgY29uc3QgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuICAgIGNvbnN0IGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcbiAgICBsZXQgZmlsbGVkQnVmZmVyQ29udGV4dDogQ29udGV4dDxUPjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBjb250ZXh0ID0gY29udGV4dHNbaV07XG4gICAgICBjb25zdCBidWZmZXIgPSBjb250ZXh0LmJ1ZmZlcjtcbiAgICAgIGJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoID09IHRoaXMubWF4QnVmZmVyU2l6ZSkge1xuICAgICAgICBmaWxsZWRCdWZmZXJDb250ZXh0ID0gY29udGV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmlsbGVkQnVmZmVyQ29udGV4dCkge1xuICAgICAgdGhpcy5vbkJ1ZmZlckZ1bGwoZmlsbGVkQnVmZmVyQ29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9lcnJvcihlcnI6IGFueSkge1xuICAgIHRoaXMuY29udGV4dHMubGVuZ3RoID0gMDtcbiAgICBzdXBlci5fZXJyb3IoZXJyKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKSB7XG4gICAgY29uc3QgeyBjb250ZXh0cywgZGVzdGluYXRpb24gfSA9IHRoaXM7XG4gICAgd2hpbGUgKGNvbnRleHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjb250ZXh0cy5zaGlmdCgpO1xuICAgICAgZGVzdGluYXRpb24ubmV4dChjb250ZXh0LmJ1ZmZlcik7XG4gICAgfVxuICAgIHN1cGVyLl9jb21wbGV0ZSgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF91bnN1YnNjcmliZSgpIHtcbiAgICB0aGlzLmNvbnRleHRzID0gbnVsbDtcbiAgfVxuXG4gIHByb3RlY3RlZCBvbkJ1ZmZlckZ1bGwoY29udGV4dDogQ29udGV4dDxUPikge1xuICAgIHRoaXMuY2xvc2VDb250ZXh0KGNvbnRleHQpO1xuICAgIGNvbnN0IGNsb3NlQWN0aW9uID0gY29udGV4dC5jbG9zZUFjdGlvbjtcbiAgICBjbG9zZUFjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMucmVtb3ZlKGNsb3NlQWN0aW9uKTtcblxuICAgIGlmICghdGhpcy5jbG9zZWQgJiYgdGhpcy50aW1lc3Bhbk9ubHkpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzLm9wZW5Db250ZXh0KCk7XG4gICAgICBjb25zdCBidWZmZXJUaW1lU3BhbiA9IHRoaXMuYnVmZmVyVGltZVNwYW47XG4gICAgICBjb25zdCB0aW1lU3Bhbk9ubHlTdGF0ZSA9IHsgc3Vic2NyaWJlcjogdGhpcywgY29udGV4dCwgYnVmZmVyVGltZVNwYW4gfTtcbiAgICAgIHRoaXMuYWRkKGNvbnRleHQuY2xvc2VBY3Rpb24gPSB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaEJ1ZmZlclRpbWVTcGFuT25seSwgYnVmZmVyVGltZVNwYW4sIHRpbWVTcGFuT25seVN0YXRlKSk7XG4gICAgfVxuICB9XG5cbiAgb3BlbkNvbnRleHQoKTogQ29udGV4dDxUPiB7XG4gICAgY29uc3QgY29udGV4dDogQ29udGV4dDxUPiA9IG5ldyBDb250ZXh0PFQ+KCk7XG4gICAgdGhpcy5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgY2xvc2VDb250ZXh0KGNvbnRleHQ6IENvbnRleHQ8VD4pIHtcbiAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoY29udGV4dC5idWZmZXIpO1xuICAgIGNvbnN0IGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcblxuICAgIGNvbnN0IHNwbGljZUluZGV4ID0gY29udGV4dHMgPyBjb250ZXh0cy5pbmRleE9mKGNvbnRleHQpIDogLTE7XG4gICAgaWYgKHNwbGljZUluZGV4ID49IDApIHtcbiAgICAgIGNvbnRleHRzLnNwbGljZShjb250ZXh0cy5pbmRleE9mKGNvbnRleHQpLCAxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hCdWZmZXJUaW1lU3Bhbk9ubHkodGhpczogQWN0aW9uPGFueT4sIHN0YXRlOiBhbnkpIHtcbiAgY29uc3Qgc3Vic2NyaWJlcjogQnVmZmVyVGltZVN1YnNjcmliZXI8YW55PiA9IHN0YXRlLnN1YnNjcmliZXI7XG5cbiAgY29uc3QgcHJldkNvbnRleHQgPSBzdGF0ZS5jb250ZXh0O1xuICBpZiAocHJldkNvbnRleHQpIHtcbiAgICBzdWJzY3JpYmVyLmNsb3NlQ29udGV4dChwcmV2Q29udGV4dCk7XG4gIH1cblxuICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgc3RhdGUuY29udGV4dCA9IHN1YnNjcmliZXIub3BlbkNvbnRleHQoKTtcbiAgICBzdGF0ZS5jb250ZXh0LmNsb3NlQWN0aW9uID0gdGhpcy5zY2hlZHVsZShzdGF0ZSwgc3RhdGUuYnVmZmVyVGltZVNwYW4pO1xuICB9XG59XG5cbmludGVyZmFjZSBEaXNwYXRjaEFyZzxUPiB7XG4gIHN1YnNjcmliZXI6IEJ1ZmZlclRpbWVTdWJzY3JpYmVyPFQ+O1xuICBjb250ZXh0OiBDb250ZXh0PFQ+O1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEJ1ZmZlckNyZWF0aW9uPFQ+KHRoaXM6IEFjdGlvbjxDcmVhdGlvblN0YXRlPFQ+Piwgc3RhdGU6IENyZWF0aW9uU3RhdGU8VD4pIHtcbiAgY29uc3QgeyBidWZmZXJDcmVhdGlvbkludGVydmFsLCBidWZmZXJUaW1lU3Bhbiwgc3Vic2NyaWJlciwgc2NoZWR1bGVyIH0gPSBzdGF0ZTtcbiAgY29uc3QgY29udGV4dCA9IHN1YnNjcmliZXIub3BlbkNvbnRleHQoKTtcbiAgY29uc3QgYWN0aW9uID0gPEFjdGlvbjxDcmVhdGlvblN0YXRlPFQ+Pj50aGlzO1xuICBpZiAoIXN1YnNjcmliZXIuY2xvc2VkKSB7XG4gICAgc3Vic2NyaWJlci5hZGQoY29udGV4dC5jbG9zZUFjdGlvbiA9IHNjaGVkdWxlci5zY2hlZHVsZTxEaXNwYXRjaEFyZzxUPj4oZGlzcGF0Y2hCdWZmZXJDbG9zZSwgYnVmZmVyVGltZVNwYW4sIHsgc3Vic2NyaWJlciwgY29udGV4dCB9KSk7XG4gICAgYWN0aW9uLnNjaGVkdWxlKHN0YXRlLCBidWZmZXJDcmVhdGlvbkludGVydmFsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEJ1ZmZlckNsb3NlPFQ+KGFyZzogRGlzcGF0Y2hBcmc8VD4pIHtcbiAgY29uc3QgeyBzdWJzY3JpYmVyLCBjb250ZXh0IH0gPSBhcmc7XG4gIHN1YnNjcmliZXIuY2xvc2VDb250ZXh0KGNvbnRleHQpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9idWZmZXJUaW1lLnRzIiwiaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJzY3JpYmFibGVPclByb21pc2UgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5cbmltcG9ydCB7IHN1YnNjcmliZVRvUmVzdWx0IH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCc7XG5pbXBvcnQgeyBPdXRlclN1YnNjcmliZXIgfSBmcm9tICcuLi9PdXRlclN1YnNjcmliZXInO1xuaW1wb3J0IHsgSW5uZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vSW5uZXJTdWJzY3JpYmVyJztcblxuLyoqXG4gKiBCdWZmZXJzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgc3RhcnRpbmcgZnJvbSBhbiBlbWlzc2lvbiBmcm9tXG4gKiBgb3BlbmluZ3NgIGFuZCBlbmRpbmcgd2hlbiB0aGUgb3V0cHV0IG9mIGBjbG9zaW5nU2VsZWN0b3JgIGVtaXRzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5Db2xsZWN0cyB2YWx1ZXMgZnJvbSB0aGUgcGFzdCBhcyBhbiBhcnJheS4gU3RhcnRzXG4gKiBjb2xsZWN0aW5nIG9ubHkgd2hlbiBgb3BlbmluZ2AgZW1pdHMsIGFuZCBjYWxscyB0aGUgYGNsb3NpbmdTZWxlY3RvcmBcbiAqIGZ1bmN0aW9uIHRvIGdldCBhbiBPYnNlcnZhYmxlIHRoYXQgdGVsbHMgd2hlbiB0byBjbG9zZSB0aGUgYnVmZmVyLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2J1ZmZlclRvZ2dsZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBCdWZmZXJzIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgYnkgb3BlbmluZyB0aGUgYnVmZmVyIHZpYSBzaWduYWxzIGZyb20gYW5cbiAqIE9ic2VydmFibGUgcHJvdmlkZWQgdG8gYG9wZW5pbmdzYCwgYW5kIGNsb3NpbmcgYW5kIHNlbmRpbmcgdGhlIGJ1ZmZlcnMgd2hlblxuICogYSBTdWJzY3JpYmFibGUgb3IgUHJvbWlzZSByZXR1cm5lZCBieSB0aGUgYGNsb3NpbmdTZWxlY3RvcmAgZnVuY3Rpb24gZW1pdHMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RXZlcnkgb3RoZXIgc2Vjb25kLCBlbWl0IHRoZSBjbGljayBldmVudHMgZnJvbSB0aGUgbmV4dCA1MDBtczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgb3BlbmluZ3MgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIGJ1ZmZlcmVkID0gY2xpY2tzLmJ1ZmZlclRvZ2dsZShvcGVuaW5ncywgaSA9PlxuICogICBpICUgMiA/IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwKSA6IFJ4Lk9ic2VydmFibGUuZW1wdHkoKVxuICogKTtcbiAqIGJ1ZmZlcmVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBidWZmZXJ9XG4gKiBAc2VlIHtAbGluayBidWZmZXJDb3VudH1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlclRpbWV9XG4gKiBAc2VlIHtAbGluayBidWZmZXJXaGVufVxuICogQHNlZSB7QGxpbmsgd2luZG93VG9nZ2xlfVxuICpcbiAqIEBwYXJhbSB7U3Vic2NyaWJhYmxlT3JQcm9taXNlPE8+fSBvcGVuaW5ncyBBIFN1YnNjcmliYWJsZSBvciBQcm9taXNlIG9mIG5vdGlmaWNhdGlvbnMgdG8gc3RhcnQgbmV3XG4gKiBidWZmZXJzLlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogTyk6IFN1YnNjcmliYWJsZU9yUHJvbWlzZX0gY2xvc2luZ1NlbGVjdG9yIEEgZnVuY3Rpb24gdGhhdCB0YWtlc1xuICogdGhlIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIGBvcGVuaW5nc2Agb2JzZXJ2YWJsZSBhbmQgcmV0dXJucyBhIFN1YnNjcmliYWJsZSBvciBQcm9taXNlLFxuICogd2hpY2gsIHdoZW4gaXQgZW1pdHMsIHNpZ25hbHMgdGhhdCB0aGUgYXNzb2NpYXRlZCBidWZmZXIgc2hvdWxkIGJlIGVtaXR0ZWRcbiAqIGFuZCBjbGVhcmVkLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUW10+fSBBbiBvYnNlcnZhYmxlIG9mIGFycmF5cyBvZiBidWZmZXJlZCB2YWx1ZXMuXG4gKiBAbWV0aG9kIGJ1ZmZlclRvZ2dsZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlclRvZ2dsZTxULCBPPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBvcGVuaW5nczogU3Vic2NyaWJhYmxlT3JQcm9taXNlPE8+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zaW5nU2VsZWN0b3I6ICh2YWx1ZTogTykgPT4gU3Vic2NyaWJhYmxlT3JQcm9taXNlPGFueT4pOiBPYnNlcnZhYmxlPFRbXT4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBCdWZmZXJUb2dnbGVPcGVyYXRvcjxULCBPPihvcGVuaW5ncywgY2xvc2luZ1NlbGVjdG9yKSk7XG59XG5cbmNsYXNzIEJ1ZmZlclRvZ2dsZU9wZXJhdG9yPFQsIE8+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVFtdPiB7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBvcGVuaW5nczogU3Vic2NyaWJhYmxlT3JQcm9taXNlPE8+LFxuICAgICAgICAgICAgICBwcml2YXRlIGNsb3NpbmdTZWxlY3RvcjogKHZhbHVlOiBPKSA9PiBTdWJzY3JpYmFibGVPclByb21pc2U8YW55Pikge1xuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFRbXT4sIHNvdXJjZTogYW55KTogYW55IHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm9wZW5pbmdzLCB0aGlzLmNsb3NpbmdTZWxlY3RvcikpO1xuICB9XG59XG5cbmludGVyZmFjZSBCdWZmZXJDb250ZXh0PFQ+IHtcbiAgYnVmZmVyOiBUW107XG4gIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgQnVmZmVyVG9nZ2xlU3Vic2NyaWJlcjxULCBPPiBleHRlbmRzIE91dGVyU3Vic2NyaWJlcjxULCBPPiB7XG4gIHByaXZhdGUgY29udGV4dHM6IEFycmF5PEJ1ZmZlckNvbnRleHQ8VD4+ID0gW107XG5cbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8VFtdPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBvcGVuaW5nczogU3Vic2NyaWJhYmxlT3JQcm9taXNlPE8+LFxuICAgICAgICAgICAgICBwcml2YXRlIGNsb3NpbmdTZWxlY3RvcjogKHZhbHVlOiBPKSA9PiBTdWJzY3JpYmFibGVPclByb21pc2U8YW55PiB8IHZvaWQpIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgb3BlbmluZ3MpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIGNvbnN0IGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICBjb25zdCBsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29udGV4dHNbaV0uYnVmZmVyLnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfZXJyb3IoZXJyOiBhbnkpOiB2b2lkIHtcbiAgICBjb25zdCBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG4gICAgd2hpbGUgKGNvbnRleHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSBjb250ZXh0cy5zaGlmdCgpO1xuICAgICAgY29udGV4dC5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIGNvbnRleHQuYnVmZmVyID0gbnVsbDtcbiAgICAgIGNvbnRleHQuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jb250ZXh0cyA9IG51bGw7XG4gICAgc3VwZXIuX2Vycm9yKGVycik7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbXBsZXRlKCk6IHZvaWQge1xuICAgIGNvbnN0IGNvbnRleHRzID0gdGhpcy5jb250ZXh0cztcbiAgICB3aGlsZSAoY29udGV4dHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY29udGV4dCA9IGNvbnRleHRzLnNoaWZ0KCk7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoY29udGV4dC5idWZmZXIpO1xuICAgICAgY29udGV4dC5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIGNvbnRleHQuYnVmZmVyID0gbnVsbDtcbiAgICAgIGNvbnRleHQuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jb250ZXh0cyA9IG51bGw7XG4gICAgc3VwZXIuX2NvbXBsZXRlKCk7XG4gIH1cblxuICBub3RpZnlOZXh0KG91dGVyVmFsdWU6IGFueSwgaW5uZXJWYWx1ZTogTyxcbiAgICAgICAgICAgICBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgICBpbm5lclN1YjogSW5uZXJTdWJzY3JpYmVyPFQsIE8+KTogdm9pZCB7XG4gICAgb3V0ZXJWYWx1ZSA/IHRoaXMuY2xvc2VCdWZmZXIob3V0ZXJWYWx1ZSkgOiB0aGlzLm9wZW5CdWZmZXIoaW5uZXJWYWx1ZSk7XG4gIH1cblxuICBub3RpZnlDb21wbGV0ZShpbm5lclN1YjogSW5uZXJTdWJzY3JpYmVyPFQsIE8+KTogdm9pZCB7XG4gICAgdGhpcy5jbG9zZUJ1ZmZlcigoPGFueT4gaW5uZXJTdWIpLmNvbnRleHQpO1xuICB9XG5cbiAgcHJpdmF0ZSBvcGVuQnVmZmVyKHZhbHVlOiBPKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNsb3NpbmdTZWxlY3RvciA9IHRoaXMuY2xvc2luZ1NlbGVjdG9yO1xuICAgICAgY29uc3QgY2xvc2luZ05vdGlmaWVyID0gY2xvc2luZ1NlbGVjdG9yLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgaWYgKGNsb3NpbmdOb3RpZmllcikge1xuICAgICAgICB0aGlzLnRyeVN1YnNjcmliZShjbG9zaW5nTm90aWZpZXIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fZXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGNsb3NlQnVmZmVyKGNvbnRleHQ6IEJ1ZmZlckNvbnRleHQ8VD4pOiB2b2lkIHtcbiAgICBjb25zdCBjb250ZXh0cyA9IHRoaXMuY29udGV4dHM7XG5cbiAgICBpZiAoY29udGV4dHMgJiYgY29udGV4dCkge1xuICAgICAgY29uc3QgeyBidWZmZXIsIHN1YnNjcmlwdGlvbiB9ID0gY29udGV4dDtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICAgICAgY29udGV4dHMuc3BsaWNlKGNvbnRleHRzLmluZGV4T2YoY29udGV4dCksIDEpO1xuICAgICAgdGhpcy5yZW1vdmUoc3Vic2NyaXB0aW9uKTtcbiAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdHJ5U3Vic2NyaWJlKGNsb3NpbmdOb3RpZmllcjogYW55KTogdm9pZCB7XG4gICAgY29uc3QgY29udGV4dHMgPSB0aGlzLmNvbnRleHRzO1xuXG4gICAgY29uc3QgYnVmZmVyOiBBcnJheTxUPiA9IFtdO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICBjb25zdCBjb250ZXh0ID0geyBidWZmZXIsIHN1YnNjcmlwdGlvbiB9O1xuICAgIGNvbnRleHRzLnB1c2goY29udGV4dCk7XG5cbiAgICBjb25zdCBpbm5lclN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGNsb3NpbmdOb3RpZmllciwgPGFueT5jb250ZXh0KTtcblxuICAgIGlmICghaW5uZXJTdWJzY3JpcHRpb24gfHwgaW5uZXJTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICB0aGlzLmNsb3NlQnVmZmVyKGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAoPGFueT4gaW5uZXJTdWJzY3JpcHRpb24pLmNvbnRleHQgPSBjb250ZXh0O1xuXG4gICAgICB0aGlzLmFkZChpbm5lclN1YnNjcmlwdGlvbik7XG4gICAgICBzdWJzY3JpcHRpb24uYWRkKGlubmVyU3Vic2NyaXB0aW9uKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvYnVmZmVyVG9nZ2xlLnRzIiwiaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgdHJ5Q2F0Y2ggfSBmcm9tICcuLi91dGlsL3RyeUNhdGNoJztcbmltcG9ydCB7IGVycm9yT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9lcnJvck9iamVjdCc7XG5cbmltcG9ydCB7IE91dGVyU3Vic2NyaWJlciB9IGZyb20gJy4uL091dGVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBJbm5lclN1YnNjcmliZXIgfSBmcm9tICcuLi9Jbm5lclN1YnNjcmliZXInO1xuaW1wb3J0IHsgc3Vic2NyaWJlVG9SZXN1bHQgfSBmcm9tICcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0JztcblxuLyoqXG4gKiBCdWZmZXJzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMsIHVzaW5nIGEgZmFjdG9yeSBmdW5jdGlvbiBvZiBjbG9zaW5nXG4gKiBPYnNlcnZhYmxlcyB0byBkZXRlcm1pbmUgd2hlbiB0byBjbG9zZSwgZW1pdCwgYW5kIHJlc2V0IHRoZSBidWZmZXIuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkNvbGxlY3RzIHZhbHVlcyBmcm9tIHRoZSBwYXN0IGFzIGFuIGFycmF5LiBXaGVuIGl0XG4gKiBzdGFydHMgY29sbGVjdGluZyB2YWx1ZXMsIGl0IGNhbGxzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdFxuICogdGVsbHMgd2hlbiB0byBjbG9zZSB0aGUgYnVmZmVyIGFuZCByZXN0YXJ0IGNvbGxlY3RpbmcuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvYnVmZmVyV2hlbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBPcGVucyBhIGJ1ZmZlciBpbW1lZGlhdGVseSwgdGhlbiBjbG9zZXMgdGhlIGJ1ZmZlciB3aGVuIHRoZSBvYnNlcnZhYmxlXG4gKiByZXR1cm5lZCBieSBjYWxsaW5nIGBjbG9zaW5nU2VsZWN0b3JgIGZ1bmN0aW9uIGVtaXRzIGEgdmFsdWUuIFdoZW4gaXQgY2xvc2VzXG4gKiB0aGUgYnVmZmVyLCBpdCBpbW1lZGlhdGVseSBvcGVucyBhIG5ldyBidWZmZXIgYW5kIHJlcGVhdHMgdGhlIHByb2Nlc3MuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBhbiBhcnJheSBvZiB0aGUgbGFzdCBjbGlja3MgZXZlcnkgWzEtNV0gcmFuZG9tIHNlY29uZHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGJ1ZmZlcmVkID0gY2xpY2tzLmJ1ZmZlcldoZW4oKCkgPT5cbiAqICAgUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwICsgTWF0aC5yYW5kb20oKSAqIDQwMDApXG4gKiApO1xuICogYnVmZmVyZWQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcn1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlckNvdW50fVxuICogQHNlZSB7QGxpbmsgYnVmZmVyVGltZX1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlclRvZ2dsZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1doZW59XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbigpOiBPYnNlcnZhYmxlfSBjbG9zaW5nU2VsZWN0b3IgQSBmdW5jdGlvbiB0aGF0IHRha2VzIG5vXG4gKiBhcmd1bWVudHMgYW5kIHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IHNpZ25hbHMgYnVmZmVyIGNsb3N1cmUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFRbXT59IEFuIG9ic2VydmFibGUgb2YgYXJyYXlzIG9mIGJ1ZmZlcmVkIHZhbHVlcy5cbiAqIEBtZXRob2QgYnVmZmVyV2hlblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlcldoZW48VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgY2xvc2luZ1NlbGVjdG9yOiAoKSA9PiBPYnNlcnZhYmxlPGFueT4pOiBPYnNlcnZhYmxlPFRbXT4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBCdWZmZXJXaGVuT3BlcmF0b3I8VD4oY2xvc2luZ1NlbGVjdG9yKSk7XG59XG5cbmNsYXNzIEJ1ZmZlcldoZW5PcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFRbXT4ge1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY2xvc2luZ1NlbGVjdG9yOiAoKSA9PiBPYnNlcnZhYmxlPGFueT4pIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUW10+LCBzb3VyY2U6IGFueSk6IGFueSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEJ1ZmZlcldoZW5TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY2xvc2luZ1NlbGVjdG9yKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIEJ1ZmZlcldoZW5TdWJzY3JpYmVyPFQ+IGV4dGVuZHMgT3V0ZXJTdWJzY3JpYmVyPFQsIGFueT4ge1xuICBwcml2YXRlIGJ1ZmZlcjogVFtdO1xuICBwcml2YXRlIHN1YnNjcmliaW5nOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgY2xvc2luZ1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFRbXT4sIHByaXZhdGUgY2xvc2luZ1NlbGVjdG9yOiAoKSA9PiBPYnNlcnZhYmxlPGFueT4pIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gICAgdGhpcy5vcGVuQnVmZmVyKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpIHtcbiAgICB0aGlzLmJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKSB7XG4gICAgY29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgaWYgKGJ1ZmZlcikge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGJ1ZmZlcik7XG4gICAgfVxuICAgIHN1cGVyLl9jb21wbGV0ZSgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF91bnN1YnNjcmliZSgpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgdGhpcy5zdWJzY3JpYmluZyA9IGZhbHNlO1xuICB9XG5cbiAgbm90aWZ5TmV4dChvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBhbnksXG4gICAgICAgICAgICAgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICAgaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBhbnk+KTogdm9pZCB7XG4gICAgdGhpcy5vcGVuQnVmZmVyKCk7XG4gIH1cblxuICBub3RpZnlDb21wbGV0ZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpYmluZykge1xuICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9wZW5CdWZmZXIoKTtcbiAgICB9XG4gIH1cblxuICBvcGVuQnVmZmVyKCkge1xuXG4gICAgbGV0IHsgY2xvc2luZ1N1YnNjcmlwdGlvbiB9ID0gdGhpcztcblxuICAgIGlmIChjbG9zaW5nU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLnJlbW92ZShjbG9zaW5nU3Vic2NyaXB0aW9uKTtcbiAgICAgIGNsb3NpbmdTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChidWZmZXIpO1xuICAgIH1cblxuICAgIHRoaXMuYnVmZmVyID0gW107XG5cbiAgICBjb25zdCBjbG9zaW5nTm90aWZpZXIgPSB0cnlDYXRjaCh0aGlzLmNsb3NpbmdTZWxlY3RvcikoKTtcblxuICAgIGlmIChjbG9zaW5nTm90aWZpZXIgPT09IGVycm9yT2JqZWN0KSB7XG4gICAgICB0aGlzLmVycm9yKGVycm9yT2JqZWN0LmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zaW5nU3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgdGhpcy5jbG9zaW5nU3Vic2NyaXB0aW9uID0gY2xvc2luZ1N1YnNjcmlwdGlvbjtcbiAgICAgIHRoaXMuYWRkKGNsb3NpbmdTdWJzY3JpcHRpb24pO1xuICAgICAgdGhpcy5zdWJzY3JpYmluZyA9IHRydWU7XG4gICAgICBjbG9zaW5nU3Vic2NyaXB0aW9uLmFkZChzdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBjbG9zaW5nTm90aWZpZXIpKTtcbiAgICAgIHRoaXMuc3Vic2NyaWJpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvYnVmZmVyV2hlbi50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2YWJsZUlucHV0IH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5cbmltcG9ydCB7IE91dGVyU3Vic2NyaWJlciB9IGZyb20gJy4uL091dGVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBzdWJzY3JpYmVUb1Jlc3VsdCB9IGZyb20gJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnO1xuXG4vKipcbiAqIENhdGNoZXMgZXJyb3JzIG9uIHRoZSBvYnNlcnZhYmxlIHRvIGJlIGhhbmRsZWQgYnkgcmV0dXJuaW5nIGEgbmV3IG9ic2VydmFibGUgb3IgdGhyb3dpbmcgYW4gZXJyb3IuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9jYXRjaC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db250aW51ZXMgd2l0aCBhIGRpZmZlcmVudCBPYnNlcnZhYmxlIHdoZW4gdGhlcmUncyBhbiBlcnJvcjwvY2FwdGlvbj5cbiAqXG4gKiBPYnNlcnZhYmxlLm9mKDEsIDIsIDMsIDQsIDUpXG4gKiAgIC5tYXAobiA9PiB7XG4gKiBcdCAgIGlmIChuID09IDQpIHtcbiAqIFx0ICAgICB0aHJvdyAnZm91ciEnO1xuICogICAgIH1cbiAqXHQgICByZXR1cm4gbjtcbiAqICAgfSlcbiAqICAgLmNhdGNoKGVyciA9PiBPYnNlcnZhYmxlLm9mKCdJJywgJ0lJJywgJ0lJSScsICdJVicsICdWJykpXG4gKiAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKiAgIC8vIDEsIDIsIDMsIEksIElJLCBJSUksIElWLCBWXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmV0cmllcyB0aGUgY2F1Z2h0IHNvdXJjZSBPYnNlcnZhYmxlIGFnYWluIGluIGNhc2Ugb2YgZXJyb3IsIHNpbWlsYXIgdG8gcmV0cnkoKSBvcGVyYXRvcjwvY2FwdGlvbj5cbiAqXG4gKiBPYnNlcnZhYmxlLm9mKDEsIDIsIDMsIDQsIDUpXG4gKiAgIC5tYXAobiA9PiB7XG4gKiBcdCAgIGlmIChuID09PSA0KSB7XG4gKiBcdCAgICAgdGhyb3cgJ2ZvdXIhJztcbiAqICAgICB9XG4gKiBcdCAgIHJldHVybiBuO1xuICogICB9KVxuICogICAuY2F0Y2goKGVyciwgY2F1Z2h0KSA9PiBjYXVnaHQpXG4gKiAgIC50YWtlKDMwKVxuICogICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICogICAvLyAxLCAyLCAzLCAxLCAyLCAzLCAuLi5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5UaHJvd3MgYSBuZXcgZXJyb3Igd2hlbiB0aGUgc291cmNlIE9ic2VydmFibGUgdGhyb3dzIGFuIGVycm9yPC9jYXB0aW9uPlxuICpcbiAqIE9ic2VydmFibGUub2YoMSwgMiwgMywgNCwgNSlcbiAqICAgLm1hcChuID0+IHtcbiAqICAgICBpZiAobiA9PSA0KSB7XG4gKiAgICAgICB0aHJvdyAnZm91ciEnO1xuICogICAgIH1cbiAqICAgICByZXR1cm4gbjtcbiAqICAgfSlcbiAqICAgLmNhdGNoKGVyciA9PiB7XG4gKiAgICAgdGhyb3cgJ2Vycm9yIGluIHNvdXJjZS4gRGV0YWlsczogJyArIGVycjtcbiAqICAgfSlcbiAqICAgLnN1YnNjcmliZShcbiAqICAgICB4ID0+IGNvbnNvbGUubG9nKHgpLFxuICogICAgIGVyciA9PiBjb25zb2xlLmxvZyhlcnIpXG4gKiAgICk7XG4gKiAgIC8vIDEsIDIsIDMsIGVycm9yIGluIHNvdXJjZS4gRGV0YWlsczogZm91ciFcbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzZWxlY3RvciBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYXMgYXJndW1lbnRzIGBlcnJgLCB3aGljaCBpcyB0aGUgZXJyb3IsIGFuZCBgY2F1Z2h0YCwgd2hpY2hcbiAqICBpcyB0aGUgc291cmNlIG9ic2VydmFibGUsIGluIGNhc2UgeW91J2QgbGlrZSB0byBcInJldHJ5XCIgdGhhdCBvYnNlcnZhYmxlIGJ5IHJldHVybmluZyBpdCBhZ2Fpbi4gV2hhdGV2ZXIgb2JzZXJ2YWJsZVxuICogIGlzIHJldHVybmVkIGJ5IHRoZSBgc2VsZWN0b3JgIHdpbGwgYmUgdXNlZCB0byBjb250aW51ZSB0aGUgb2JzZXJ2YWJsZSBjaGFpbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgdGhhdCBvcmlnaW5hdGVzIGZyb20gZWl0aGVyIHRoZSBzb3VyY2Ugb3IgdGhlIG9ic2VydmFibGUgcmV0dXJuZWQgYnkgdGhlXG4gKiAgY2F0Y2ggYHNlbGVjdG9yYCBmdW5jdGlvbi5cbiAqIEBtZXRob2QgY2F0Y2hcbiAqIEBuYW1lIGNhdGNoXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NhdGNoPFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHNlbGVjdG9yOiAoZXJyOiBhbnksIGNhdWdodDogT2JzZXJ2YWJsZTxUPikgPT4gT2JzZXJ2YWJsZUlucHV0PFI+KTogT2JzZXJ2YWJsZTxUIHwgUj4ge1xuICBjb25zdCBvcGVyYXRvciA9IG5ldyBDYXRjaE9wZXJhdG9yKHNlbGVjdG9yKTtcbiAgY29uc3QgY2F1Z2h0ID0gdGhpcy5saWZ0KG9wZXJhdG9yKTtcbiAgcmV0dXJuIChvcGVyYXRvci5jYXVnaHQgPSBjYXVnaHQpO1xufVxuXG5jbGFzcyBDYXRjaE9wZXJhdG9yPFQsIFI+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVCB8IFI+IHtcbiAgY2F1Z2h0OiBPYnNlcnZhYmxlPFQ+O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc2VsZWN0b3I6IChlcnI6IGFueSwgY2F1Z2h0OiBPYnNlcnZhYmxlPFQ+KSA9PiBPYnNlcnZhYmxlSW5wdXQ8VCB8IFI+KSB7XG4gIH1cblxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8Uj4sIHNvdXJjZTogYW55KTogYW55IHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgQ2F0Y2hTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuc2VsZWN0b3IsIHRoaXMuY2F1Z2h0KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIENhdGNoU3Vic2NyaWJlcjxULCBSPiBleHRlbmRzIE91dGVyU3Vic2NyaWJlcjxULCBUIHwgUj4ge1xuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxhbnk+LFxuICAgICAgICAgICAgICBwcml2YXRlIHNlbGVjdG9yOiAoZXJyOiBhbnksIGNhdWdodDogT2JzZXJ2YWJsZTxUPikgPT4gT2JzZXJ2YWJsZUlucHV0PFQgfCBSPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBjYXVnaHQ6IE9ic2VydmFibGU8VD4pIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gIH1cblxuICAvLyBOT1RFOiBvdmVycmlkaW5nIGBlcnJvcmAgaW5zdGVhZCBvZiBgX2Vycm9yYCBiZWNhdXNlIHdlIGRvbid0IHdhbnRcbiAgLy8gdG8gaGF2ZSB0aGlzIGZsYWcgdGhpcyBzdWJzY3JpYmVyIGFzIGBpc1N0b3BwZWRgLiBXZSBjYW4gbWltaWMgdGhlXG4gIC8vIGJlaGF2aW9yIG9mIHRoZSBSZXRyeVN1YnNjcmliZXIgKGZyb20gdGhlIGByZXRyeWAgb3BlcmF0b3IpLCB3aGVyZVxuICAvLyB3ZSB1bnN1YnNjcmliZSBmcm9tIG91ciBzb3VyY2UgY2hhaW4sIHJlc2V0IG91ciBTdWJzY3JpYmVyIGZsYWdzLFxuICAvLyB0aGVuIHN1YnNjcmliZSB0byB0aGUgc2VsZWN0b3IgcmVzdWx0LlxuICBlcnJvcihlcnI6IGFueSkge1xuICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgIGxldCByZXN1bHQ6IGFueTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuc2VsZWN0b3IoZXJyLCB0aGlzLmNhdWdodCk7XG4gICAgICB9IGNhdGNoIChlcnIyKSB7XG4gICAgICAgIHN1cGVyLmVycm9yKGVycjIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl91bnN1YnNjcmliZUFuZFJlY3ljbGUoKTtcbiAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJlc3VsdCkpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9jYXRjaC50cyIsImltcG9ydCB7IENvbWJpbmVMYXRlc3RPcGVyYXRvciB9IGZyb20gJy4vY29tYmluZUxhdGVzdCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5cbi8qKlxuICogQ29udmVydHMgYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZSBpbnRvIGEgZmlyc3Qtb3JkZXIgT2JzZXJ2YWJsZSBieSB3YWl0aW5nXG4gKiBmb3IgdGhlIG91dGVyIE9ic2VydmFibGUgdG8gY29tcGxldGUsIHRoZW4gYXBwbHlpbmcge0BsaW5rIGNvbWJpbmVMYXRlc3R9LlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBhbiBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzIGJ5IGFwcGx5aW5nXG4gKiB7QGxpbmsgY29tYmluZUxhdGVzdH0gd2hlbiB0aGUgT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlcyBjb21wbGV0ZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29tYmluZUFsbC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBUYWtlcyBhbiBPYnNlcnZhYmxlIG9mIE9ic2VydmFibGVzLCBhbmQgY29sbGVjdHMgYWxsIE9ic2VydmFibGVzIGZyb20gaXQuXG4gKiBPbmNlIHRoZSBvdXRlciBPYnNlcnZhYmxlIGNvbXBsZXRlcywgaXQgc3Vic2NyaWJlcyB0byBhbGwgY29sbGVjdGVkXG4gKiBPYnNlcnZhYmxlcyBhbmQgY29tYmluZXMgdGhlaXIgdmFsdWVzIHVzaW5nIHRoZSB7QGxpbmsgY29tYmluZUxhdGVzdH1cbiAqIHN0cmF0ZWd5LCBzdWNoIHRoYXQ6XG4gKiAtIEV2ZXJ5IHRpbWUgYW4gaW5uZXIgT2JzZXJ2YWJsZSBlbWl0cywgdGhlIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzLlxuICogLSBXaGVuIHRoZSByZXR1cm5lZCBvYnNlcnZhYmxlIGVtaXRzLCBpdCBlbWl0cyBhbGwgb2YgdGhlIGxhdGVzdCB2YWx1ZXMgYnk6XG4gKiAgIC0gSWYgYSBgcHJvamVjdGAgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIGl0IGlzIGNhbGxlZCB3aXRoIGVhY2ggcmVjZW50IHZhbHVlXG4gKiAgICAgZnJvbSBlYWNoIGlubmVyIE9ic2VydmFibGUgaW4gd2hhdGV2ZXIgb3JkZXIgdGhleSBhcnJpdmVkLCBhbmQgdGhlIHJlc3VsdFxuICogICAgIG9mIHRoZSBgcHJvamVjdGAgZnVuY3Rpb24gaXMgd2hhdCBpcyBlbWl0dGVkIGJ5IHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqICAgLSBJZiB0aGVyZSBpcyBubyBgcHJvamVjdGAgZnVuY3Rpb24sIGFuIGFycmF5IG9mIGFsbCBvZiB0aGUgbW9zdCByZWNlbnRcbiAqICAgICB2YWx1ZXMgaXMgZW1pdHRlZCBieSB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+TWFwIHR3byBjbGljayBldmVudHMgdG8gYSBmaW5pdGUgaW50ZXJ2YWwgT2JzZXJ2YWJsZSwgdGhlbiBhcHBseSBjb21iaW5lQWxsPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBoaWdoZXJPcmRlciA9IGNsaWNrcy5tYXAoZXYgPT5cbiAqICAgUnguT2JzZXJ2YWJsZS5pbnRlcnZhbChNYXRoLnJhbmRvbSgpKjIwMDApLnRha2UoMylcbiAqICkudGFrZSgyKTtcbiAqIHZhciByZXN1bHQgPSBoaWdoZXJPcmRlci5jb21iaW5lQWxsKCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVMYXRlc3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJvamVjdF0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gbWFwIHRoZSBtb3N0IHJlY2VudFxuICogdmFsdWVzIGZyb20gZWFjaCBpbm5lciBPYnNlcnZhYmxlIGludG8gYSBuZXcgcmVzdWx0LiBUYWtlcyBlYWNoIG9mIHRoZSBtb3N0XG4gKiByZWNlbnQgdmFsdWVzIGZyb20gZWFjaCBjb2xsZWN0ZWQgaW5uZXIgT2JzZXJ2YWJsZSBhcyBhcmd1bWVudHMsIGluIG9yZGVyLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiBwcm9qZWN0ZWQgcmVzdWx0cyBvciBhcnJheXMgb2YgcmVjZW50XG4gKiB2YWx1ZXMuXG4gKiBAbWV0aG9kIGNvbWJpbmVBbGxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21iaW5lQWxsPFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHByb2plY3Q/OiAoLi4udmFsdWVzOiBBcnJheTxhbnk+KSA9PiBSKTogT2JzZXJ2YWJsZTxSPiB7XG4gIHJldHVybiB0aGlzLmxpZnQobmV3IENvbWJpbmVMYXRlc3RPcGVyYXRvcihwcm9qZWN0KSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL2NvbWJpbmVBbGwudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpYmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IE1lcmdlQWxsT3BlcmF0b3IgfSBmcm9tICcuL21lcmdlQWxsJztcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0QWxsPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4pOiBUO1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEFsbDxULCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+KTogU3Vic2NyaWJhYmxlPFI+O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlIGludG8gYSBmaXJzdC1vcmRlciBPYnNlcnZhYmxlIGJ5XG4gKiBjb25jYXRlbmF0aW5nIHRoZSBpbm5lciBPYnNlcnZhYmxlcyBpbiBvcmRlci5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RmxhdHRlbnMgYW4gT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlcyBieSBwdXR0aW5nIG9uZVxuICogaW5uZXIgT2JzZXJ2YWJsZSBhZnRlciB0aGUgb3RoZXIuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY29uY2F0QWxsLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEpvaW5zIGV2ZXJ5IE9ic2VydmFibGUgZW1pdHRlZCBieSB0aGUgc291cmNlIChhIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlKSwgaW5cbiAqIGEgc2VyaWFsIGZhc2hpb24uIEl0IHN1YnNjcmliZXMgdG8gZWFjaCBpbm5lciBPYnNlcnZhYmxlIG9ubHkgYWZ0ZXIgdGhlXG4gKiBwcmV2aW91cyBpbm5lciBPYnNlcnZhYmxlIGhhcyBjb21wbGV0ZWQsIGFuZCBtZXJnZXMgYWxsIG9mIHRoZWlyIHZhbHVlcyBpbnRvXG4gKiB0aGUgcmV0dXJuZWQgb2JzZXJ2YWJsZS5cbiAqXG4gKiBfX1dhcm5pbmc6X18gSWYgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGVtaXRzIE9ic2VydmFibGVzIHF1aWNrbHkgYW5kXG4gKiBlbmRsZXNzbHksIGFuZCB0aGUgaW5uZXIgT2JzZXJ2YWJsZXMgaXQgZW1pdHMgZ2VuZXJhbGx5IGNvbXBsZXRlIHNsb3dlciB0aGFuXG4gKiB0aGUgc291cmNlIGVtaXRzLCB5b3UgY2FuIHJ1biBpbnRvIG1lbW9yeSBpc3N1ZXMgYXMgdGhlIGluY29taW5nIE9ic2VydmFibGVzXG4gKiBjb2xsZWN0IGluIGFuIHVuYm91bmRlZCBidWZmZXIuXG4gKlxuICogTm90ZTogYGNvbmNhdEFsbGAgaXMgZXF1aXZhbGVudCB0byBgbWVyZ2VBbGxgIHdpdGggY29uY3VycmVuY3kgcGFyYW1ldGVyIHNldFxuICogdG8gYDFgLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkZvciBlYWNoIGNsaWNrIGV2ZW50LCB0aWNrIGV2ZXJ5IHNlY29uZCBmcm9tIDAgdG8gMywgd2l0aCBubyBjb25jdXJyZW5jeTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgaGlnaGVyT3JkZXIgPSBjbGlja3MubWFwKGV2ID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkudGFrZSg0KSk7XG4gKiB2YXIgZmlyc3RPcmRlciA9IGhpZ2hlck9yZGVyLmNvbmNhdEFsbCgpO1xuICogZmlyc3RPcmRlci5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbiB0aGUgZm9sbG93aW5nOlxuICogLy8gKHJlc3VsdHMgYXJlIG5vdCBjb25jdXJyZW50KVxuICogLy8gRm9yIGV2ZXJ5IGNsaWNrIG9uIHRoZSBcImRvY3VtZW50XCIgaXQgd2lsbCBlbWl0IHZhbHVlcyAwIHRvIDMgc3BhY2VkXG4gKiAvLyBvbiBhIDEwMDBtcyBpbnRlcnZhbFxuICogLy8gb25lIGNsaWNrID0gMTAwMG1zLT4gMCAtMTAwMG1zLT4gMSAtMTAwMG1zLT4gMiAtMTAwMG1zLT4gM1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXR9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXBUb31cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaH1cbiAqIEBzZWUge0BsaW5rIHppcEFsbH1cbiAqXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIGVtaXR0aW5nIHZhbHVlcyBmcm9tIGFsbCB0aGUgaW5uZXJcbiAqIE9ic2VydmFibGVzIGNvbmNhdGVuYXRlZC5cbiAqIEBtZXRob2QgY29uY2F0QWxsXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0QWxsPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4pOiBUIHtcbiAgcmV0dXJuIDxhbnk+dGhpcy5saWZ0PGFueT4obmV3IE1lcmdlQWxsT3BlcmF0b3I8VD4oMSkpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9jb25jYXRBbGwudHMiLCJpbXBvcnQgeyBNZXJnZU1hcE9wZXJhdG9yIH0gZnJvbSAnLi9tZXJnZU1hcCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZhYmxlSW5wdXQgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0TWFwPFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHByb2plY3Q6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gIE9ic2VydmFibGVJbnB1dDxSPik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gY29uY2F0TWFwPFQsIEksIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHByb2plY3Q6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gIE9ic2VydmFibGVJbnB1dDxJPiwgcmVzdWx0U2VsZWN0b3I6IChvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcikgPT4gUik6IE9ic2VydmFibGU8Uj47XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuXG4vKipcbiAqIFByb2plY3RzIGVhY2ggc291cmNlIHZhbHVlIHRvIGFuIE9ic2VydmFibGUgd2hpY2ggaXMgbWVyZ2VkIGluIHRoZSBvdXRwdXRcbiAqIE9ic2VydmFibGUsIGluIGEgc2VyaWFsaXplZCBmYXNoaW9uIHdhaXRpbmcgZm9yIGVhY2ggb25lIHRvIGNvbXBsZXRlIGJlZm9yZVxuICogbWVyZ2luZyB0aGUgbmV4dC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TWFwcyBlYWNoIHZhbHVlIHRvIGFuIE9ic2VydmFibGUsIHRoZW4gZmxhdHRlbnMgYWxsIG9mXG4gKiB0aGVzZSBpbm5lciBPYnNlcnZhYmxlcyB1c2luZyB7QGxpbmsgY29uY2F0QWxsfS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9jb25jYXRNYXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiAoc28tY2FsbGVkIFwiaW5uZXJcIikgT2JzZXJ2YWJsZS4gRWFjaCBuZXcgaW5uZXIgT2JzZXJ2YWJsZSBpc1xuICogY29uY2F0ZW5hdGVkIHdpdGggdGhlIHByZXZpb3VzIGlubmVyIE9ic2VydmFibGUuXG4gKlxuICogX19XYXJuaW5nOl9fIGlmIHNvdXJjZSB2YWx1ZXMgYXJyaXZlIGVuZGxlc3NseSBhbmQgZmFzdGVyIHRoYW4gdGhlaXJcbiAqIGNvcnJlc3BvbmRpbmcgaW5uZXIgT2JzZXJ2YWJsZXMgY2FuIGNvbXBsZXRlLCBpdCB3aWxsIHJlc3VsdCBpbiBtZW1vcnkgaXNzdWVzXG4gKiBhcyBpbm5lciBPYnNlcnZhYmxlcyBhbWFzcyBpbiBhbiB1bmJvdW5kZWQgYnVmZmVyIHdhaXRpbmcgZm9yIHRoZWlyIHR1cm4gdG9cbiAqIGJlIHN1YnNjcmliZWQgdG8uXG4gKlxuICogTm90ZTogYGNvbmNhdE1hcGAgaXMgZXF1aXZhbGVudCB0byBgbWVyZ2VNYXBgIHdpdGggY29uY3VycmVuY3kgcGFyYW1ldGVyIHNldFxuICogdG8gYDFgLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkZvciBlYWNoIGNsaWNrIGV2ZW50LCB0aWNrIGV2ZXJ5IHNlY29uZCBmcm9tIDAgdG8gMywgd2l0aCBubyBjb25jdXJyZW5jeTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmNvbmNhdE1hcChldiA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoNCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyAocmVzdWx0cyBhcmUgbm90IGNvbmN1cnJlbnQpXG4gKiAvLyBGb3IgZXZlcnkgY2xpY2sgb24gdGhlIFwiZG9jdW1lbnRcIiBpdCB3aWxsIGVtaXQgdmFsdWVzIDAgdG8gMyBzcGFjZWRcbiAqIC8vIG9uIGEgMTAwMG1zIGludGVydmFsXG4gKiAvLyBvbmUgY2xpY2sgPSAxMDAwbXMtPiAwIC0xMDAwbXMtPiAxIC0xMDAwbXMtPiAyIC0xMDAwbXMtPiAzXG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0fVxuICogQHNlZSB7QGxpbmsgY29uY2F0QWxsfVxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwVG99XG4gKiBAc2VlIHtAbGluayBleGhhdXN0TWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXB9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgP2luZGV4OiBudW1iZXIpOiBPYnNlcnZhYmxlSW5wdXR9IHByb2plY3QgQSBmdW5jdGlvblxuICogdGhhdCwgd2hlbiBhcHBsaWVkIHRvIGFuIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHJldHVybnMgYW5cbiAqIE9ic2VydmFibGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKTogYW55fSBbcmVzdWx0U2VsZWN0b3JdXG4gKiBBIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSAob3V0ZXIpIGVtaXNzaW9uIGFuZCB0aGUgaW5uZXIgT2JzZXJ2YWJsZVxuICogZW1pc3Npb24uIFRoZSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb24gYXJlOlxuICogLSBgb3V0ZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogLSBgb3V0ZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSBmcm9tIHRoZSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gb2JzZXJ2YWJsZSBvZiB2YWx1ZXMgbWVyZ2VkIGZyb20gdGhlIHByb2plY3RlZFxuICogT2JzZXJ2YWJsZXMgYXMgdGhleSB3ZXJlIHN1YnNjcmliZWQgdG8sIG9uZSBhdCBhIHRpbWUuIE9wdGlvbmFsbHksIHRoZXNlXG4gKiB2YWx1ZXMgbWF5IGhhdmUgYmVlbiBwcm9qZWN0ZWQgZnJvbSBhIHBhc3NlZCBgcHJvamVjdFJlc3VsdGAgYXJndW1lbnQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGVcbiAqIHByb2plY3Rpb24gZnVuY3Rpb24gKGFuZCB0aGUgb3B0aW9uYWwgYHJlc3VsdFNlbGVjdG9yYCkgdG8gZWFjaCBpdGVtIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgdGFraW5nIHZhbHVlcyBmcm9tIGVhY2ggcHJvamVjdGVkIGlubmVyXG4gKiBPYnNlcnZhYmxlIHNlcXVlbnRpYWxseS5cbiAqIEBtZXRob2QgY29uY2F0TWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0TWFwPFQsIEksIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHByb2plY3Q6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gIE9ic2VydmFibGVJbnB1dDxJPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U2VsZWN0b3I/OiAob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpID0+IFIpIHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgTWVyZ2VNYXBPcGVyYXRvcihwcm9qZWN0LCByZXN1bHRTZWxlY3RvciwgMSkpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9jb25jYXRNYXAudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZhYmxlSW5wdXQgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IE1lcmdlTWFwVG9PcGVyYXRvciB9IGZyb20gJy4vbWVyZ2VNYXBUbyc7XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdE1hcFRvPFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIG9ic2VydmFibGU6IE9ic2VydmFibGVJbnB1dDxSPik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gY29uY2F0TWFwVG88VCwgSSwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgb2JzZXJ2YWJsZTogT2JzZXJ2YWJsZUlucHV0PEk+LCByZXN1bHRTZWxlY3RvcjogKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKSA9PiBSKTogT2JzZXJ2YWJsZTxSPjtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gdGhlIHNhbWUgT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgbXVsdGlwbGVcbiAqIHRpbWVzIGluIGEgc2VyaWFsaXplZCBmYXNoaW9uIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBjb25jYXRNYXB9LCBidXQgbWFwcyBlYWNoIHZhbHVlXG4gKiBhbHdheXMgdG8gdGhlIHNhbWUgaW5uZXIgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9jb25jYXRNYXBUby5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBNYXBzIGVhY2ggc291cmNlIHZhbHVlIHRvIHRoZSBnaXZlbiBPYnNlcnZhYmxlIGBpbm5lck9ic2VydmFibGVgIHJlZ2FyZGxlc3NcbiAqIG9mIHRoZSBzb3VyY2UgdmFsdWUsIGFuZCB0aGVuIGZsYXR0ZW5zIHRob3NlIHJlc3VsdGluZyBPYnNlcnZhYmxlcyBpbnRvIG9uZVxuICogc2luZ2xlIE9ic2VydmFibGUsIHdoaWNoIGlzIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gRWFjaCBuZXcgYGlubmVyT2JzZXJ2YWJsZWBcbiAqIGluc3RhbmNlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGlzIGNvbmNhdGVuYXRlZCB3aXRoIHRoZSBwcmV2aW91c1xuICogYGlubmVyT2JzZXJ2YWJsZWAgaW5zdGFuY2UuXG4gKlxuICogX19XYXJuaW5nOl9fIGlmIHNvdXJjZSB2YWx1ZXMgYXJyaXZlIGVuZGxlc3NseSBhbmQgZmFzdGVyIHRoYW4gdGhlaXJcbiAqIGNvcnJlc3BvbmRpbmcgaW5uZXIgT2JzZXJ2YWJsZXMgY2FuIGNvbXBsZXRlLCBpdCB3aWxsIHJlc3VsdCBpbiBtZW1vcnkgaXNzdWVzXG4gKiBhcyBpbm5lciBPYnNlcnZhYmxlcyBhbWFzcyBpbiBhbiB1bmJvdW5kZWQgYnVmZmVyIHdhaXRpbmcgZm9yIHRoZWlyIHR1cm4gdG9cbiAqIGJlIHN1YnNjcmliZWQgdG8uXG4gKlxuICogTm90ZTogYGNvbmNhdE1hcFRvYCBpcyBlcXVpdmFsZW50IHRvIGBtZXJnZU1hcFRvYCB3aXRoIGNvbmN1cnJlbmN5IHBhcmFtZXRlclxuICogc2V0IHRvIGAxYC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Gb3IgZWFjaCBjbGljayBldmVudCwgdGljayBldmVyeSBzZWNvbmQgZnJvbSAwIHRvIDMsIHdpdGggbm8gY29uY3VycmVuY3k8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5jb25jYXRNYXBUbyhSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApLnRha2UoNCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyAocmVzdWx0cyBhcmUgbm90IGNvbmN1cnJlbnQpXG4gKiAvLyBGb3IgZXZlcnkgY2xpY2sgb24gdGhlIFwiZG9jdW1lbnRcIiBpdCB3aWxsIGVtaXQgdmFsdWVzIDAgdG8gMyBzcGFjZWRcbiAqIC8vIG9uIGEgMTAwMG1zIGludGVydmFsXG4gKiAvLyBvbmUgY2xpY2sgPSAxMDAwbXMtPiAwIC0xMDAwbXMtPiAxIC0xMDAwbXMtPiAyIC0xMDAwbXMtPiAzXG4gKlxuICogQHNlZSB7QGxpbmsgY29uY2F0fVxuICogQHNlZSB7QGxpbmsgY29uY2F0QWxsfVxuICogQHNlZSB7QGxpbmsgY29uY2F0TWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcFRvfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZUlucHV0fSBpbm5lck9ic2VydmFibGUgQW4gT2JzZXJ2YWJsZSB0byByZXBsYWNlIGVhY2ggdmFsdWUgZnJvbVxuICogdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcik6IGFueX0gW3Jlc3VsdFNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0byBwcm9kdWNlIHRoZSB2YWx1ZSBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUgYmFzZWQgb24gdGhlIHZhbHVlc1xuICogYW5kIHRoZSBpbmRpY2VzIG9mIHRoZSBzb3VyY2UgKG91dGVyKSBlbWlzc2lvbiBhbmQgdGhlIGlubmVyIE9ic2VydmFibGVcbiAqIGVtaXNzaW9uLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZTpcbiAqIC0gYG91dGVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJWYWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIC0gYG91dGVySW5kZXhgOiB0aGUgXCJpbmRleFwiIG9mIHRoZSB2YWx1ZSB0aGF0IGNhbWUgZnJvbSB0aGUgc291cmNlXG4gKiAtIGBpbm5lckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgZnJvbSB0aGUgcHJvamVjdGVkIE9ic2VydmFibGVcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIG9ic2VydmFibGUgb2YgdmFsdWVzIG1lcmdlZCB0b2dldGhlciBieSBqb2luaW5nIHRoZVxuICogcGFzc2VkIG9ic2VydmFibGUgd2l0aCBpdHNlbGYsIG9uZSBhZnRlciB0aGUgb3RoZXIsIGZvciBlYWNoIHZhbHVlIGVtaXR0ZWRcbiAqIGZyb20gdGhlIHNvdXJjZS5cbiAqIEBtZXRob2QgY29uY2F0TWFwVG9cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRNYXBUbzxULCBJLCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBpbm5lck9ic2VydmFibGU6IE9ic2VydmFibGU8ST4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U2VsZWN0b3I/OiAob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpID0+IFIpOiBPYnNlcnZhYmxlPFI+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgTWVyZ2VNYXBUb09wZXJhdG9yKGlubmVyT2JzZXJ2YWJsZSwgcmVzdWx0U2VsZWN0b3IsIDEpKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvY29uY2F0TWFwVG8udHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IE9ic2VydmVyIH0gZnJvbSAnLi4vT2JzZXJ2ZXInO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuXG4vKipcbiAqIENvdW50cyB0aGUgbnVtYmVyIG9mIGVtaXNzaW9ucyBvbiB0aGUgc291cmNlIGFuZCBlbWl0cyB0aGF0IG51bWJlciB3aGVuIHRoZVxuICogc291cmNlIGNvbXBsZXRlcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+VGVsbHMgaG93IG1hbnkgdmFsdWVzIHdlcmUgZW1pdHRlZCwgd2hlbiB0aGUgc291cmNlXG4gKiBjb21wbGV0ZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvY291bnQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGNvdW50YCB0cmFuc2Zvcm1zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB2YWx1ZXMgaW50byBhbiBPYnNlcnZhYmxlIHRoYXRcbiAqIGVtaXRzIGEgc2luZ2xlIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGUgbnVtYmVyIG9mIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZVxuICogc291cmNlIE9ic2VydmFibGUuIElmIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0ZXJtaW5hdGVzIHdpdGggYW4gZXJyb3IsIGBjb3VudGBcbiAqIHdpbGwgcGFzcyB0aGlzIGVycm9yIG5vdGlmaWNhdGlvbiBhbG9uZyB3aXRob3V0IGVtaXR0aW5nIGEgdmFsdWUgZmlyc3QuIElmXG4gKiB0aGUgc291cmNlIE9ic2VydmFibGUgZG9lcyBub3QgdGVybWluYXRlIGF0IGFsbCwgYGNvdW50YCB3aWxsIG5laXRoZXIgZW1pdFxuICogYSB2YWx1ZSBub3IgdGVybWluYXRlLiBUaGlzIG9wZXJhdG9yIHRha2VzIGFuIG9wdGlvbmFsIGBwcmVkaWNhdGVgIGZ1bmN0aW9uXG4gKiBhcyBhcmd1bWVudCwgaW4gd2hpY2ggY2FzZSB0aGUgb3V0cHV0IGVtaXNzaW9uIHdpbGwgcmVwcmVzZW50IHRoZSBudW1iZXIgb2ZcbiAqIHNvdXJjZSB2YWx1ZXMgdGhhdCBtYXRjaGVkIGB0cnVlYCB3aXRoIHRoZSBgcHJlZGljYXRlYC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db3VudHMgaG93IG1hbnkgc2Vjb25kcyBoYXZlIHBhc3NlZCBiZWZvcmUgdGhlIGZpcnN0IGNsaWNrIGhhcHBlbmVkPC9jYXB0aW9uPlxuICogdmFyIHNlY29uZHMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBzZWNvbmRzQmVmb3JlQ2xpY2sgPSBzZWNvbmRzLnRha2VVbnRpbChjbGlja3MpO1xuICogdmFyIHJlc3VsdCA9IHNlY29uZHNCZWZvcmVDbGljay5jb3VudCgpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5Db3VudHMgaG93IG1hbnkgb2RkIG51bWJlcnMgYXJlIHRoZXJlIGJldHdlZW4gMSBhbmQgNzwvY2FwdGlvbj5cbiAqIHZhciBudW1iZXJzID0gUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCA3KTtcbiAqIHZhciByZXN1bHQgPSBudW1iZXJzLmNvdW50KGkgPT4gaSAlIDIgPT09IDEpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluOlxuICogLy8gNFxuICpcbiAqIEBzZWUge0BsaW5rIG1heH1cbiAqIEBzZWUge0BsaW5rIG1pbn1cbiAqIEBzZWUge0BsaW5rIHJlZHVjZX1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpOiBudW1iZXIsIHNvdXJjZTogT2JzZXJ2YWJsZTxUPik6IGJvb2xlYW59IFtwcmVkaWNhdGVdIEFcbiAqIGJvb2xlYW4gZnVuY3Rpb24gdG8gc2VsZWN0IHdoYXQgdmFsdWVzIGFyZSB0byBiZSBjb3VudGVkLiBJdCBpcyBwcm92aWRlZCB3aXRoXG4gKiBhcmd1bWVudHMgb2Y6XG4gKiAtIGB2YWx1ZWA6IHRoZSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIC0gYGluZGV4YDogdGhlICh6ZXJvLWJhc2VkKSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogLSBgc291cmNlYDogdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGluc3RhbmNlIGl0c2VsZi5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2Ygb25lIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIGNvdW50IGFzXG4gKiBkZXNjcmliZWQgYWJvdmUuXG4gKiBAbWV0aG9kIGNvdW50XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY291bnQ8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgcHJlZGljYXRlPzogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IGJvb2xlYW4pOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBDb3VudE9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpcykpO1xufVxuXG5jbGFzcyBDb3VudE9wZXJhdG9yPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgbnVtYmVyPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcHJlZGljYXRlPzogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IGJvb2xlYW4sXG4gICAgICAgICAgICAgIHByaXZhdGUgc291cmNlPzogT2JzZXJ2YWJsZTxUPikge1xuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPG51bWJlcj4sIHNvdXJjZTogYW55KTogYW55IHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgQ291bnRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJlZGljYXRlLCB0aGlzLnNvdXJjZSkpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBDb3VudFN1YnNjcmliZXI8VD4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgcHJpdmF0ZSBjb3VudDogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBpbmRleDogbnVtYmVyID0gMDtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogT2JzZXJ2ZXI8bnVtYmVyPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBwcmVkaWNhdGU/OiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIsIHNvdXJjZTogT2JzZXJ2YWJsZTxUPikgPT4gYm9vbGVhbixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBzb3VyY2U/OiBPYnNlcnZhYmxlPFQ+KSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHZhbHVlOiBUKTogdm9pZCB7XG4gICAgaWYgKHRoaXMucHJlZGljYXRlKSB7XG4gICAgICB0aGlzLl90cnlQcmVkaWNhdGUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvdW50Kys7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfdHJ5UHJlZGljYXRlKHZhbHVlOiBUKSB7XG4gICAgbGV0IHJlc3VsdDogYW55O1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlKHZhbHVlLCB0aGlzLmluZGV4KyssIHRoaXMuc291cmNlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICB0aGlzLmNvdW50Kys7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jb21wbGV0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5jb3VudCk7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL2NvdW50LnRzIiwiaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJzY3JpYmFibGVPclByb21pc2UgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiwgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5cbmltcG9ydCB7IE91dGVyU3Vic2NyaWJlciB9IGZyb20gJy4uL091dGVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBJbm5lclN1YnNjcmliZXIgfSBmcm9tICcuLi9Jbm5lclN1YnNjcmliZXInO1xuaW1wb3J0IHsgc3Vic2NyaWJlVG9SZXN1bHQgfSBmcm9tICcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0JztcblxuLyoqXG4gKiBFbWl0cyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIG9ubHkgYWZ0ZXIgYSBwYXJ0aWN1bGFyIHRpbWUgc3BhblxuICogZGV0ZXJtaW5lZCBieSBhbm90aGVyIE9ic2VydmFibGUgaGFzIHBhc3NlZCB3aXRob3V0IGFub3RoZXIgc291cmNlIGVtaXNzaW9uLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGRlYm91bmNlVGltZX0sIGJ1dCB0aGUgdGltZSBzcGFuIG9mXG4gKiBlbWlzc2lvbiBzaWxlbmNlIGlzIGRldGVybWluZWQgYnkgYSBzZWNvbmQgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kZWJvdW5jZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgZGVib3VuY2VgIGRlbGF5cyB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCBkcm9wcyBwcmV2aW91c1xuICogcGVuZGluZyBkZWxheWVkIGVtaXNzaW9ucyBpZiBhIG5ldyB2YWx1ZSBhcnJpdmVzIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIFRoaXMgb3BlcmF0b3Iga2VlcHMgdHJhY2sgb2YgdGhlIG1vc3QgcmVjZW50IHZhbHVlIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSwgYW5kIHNwYXducyBhIGR1cmF0aW9uIE9ic2VydmFibGUgYnkgY2FsbGluZyB0aGVcbiAqIGBkdXJhdGlvblNlbGVjdG9yYCBmdW5jdGlvbi4gVGhlIHZhbHVlIGlzIGVtaXR0ZWQgb25seSB3aGVuIHRoZSBkdXJhdGlvblxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlIG9yIGNvbXBsZXRlcywgYW5kIGlmIG5vIG90aGVyIHZhbHVlIHdhcyBlbWl0dGVkIG9uXG4gKiB0aGUgc291cmNlIE9ic2VydmFibGUgc2luY2UgdGhlIGR1cmF0aW9uIE9ic2VydmFibGUgd2FzIHNwYXduZWQuIElmIGEgbmV3XG4gKiB2YWx1ZSBhcHBlYXJzIGJlZm9yZSB0aGUgZHVyYXRpb24gT2JzZXJ2YWJsZSBlbWl0cywgdGhlIHByZXZpb3VzIHZhbHVlIHdpbGxcbiAqIGJlIGRyb3BwZWQgYW5kIHdpbGwgbm90IGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIExpa2Uge0BsaW5rIGRlYm91bmNlVGltZX0sIHRoaXMgaXMgYSByYXRlLWxpbWl0aW5nIG9wZXJhdG9yLCBhbmQgYWxzbyBhXG4gKiBkZWxheS1saWtlIG9wZXJhdG9yIHNpbmNlIG91dHB1dCBlbWlzc2lvbnMgZG8gbm90IG5lY2Vzc2FyaWx5IG9jY3VyIGF0IHRoZVxuICogc2FtZSB0aW1lIGFzIHRoZXkgZGlkIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IHRoZSBtb3N0IHJlY2VudCBjbGljayBhZnRlciBhIGJ1cnN0IG9mIGNsaWNrczwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmRlYm91bmNlKCgpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdH1cbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlVGltZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5V2hlbn1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQpOiBTdWJzY3JpYmFibGVPclByb21pc2V9IGR1cmF0aW9uU2VsZWN0b3IgQSBmdW5jdGlvblxuICogdGhhdCByZWNlaXZlcyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBmb3IgY29tcHV0aW5nIHRoZSB0aW1lb3V0XG4gKiBkdXJhdGlvbiBmb3IgZWFjaCBzb3VyY2UgdmFsdWUsIHJldHVybmVkIGFzIGFuIE9ic2VydmFibGUgb3IgYSBQcm9taXNlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGRlbGF5cyB0aGUgZW1pc3Npb25zIG9mIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgYnkgdGhlIHNwZWNpZmllZCBkdXJhdGlvbiBPYnNlcnZhYmxlIHJldHVybmVkIGJ5XG4gKiBgZHVyYXRpb25TZWxlY3RvcmAsIGFuZCBtYXkgZHJvcCBzb21lIHZhbHVlcyBpZiB0aGV5IG9jY3VyIHRvbyBmcmVxdWVudGx5LlxuICogQG1ldGhvZCBkZWJvdW5jZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIGR1cmF0aW9uU2VsZWN0b3I6ICh2YWx1ZTogVCkgPT4gU3Vic2NyaWJhYmxlT3JQcm9taXNlPG51bWJlcj4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgRGVib3VuY2VPcGVyYXRvcihkdXJhdGlvblNlbGVjdG9yKSk7XG59XG5cbmNsYXNzIERlYm91bmNlT3BlcmF0b3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZHVyYXRpb25TZWxlY3RvcjogKHZhbHVlOiBUKSA9PiBTdWJzY3JpYmFibGVPclByb21pc2U8bnVtYmVyPikge1xuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+LCBzb3VyY2U6IGFueSk6IFRlYXJkb3duTG9naWMge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEZWJvdW5jZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kdXJhdGlvblNlbGVjdG9yKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIERlYm91bmNlU3Vic2NyaWJlcjxULCBSPiBleHRlbmRzIE91dGVyU3Vic2NyaWJlcjxULCBSPiB7XG4gIHByaXZhdGUgdmFsdWU6IFQ7XG4gIHByaXZhdGUgaGFzVmFsdWU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBkdXJhdGlvblN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxSPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBkdXJhdGlvblNlbGVjdG9yOiAodmFsdWU6IFQpID0+IFN1YnNjcmliYWJsZU9yUHJvbWlzZTxudW1iZXI+KSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHZhbHVlOiBUKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZHVyYXRpb25TZWxlY3Rvci5jYWxsKHRoaXMsIHZhbHVlKTtcblxuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICB0aGlzLl90cnlOZXh0KHZhbHVlLCByZXN1bHQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKTogdm9pZCB7XG4gICAgdGhpcy5lbWl0VmFsdWUoKTtcbiAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gIH1cblxuICBwcml2YXRlIF90cnlOZXh0KHZhbHVlOiBULCBkdXJhdGlvbjogU3Vic2NyaWJhYmxlT3JQcm9taXNlPG51bWJlcj4pOiB2b2lkIHtcbiAgICBsZXQgc3Vic2NyaXB0aW9uID0gdGhpcy5kdXJhdGlvblN1YnNjcmlwdGlvbjtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgaWYgKHN1YnNjcmlwdGlvbikge1xuICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aGlzLnJlbW92ZShzdWJzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGR1cmF0aW9uKTtcbiAgICBpZiAoIXN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgIHRoaXMuYWRkKHRoaXMuZHVyYXRpb25TdWJzY3JpcHRpb24gPSBzdWJzY3JpcHRpb24pO1xuICAgIH1cbiAgfVxuXG4gIG5vdGlmeU5leHQob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogUixcbiAgICAgICAgICAgICBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgICBpbm5lclN1YjogSW5uZXJTdWJzY3JpYmVyPFQsIFI+KTogdm9pZCB7XG4gICAgdGhpcy5lbWl0VmFsdWUoKTtcbiAgfVxuXG4gIG5vdGlmeUNvbXBsZXRlKCk6IHZvaWQge1xuICAgIHRoaXMuZW1pdFZhbHVlKCk7XG4gIH1cblxuICBlbWl0VmFsdWUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaGFzVmFsdWUpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHRoaXMuZHVyYXRpb25TdWJzY3JpcHRpb247XG4gICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIHRoaXMuZHVyYXRpb25TdWJzY3JpcHRpb24gPSBudWxsO1xuICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoc3Vic2NyaXB0aW9uKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgc3VwZXIuX25leHQodmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9kZWJvdW5jZS50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgSVNjaGVkdWxlciB9IGZyb20gJy4uL1NjaGVkdWxlcic7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24sIFRlYXJkb3duTG9naWMgfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgYXN5bmMgfSBmcm9tICcuLi9zY2hlZHVsZXIvYXN5bmMnO1xuXG4vKipcbiAqIEVtaXRzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgb25seSBhZnRlciBhIHBhcnRpY3VsYXIgdGltZSBzcGFuXG4gKiBoYXMgcGFzc2VkIHdpdGhvdXQgYW5vdGhlciBzb3VyY2UgZW1pc3Npb24uXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgZGVsYXl9LCBidXQgcGFzc2VzIG9ubHkgdGhlIG1vc3RcbiAqIHJlY2VudCB2YWx1ZSBmcm9tIGVhY2ggYnVyc3Qgb2YgZW1pc3Npb25zLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RlYm91bmNlVGltZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgZGVib3VuY2VUaW1lYCBkZWxheXMgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBidXQgZHJvcHNcbiAqIHByZXZpb3VzIHBlbmRpbmcgZGVsYXllZCBlbWlzc2lvbnMgaWYgYSBuZXcgdmFsdWUgYXJyaXZlcyBvbiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGlzIG9wZXJhdG9yIGtlZXBzIHRyYWNrIG9mIHRoZSBtb3N0IHJlY2VudCB2YWx1ZSBmcm9tIHRoZVxuICogc291cmNlIE9ic2VydmFibGUsIGFuZCBlbWl0cyB0aGF0IG9ubHkgd2hlbiBgZHVlVGltZWAgZW5vdWdoIHRpbWUgaGFzIHBhc3NlZFxuICogd2l0aG91dCBhbnkgb3RoZXIgdmFsdWUgYXBwZWFyaW5nIG9uIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgYSBuZXcgdmFsdWVcbiAqIGFwcGVhcnMgYmVmb3JlIGBkdWVUaW1lYCBzaWxlbmNlIG9jY3VycywgdGhlIHByZXZpb3VzIHZhbHVlIHdpbGwgYmUgZHJvcHBlZFxuICogYW5kIHdpbGwgbm90IGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIFRoaXMgaXMgYSByYXRlLWxpbWl0aW5nIG9wZXJhdG9yLCBiZWNhdXNlIGl0IGlzIGltcG9zc2libGUgZm9yIG1vcmUgdGhhbiBvbmVcbiAqIHZhbHVlIHRvIGJlIGVtaXR0ZWQgaW4gYW55IHRpbWUgd2luZG93IG9mIGR1cmF0aW9uIGBkdWVUaW1lYCwgYnV0IGl0IGlzIGFsc29cbiAqIGEgZGVsYXktbGlrZSBvcGVyYXRvciBzaW5jZSBvdXRwdXQgZW1pc3Npb25zIGRvIG5vdCBvY2N1ciBhdCB0aGUgc2FtZSB0aW1lIGFzXG4gKiB0aGV5IGRpZCBvbiB0aGUgc291cmNlIE9ic2VydmFibGUuIE9wdGlvbmFsbHkgdGFrZXMgYSB7QGxpbmsgSVNjaGVkdWxlcn0gZm9yXG4gKiBtYW5hZ2luZyB0aW1lcnMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCB0aGUgbW9zdCByZWNlbnQgY2xpY2sgYWZ0ZXIgYSBidXJzdCBvZiBjbGlja3M8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5kZWJvdW5jZVRpbWUoMTAwMCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGF1ZGl0VGltZX1cbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlfVxuICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gKiBAc2VlIHtAbGluayBzYW1wbGVUaW1lfVxuICogQHNlZSB7QGxpbmsgdGhyb3R0bGVUaW1lfVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkdWVUaW1lIFRoZSB0aW1lb3V0IGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyAob3IgdGhlIHRpbWVcbiAqIHVuaXQgZGV0ZXJtaW5lZCBpbnRlcm5hbGx5IGJ5IHRoZSBvcHRpb25hbCBgc2NoZWR1bGVyYCkgZm9yIHRoZSB3aW5kb3cgb2ZcbiAqIHRpbWUgcmVxdWlyZWQgdG8gd2FpdCBmb3IgZW1pc3Npb24gc2lsZW5jZSBiZWZvcmUgZW1pdHRpbmcgdGhlIG1vc3QgcmVjZW50XG4gKiBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yXG4gKiBtYW5hZ2luZyB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRoZSB0aW1lb3V0IGZvciBlYWNoIHZhbHVlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGRlbGF5cyB0aGUgZW1pc3Npb25zIG9mIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgYnkgdGhlIHNwZWNpZmllZCBgZHVlVGltZWAsIGFuZCBtYXkgZHJvcCBzb21lIHZhbHVlcyBpZiB0aGV5IG9jY3VyXG4gKiB0b28gZnJlcXVlbnRseS5cbiAqIEBtZXRob2QgZGVib3VuY2VUaW1lXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2VUaW1lPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIGR1ZVRpbWU6IG51bWJlciwgc2NoZWR1bGVyOiBJU2NoZWR1bGVyID0gYXN5bmMpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgRGVib3VuY2VUaW1lT3BlcmF0b3IoZHVlVGltZSwgc2NoZWR1bGVyKSk7XG59XG5cbmNsYXNzIERlYm91bmNlVGltZU9wZXJhdG9yPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGR1ZVRpbWU6IG51bWJlciwgcHJpdmF0ZSBzY2hlZHVsZXI6IElTY2hlZHVsZXIpIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPiwgc291cmNlOiBhbnkpOiBUZWFyZG93bkxvZ2ljIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGVib3VuY2VUaW1lU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmR1ZVRpbWUsIHRoaXMuc2NoZWR1bGVyKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIERlYm91bmNlVGltZVN1YnNjcmliZXI8VD4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgcHJpdmF0ZSBkZWJvdW5jZWRTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiA9IG51bGw7XG4gIHByaXZhdGUgbGFzdFZhbHVlOiBUID0gbnVsbDtcbiAgcHJpdmF0ZSBoYXNWYWx1ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFQ+LFxuICAgICAgICAgICAgICBwcml2YXRlIGR1ZVRpbWU6IG51bWJlcixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBzY2hlZHVsZXI6IElTY2hlZHVsZXIpIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpIHtcbiAgICB0aGlzLmNsZWFyRGVib3VuY2UoKTtcbiAgICB0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgIHRoaXMuYWRkKHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hOZXh0LCB0aGlzLmR1ZVRpbWUsIHRoaXMpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKSB7XG4gICAgdGhpcy5kZWJvdW5jZWROZXh0KCk7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICB9XG5cbiAgZGVib3VuY2VkTmV4dCgpOiB2b2lkIHtcbiAgICB0aGlzLmNsZWFyRGVib3VuY2UoKTtcblxuICAgIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5sYXN0VmFsdWUpO1xuICAgICAgdGhpcy5sYXN0VmFsdWUgPSBudWxsO1xuICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2xlYXJEZWJvdW5jZSgpOiB2b2lkIHtcbiAgICBjb25zdCBkZWJvdW5jZWRTdWJzY3JpcHRpb24gPSB0aGlzLmRlYm91bmNlZFN1YnNjcmlwdGlvbjtcblxuICAgIGlmIChkZWJvdW5jZWRTdWJzY3JpcHRpb24gIT09IG51bGwpIHtcbiAgICAgIHRoaXMucmVtb3ZlKGRlYm91bmNlZFN1YnNjcmlwdGlvbik7XG4gICAgICBkZWJvdW5jZWRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMuZGVib3VuY2VkU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hOZXh0KHN1YnNjcmliZXI6IERlYm91bmNlVGltZVN1YnNjcmliZXI8YW55Pikge1xuICBzdWJzY3JpYmVyLmRlYm91bmNlZE5leHQoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvZGVib3VuY2VUaW1lLnRzIiwiaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRJZkVtcHR5PFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIGRlZmF1bHRWYWx1ZT86IFQpOiBPYnNlcnZhYmxlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRJZkVtcHR5PFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIGRlZmF1bHRWYWx1ZT86IFIpOiBPYnNlcnZhYmxlPFQgfCBSPjtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbi8qKlxuICogRW1pdHMgYSBnaXZlbiB2YWx1ZSBpZiB0aGUgc291cmNlIE9ic2VydmFibGUgY29tcGxldGVzIHdpdGhvdXQgZW1pdHRpbmcgYW55XG4gKiBgbmV4dGAgdmFsdWUsIG90aGVyd2lzZSBtaXJyb3JzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SWYgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHR1cm5zIG91dCB0byBiZSBlbXB0eSwgdGhlblxuICogdGhpcyBvcGVyYXRvciB3aWxsIGVtaXQgYSBkZWZhdWx0IHZhbHVlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RlZmF1bHRJZkVtcHR5LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBkZWZhdWx0SWZFbXB0eWAgZW1pdHMgdGhlIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBvciBhXG4gKiBzcGVjaWZpZWQgZGVmYXVsdCB2YWx1ZSBpZiB0aGUgc291cmNlIE9ic2VydmFibGUgaXMgZW1wdHkgKGNvbXBsZXRlcyB3aXRob3V0XG4gKiBoYXZpbmcgZW1pdHRlZCBhbnkgYG5leHRgIHZhbHVlKS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5JZiBubyBjbGlja3MgaGFwcGVuIGluIDUgc2Vjb25kcywgdGhlbiBlbWl0IFwibm8gY2xpY2tzXCI8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGNsaWNrc0JlZm9yZUZpdmUgPSBjbGlja3MudGFrZVVudGlsKFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoNTAwMCkpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrc0JlZm9yZUZpdmUuZGVmYXVsdElmRW1wdHkoJ25vIGNsaWNrcycpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBlbXB0eX1cbiAqIEBzZWUge0BsaW5rIGxhc3R9XG4gKlxuICogQHBhcmFtIHthbnl9IFtkZWZhdWx0VmFsdWU9bnVsbF0gVGhlIGRlZmF1bHQgdmFsdWUgdXNlZCBpZiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGlzIGVtcHR5LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGVpdGhlciB0aGUgc3BlY2lmaWVkXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiB0aGUgc291cmNlIE9ic2VydmFibGUgZW1pdHMgbm8gaXRlbXMsIG9yIHRoZSB2YWx1ZXMgZW1pdHRlZFxuICogYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBkZWZhdWx0SWZFbXB0eVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRJZkVtcHR5PFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIGRlZmF1bHRWYWx1ZTogUiA9IG51bGwpOiBPYnNlcnZhYmxlPFQgfCBSPiB7XG4gIHJldHVybiB0aGlzLmxpZnQobmV3IERlZmF1bHRJZkVtcHR5T3BlcmF0b3IoZGVmYXVsdFZhbHVlKSk7XG59XG5cbmNsYXNzIERlZmF1bHRJZkVtcHR5T3BlcmF0b3I8VCwgUj4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUIHwgUj4ge1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgZGVmYXVsdFZhbHVlOiBSKSB7XG4gIH1cblxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VCB8IFI+LCBzb3VyY2U6IGFueSk6IGFueSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERlZmF1bHRJZkVtcHR5U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmRlZmF1bHRWYWx1ZSkpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBEZWZhdWx0SWZFbXB0eVN1YnNjcmliZXI8VCwgUj4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgcHJpdmF0ZSBpc0VtcHR5OiBib29sZWFuID0gdHJ1ZTtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxUIHwgUj4sIHByaXZhdGUgZGVmYXVsdFZhbHVlOiBSKSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHZhbHVlOiBUKTogdm9pZCB7XG4gICAgdGhpcy5pc0VtcHR5ID0gZmFsc2U7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMuZGVmYXVsdFZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL2RlZmF1bHRJZkVtcHR5LnRzIiwiaW1wb3J0IHsgYXN5bmMgfSBmcm9tICcuLi9zY2hlZHVsZXIvYXN5bmMnO1xuaW1wb3J0IHsgaXNEYXRlIH0gZnJvbSAnLi4vdXRpbC9pc0RhdGUnO1xuaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBJU2NoZWR1bGVyIH0gZnJvbSAnLi4vU2NoZWR1bGVyJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4uL3NjaGVkdWxlci9BY3Rpb24nO1xuaW1wb3J0IHsgTm90aWZpY2F0aW9uIH0gZnJvbSAnLi4vTm90aWZpY2F0aW9uJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFBhcnRpYWxPYnNlcnZlciB9IGZyb20gJy4uL09ic2VydmVyJztcbmltcG9ydCB7IFRlYXJkb3duTG9naWMgfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuXG4vKipcbiAqIERlbGF5cyB0aGUgZW1pc3Npb24gb2YgaXRlbXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgYSBnaXZlbiB0aW1lb3V0IG9yXG4gKiB1bnRpbCBhIGdpdmVuIERhdGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlRpbWUgc2hpZnRzIGVhY2ggaXRlbSBieSBzb21lIHNwZWNpZmllZCBhbW91bnQgb2ZcbiAqIG1pbGxpc2Vjb25kcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kZWxheS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBJZiB0aGUgZGVsYXkgYXJndW1lbnQgaXMgYSBOdW1iZXIsIHRoaXMgb3BlcmF0b3IgdGltZSBzaGlmdHMgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBieSB0aGF0IGFtb3VudCBvZiB0aW1lIGV4cHJlc3NlZCBpbiBtaWxsaXNlY29uZHMuIFRoZSByZWxhdGl2ZVxuICogdGltZSBpbnRlcnZhbHMgYmV0d2VlbiB0aGUgdmFsdWVzIGFyZSBwcmVzZXJ2ZWQuXG4gKlxuICogSWYgdGhlIGRlbGF5IGFyZ3VtZW50IGlzIGEgRGF0ZSwgdGhpcyBvcGVyYXRvciB0aW1lIHNoaWZ0cyB0aGUgc3RhcnQgb2YgdGhlXG4gKiBPYnNlcnZhYmxlIGV4ZWN1dGlvbiB1bnRpbCB0aGUgZ2l2ZW4gZGF0ZSBvY2N1cnMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RGVsYXkgZWFjaCBjbGljayBieSBvbmUgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBkZWxheWVkQ2xpY2tzID0gY2xpY2tzLmRlbGF5KDEwMDApOyAvLyBlYWNoIGNsaWNrIGVtaXR0ZWQgYWZ0ZXIgMSBzZWNvbmRcbiAqIGRlbGF5ZWRDbGlja3Muc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkRlbGF5IGFsbCBjbGlja3MgdW50aWwgYSBmdXR1cmUgZGF0ZSBoYXBwZW5zPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBkYXRlID0gbmV3IERhdGUoJ01hcmNoIDE1LCAyMDUwIDEyOjAwOjAwJyk7IC8vIGluIHRoZSBmdXR1cmVcbiAqIHZhciBkZWxheWVkQ2xpY2tzID0gY2xpY2tzLmRlbGF5KGRhdGUpOyAvLyBjbGljayBlbWl0dGVkIG9ubHkgYWZ0ZXIgdGhhdCBkYXRlXG4gKiBkZWxheWVkQ2xpY2tzLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZVRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWxheVdoZW59XG4gKlxuICogQHBhcmFtIHtudW1iZXJ8RGF0ZX0gZGVsYXkgVGhlIGRlbGF5IGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyAoYSBgbnVtYmVyYCkgb3JcbiAqIGEgYERhdGVgIHVudGlsIHdoaWNoIHRoZSBlbWlzc2lvbiBvZiB0aGUgc291cmNlIGl0ZW1zIGlzIGRlbGF5ZWQuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIElTY2hlZHVsZXIgdG8gdXNlIGZvclxuICogbWFuYWdpbmcgdGhlIHRpbWVycyB0aGF0IGhhbmRsZSB0aGUgdGltZS1zaGlmdCBmb3IgZWFjaCBpdGVtLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGRlbGF5cyB0aGUgZW1pc3Npb25zIG9mIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgYnkgdGhlIHNwZWNpZmllZCB0aW1lb3V0IG9yIERhdGUuXG4gKiBAbWV0aG9kIGRlbGF5XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVsYXk8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgZGVsYXk6IG51bWJlcnxEYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlcjogSVNjaGVkdWxlciA9IGFzeW5jKTogT2JzZXJ2YWJsZTxUPiB7XG4gIGNvbnN0IGFic29sdXRlRGVsYXkgPSBpc0RhdGUoZGVsYXkpO1xuICBjb25zdCBkZWxheUZvciA9IGFic29sdXRlRGVsYXkgPyAoK2RlbGF5IC0gc2NoZWR1bGVyLm5vdygpKSA6IE1hdGguYWJzKDxudW1iZXI+ZGVsYXkpO1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEZWxheU9wZXJhdG9yKGRlbGF5Rm9yLCBzY2hlZHVsZXIpKTtcbn1cblxuY2xhc3MgRGVsYXlPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBkZWxheTogbnVtYmVyLFxuICAgICAgICAgICAgICBwcml2YXRlIHNjaGVkdWxlcjogSVNjaGVkdWxlcikge1xuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+LCBzb3VyY2U6IGFueSk6IFRlYXJkb3duTG9naWMge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEZWxheVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5kZWxheSwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgRGVsYXlTdGF0ZTxUPiB7XG4gIHNvdXJjZTogRGVsYXlTdWJzY3JpYmVyPFQ+O1xuICBkZXN0aW5hdGlvbjogUGFydGlhbE9ic2VydmVyPFQ+O1xuICBzY2hlZHVsZXI6IElTY2hlZHVsZXI7XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBEZWxheVN1YnNjcmliZXI8VD4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgcHJpdmF0ZSBxdWV1ZTogQXJyYXk8RGVsYXlNZXNzYWdlPFQ+PiA9IFtdO1xuICBwcml2YXRlIGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGVycm9yZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBwcml2YXRlIHN0YXRpYyBkaXNwYXRjaDxUPih0aGlzOiBBY3Rpb248RGVsYXlTdGF0ZTxUPj4sIHN0YXRlOiBEZWxheVN0YXRlPFQ+KTogdm9pZCB7XG4gICAgY29uc3Qgc291cmNlID0gc3RhdGUuc291cmNlO1xuICAgIGNvbnN0IHF1ZXVlID0gc291cmNlLnF1ZXVlO1xuICAgIGNvbnN0IHNjaGVkdWxlciA9IHN0YXRlLnNjaGVkdWxlcjtcbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHN0YXRlLmRlc3RpbmF0aW9uO1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDAgJiYgKHF1ZXVlWzBdLnRpbWUgLSBzY2hlZHVsZXIubm93KCkpIDw9IDApIHtcbiAgICAgIHF1ZXVlLnNoaWZ0KCkubm90aWZpY2F0aW9uLm9ic2VydmUoZGVzdGluYXRpb24pO1xuICAgIH1cblxuICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBkZWxheSA9IE1hdGgubWF4KDAsIHF1ZXVlWzBdLnRpbWUgLSBzY2hlZHVsZXIubm93KCkpO1xuICAgICAgdGhpcy5zY2hlZHVsZShzdGF0ZSwgZGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2UuYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8VD4sXG4gICAgICAgICAgICAgIHByaXZhdGUgZGVsYXk6IG51bWJlcixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBzY2hlZHVsZXI6IElTY2hlZHVsZXIpIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gIH1cblxuICBwcml2YXRlIF9zY2hlZHVsZShzY2hlZHVsZXI6IElTY2hlZHVsZXIpOiB2b2lkIHtcbiAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlPERlbGF5U3RhdGU8VD4+KERlbGF5U3Vic2NyaWJlci5kaXNwYXRjaCwgdGhpcy5kZWxheSwge1xuICAgICAgc291cmNlOiB0aGlzLCBkZXN0aW5hdGlvbjogdGhpcy5kZXN0aW5hdGlvbiwgc2NoZWR1bGVyOiBzY2hlZHVsZXJcbiAgICB9KSk7XG4gIH1cblxuICBwcml2YXRlIHNjaGVkdWxlTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbjogTm90aWZpY2F0aW9uPFQ+KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZXJyb3JlZCA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgRGVsYXlNZXNzYWdlKHNjaGVkdWxlci5ub3coKSArIHRoaXMuZGVsYXksIG5vdGlmaWNhdGlvbik7XG4gICAgdGhpcy5xdWV1ZS5wdXNoKG1lc3NhZ2UpO1xuXG4gICAgaWYgKHRoaXMuYWN0aXZlID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5fc2NoZWR1bGUoc2NoZWR1bGVyKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpIHtcbiAgICB0aGlzLnNjaGVkdWxlTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbi5jcmVhdGVOZXh0KHZhbHVlKSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2Vycm9yKGVycjogYW55KSB7XG4gICAgdGhpcy5lcnJvcmVkID0gdHJ1ZTtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jb21wbGV0ZSgpIHtcbiAgICB0aGlzLnNjaGVkdWxlTm90aWZpY2F0aW9uKE5vdGlmaWNhdGlvbi5jcmVhdGVDb21wbGV0ZSgpKTtcbiAgfVxufVxuXG5jbGFzcyBEZWxheU1lc3NhZ2U8VD4ge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcmVhZG9ubHkgdGltZTogbnVtYmVyLFxuICAgICAgICAgICAgICBwdWJsaWMgcmVhZG9ubHkgbm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb248VD4pIHtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9kZWxheS50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBUZWFyZG93bkxvZ2ljIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcblxuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vT3V0ZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IElubmVyU3Vic2NyaWJlciB9IGZyb20gJy4uL0lubmVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBzdWJzY3JpYmVUb1Jlc3VsdCB9IGZyb20gJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnO1xuXG4vKipcbiAqIERlbGF5cyB0aGUgZW1pc3Npb24gb2YgaXRlbXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgYnkgYSBnaXZlbiB0aW1lIHNwYW5cbiAqIGRldGVybWluZWQgYnkgdGhlIGVtaXNzaW9ucyBvZiBhbm90aGVyIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgZGVsYXl9LCBidXQgdGhlIHRpbWUgc3BhbiBvZiB0aGVcbiAqIGRlbGF5IGR1cmF0aW9uIGlzIGRldGVybWluZWQgYnkgYSBzZWNvbmQgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kZWxheVdoZW4ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGRlbGF5V2hlbmAgdGltZSBzaGlmdHMgZWFjaCBlbWl0dGVkIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJ5IGFcbiAqIHRpbWUgc3BhbiBkZXRlcm1pbmVkIGJ5IGFub3RoZXIgT2JzZXJ2YWJsZS4gV2hlbiB0aGUgc291cmNlIGVtaXRzIGEgdmFsdWUsXG4gKiB0aGUgYGRlbGF5RHVyYXRpb25TZWxlY3RvcmAgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhlIHNvdXJjZSB2YWx1ZSBhc1xuICogYXJndW1lbnQsIGFuZCBzaG91bGQgcmV0dXJuIGFuIE9ic2VydmFibGUsIGNhbGxlZCB0aGUgXCJkdXJhdGlvblwiIE9ic2VydmFibGUuXG4gKiBUaGUgc291cmNlIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIG9ubHkgd2hlbiB0aGUgZHVyYXRpb25cbiAqIE9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZSBvciBjb21wbGV0ZXMuXG4gKlxuICogT3B0aW9uYWxseSwgYGRlbGF5V2hlbmAgdGFrZXMgYSBzZWNvbmQgYXJndW1lbnQsIGBzdWJzY3JpcHRpb25EZWxheWAsIHdoaWNoXG4gKiBpcyBhbiBPYnNlcnZhYmxlLiBXaGVuIGBzdWJzY3JpcHRpb25EZWxheWAgZW1pdHMgaXRzIGZpcnN0IHZhbHVlIG9yXG4gKiBjb21wbGV0ZXMsIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBpcyBzdWJzY3JpYmVkIHRvIGFuZCBzdGFydHMgYmVoYXZpbmcgbGlrZVxuICogZGVzY3JpYmVkIGluIHRoZSBwcmV2aW91cyBwYXJhZ3JhcGguIElmIGBzdWJzY3JpcHRpb25EZWxheWAgaXMgbm90IHByb3ZpZGVkLFxuICogYGRlbGF5V2hlbmAgd2lsbCBzdWJzY3JpYmUgdG8gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGFzIHNvb24gYXMgdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSBpcyBzdWJzY3JpYmVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkRlbGF5IGVhY2ggY2xpY2sgYnkgYSByYW5kb20gYW1vdW50IG9mIHRpbWUsIGJldHdlZW4gMCBhbmQgNSBzZWNvbmRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBkZWxheWVkQ2xpY2tzID0gY2xpY2tzLmRlbGF5V2hlbihldmVudCA9PlxuICogICBSeC5PYnNlcnZhYmxlLmludGVydmFsKE1hdGgucmFuZG9tKCkgKiA1MDAwKVxuICogKTtcbiAqIGRlbGF5ZWRDbGlja3Muc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlfVxuICogQHNlZSB7QGxpbmsgZGVsYXl9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IE9ic2VydmFibGV9IGRlbGF5RHVyYXRpb25TZWxlY3RvciBBIGZ1bmN0aW9uIHRoYXRcbiAqIHJldHVybnMgYW4gT2JzZXJ2YWJsZSBmb3IgZWFjaCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hpY2hcbiAqIGlzIHRoZW4gdXNlZCB0byBkZWxheSB0aGUgZW1pc3Npb24gb2YgdGhhdCBpdGVtIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZVxuICogdW50aWwgdGhlIE9ic2VydmFibGUgcmV0dXJuZWQgZnJvbSB0aGlzIGZ1bmN0aW9uIGVtaXRzIGEgdmFsdWUuXG4gKiBAcGFyYW0ge09ic2VydmFibGV9IHN1YnNjcmlwdGlvbkRlbGF5IEFuIE9ic2VydmFibGUgdGhhdCB0cmlnZ2VycyB0aGVcbiAqIHN1YnNjcmlwdGlvbiB0byB0aGUgc291cmNlIE9ic2VydmFibGUgb25jZSBpdCBlbWl0cyBhbnkgdmFsdWUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZGVsYXlzIHRoZSBlbWlzc2lvbnMgb2YgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBieSBhbiBhbW91bnQgb2YgdGltZSBzcGVjaWZpZWQgYnkgdGhlIE9ic2VydmFibGUgcmV0dXJuZWQgYnlcbiAqIGBkZWxheUR1cmF0aW9uU2VsZWN0b3JgLlxuICogQG1ldGhvZCBkZWxheVdoZW5cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxheVdoZW48VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgZGVsYXlEdXJhdGlvblNlbGVjdG9yOiAodmFsdWU6IFQpID0+IE9ic2VydmFibGU8YW55PixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uRGVsYXk/OiBPYnNlcnZhYmxlPGFueT4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgaWYgKHN1YnNjcmlwdGlvbkRlbGF5KSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25EZWxheU9ic2VydmFibGUodGhpcywgc3Vic2NyaXB0aW9uRGVsYXkpXG4gICAgICAgICAgICAubGlmdChuZXcgRGVsYXlXaGVuT3BlcmF0b3IoZGVsYXlEdXJhdGlvblNlbGVjdG9yKSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgRGVsYXlXaGVuT3BlcmF0b3IoZGVsYXlEdXJhdGlvblNlbGVjdG9yKSk7XG59XG5cbmNsYXNzIERlbGF5V2hlbk9wZXJhdG9yPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRlbGF5RHVyYXRpb25TZWxlY3RvcjogKHZhbHVlOiBUKSA9PiBPYnNlcnZhYmxlPGFueT4pIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPiwgc291cmNlOiBhbnkpOiBUZWFyZG93bkxvZ2ljIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRGVsYXlXaGVuU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmRlbGF5RHVyYXRpb25TZWxlY3RvcikpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBEZWxheVdoZW5TdWJzY3JpYmVyPFQsIFI+IGV4dGVuZHMgT3V0ZXJTdWJzY3JpYmVyPFQsIFI+IHtcbiAgcHJpdmF0ZSBjb21wbGV0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBkZWxheU5vdGlmaWVyU3Vic2NyaXB0aW9uczogQXJyYXk8U3Vic2NyaXB0aW9uPiA9IFtdO1xuICBwcml2YXRlIHZhbHVlczogQXJyYXk8VD4gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxUPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBkZWxheUR1cmF0aW9uU2VsZWN0b3I6ICh2YWx1ZTogVCkgPT4gT2JzZXJ2YWJsZTxhbnk+KSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICB9XG5cbiAgbm90aWZ5TmV4dChvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBhbnksXG4gICAgICAgICAgICAgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICAgaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBSPik6IHZvaWQge1xuICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChvdXRlclZhbHVlKTtcbiAgICB0aGlzLnJlbW92ZVN1YnNjcmlwdGlvbihpbm5lclN1Yik7XG4gICAgdGhpcy50cnlDb21wbGV0ZSgpO1xuICB9XG5cbiAgbm90aWZ5RXJyb3IoZXJyb3I6IGFueSwgaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBSPik6IHZvaWQge1xuICAgIHRoaXMuX2Vycm9yKGVycm9yKTtcbiAgfVxuXG4gIG5vdGlmeUNvbXBsZXRlKGlubmVyU3ViOiBJbm5lclN1YnNjcmliZXI8VCwgUj4pOiB2b2lkIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMucmVtb3ZlU3Vic2NyaXB0aW9uKGlubmVyU3ViKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMudHJ5Q29tcGxldGUoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZWxheU5vdGlmaWVyID0gdGhpcy5kZWxheUR1cmF0aW9uU2VsZWN0b3IodmFsdWUpO1xuICAgICAgaWYgKGRlbGF5Tm90aWZpZXIpIHtcbiAgICAgICAgdGhpcy50cnlEZWxheShkZWxheU5vdGlmaWVyLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbXBsZXRlKCk6IHZvaWQge1xuICAgIHRoaXMuY29tcGxldGVkID0gdHJ1ZTtcbiAgICB0aGlzLnRyeUNvbXBsZXRlKCk7XG4gIH1cblxuICBwcml2YXRlIHJlbW92ZVN1YnNjcmlwdGlvbihzdWJzY3JpcHRpb246IElubmVyU3Vic2NyaWJlcjxULCBSPik6IFQge1xuICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uSWR4ID0gdGhpcy5kZWxheU5vdGlmaWVyU3Vic2NyaXB0aW9ucy5pbmRleE9mKHN1YnNjcmlwdGlvbik7XG4gICAgbGV0IHZhbHVlOiBUID0gbnVsbDtcblxuICAgIGlmIChzdWJzY3JpcHRpb25JZHggIT09IC0xKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMudmFsdWVzW3N1YnNjcmlwdGlvbklkeF07XG4gICAgICB0aGlzLmRlbGF5Tm90aWZpZXJTdWJzY3JpcHRpb25zLnNwbGljZShzdWJzY3JpcHRpb25JZHgsIDEpO1xuICAgICAgdGhpcy52YWx1ZXMuc3BsaWNlKHN1YnNjcmlwdGlvbklkeCwgMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgcHJpdmF0ZSB0cnlEZWxheShkZWxheU5vdGlmaWVyOiBPYnNlcnZhYmxlPGFueT4sIHZhbHVlOiBUKTogdm9pZCB7XG4gICAgY29uc3Qgbm90aWZpZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBkZWxheU5vdGlmaWVyLCB2YWx1ZSk7XG4gICAgdGhpcy5hZGQobm90aWZpZXJTdWJzY3JpcHRpb24pO1xuXG4gICAgdGhpcy5kZWxheU5vdGlmaWVyU3Vic2NyaXB0aW9ucy5wdXNoKG5vdGlmaWVyU3Vic2NyaXB0aW9uKTtcbiAgICB0aGlzLnZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgdHJ5Q29tcGxldGUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuY29tcGxldGVkICYmIHRoaXMuZGVsYXlOb3RpZmllclN1YnNjcmlwdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBTdWJzY3JpcHRpb25EZWxheU9ic2VydmFibGU8VD4gZXh0ZW5kcyBPYnNlcnZhYmxlPFQ+IHtcbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHNvdXJjZTogT2JzZXJ2YWJsZTxUPiwgcHJpdmF0ZSBzdWJzY3JpcHRpb25EZWxheTogT2JzZXJ2YWJsZTxhbnk+KSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4pIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbkRlbGF5LnN1YnNjcmliZShuZXcgU3Vic2NyaXB0aW9uRGVsYXlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuc291cmNlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIFN1YnNjcmlwdGlvbkRlbGF5U3Vic2NyaWJlcjxUPiBleHRlbmRzIFN1YnNjcmliZXI8VD4ge1xuICBwcml2YXRlIHNvdXJjZVN1YnNjcmliZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHBhcmVudDogU3Vic2NyaWJlcjxUPiwgcHJpdmF0ZSBzb3VyY2U6IE9ic2VydmFibGU8VD4pIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHVudXNlZDogYW55KSB7XG4gICAgdGhpcy5zdWJzY3JpYmVUb1NvdXJjZSgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9lcnJvcihlcnI6IGFueSkge1xuICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLnBhcmVudC5lcnJvcihlcnIpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jb21wbGV0ZSgpIHtcbiAgICB0aGlzLnN1YnNjcmliZVRvU291cmNlKCk7XG4gIH1cblxuICBwcml2YXRlIHN1YnNjcmliZVRvU291cmNlKCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5zb3VyY2VTdWJzY3JpYmVkKSB7XG4gICAgICB0aGlzLnNvdXJjZVN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgdGhpcy5zb3VyY2Uuc3Vic2NyaWJlKHRoaXMucGFyZW50KTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvZGVsYXlXaGVuLnRzIiwiaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBOb3RpZmljYXRpb24gfSBmcm9tICcuLi9Ob3RpZmljYXRpb24nO1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIE9ic2VydmFibGUgb2Yge0BsaW5rIE5vdGlmaWNhdGlvbn0gb2JqZWN0cyBpbnRvIHRoZSBlbWlzc2lvbnNcbiAqIHRoYXQgdGhleSByZXByZXNlbnQuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlVud3JhcHMge0BsaW5rIE5vdGlmaWNhdGlvbn0gb2JqZWN0cyBhcyBhY3R1YWwgYG5leHRgLFxuICogYGVycm9yYCBhbmQgYGNvbXBsZXRlYCBlbWlzc2lvbnMuIFRoZSBvcHBvc2l0ZSBvZiB7QGxpbmsgbWF0ZXJpYWxpemV9Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2RlbWF0ZXJpYWxpemUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGRlbWF0ZXJpYWxpemVgIGlzIGFzc3VtZWQgdG8gb3BlcmF0ZSBhbiBPYnNlcnZhYmxlIHRoYXQgb25seSBlbWl0c1xuICoge0BsaW5rIE5vdGlmaWNhdGlvbn0gb2JqZWN0cyBhcyBgbmV4dGAgZW1pc3Npb25zLCBhbmQgZG9lcyBub3QgZW1pdCBhbnlcbiAqIGBlcnJvcmAuIFN1Y2ggT2JzZXJ2YWJsZSBpcyB0aGUgb3V0cHV0IG9mIGEgYG1hdGVyaWFsaXplYCBvcGVyYXRpb24uIFRob3NlXG4gKiBub3RpZmljYXRpb25zIGFyZSB0aGVuIHVud3JhcHBlZCB1c2luZyB0aGUgbWV0YWRhdGEgdGhleSBjb250YWluLCBhbmQgZW1pdHRlZFxuICogYXMgYG5leHRgLCBgZXJyb3JgLCBhbmQgYGNvbXBsZXRlYCBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogVXNlIHRoaXMgb3BlcmF0b3IgaW4gY29uanVuY3Rpb24gd2l0aCB7QGxpbmsgbWF0ZXJpYWxpemV9LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvbnZlcnQgYW4gT2JzZXJ2YWJsZSBvZiBOb3RpZmljYXRpb25zIHRvIGFuIGFjdHVhbCBPYnNlcnZhYmxlPC9jYXB0aW9uPlxuICogdmFyIG5vdGlmQSA9IG5ldyBSeC5Ob3RpZmljYXRpb24oJ04nLCAnQScpO1xuICogdmFyIG5vdGlmQiA9IG5ldyBSeC5Ob3RpZmljYXRpb24oJ04nLCAnQicpO1xuICogdmFyIG5vdGlmRSA9IG5ldyBSeC5Ob3RpZmljYXRpb24oJ0UnLCB2b2lkIDAsXG4gKiAgIG5ldyBUeXBlRXJyb3IoJ3gudG9VcHBlckNhc2UgaXMgbm90IGEgZnVuY3Rpb24nKVxuICogKTtcbiAqIHZhciBtYXRlcmlhbGl6ZWQgPSBSeC5PYnNlcnZhYmxlLm9mKG5vdGlmQSwgbm90aWZCLCBub3RpZkUpO1xuICogdmFyIHVwcGVyQ2FzZSA9IG1hdGVyaWFsaXplZC5kZW1hdGVyaWFsaXplKCk7XG4gKiB1cHBlckNhc2Uuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCksIGUgPT4gY29uc29sZS5lcnJvcihlKSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbjpcbiAqIC8vIEFcbiAqIC8vIEJcbiAqIC8vIFR5cGVFcnJvcjogeC50b1VwcGVyQ2FzZSBpcyBub3QgYSBmdW5jdGlvblxuICpcbiAqIEBzZWUge0BsaW5rIE5vdGlmaWNhdGlvbn1cbiAqIEBzZWUge0BsaW5rIG1hdGVyaWFsaXplfVxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBhbmQgbm90aWZpY2F0aW9uc1xuICogZW1iZWRkZWQgaW4gTm90aWZpY2F0aW9uIG9iamVjdHMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIGRlbWF0ZXJpYWxpemVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZW1hdGVyaWFsaXplPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4pOiBPYnNlcnZhYmxlPGFueT4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBEZU1hdGVyaWFsaXplT3BlcmF0b3IoKSk7XG59XG5cbmNsYXNzIERlTWF0ZXJpYWxpemVPcGVyYXRvcjxUIGV4dGVuZHMgTm90aWZpY2F0aW9uPGFueT4sIFI+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgUj4ge1xuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8YW55Piwgc291cmNlOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBEZU1hdGVyaWFsaXplU3Vic2NyaWJlcihzdWJzY3JpYmVyKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIERlTWF0ZXJpYWxpemVTdWJzY3JpYmVyPFQgZXh0ZW5kcyBOb3RpZmljYXRpb248YW55Pj4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8YW55Pikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCkge1xuICAgIHZhbHVlLm9ic2VydmUodGhpcy5kZXN0aW5hdGlvbik7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvZGVtYXRlcmlhbGl6ZS50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBPdXRlclN1YnNjcmliZXIgfSBmcm9tICcuLi9PdXRlclN1YnNjcmliZXInO1xuaW1wb3J0IHsgSW5uZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vSW5uZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IHN1YnNjcmliZVRvUmVzdWx0IH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCc7XG5pbXBvcnQgeyBJU2V0LCBTZXQgfSBmcm9tICcuLi91dGlsL1NldCc7XG5cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYWxsIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHRoYXQgYXJlIGRpc3RpbmN0IGJ5IGNvbXBhcmlzb24gZnJvbSBwcmV2aW91cyBpdGVtcy5cbiAqXG4gKiBJZiBhIGtleVNlbGVjdG9yIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCB0aGVuIGl0IHdpbGwgcHJvamVjdCBlYWNoIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBvYnNlcnZhYmxlIGludG8gYSBuZXcgdmFsdWUgdGhhdCBpdCB3aWxsXG4gKiBjaGVjayBmb3IgZXF1YWxpdHkgd2l0aCBwcmV2aW91c2x5IHByb2plY3RlZCB2YWx1ZXMuIElmIGEga2V5U2VsZWN0b3IgZnVuY3Rpb24gaXMgbm90IHByb3ZpZGVkLCBpdCB3aWxsIHVzZSBlYWNoIHZhbHVlIGZyb20gdGhlXG4gKiBzb3VyY2Ugb2JzZXJ2YWJsZSBkaXJlY3RseSB3aXRoIGFuIGVxdWFsaXR5IGNoZWNrIGFnYWluc3QgcHJldmlvdXMgdmFsdWVzLlxuICpcbiAqIEluIEphdmFTY3JpcHQgcnVudGltZXMgdGhhdCBzdXBwb3J0IGBTZXRgLCB0aGlzIG9wZXJhdG9yIHdpbGwgdXNlIGEgYFNldGAgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSBvZiB0aGUgZGlzdGluY3QgdmFsdWUgY2hlY2tpbmcuXG4gKlxuICogSW4gb3RoZXIgcnVudGltZXMsIHRoaXMgb3BlcmF0b3Igd2lsbCB1c2UgYSBtaW5pbWFsIGltcGxlbWVudGF0aW9uIG9mIGBTZXRgIHRoYXQgcmVsaWVzIG9uIGFuIGBBcnJheWAgYW5kIGBpbmRleE9mYCB1bmRlciB0aGVcbiAqIGhvb2QsIHNvIHBlcmZvcm1hbmNlIHdpbGwgZGVncmFkZSBhcyBtb3JlIHZhbHVlcyBhcmUgY2hlY2tlZCBmb3IgZGlzdGluY3Rpb24uIEV2ZW4gaW4gbmV3ZXIgYnJvd3NlcnMsIGEgbG9uZy1ydW5uaW5nIGBkaXN0aW5jdGBcbiAqIHVzZSBtaWdodCByZXN1bHQgaW4gbWVtb3J5IGxlYWtzLiBUbyBoZWxwIGFsbGV2aWF0ZSB0aGlzIGluIHNvbWUgc2NlbmFyaW9zLCBhbiBvcHRpb25hbCBgZmx1c2hlc2AgcGFyYW1ldGVyIGlzIGFsc28gcHJvdmlkZWQgc29cbiAqIHRoYXQgdGhlIGludGVybmFsIGBTZXRgIGNhbiBiZSBcImZsdXNoZWRcIiwgYmFzaWNhbGx5IGNsZWFyaW5nIGl0IG9mIHZhbHVlcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5BIHNpbXBsZSBleGFtcGxlIHdpdGggbnVtYmVyczwvY2FwdGlvbj5cbiAqIE9ic2VydmFibGUub2YoMSwgMSwgMiwgMiwgMiwgMSwgMiwgMywgNCwgMywgMiwgMSlcbiAqICAgLmRpc3RpbmN0KClcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTsgLy8gMSwgMiwgMywgNFxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkFuIGV4YW1wbGUgdXNpbmcgYSBrZXlTZWxlY3RvciBmdW5jdGlvbjwvY2FwdGlvbj5cbiAqIGludGVyZmFjZSBQZXJzb24ge1xuICogICAgYWdlOiBudW1iZXIsXG4gKiAgICBuYW1lOiBzdHJpbmdcbiAqIH1cbiAqXG4gKiBPYnNlcnZhYmxlLm9mPFBlcnNvbj4oXG4gKiAgICAgeyBhZ2U6IDQsIG5hbWU6ICdGb28nfSxcbiAqICAgICB7IGFnZTogNywgbmFtZTogJ0Jhcid9LFxuICogICAgIHsgYWdlOiA1LCBuYW1lOiAnRm9vJ30pXG4gKiAgICAgLmRpc3RpbmN0KChwOiBQZXJzb24pID0+IHAubmFtZSlcbiAqICAgICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIC8vIGRpc3BsYXlzOlxuICogLy8geyBhZ2U6IDQsIG5hbWU6ICdGb28nIH1cbiAqIC8vIHsgYWdlOiA3LCBuYW1lOiAnQmFyJyB9XG4gKlxuICogQHNlZSB7QGxpbmsgZGlzdGluY3RVbnRpbENoYW5nZWR9XG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBba2V5U2VsZWN0b3JdIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIHNlbGVjdCB3aGljaCB2YWx1ZSB5b3Ugd2FudCB0byBjaGVjayBhcyBkaXN0aW5jdC5cbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gW2ZsdXNoZXNdIE9wdGlvbmFsIE9ic2VydmFibGUgZm9yIGZsdXNoaW5nIHRoZSBpbnRlcm5hbCBIYXNoU2V0IG9mIHRoZSBvcGVyYXRvci5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aXRoIGRpc3RpbmN0IHZhbHVlcy5cbiAqIEBtZXRob2QgZGlzdGluY3RcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0aW5jdDxULCBLPih0aGlzOiBPYnNlcnZhYmxlPFQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVNlbGVjdG9yPzogKHZhbHVlOiBUKSA9PiBLLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoZXM/OiBPYnNlcnZhYmxlPGFueT4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgRGlzdGluY3RPcGVyYXRvcihrZXlTZWxlY3RvciwgZmx1c2hlcykpO1xufVxuXG5jbGFzcyBEaXN0aW5jdE9wZXJhdG9yPFQsIEs+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGtleVNlbGVjdG9yOiAodmFsdWU6IFQpID0+IEssIHByaXZhdGUgZmx1c2hlczogT2JzZXJ2YWJsZTxhbnk+KSB7XG4gIH1cblxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4sIHNvdXJjZTogYW55KTogVGVhcmRvd25Mb2dpYyB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERpc3RpbmN0U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmtleVNlbGVjdG9yLCB0aGlzLmZsdXNoZXMpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuZXhwb3J0IGNsYXNzIERpc3RpbmN0U3Vic2NyaWJlcjxULCBLPiBleHRlbmRzIE91dGVyU3Vic2NyaWJlcjxULCBUPiB7XG4gIHByaXZhdGUgdmFsdWVzOiBJU2V0PEs+ID0gbmV3IFNldDxLPigpO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFQ+LCBwcml2YXRlIGtleVNlbGVjdG9yOiAodmFsdWU6IFQpID0+IEssIGZsdXNoZXM6IE9ic2VydmFibGU8YW55Pikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcblxuICAgIGlmIChmbHVzaGVzKSB7XG4gICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCBmbHVzaGVzKSk7XG4gICAgfVxuICB9XG5cbiAgbm90aWZ5TmV4dChvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBULFxuICAgICAgICAgICAgIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgIGlubmVyU3ViOiBJbm5lclN1YnNjcmliZXI8VCwgVD4pOiB2b2lkIHtcbiAgICB0aGlzLnZhbHVlcy5jbGVhcigpO1xuICB9XG5cbiAgbm90aWZ5RXJyb3IoZXJyb3I6IGFueSwgaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBUPik6IHZvaWQge1xuICAgIHRoaXMuX2Vycm9yKGVycm9yKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmtleVNlbGVjdG9yKSB7XG4gICAgICB0aGlzLl91c2VLZXlTZWxlY3Rvcih2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ZpbmFsaXplTmV4dCh2YWx1ZSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX3VzZUtleVNlbGVjdG9yKHZhbHVlOiBUKTogdm9pZCB7XG4gICAgbGV0IGtleTogSztcbiAgICBjb25zdCB7IGRlc3RpbmF0aW9uIH0gPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICBrZXkgPSB0aGlzLmtleVNlbGVjdG9yKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2ZpbmFsaXplTmV4dChrZXksIHZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgX2ZpbmFsaXplTmV4dChrZXk6IEt8VCwgdmFsdWU6IFQpIHtcbiAgICBjb25zdCB7IHZhbHVlcyB9ID0gdGhpcztcbiAgICBpZiAoIXZhbHVlcy5oYXMoPEs+a2V5KSkge1xuICAgICAgdmFsdWVzLmFkZCg8Sz5rZXkpO1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICB9XG4gIH1cblxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9kaXN0aW5jdC50cyIsImltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkIH0gZnJvbSAnLi9kaXN0aW5jdFVudGlsQ2hhbmdlZCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIGtleTogc3RyaW5nKTogT2JzZXJ2YWJsZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZDxULCBLPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBrZXk6IHN0cmluZywgY29tcGFyZTogKHg6IEssIHk6IEspID0+IGJvb2xlYW4pOiBPYnNlcnZhYmxlPFQ+O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cblxuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBhcmUgZGlzdGluY3QgYnkgY29tcGFyaXNvbiBmcm9tIHRoZSBwcmV2aW91cyBpdGVtLFxuICogdXNpbmcgYSBwcm9wZXJ0eSBhY2Nlc3NlZCBieSB1c2luZyB0aGUga2V5IHByb3ZpZGVkIHRvIGNoZWNrIGlmIHRoZSB0d28gaXRlbXMgYXJlIGRpc3RpbmN0LlxuICpcbiAqIElmIGEgY29tcGFyYXRvciBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdGhlbiBpdCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBpdGVtIHRvIHRlc3QgZm9yIHdoZXRoZXIgb3Igbm90IHRoYXQgdmFsdWUgc2hvdWxkIGJlIGVtaXR0ZWQuXG4gKlxuICogSWYgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIGlzIG5vdCBwcm92aWRlZCwgYW4gZXF1YWxpdHkgY2hlY2sgaXMgdXNlZCBieSBkZWZhdWx0LlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkFuIGV4YW1wbGUgY29tcGFyaW5nIHRoZSBuYW1lIG9mIHBlcnNvbnM8L2NhcHRpb24+XG4gKlxuICogIGludGVyZmFjZSBQZXJzb24ge1xuICogICAgIGFnZTogbnVtYmVyLFxuICogICAgIG5hbWU6IHN0cmluZ1xuICogIH1cbiAqXG4gKiBPYnNlcnZhYmxlLm9mPFBlcnNvbj4oXG4gKiAgICAgeyBhZ2U6IDQsIG5hbWU6ICdGb28nfSxcbiAqICAgICB7IGFnZTogNywgbmFtZTogJ0Jhcid9LFxuICogICAgIHsgYWdlOiA1LCBuYW1lOiAnRm9vJ30sXG4gKiAgICAgeyBhZ2U6IDYsIG5hbWU6ICdGb28nfSlcbiAqICAgICAuZGlzdGluY3RVbnRpbEtleUNoYW5nZWQoJ25hbWUnKVxuICogICAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gZGlzcGxheXM6XG4gKiAvLyB7IGFnZTogNCwgbmFtZTogJ0ZvbycgfVxuICogLy8geyBhZ2U6IDcsIG5hbWU6ICdCYXInIH1cbiAqIC8vIHsgYWdlOiA1LCBuYW1lOiAnRm9vJyB9XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+QW4gZXhhbXBsZSBjb21wYXJpbmcgdGhlIGZpcnN0IGxldHRlcnMgb2YgdGhlIG5hbWU8L2NhcHRpb24+XG4gKlxuICogaW50ZXJmYWNlIFBlcnNvbiB7XG4gKiAgICAgYWdlOiBudW1iZXIsXG4gKiAgICAgbmFtZTogc3RyaW5nXG4gKiAgfVxuICpcbiAqIE9ic2VydmFibGUub2Y8UGVyc29uPihcbiAqICAgICB7IGFnZTogNCwgbmFtZTogJ0ZvbzEnfSxcbiAqICAgICB7IGFnZTogNywgbmFtZTogJ0Jhcid9LFxuICogICAgIHsgYWdlOiA1LCBuYW1lOiAnRm9vMid9LFxuICogICAgIHsgYWdlOiA2LCBuYW1lOiAnRm9vMyd9KVxuICogICAgIC5kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCgnbmFtZScsICh4OiBzdHJpbmcsIHk6IHN0cmluZykgPT4geC5zdWJzdHJpbmcoMCwgMykgPT09IHkuc3Vic3RyaW5nKDAsIDMpKVxuICogICAgIC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gZGlzcGxheXM6XG4gKiAvLyB7IGFnZTogNCwgbmFtZTogJ0ZvbzEnIH1cbiAqIC8vIHsgYWdlOiA3LCBuYW1lOiAnQmFyJyB9XG4gKiAvLyB7IGFnZTogNSwgbmFtZTogJ0ZvbzInIH1cbiAqXG4gKiBAc2VlIHtAbGluayBkaXN0aW5jdH1cbiAqIEBzZWUge0BsaW5rIGRpc3RpbmN0VW50aWxDaGFuZ2VkfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgU3RyaW5nIGtleSBmb3Igb2JqZWN0IHByb3BlcnR5IGxvb2t1cCBvbiBlYWNoIGl0ZW0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY29tcGFyZV0gT3B0aW9uYWwgY29tcGFyaXNvbiBmdW5jdGlvbiBjYWxsZWQgdG8gdGVzdCBpZiBhbiBpdGVtIGlzIGRpc3RpbmN0IGZyb20gdGhlIHByZXZpb3VzIGl0ZW0gaW4gdGhlIHNvdXJjZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBpdGVtcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aXRoIGRpc3RpbmN0IHZhbHVlcyBiYXNlZCBvbiB0aGUga2V5IHNwZWNpZmllZC5cbiAqIEBtZXRob2QgZGlzdGluY3RVbnRpbEtleUNoYW5nZWRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZDxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBrZXk6IHN0cmluZywgY29tcGFyZT86ICh4OiBULCB5OiBUKSA9PiBib29sZWFuKTogT2JzZXJ2YWJsZTxUPiB7XG4gIHJldHVybiBkaXN0aW5jdFVudGlsQ2hhbmdlZC5jYWxsKHRoaXMsIGZ1bmN0aW9uKHg6IFQsIHk6IFQpIHtcbiAgICBpZiAoY29tcGFyZSkge1xuICAgICAgcmV0dXJuIGNvbXBhcmUoeFtrZXldLCB5W2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4geFtrZXldID09PSB5W2tleV07XG4gIH0pO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9kaXN0aW5jdFVudGlsS2V5Q2hhbmdlZC50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgUGFydGlhbE9ic2VydmVyIH0gZnJvbSAnLi4vT2JzZXJ2ZXInO1xuaW1wb3J0IHsgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9kbzxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBuZXh0OiAoeDogVCkgPT4gdm9pZCwgZXJyb3I/OiAoZTogYW55KSA9PiB2b2lkLCBjb21wbGV0ZT86ICgpID0+IHZvaWQpOiBPYnNlcnZhYmxlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIF9kbzxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBvYnNlcnZlcjogUGFydGlhbE9ic2VydmVyPFQ+KTogT2JzZXJ2YWJsZTxUPjtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbi8qKlxuICogUGVyZm9ybSBhIHNpZGUgZWZmZWN0IGZvciBldmVyeSBlbWlzc2lvbiBvbiB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCByZXR1cm5cbiAqIGFuIE9ic2VydmFibGUgdGhhdCBpcyBpZGVudGljYWwgdG8gdGhlIHNvdXJjZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SW50ZXJjZXB0cyBlYWNoIGVtaXNzaW9uIG9uIHRoZSBzb3VyY2UgYW5kIHJ1bnMgYVxuICogZnVuY3Rpb24sIGJ1dCByZXR1cm5zIGFuIG91dHB1dCB3aGljaCBpcyBpZGVudGljYWwgdG8gdGhlIHNvdXJjZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9kby5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGEgbWlycm9yZWQgT2JzZXJ2YWJsZSBvZiB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCBtb2RpZmllZCBzbyB0aGF0XG4gKiB0aGUgcHJvdmlkZWQgT2JzZXJ2ZXIgaXMgY2FsbGVkIHRvIHBlcmZvcm0gYSBzaWRlIGVmZmVjdCBmb3IgZXZlcnkgdmFsdWUsXG4gKiBlcnJvciwgYW5kIGNvbXBsZXRpb24gZW1pdHRlZCBieSB0aGUgc291cmNlLiBBbnkgZXJyb3JzIHRoYXQgYXJlIHRocm93biBpblxuICogdGhlIGFmb3JlbWVudGlvbmVkIE9ic2VydmVyIG9yIGhhbmRsZXJzIGFyZSBzYWZlbHkgc2VudCBkb3duIHRoZSBlcnJvciBwYXRoXG4gKiBvZiB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogVGhpcyBvcGVyYXRvciBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZyB5b3VyIE9ic2VydmFibGVzIGZvciB0aGUgY29ycmVjdCB2YWx1ZXNcbiAqIG9yIHBlcmZvcm1pbmcgb3RoZXIgc2lkZSBlZmZlY3RzLlxuICpcbiAqIE5vdGU6IHRoaXMgaXMgZGlmZmVyZW50IHRvIGEgYHN1YnNjcmliZWAgb24gdGhlIE9ic2VydmFibGUuIElmIHRoZSBPYnNlcnZhYmxlXG4gKiByZXR1cm5lZCBieSBgZG9gIGlzIG5vdCBzdWJzY3JpYmVkLCB0aGUgc2lkZSBlZmZlY3RzIHNwZWNpZmllZCBieSB0aGVcbiAqIE9ic2VydmVyIHdpbGwgbmV2ZXIgaGFwcGVuLiBgZG9gIHRoZXJlZm9yZSBzaW1wbHkgc3BpZXMgb24gZXhpc3RpbmdcbiAqIGV4ZWN1dGlvbiwgaXQgZG9lcyBub3QgdHJpZ2dlciBhbiBleGVjdXRpb24gdG8gaGFwcGVuIGxpa2UgYHN1YnNjcmliZWAgZG9lcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgZXZlcnkgZXZlcnkgY2xpY2sgdG8gdGhlIGNsaWVudFggcG9zaXRpb24gb2YgdGhhdCBjbGljaywgd2hpbGUgYWxzbyBsb2dnaW5nIHRoZSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcG9zaXRpb25zID0gY2xpY2tzXG4gKiAgIC5kbyhldiA9PiBjb25zb2xlLmxvZyhldikpXG4gKiAgIC5tYXAoZXYgPT4gZXYuY2xpZW50WCk7XG4gKiBwb3NpdGlvbnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIG1hcH1cbiAqIEBzZWUge0BsaW5rIHN1YnNjcmliZX1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmVyfGZ1bmN0aW9ufSBbbmV4dE9yT2JzZXJ2ZXJdIEEgbm9ybWFsIE9ic2VydmVyIG9iamVjdCBvciBhXG4gKiBjYWxsYmFjayBmb3IgYG5leHRgLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2Vycm9yXSBDYWxsYmFjayBmb3IgZXJyb3JzIGluIHRoZSBzb3VyY2UuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbY29tcGxldGVdIENhbGxiYWNrIGZvciB0aGUgY29tcGxldGlvbiBvZiB0aGUgc291cmNlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBpZGVudGljYWwgdG8gdGhlIHNvdXJjZSwgYnV0IHJ1bnMgdGhlXG4gKiBzcGVjaWZpZWQgT2JzZXJ2ZXIgb3IgY2FsbGJhY2socykgZm9yIGVhY2ggaXRlbS5cbiAqIEBtZXRob2QgZG9cbiAqIEBuYW1lIGRvXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2RvPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIG5leHRPck9ic2VydmVyPzogUGFydGlhbE9ic2VydmVyPFQ+IHwgKCh4OiBUKSA9PiB2b2lkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I/OiAoZTogYW55KSA9PiB2b2lkLFxuICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZT86ICgpID0+IHZvaWQpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgRG9PcGVyYXRvcihuZXh0T3JPYnNlcnZlciwgZXJyb3IsIGNvbXBsZXRlKSk7XG59XG5cbmNsYXNzIERvT3BlcmF0b3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbmV4dE9yT2JzZXJ2ZXI/OiBQYXJ0aWFsT2JzZXJ2ZXI8VD4gfCAoKHg6IFQpID0+IHZvaWQpLFxuICAgICAgICAgICAgICBwcml2YXRlIGVycm9yPzogKGU6IGFueSkgPT4gdm9pZCxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBjb21wbGV0ZT86ICgpID0+IHZvaWQpIHtcbiAgfVxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4sIHNvdXJjZTogYW55KTogVGVhcmRvd25Mb2dpYyB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IERvU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm5leHRPck9ic2VydmVyLCB0aGlzLmVycm9yLCB0aGlzLmNvbXBsZXRlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIERvU3Vic2NyaWJlcjxUPiBleHRlbmRzIFN1YnNjcmliZXI8VD4ge1xuXG4gIHByaXZhdGUgc2FmZVN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD47XG5cbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8VD4sXG4gICAgICAgICAgICAgIG5leHRPck9ic2VydmVyPzogUGFydGlhbE9ic2VydmVyPFQ+IHwgKCh4OiBUKSA9PiB2b2lkKSxcbiAgICAgICAgICAgICAgZXJyb3I/OiAoZTogYW55KSA9PiB2b2lkLFxuICAgICAgICAgICAgICBjb21wbGV0ZT86ICgpID0+IHZvaWQpIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG5cbiAgICBjb25zdCBzYWZlU3Vic2NyaWJlciA9IG5ldyBTdWJzY3JpYmVyPFQ+KG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xuICAgIHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSA9IHRydWU7XG4gICAgdGhpcy5hZGQoc2FmZVN1YnNjcmliZXIpO1xuICAgIHRoaXMuc2FmZVN1YnNjcmliZXIgPSBzYWZlU3Vic2NyaWJlcjtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIGNvbnN0IHsgc2FmZVN1YnNjcmliZXIgfSA9IHRoaXM7XG4gICAgc2FmZVN1YnNjcmliZXIubmV4dCh2YWx1ZSk7XG4gICAgaWYgKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93bikge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9lcnJvcihlcnI6IGFueSk6IHZvaWQge1xuICAgIGNvbnN0IHsgc2FmZVN1YnNjcmliZXIgfSA9IHRoaXM7XG4gICAgc2FmZVN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICBpZiAoc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKHNhZmVTdWJzY3JpYmVyLnN5bmNFcnJvclZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKTogdm9pZCB7XG4gICAgY29uc3QgeyBzYWZlU3Vic2NyaWJlciB9ID0gdGhpcztcbiAgICBzYWZlU3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgIGlmIChzYWZlU3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd24pIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3Ioc2FmZVN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL2RvLnRzIiwiaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvciB9IGZyb20gJy4uL3V0aWwvQXJndW1lbnRPdXRPZlJhbmdlRXJyb3InO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5cbi8qKlxuICogRW1pdHMgdGhlIHNpbmdsZSB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIGBpbmRleGAgaW4gYSBzZXF1ZW5jZSBvZiBlbWlzc2lvbnNcbiAqIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5FbWl0cyBvbmx5IHRoZSBpLXRoIHZhbHVlLCB0aGVuIGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9lbGVtZW50QXQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGVsZW1lbnRBdGAgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIGl0ZW0gYXQgdGhlIHNwZWNpZmllZFxuICogYGluZGV4YCBpbiB0aGUgc291cmNlIE9ic2VydmFibGUsIG9yIGEgZGVmYXVsdCB2YWx1ZSBpZiB0aGF0IGBpbmRleGAgaXMgb3V0XG4gKiBvZiByYW5nZSBhbmQgdGhlIGBkZWZhdWx0YCBhcmd1bWVudCBpcyBwcm92aWRlZC4gSWYgdGhlIGBkZWZhdWx0YCBhcmd1bWVudCBpc1xuICogbm90IGdpdmVuIGFuZCB0aGUgYGluZGV4YCBpcyBvdXQgb2YgcmFuZ2UsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSB3aWxsIGVtaXQgYW5cbiAqIGBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcmAgZXJyb3IuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBvbmx5IHRoZSB0aGlyZCBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmVsZW1lbnRBdCgyKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogLy8gUmVzdWx0cyBpbjpcbiAqIC8vIGNsaWNrIDEgPSBub3RoaW5nXG4gKiAvLyBjbGljayAyID0gbm90aGluZ1xuICogLy8gY2xpY2sgMyA9IE1vdXNlRXZlbnQgb2JqZWN0IGxvZ2dlZCB0byBjb25zb2xlXG4gKlxuICogQHNlZSB7QGxpbmsgZmlyc3R9XG4gKiBAc2VlIHtAbGluayBsYXN0fVxuICogQHNlZSB7QGxpbmsgc2tpcH1cbiAqIEBzZWUge0BsaW5rIHNpbmdsZX1cbiAqIEBzZWUge0BsaW5rIHRha2V9XG4gKlxuICogQHRocm93cyB7QXJndW1lbnRPdXRPZlJhbmdlRXJyb3J9IFdoZW4gdXNpbmcgYGVsZW1lbnRBdChpKWAsIGl0IGRlbGl2ZXJzIGFuXG4gKiBBcmd1bWVudE91dE9yUmFuZ2VFcnJvciB0byB0aGUgT2JzZXJ2ZXIncyBgZXJyb3JgIGNhbGxiYWNrIGlmIGBpIDwgMGAgb3IgdGhlXG4gKiBPYnNlcnZhYmxlIGhhcyBjb21wbGV0ZWQgYmVmb3JlIGVtaXR0aW5nIHRoZSBpLXRoIGBuZXh0YCBub3RpZmljYXRpb24uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IElzIHRoZSBudW1iZXIgYGlgIGZvciB0aGUgaS10aCBzb3VyY2UgZW1pc3Npb24gdGhhdCBoYXNcbiAqIGhhcHBlbmVkIHNpbmNlIHRoZSBzdWJzY3JpcHRpb24sIHN0YXJ0aW5nIGZyb20gdGhlIG51bWJlciBgMGAuXG4gKiBAcGFyYW0ge1R9IFtkZWZhdWx0VmFsdWVdIFRoZSBkZWZhdWx0IHZhbHVlIHJldHVybmVkIGZvciBtaXNzaW5nIGluZGljZXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYSBzaW5nbGUgaXRlbSwgaWYgaXQgaXMgZm91bmQuXG4gKiBPdGhlcndpc2UsIHdpbGwgZW1pdCB0aGUgZGVmYXVsdCB2YWx1ZSBpZiBnaXZlbi4gSWYgbm90LCB0aGVuIGVtaXRzIGFuIGVycm9yLlxuICogQG1ldGhvZCBlbGVtZW50QXRcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50QXQ8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgaW5kZXg6IG51bWJlciwgZGVmYXVsdFZhbHVlPzogVCk6IE9ic2VydmFibGU8VD4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBFbGVtZW50QXRPcGVyYXRvcihpbmRleCwgZGVmYXVsdFZhbHVlKSk7XG59XG5cbmNsYXNzIEVsZW1lbnRBdE9wZXJhdG9yPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVD4ge1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaW5kZXg6IG51bWJlciwgcHJpdmF0ZSBkZWZhdWx0VmFsdWU/OiBUKSB7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPiwgc291cmNlOiBhbnkpOiBUZWFyZG93bkxvZ2ljIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgRWxlbWVudEF0U3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmluZGV4LCB0aGlzLmRlZmF1bHRWYWx1ZSkpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBFbGVtZW50QXRTdWJzY3JpYmVyPFQ+IGV4dGVuZHMgU3Vic2NyaWJlcjxUPiB7XG5cbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8VD4sIHByaXZhdGUgaW5kZXg6IG51bWJlciwgcHJpdmF0ZSBkZWZhdWx0VmFsdWU/OiBUKSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHg6IFQpIHtcbiAgICBpZiAodGhpcy5pbmRleC0tID09PSAwKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoeCk7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jb21wbGV0ZSgpIHtcbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgaWYgKHRoaXMuaW5kZXggPj0gMCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLmRlZmF1bHRWYWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dCh0aGlzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL2VsZW1lbnRBdC50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgT2JzZXJ2ZXIgfSBmcm9tICcuLi9PYnNlcnZlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2hldGhlciBvciBub3QgZXZlcnkgaXRlbSBvZiB0aGUgc291cmNlIHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIHNwZWNpZmllZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5BIHNpbXBsZSBleGFtcGxlIGVtaXR0aW5nIHRydWUgaWYgYWxsIGVsZW1lbnRzIGFyZSBsZXNzIHRoYW4gNSwgZmFsc2Ugb3RoZXJ3aXNlPC9jYXB0aW9uPlxuICogIE9ic2VydmFibGUub2YoMSwgMiwgMywgNCwgNSwgNilcbiAqICAgICAuZXZlcnkoeCA9PiB4IDwgNSlcbiAqICAgICAuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpOyAvLyAtPiBmYWxzZVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZSBBIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyBpZiBhbiBpdGVtIG1lZXRzIGEgc3BlY2lmaWVkIGNvbmRpdGlvbi5cbiAqIEBwYXJhbSB7YW55fSBbdGhpc0FyZ10gT3B0aW9uYWwgb2JqZWN0IHRvIHVzZSBmb3IgYHRoaXNgIGluIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgb2YgYm9vbGVhbnMgdGhhdCBkZXRlcm1pbmVzIGlmIGFsbCBpdGVtcyBvZiB0aGUgc291cmNlIE9ic2VydmFibGUgbWVldCB0aGUgY29uZGl0aW9uIHNwZWNpZmllZC5cbiAqIEBtZXRob2QgZXZlcnlcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBldmVyeTxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBwcmVkaWNhdGU6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBib29sZWFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNBcmc/OiBhbnkpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgRXZlcnlPcGVyYXRvcihwcmVkaWNhdGUsIHRoaXNBcmcsIHRoaXMpKTtcbn1cblxuY2xhc3MgRXZlcnlPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIGJvb2xlYW4+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwcmVkaWNhdGU6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBib29sZWFuLFxuICAgICAgICAgICAgICBwcml2YXRlIHRoaXNBcmc/OiBhbnksXG4gICAgICAgICAgICAgIHByaXZhdGUgc291cmNlPzogT2JzZXJ2YWJsZTxUPikge1xuICB9XG5cbiAgY2FsbChvYnNlcnZlcjogU3Vic2NyaWJlcjxib29sZWFuPiwgc291cmNlOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBFdmVyeVN1YnNjcmliZXIob2JzZXJ2ZXIsIHRoaXMucHJlZGljYXRlLCB0aGlzLnRoaXNBcmcsIHRoaXMuc291cmNlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIEV2ZXJ5U3Vic2NyaWJlcjxUPiBleHRlbmRzIFN1YnNjcmliZXI8VD4ge1xuICBwcml2YXRlIGluZGV4OiBudW1iZXIgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBPYnNlcnZlcjxib29sZWFuPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBwcmVkaWNhdGU6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBib29sZWFuLFxuICAgICAgICAgICAgICBwcml2YXRlIHRoaXNBcmc6IGFueSxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBzb3VyY2U/OiBPYnNlcnZhYmxlPFQ+KSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmcgfHwgdGhpcztcbiAgfVxuXG4gIHByaXZhdGUgbm90aWZ5Q29tcGxldGUoZXZlcnlWYWx1ZU1hdGNoOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGV2ZXJ5VmFsdWVNYXRjaCk7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHZhbHVlOiBUKTogdm9pZCB7XG4gICAgbGV0IHJlc3VsdCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnByZWRpY2F0ZS5jYWxsKHRoaXMudGhpc0FyZywgdmFsdWUsIHRoaXMuaW5kZXgrKywgdGhpcy5zb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB0aGlzLm5vdGlmeUNvbXBsZXRlKGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbXBsZXRlKCk6IHZvaWQge1xuICAgIHRoaXMubm90aWZ5Q29tcGxldGUodHJ1ZSk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvZXZlcnkudHMiLCJpbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiwgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBPdXRlclN1YnNjcmliZXIgfSBmcm9tICcuLi9PdXRlclN1YnNjcmliZXInO1xuaW1wb3J0IHsgc3Vic2NyaWJlVG9SZXN1bHQgfSBmcm9tICcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0JztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlIGludG8gYSBmaXJzdC1vcmRlciBPYnNlcnZhYmxlIGJ5IGRyb3BwaW5nXG4gKiBpbm5lciBPYnNlcnZhYmxlcyB3aGlsZSB0aGUgcHJldmlvdXMgaW5uZXIgT2JzZXJ2YWJsZSBoYXMgbm90IHlldCBjb21wbGV0ZWQuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkZsYXR0ZW5zIGFuIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXMgYnkgZHJvcHBpbmcgdGhlXG4gKiBuZXh0IGlubmVyIE9ic2VydmFibGVzIHdoaWxlIHRoZSBjdXJyZW50IGlubmVyIGlzIHN0aWxsIGV4ZWN1dGluZy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9leGhhdXN0LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBleGhhdXN0YCBzdWJzY3JpYmVzIHRvIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBPYnNlcnZhYmxlcywgYWxzbyBrbm93biBhcyBhXG4gKiBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZSBlbWl0dGVkIGlubmVyXG4gKiBPYnNlcnZhYmxlcywgdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJlZ2lucyBlbWl0dGluZyB0aGUgaXRlbXMgZW1pdHRlZCBieSB0aGF0XG4gKiBpbm5lciBPYnNlcnZhYmxlLiBTbyBmYXIsIGl0IGJlaGF2ZXMgbGlrZSB7QGxpbmsgbWVyZ2VBbGx9LiBIb3dldmVyLFxuICogYGV4aGF1c3RgIGlnbm9yZXMgZXZlcnkgbmV3IGlubmVyIE9ic2VydmFibGUgaWYgdGhlIHByZXZpb3VzIE9ic2VydmFibGUgaGFzXG4gKiBub3QgeWV0IGNvbXBsZXRlZC4gT25jZSB0aGF0IG9uZSBjb21wbGV0ZXMsIGl0IHdpbGwgYWNjZXB0IGFuZCBmbGF0dGVuIHRoZVxuICogbmV4dCBpbm5lciBPYnNlcnZhYmxlIGFuZCByZXBlYXQgdGhpcyBwcm9jZXNzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlJ1biBhIGZpbml0ZSB0aW1lciBmb3IgZWFjaCBjbGljaywgb25seSBpZiB0aGVyZSBpcyBubyBjdXJyZW50bHkgYWN0aXZlIHRpbWVyPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBoaWdoZXJPcmRlciA9IGNsaWNrcy5tYXAoKGV2KSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHZhciByZXN1bHQgPSBoaWdoZXJPcmRlci5leGhhdXN0KCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbWJpbmVBbGx9XG4gKiBAc2VlIHtAbGluayBjb25jYXRBbGx9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2h9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3RNYXB9XG4gKiBAc2VlIHtAbGluayB6aXBBbGx9XG4gKlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IHRha2VzIGEgc291cmNlIG9mIE9ic2VydmFibGVzIGFuZCBwcm9wYWdhdGVzIHRoZSBmaXJzdCBvYnNlcnZhYmxlXG4gKiBleGNsdXNpdmVseSB1bnRpbCBpdCBjb21wbGV0ZXMgYmVmb3JlIHN1YnNjcmliaW5nIHRvIHRoZSBuZXh0LlxuICogQG1ldGhvZCBleGhhdXN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhoYXVzdDxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+KTogT2JzZXJ2YWJsZTxUPiB7XG4gIHJldHVybiB0aGlzLmxpZnQobmV3IFN3aXRjaEZpcnN0T3BlcmF0b3I8VD4oKSk7XG59XG5cbmNsYXNzIFN3aXRjaEZpcnN0T3BlcmF0b3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUPiB7XG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPiwgc291cmNlOiBhbnkpOiBUZWFyZG93bkxvZ2ljIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU3dpdGNoRmlyc3RTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgU3dpdGNoRmlyc3RTdWJzY3JpYmVyPFQ+IGV4dGVuZHMgT3V0ZXJTdWJzY3JpYmVyPFQsIFQ+IHtcbiAgcHJpdmF0ZSBoYXNDb21wbGV0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBoYXNTdWJzY3JpcHRpb246IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxUPikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5oYXNTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuaGFzU3Vic2NyaXB0aW9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jb21wbGV0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgaWYgKCF0aGlzLmhhc1N1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIG5vdGlmeUNvbXBsZXRlKGlubmVyU3ViOiBTdWJzY3JpcHRpb24pOiB2b2lkIHtcbiAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgdGhpcy5oYXNTdWJzY3JpcHRpb24gPSBmYWxzZTtcbiAgICBpZiAodGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvZXhoYXVzdC50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2YWJsZUlucHV0IH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vT3V0ZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IElubmVyU3Vic2NyaWJlciB9IGZyb20gJy4uL0lubmVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBzdWJzY3JpYmVUb1Jlc3VsdCB9IGZyb20gJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmV4cG9ydCBmdW5jdGlvbiBleGhhdXN0TWFwPFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHByb2plY3Q6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gT2JzZXJ2YWJsZUlucHV0PFI+KTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiBleGhhdXN0TWFwPFQsIEksIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHByb2plY3Q6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gT2JzZXJ2YWJsZUlucHV0PEk+LCByZXN1bHRTZWxlY3RvcjogKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKSA9PiBSKTogT2JzZXJ2YWJsZTxSPjtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSBvbmx5IGlmIHRoZSBwcmV2aW91cyBwcm9qZWN0ZWQgT2JzZXJ2YWJsZSBoYXMgY29tcGxldGVkLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5NYXBzIGVhY2ggdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSwgdGhlbiBmbGF0dGVucyBhbGwgb2ZcbiAqIHRoZXNlIGlubmVyIE9ic2VydmFibGVzIHVzaW5nIHtAbGluayBleGhhdXN0fS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9leGhhdXN0TWFwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW1zIGJhc2VkIG9uIGFwcGx5aW5nIGEgZnVuY3Rpb24gdGhhdCB5b3VcbiAqIHN1cHBseSB0byBlYWNoIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUsIHdoZXJlIHRoYXQgZnVuY3Rpb25cbiAqIHJldHVybnMgYW4gKHNvLWNhbGxlZCBcImlubmVyXCIpIE9ic2VydmFibGUuIFdoZW4gaXQgcHJvamVjdHMgYSBzb3VyY2UgdmFsdWUgdG9cbiAqIGFuIE9ic2VydmFibGUsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiZWdpbnMgZW1pdHRpbmcgdGhlIGl0ZW1zIGVtaXR0ZWQgYnlcbiAqIHRoYXQgcHJvamVjdGVkIE9ic2VydmFibGUuIEhvd2V2ZXIsIGBleGhhdXN0TWFwYCBpZ25vcmVzIGV2ZXJ5IG5ldyBwcm9qZWN0ZWRcbiAqIE9ic2VydmFibGUgaWYgdGhlIHByZXZpb3VzIHByb2plY3RlZCBPYnNlcnZhYmxlIGhhcyBub3QgeWV0IGNvbXBsZXRlZC4gT25jZVxuICogdGhhdCBvbmUgY29tcGxldGVzLCBpdCB3aWxsIGFjY2VwdCBhbmQgZmxhdHRlbiB0aGUgbmV4dCBwcm9qZWN0ZWQgT2JzZXJ2YWJsZVxuICogYW5kIHJlcGVhdCB0aGlzIHByb2Nlc3MuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UnVuIGEgZmluaXRlIHRpbWVyIGZvciBlYWNoIGNsaWNrLCBvbmx5IGlmIHRoZXJlIGlzIG5vIGN1cnJlbnRseSBhY3RpdmUgdGltZXI8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5leGhhdXN0TWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZU1hcH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGVJbnB1dH0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIGNvbnRhaW5pbmcgcHJvamVjdGVkIE9ic2VydmFibGVzXG4gKiBvZiBlYWNoIGl0ZW0gb2YgdGhlIHNvdXJjZSwgaWdub3JpbmcgcHJvamVjdGVkIE9ic2VydmFibGVzIHRoYXQgc3RhcnQgYmVmb3JlXG4gKiB0aGVpciBwcmVjZWRpbmcgT2JzZXJ2YWJsZSBoYXMgY29tcGxldGVkLlxuICogQG1ldGhvZCBleGhhdXN0TWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhoYXVzdE1hcDxULCBJLCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBwcm9qZWN0OiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IE9ic2VydmFibGVJbnB1dDxJPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFNlbGVjdG9yPzogKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKSA9PiBSKTogT2JzZXJ2YWJsZTxSPiB7XG4gIHJldHVybiB0aGlzLmxpZnQobmV3IFN3aXRjaEZpcnN0TWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpKTtcbn1cblxuY2xhc3MgU3dpdGNoRmlyc3RNYXBPcGVyYXRvcjxULCBJLCBSPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFI+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwcm9qZWN0OiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IE9ic2VydmFibGVJbnB1dDxJPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSByZXN1bHRTZWxlY3Rvcj86IChvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcikgPT4gUikge1xuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFI+LCBzb3VyY2U6IGFueSk6IGFueSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFN3aXRjaEZpcnN0TWFwU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByb2plY3QsIHRoaXMucmVzdWx0U2VsZWN0b3IpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgU3dpdGNoRmlyc3RNYXBTdWJzY3JpYmVyPFQsIEksIFI+IGV4dGVuZHMgT3V0ZXJTdWJzY3JpYmVyPFQsIEk+IHtcbiAgcHJpdmF0ZSBoYXNTdWJzY3JpcHRpb246IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBoYXNDb21wbGV0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBpbmRleDogbnVtYmVyID0gMDtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxSPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBwcm9qZWN0OiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IE9ic2VydmFibGVJbnB1dDxJPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSByZXN1bHRTZWxlY3Rvcj86IChvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcikgPT4gUikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5oYXNTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMudHJ5TmV4dCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cnlOZXh0KHZhbHVlOiBUKTogdm9pZCB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnByb2plY3QodmFsdWUsIGluZGV4KTtcbiAgICAgIHRoaXMuaGFzU3Vic2NyaXB0aW9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIHJlc3VsdCwgdmFsdWUsIGluZGV4KSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKTogdm9pZCB7XG4gICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgIGlmICghdGhpcy5oYXNTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9XG4gIH1cblxuICBub3RpZnlOZXh0KG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksXG4gICAgICAgICAgICAgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICAgaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBJPik6IHZvaWQge1xuICAgIGNvbnN0IHsgcmVzdWx0U2VsZWN0b3IsIGRlc3RpbmF0aW9uIH0gPSB0aGlzO1xuICAgIGlmIChyZXN1bHRTZWxlY3Rvcikge1xuICAgICAgdGhpcy50cnlTZWxlY3RSZXN1bHQob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cnlTZWxlY3RSZXN1bHQob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCB7IHJlc3VsdFNlbGVjdG9yLCBkZXN0aW5hdGlvbiB9ID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcmVzdWx0U2VsZWN0b3Iob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgICBkZXN0aW5hdGlvbi5uZXh0KHJlc3VsdCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIG5vdGlmeUVycm9yKGVycjogYW55KTogdm9pZCB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICB9XG5cbiAgbm90aWZ5Q29tcGxldGUoaW5uZXJTdWI6IFN1YnNjcmlwdGlvbik6IHZvaWQge1xuICAgIHRoaXMucmVtb3ZlKGlubmVyU3ViKTtcblxuICAgIHRoaXMuaGFzU3Vic2NyaXB0aW9uID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuaGFzQ29tcGxldGVkKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL2V4aGF1c3RNYXAudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBJU2NoZWR1bGVyIH0gZnJvbSAnLi4vU2NoZWR1bGVyJztcbmltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgdHJ5Q2F0Y2ggfSBmcm9tICcuLi91dGlsL3RyeUNhdGNoJztcbmltcG9ydCB7IGVycm9yT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9lcnJvck9iamVjdCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vT3V0ZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IElubmVyU3Vic2NyaWJlciB9IGZyb20gJy4uL0lubmVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBzdWJzY3JpYmVUb1Jlc3VsdCB9IGZyb20gJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmQ8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgcHJvamVjdDogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBPYnNlcnZhYmxlPFQ+LCBjb25jdXJyZW50PzogbnVtYmVyLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBleHBhbmQ8VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgcHJvamVjdDogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBPYnNlcnZhYmxlPFI+LCBjb25jdXJyZW50PzogbnVtYmVyLCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxSPjtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbi8qKlxuICogUmVjdXJzaXZlbHkgcHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW5cbiAqIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBzaW1pbGFyIHRvIHtAbGluayBtZXJnZU1hcH0sIGJ1dCBhcHBsaWVzIHRoZVxuICogcHJvamVjdGlvbiBmdW5jdGlvbiB0byBldmVyeSBzb3VyY2UgdmFsdWUgYXMgd2VsbCBhcyBldmVyeSBvdXRwdXQgdmFsdWUuXG4gKiBJdCdzIHJlY3Vyc2l2ZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9leHBhbmQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiBPYnNlcnZhYmxlLCBhbmQgdGhlbiBtZXJnaW5nIHRob3NlIHJlc3VsdGluZyBPYnNlcnZhYmxlcyBhbmRcbiAqIGVtaXR0aW5nIHRoZSByZXN1bHRzIG9mIHRoaXMgbWVyZ2VyLiAqRXhwYW5kKiB3aWxsIHJlLWVtaXQgb24gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSBldmVyeSBzb3VyY2UgdmFsdWUuIFRoZW4sIGVhY2ggb3V0cHV0IHZhbHVlIGlzIGdpdmVuIHRvIHRoZVxuICogYHByb2plY3RgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gaW5uZXIgT2JzZXJ2YWJsZSB0byBiZSBtZXJnZWQgb24gdGhlXG4gKiBvdXRwdXQgT2JzZXJ2YWJsZS4gVGhvc2Ugb3V0cHV0IHZhbHVlcyByZXN1bHRpbmcgZnJvbSB0aGUgcHJvamVjdGlvbiBhcmUgYWxzb1xuICogZ2l2ZW4gdG8gdGhlIGBwcm9qZWN0YCBmdW5jdGlvbiB0byBwcm9kdWNlIG5ldyBvdXRwdXQgdmFsdWVzLiBUaGlzIGlzIGhvd1xuICogKmV4cGFuZCogYmVoYXZlcyByZWN1cnNpdmVseS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5TdGFydCBlbWl0dGluZyB0aGUgcG93ZXJzIG9mIHR3byBvbiBldmVyeSBjbGljaywgYXQgbW9zdCAxMCBvZiB0aGVtPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBwb3dlcnNPZlR3byA9IGNsaWNrc1xuICogICAubWFwVG8oMSlcbiAqICAgLmV4cGFuZCh4ID0+IFJ4Lk9ic2VydmFibGUub2YoMiAqIHgpLmRlbGF5KDEwMDApKVxuICogICAudGFrZSgxMCk7XG4gKiBwb3dlcnNPZlR3by5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBtZXJnZVNjYW59XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gT2JzZXJ2YWJsZX0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2Ugb3IgdGhlIG91dHB1dCBPYnNlcnZhYmxlLFxuICogcmV0dXJucyBhbiBPYnNlcnZhYmxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW50PU51bWJlci5QT1NJVElWRV9JTkZJTklUWV0gTWF4aW11bSBudW1iZXIgb2YgaW5wdXRcbiAqIE9ic2VydmFibGVzIGJlaW5nIHN1YnNjcmliZWQgdG8gY29uY3VycmVudGx5LlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9bnVsbF0gVGhlIElTY2hlZHVsZXIgdG8gdXNlIGZvciBzdWJzY3JpYmluZyB0b1xuICogZWFjaCBwcm9qZWN0ZWQgaW5uZXIgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgc291cmNlIHZhbHVlcyBhbmQgYWxzb1xuICogcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBwcm9qZWN0aW9uIGZ1bmN0aW9uIHRvIGVhY2ggdmFsdWUgZW1pdHRlZCBvbiB0aGVcbiAqIG91dHB1dCBPYnNlcnZhYmxlIGFuZCBhbmQgbWVyZ2luZyB0aGUgcmVzdWx0cyBvZiB0aGUgT2JzZXJ2YWJsZXMgb2J0YWluZWRcbiAqIGZyb20gdGhpcyB0cmFuc2Zvcm1hdGlvbi5cbiAqIEBtZXRob2QgZXhwYW5kXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kPFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHByb2plY3Q6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gT2JzZXJ2YWJsZTxSPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY3VycmVudDogbnVtYmVyID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZXI6IElTY2hlZHVsZXIgPSB1bmRlZmluZWQpOiBPYnNlcnZhYmxlPFI+IHtcbiAgY29uY3VycmVudCA9IChjb25jdXJyZW50IHx8IDApIDwgMSA/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSA6IGNvbmN1cnJlbnQ7XG5cbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgRXhwYW5kT3BlcmF0b3IocHJvamVjdCwgY29uY3VycmVudCwgc2NoZWR1bGVyKSk7XG59XG5cbmV4cG9ydCBjbGFzcyBFeHBhbmRPcGVyYXRvcjxULCBSPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFI+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwcm9qZWN0OiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IE9ic2VydmFibGU8Uj4sXG4gICAgICAgICAgICAgIHByaXZhdGUgY29uY3VycmVudDogbnVtYmVyLFxuICAgICAgICAgICAgICBwcml2YXRlIHNjaGVkdWxlcjogSVNjaGVkdWxlcikge1xuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFI+LCBzb3VyY2U6IGFueSk6IGFueSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEV4cGFuZFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcm9qZWN0LCB0aGlzLmNvbmN1cnJlbnQsIHRoaXMuc2NoZWR1bGVyKSk7XG4gIH1cbn1cblxuaW50ZXJmYWNlIERpc3BhdGNoQXJnPFQsIFI+IHtcbiAgc3Vic2NyaWJlcjogRXhwYW5kU3Vic2NyaWJlcjxULCBSPjtcbiAgcmVzdWx0OiBPYnNlcnZhYmxlPFI+O1xuICB2YWx1ZTogYW55O1xuICBpbmRleDogbnVtYmVyO1xufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuZXhwb3J0IGNsYXNzIEV4cGFuZFN1YnNjcmliZXI8VCwgUj4gZXh0ZW5kcyBPdXRlclN1YnNjcmliZXI8VCwgUj4ge1xuICBwcml2YXRlIGluZGV4OiBudW1iZXIgPSAwO1xuICBwcml2YXRlIGFjdGl2ZTogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBoYXNDb21wbGV0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBidWZmZXI6IGFueVtdO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFI+LFxuICAgICAgICAgICAgICBwcml2YXRlIHByb2plY3Q6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gT2JzZXJ2YWJsZTxSPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBjb25jdXJyZW50OiBudW1iZXIsXG4gICAgICAgICAgICAgIHByaXZhdGUgc2NoZWR1bGVyOiBJU2NoZWR1bGVyKSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICAgIGlmIChjb25jdXJyZW50IDwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGRpc3BhdGNoPFQsIFI+KGFyZzogRGlzcGF0Y2hBcmc8VCwgUj4pOiB2b2lkIHtcbiAgICBjb25zdCB7c3Vic2NyaWJlciwgcmVzdWx0LCB2YWx1ZSwgaW5kZXh9ID0gYXJnO1xuICAgIHN1YnNjcmliZXIuc3Vic2NyaWJlVG9Qcm9qZWN0aW9uKHJlc3VsdCwgdmFsdWUsIGluZGV4KTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuXG4gICAgaWYgKGRlc3RpbmF0aW9uLmNsb3NlZCkge1xuICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICBpZiAodGhpcy5hY3RpdmUgPCB0aGlzLmNvbmN1cnJlbnQpIHtcbiAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgbGV0IHJlc3VsdCA9IHRyeUNhdGNoKHRoaXMucHJvamVjdCkodmFsdWUsIGluZGV4KTtcbiAgICAgIGlmIChyZXN1bHQgPT09IGVycm9yT2JqZWN0KSB7XG4gICAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycm9yT2JqZWN0LmUpO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5zY2hlZHVsZXIpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb1Byb2plY3Rpb24ocmVzdWx0LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RhdGU6IERpc3BhdGNoQXJnPFQsIFI+ID0geyBzdWJzY3JpYmVyOiB0aGlzLCByZXN1bHQsIHZhbHVlLCBpbmRleCB9O1xuICAgICAgICB0aGlzLmFkZCh0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShFeHBhbmRTdWJzY3JpYmVyLmRpc3BhdGNoLCAwLCBzdGF0ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN1YnNjcmliZVRvUHJvamVjdGlvbihyZXN1bHQ6IGFueSwgdmFsdWU6IFQsIGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmFjdGl2ZSsrO1xuICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0PFQsIFI+KHRoaXMsIHJlc3VsdCwgdmFsdWUsIGluZGV4KSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbXBsZXRlKCk6IHZvaWQge1xuICAgIHRoaXMuaGFzQ29tcGxldGVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5oYXNDb21wbGV0ZWQgJiYgdGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9XG4gIH1cblxuICBub3RpZnlOZXh0KG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IFIsXG4gICAgICAgICAgICAgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICAgaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBSPik6IHZvaWQge1xuICAgIHRoaXMuX25leHQoaW5uZXJWYWx1ZSk7XG4gIH1cblxuICBub3RpZnlDb21wbGV0ZShpbm5lclN1YjogU3Vic2NyaXB0aW9uKTogdm9pZCB7XG4gICAgY29uc3QgYnVmZmVyID0gdGhpcy5idWZmZXI7XG4gICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgIHRoaXMuYWN0aXZlLS07XG4gICAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fbmV4dChidWZmZXIuc2hpZnQoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc0NvbXBsZXRlZCAmJiB0aGlzLmFjdGl2ZSA9PT0gMCkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9leHBhbmQudHMiLCJpbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiwgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCB3aWxsIGNhbGwgYSBzcGVjaWZpZWQgZnVuY3Rpb24gd2hlblxuICogdGhlIHNvdXJjZSB0ZXJtaW5hdGVzIG9uIGNvbXBsZXRlIG9yIGVycm9yLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gc291cmNlIHRlcm1pbmF0ZXMuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgc291cmNlLCBidXQgd2lsbCBjYWxsIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gb24gdGVybWluYXRpb24uXG4gKiBAbWV0aG9kIGZpbmFsbHlcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfZmluYWxseTxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBjYWxsYmFjazogKCkgPT4gdm9pZCk6IE9ic2VydmFibGU8VD4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBGaW5hbGx5T3BlcmF0b3IoY2FsbGJhY2spKTtcbn1cblxuY2xhc3MgRmluYWxseU9wZXJhdG9yPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNhbGxiYWNrOiAoKSA9PiB2b2lkKSB7XG4gIH1cblxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4sIHNvdXJjZTogYW55KTogVGVhcmRvd25Mb2dpYyB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IEZpbmFsbHlTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY2FsbGJhY2spKTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgRmluYWxseVN1YnNjcmliZXI8VD4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8VD4sIGNhbGxiYWNrOiAoKSA9PiB2b2lkKSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICAgIHRoaXMuYWRkKG5ldyBTdWJzY3JpcHRpb24oY2FsbGJhY2spKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9maW5hbGx5LnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgRmluZFZhbHVlT3BlcmF0b3IgfSBmcm9tICcuL2ZpbmQnO1xuXG4vKipcbiAqIEVtaXRzIG9ubHkgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0XG4gKiBtZWV0cyBzb21lIGNvbmRpdGlvbi5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBmaW5kfSwgYnV0IGVtaXRzIHRoZSBpbmRleCBvZiB0aGVcbiAqIGZvdW5kIHZhbHVlLCBub3QgdGhlIHZhbHVlIGl0c2VsZi48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9maW5kSW5kZXgucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYGZpbmRJbmRleGAgc2VhcmNoZXMgZm9yIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IG1hdGNoZXNcbiAqIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9uIGVtYm9kaWVkIGJ5IHRoZSBgcHJlZGljYXRlYCwgYW5kIHJldHVybnMgdGhlXG4gKiAoemVyby1iYXNlZCkgaW5kZXggb2YgdGhlIGZpcnN0IG9jY3VycmVuY2UgaW4gdGhlIHNvdXJjZS4gVW5saWtlXG4gKiB7QGxpbmsgZmlyc3R9LCB0aGUgYHByZWRpY2F0ZWAgaXMgcmVxdWlyZWQgaW4gYGZpbmRJbmRleGAsIGFuZCBkb2VzIG5vdCBlbWl0XG4gKiBhbiBlcnJvciBpZiBhIHZhbGlkIHZhbHVlIGlzIG5vdCBmb3VuZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IHRoZSBpbmRleCBvZiBmaXJzdCBjbGljayB0aGF0IGhhcHBlbnMgb24gYSBESVYgZWxlbWVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmZpbmRJbmRleChldiA9PiBldi50YXJnZXQudGFnTmFtZSA9PT0gJ0RJVicpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBmaWx0ZXJ9XG4gKiBAc2VlIHtAbGluayBmaW5kfVxuICogQHNlZSB7QGxpbmsgZmlyc3R9XG4gKiBAc2VlIHtAbGluayB0YWtlfVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIsIHNvdXJjZTogT2JzZXJ2YWJsZTxUPik6IGJvb2xlYW59IHByZWRpY2F0ZVxuICogQSBmdW5jdGlvbiBjYWxsZWQgd2l0aCBlYWNoIGl0ZW0gdG8gdGVzdCBmb3IgY29uZGl0aW9uIG1hdGNoaW5nLlxuICogQHBhcmFtIHthbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIGB0aGlzYFxuICogaW4gdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0gdGhhdFxuICogbWF0Y2hlcyB0aGUgY29uZGl0aW9uLlxuICogQG1ldGhvZCBmaW5kXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEluZGV4PFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIHByZWRpY2F0ZTogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IGJvb2xlYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNBcmc/OiBhbnkpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuICByZXR1cm4gPGFueT50aGlzLmxpZnQ8YW55PihuZXcgRmluZFZhbHVlT3BlcmF0b3IocHJlZGljYXRlLCB0aGlzLCB0cnVlLCB0aGlzQXJnKSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL2ZpbmRJbmRleC50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgRW1wdHlFcnJvciB9IGZyb20gJy4uL3V0aWwvRW1wdHlFcnJvcic7XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0PFQsIFMgZXh0ZW5kcyBUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGU6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiB2YWx1ZSBpcyBTKTogT2JzZXJ2YWJsZTxTPjtcbmV4cG9ydCBmdW5jdGlvbiBmaXJzdDxULCBTIGV4dGVuZHMgVCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZGljYXRlOiAodmFsdWU6IFQgfCBTLCBpbmRleDogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IHZhbHVlIGlzIFMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFNlbGVjdG9yOiAodmFsdWU6IFMsIGluZGV4OiBudW1iZXIpID0+IFIsIGRlZmF1bHRWYWx1ZT86IFIpOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0PFQsIFMgZXh0ZW5kcyBUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGU6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiB2YWx1ZSBpcyBTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTZWxlY3Rvcjogdm9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPzogUyk6IE9ic2VydmFibGU8Uz47XG5leHBvcnQgZnVuY3Rpb24gZmlyc3Q8VD4odGhpczogT2JzZXJ2YWJsZTxUPixcbiAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGU/OiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIsIHNvdXJjZTogT2JzZXJ2YWJsZTxUPikgPT4gYm9vbGVhbik6IE9ic2VydmFibGU8VD47XG5leHBvcnQgZnVuY3Rpb24gZmlyc3Q8VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGU6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBib29sZWFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFNlbGVjdG9yPzogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBSLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT86IFIpOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0PFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgcHJlZGljYXRlOiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIsIHNvdXJjZTogT2JzZXJ2YWJsZTxUPikgPT4gYm9vbGVhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTZWxlY3Rvcjogdm9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU/OiBUKTogT2JzZXJ2YWJsZTxUPjtcblxuLyoqXG4gKiBFbWl0cyBvbmx5IHRoZSBmaXJzdCB2YWx1ZSAob3IgdGhlIGZpcnN0IHZhbHVlIHRoYXQgbWVldHMgc29tZSBjb25kaXRpb24pXG4gKiBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+RW1pdHMgb25seSB0aGUgZmlyc3QgdmFsdWUuIE9yIGVtaXRzIG9ubHkgdGhlIGZpcnN0XG4gKiB2YWx1ZSB0aGF0IHBhc3NlcyBzb21lIHRlc3QuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvZmlyc3QucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogSWYgY2FsbGVkIHdpdGggbm8gYXJndW1lbnRzLCBgZmlyc3RgIGVtaXRzIHRoZSBmaXJzdCB2YWx1ZSBvZiB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLCB0aGVuIGNvbXBsZXRlcy4gSWYgY2FsbGVkIHdpdGggYSBgcHJlZGljYXRlYCBmdW5jdGlvbiwgYGZpcnN0YFxuICogZW1pdHMgdGhlIGZpcnN0IHZhbHVlIG9mIHRoZSBzb3VyY2UgdGhhdCBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgY29uZGl0aW9uLiBJdFxuICogbWF5IGFsc28gdGFrZSBhIGByZXN1bHRTZWxlY3RvcmAgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgb3V0cHV0IHZhbHVlIGZyb21cbiAqIHRoZSBpbnB1dCB2YWx1ZSwgYW5kIGEgYGRlZmF1bHRWYWx1ZWAgdG8gZW1pdCBpbiBjYXNlIHRoZSBzb3VyY2UgY29tcGxldGVzXG4gKiBiZWZvcmUgaXQgaXMgYWJsZSB0byBlbWl0IGEgdmFsaWQgdmFsdWUuIFRocm93cyBhbiBlcnJvciBpZiBgZGVmYXVsdFZhbHVlYFxuICogd2FzIG5vdCBwcm92aWRlZCBhbmQgYSBtYXRjaGluZyBlbGVtZW50IGlzIG5vdCBmb3VuZC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5FbWl0IG9ubHkgdGhlIGZpcnN0IGNsaWNrIHRoYXQgaGFwcGVucyBvbiB0aGUgRE9NPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MuZmlyc3QoKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdHMgdGhlIGZpcnN0IGNsaWNrIHRoYXQgaGFwcGVucyBvbiBhIERJVjwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLmZpcnN0KGV2ID0+IGV2LnRhcmdldC50YWdOYW1lID09PSAnRElWJyk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGZpbHRlcn1cbiAqIEBzZWUge0BsaW5rIGZpbmR9XG4gKiBAc2VlIHtAbGluayB0YWtlfVxuICpcbiAqIEB0aHJvd3Mge0VtcHR5RXJyb3J9IERlbGl2ZXJzIGFuIEVtcHR5RXJyb3IgdG8gdGhlIE9ic2VydmVyJ3MgYGVycm9yYFxuICogY2FsbGJhY2sgaWYgdGhlIE9ic2VydmFibGUgY29tcGxldGVzIGJlZm9yZSBhbnkgYG5leHRgIG5vdGlmaWNhdGlvbiB3YXMgc2VudC5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pOiBib29sZWFufSBbcHJlZGljYXRlXVxuICogQW4gb3B0aW9uYWwgZnVuY3Rpb24gY2FsbGVkIHdpdGggZWFjaCBpdGVtIHRvIHRlc3QgZm9yIGNvbmRpdGlvbiBtYXRjaGluZy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24odmFsdWU6IFQsIGluZGV4OiBudW1iZXIpOiBSfSBbcmVzdWx0U2VsZWN0b3JdIEEgZnVuY3Rpb24gdG9cbiAqIHByb2R1Y2UgdGhlIHZhbHVlIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiYXNlZCBvbiB0aGUgdmFsdWVzXG4gKiBhbmQgdGhlIGluZGljZXMgb2YgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBUaGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGlzXG4gKiBmdW5jdGlvbiBhcmU6XG4gKiAtIGB2YWx1ZWA6IHRoZSB2YWx1ZSB0aGF0IHdhcyBlbWl0dGVkIG9uIHRoZSBzb3VyY2UuXG4gKiAtIGBpbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHNvdXJjZS5cbiAqIEBwYXJhbSB7Un0gW2RlZmF1bHRWYWx1ZV0gVGhlIGRlZmF1bHQgdmFsdWUgZW1pdHRlZCBpbiBjYXNlIG5vIHZhbGlkIHZhbHVlXG4gKiB3YXMgZm91bmQgb24gdGhlIHNvdXJjZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VHxSPn0gQW4gT2JzZXJ2YWJsZSBvZiB0aGUgZmlyc3QgaXRlbSB0aGF0IG1hdGNoZXMgdGhlXG4gKiBjb25kaXRpb24uXG4gKiBAbWV0aG9kIGZpcnN0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlyc3Q8VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgcHJlZGljYXRlPzogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IGJvb2xlYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U2VsZWN0b3I/OiAoKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBSKSB8IHZvaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlPzogUik6IE9ic2VydmFibGU8VCB8IFI+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgRmlyc3RPcGVyYXRvcihwcmVkaWNhdGUsIHJlc3VsdFNlbGVjdG9yLCBkZWZhdWx0VmFsdWUsIHRoaXMpKTtcbn1cblxuY2xhc3MgRmlyc3RPcGVyYXRvcjxULCBSPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFI+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwcmVkaWNhdGU/OiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIsIHNvdXJjZTogT2JzZXJ2YWJsZTxUPikgPT4gYm9vbGVhbixcbiAgICAgICAgICAgICAgcHJpdmF0ZSByZXN1bHRTZWxlY3Rvcj86ICgodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IFIpIHwgdm9pZCxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBkZWZhdWx0VmFsdWU/OiBhbnksXG4gICAgICAgICAgICAgIHByaXZhdGUgc291cmNlPzogT2JzZXJ2YWJsZTxUPikge1xuICB9XG5cbiAgY2FsbChvYnNlcnZlcjogU3Vic2NyaWJlcjxSPiwgc291cmNlOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBGaXJzdFN1YnNjcmliZXIob2JzZXJ2ZXIsIHRoaXMucHJlZGljYXRlLCB0aGlzLnJlc3VsdFNlbGVjdG9yLCB0aGlzLmRlZmF1bHRWYWx1ZSwgdGhpcy5zb3VyY2UpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgRmlyc3RTdWJzY3JpYmVyPFQsIFI+IGV4dGVuZHMgU3Vic2NyaWJlcjxUPiB7XG4gIHByaXZhdGUgaW5kZXg6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgaGFzQ29tcGxldGVkOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgX2VtaXR0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxSPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBwcmVkaWNhdGU/OiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIsIHNvdXJjZTogT2JzZXJ2YWJsZTxUPikgPT4gYm9vbGVhbixcbiAgICAgICAgICAgICAgcHJpdmF0ZSByZXN1bHRTZWxlY3Rvcj86ICgodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IFIpIHwgdm9pZCxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBkZWZhdWx0VmFsdWU/OiBhbnksXG4gICAgICAgICAgICAgIHByaXZhdGUgc291cmNlPzogT2JzZXJ2YWJsZTxUPikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgIGlmICh0aGlzLnByZWRpY2F0ZSkge1xuICAgICAgdGhpcy5fdHJ5UHJlZGljYXRlKHZhbHVlLCBpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2VtaXQodmFsdWUsIGluZGV4KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF90cnlQcmVkaWNhdGUodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpIHtcbiAgICBsZXQgcmVzdWx0OiBhbnk7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IHRoaXMucHJlZGljYXRlKHZhbHVlLCBpbmRleCwgdGhpcy5zb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICB0aGlzLl9lbWl0KHZhbHVlLCBpbmRleCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfZW1pdCh2YWx1ZTogYW55LCBpbmRleDogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMucmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgIHRoaXMuX3RyeVJlc3VsdFNlbGVjdG9yKHZhbHVlLCBpbmRleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2VtaXRGaW5hbCh2YWx1ZSk7XG4gIH1cblxuICBwcml2YXRlIF90cnlSZXN1bHRTZWxlY3Rvcih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikge1xuICAgIGxldCByZXN1bHQ6IGFueTtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gKDxhbnk+dGhpcykucmVzdWx0U2VsZWN0b3IodmFsdWUsIGluZGV4KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZW1pdEZpbmFsKHJlc3VsdCk7XG4gIH1cblxuICBwcml2YXRlIF9lbWl0RmluYWwodmFsdWU6IGFueSkge1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICBpZiAoIXRoaXMuX2VtaXR0ZWQpIHtcbiAgICAgIHRoaXMuX2VtaXR0ZWQgPSB0cnVlO1xuICAgICAgZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKTogdm9pZCB7XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgIGlmICghdGhpcy5oYXNDb21wbGV0ZWQgJiYgdHlwZW9mIHRoaXMuZGVmYXVsdFZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZGVzdGluYXRpb24ubmV4dCh0aGlzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuaGFzQ29tcGxldGVkKSB7XG4gICAgICBkZXN0aW5hdGlvbi5lcnJvcihuZXcgRW1wdHlFcnJvcik7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL2ZpcnN0LnRzIiwiaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJy4uL1N1YmplY3QnO1xuaW1wb3J0IHsgTWFwIH0gZnJvbSAnLi4vdXRpbC9NYXAnO1xuaW1wb3J0IHsgRmFzdE1hcCB9IGZyb20gJy4uL3V0aWwvRmFzdE1hcCc7XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwQnk8VCwgSz4odGhpczogT2JzZXJ2YWJsZTxUPiwga2V5U2VsZWN0b3I6ICh2YWx1ZTogVCkgPT4gSyk6IE9ic2VydmFibGU8R3JvdXBlZE9ic2VydmFibGU8SywgVD4+O1xuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwQnk8VCwgSz4odGhpczogT2JzZXJ2YWJsZTxUPiwga2V5U2VsZWN0b3I6ICh2YWx1ZTogVCkgPT4gSywgZWxlbWVudFNlbGVjdG9yOiB2b2lkLCBkdXJhdGlvblNlbGVjdG9yOiAoZ3JvdXBlZDogR3JvdXBlZE9ic2VydmFibGU8SywgVD4pID0+IE9ic2VydmFibGU8YW55Pik6IE9ic2VydmFibGU8R3JvdXBlZE9ic2VydmFibGU8SywgVD4+O1xuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwQnk8VCwgSywgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwga2V5U2VsZWN0b3I6ICh2YWx1ZTogVCkgPT4gSywgZWxlbWVudFNlbGVjdG9yPzogKHZhbHVlOiBUKSA9PiBSLCBkdXJhdGlvblNlbGVjdG9yPzogKGdyb3VwZWQ6IEdyb3VwZWRPYnNlcnZhYmxlPEssIFI+KSA9PiBPYnNlcnZhYmxlPGFueT4pOiBPYnNlcnZhYmxlPEdyb3VwZWRPYnNlcnZhYmxlPEssIFI+PjtcbmV4cG9ydCBmdW5jdGlvbiBncm91cEJ5PFQsIEssIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIGtleVNlbGVjdG9yOiAodmFsdWU6IFQpID0+IEssIGVsZW1lbnRTZWxlY3Rvcj86ICh2YWx1ZTogVCkgPT4gUiwgZHVyYXRpb25TZWxlY3Rvcj86IChncm91cGVkOiBHcm91cGVkT2JzZXJ2YWJsZTxLLCBSPikgPT4gT2JzZXJ2YWJsZTxhbnk+LCBzdWJqZWN0U2VsZWN0b3I/OiAoKSA9PiBTdWJqZWN0PFI+KTogT2JzZXJ2YWJsZTxHcm91cGVkT2JzZXJ2YWJsZTxLLCBSPj47XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuXG4vKipcbiAqIEdyb3VwcyB0aGUgaXRlbXMgZW1pdHRlZCBieSBhbiBPYnNlcnZhYmxlIGFjY29yZGluZyB0byBhIHNwZWNpZmllZCBjcml0ZXJpb24sXG4gKiBhbmQgZW1pdHMgdGhlc2UgZ3JvdXBlZCBpdGVtcyBhcyBgR3JvdXBlZE9ic2VydmFibGVzYCwgb25lXG4gKiB7QGxpbmsgR3JvdXBlZE9ic2VydmFibGV9IHBlciBncm91cC5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2dyb3VwQnkucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+R3JvdXAgb2JqZWN0cyBieSBpZCBhbmQgcmV0dXJuIGFzIGFycmF5PC9jYXB0aW9uPlxuICogT2JzZXJ2YWJsZS5vZjxPYmo+KHtpZDogMSwgbmFtZTogJ2F6ZTEnfSxcbiAqICAgICAgICAgICAgICAgICAgICB7aWQ6IDIsIG5hbWU6ICdzZjInfSxcbiAqICAgICAgICAgICAgICAgICAgICB7aWQ6IDIsIG5hbWU6ICdkZzInfSxcbiAqICAgICAgICAgICAgICAgICAgICB7aWQ6IDEsIG5hbWU6ICdlcmcxJ30sXG4gKiAgICAgICAgICAgICAgICAgICAge2lkOiAxLCBuYW1lOiAnZGYxJ30sXG4gKiAgICAgICAgICAgICAgICAgICAge2lkOiAyLCBuYW1lOiAnc2ZxZmIyJ30sXG4gKiAgICAgICAgICAgICAgICAgICAge2lkOiAzLCBuYW1lOiAncWZzMyd9LFxuICogICAgICAgICAgICAgICAgICAgIHtpZDogMiwgbmFtZTogJ3FzZ3FzZmcyJ31cbiAqICAgICApXG4gKiAgICAgLmdyb3VwQnkocCA9PiBwLmlkKVxuICogICAgIC5mbGF0TWFwKCAoZ3JvdXAkKSA9PiBncm91cCQucmVkdWNlKChhY2MsIGN1cikgPT4gWy4uLmFjYywgY3VyXSwgW10pKVxuICogICAgIC5zdWJzY3JpYmUocCA9PiBjb25zb2xlLmxvZyhwKSk7XG4gKlxuICogLy8gZGlzcGxheXM6XG4gKiAvLyBbIHsgaWQ6IDEsIG5hbWU6ICdhemUxJyB9LFxuICogLy8gICB7IGlkOiAxLCBuYW1lOiAnZXJnMScgfSxcbiAqIC8vICAgeyBpZDogMSwgbmFtZTogJ2RmMScgfSBdXG4gKiAvL1xuICogLy8gWyB7IGlkOiAyLCBuYW1lOiAnc2YyJyB9LFxuICogLy8gICB7IGlkOiAyLCBuYW1lOiAnZGcyJyB9LFxuICogLy8gICB7IGlkOiAyLCBuYW1lOiAnc2ZxZmIyJyB9LFxuICogLy8gICB7IGlkOiAyLCBuYW1lOiAncXNncXNmZzInIH0gXVxuICogLy9cbiAqIC8vIFsgeyBpZDogMywgbmFtZTogJ3FmczMnIH0gXVxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlBpdm90IGRhdGEgb24gdGhlIGlkIGZpZWxkPC9jYXB0aW9uPlxuICogT2JzZXJ2YWJsZS5vZjxPYmo+KHtpZDogMSwgbmFtZTogJ2F6ZTEnfSxcbiAqICAgICAgICAgICAgICAgICAgICB7aWQ6IDIsIG5hbWU6ICdzZjInfSxcbiAqICAgICAgICAgICAgICAgICAgICB7aWQ6IDIsIG5hbWU6ICdkZzInfSxcbiAqICAgICAgICAgICAgICAgICAgICB7aWQ6IDEsIG5hbWU6ICdlcmcxJ30sXG4gKiAgICAgICAgICAgICAgICAgICAge2lkOiAxLCBuYW1lOiAnZGYxJ30sXG4gKiAgICAgICAgICAgICAgICAgICAge2lkOiAyLCBuYW1lOiAnc2ZxZmIyJ30sXG4gKiAgICAgICAgICAgICAgICAgICAge2lkOiAzLCBuYW1lOiAncWZzMSd9LFxuICogICAgICAgICAgICAgICAgICAgIHtpZDogMiwgbmFtZTogJ3FzZ3FzZmcyJ31cbiAqICAgICAgICAgICAgICAgICAgIClcbiAqICAgICAuZ3JvdXBCeShwID0+IHAuaWQsIHAgPT4gcC5hbm1lKVxuICogICAgIC5mbGF0TWFwKCAoZ3JvdXAkKSA9PiBncm91cCQucmVkdWNlKChhY2MsIGN1cikgPT4gWy4uLmFjYywgY3VyXSwgW1wiXCIgKyBncm91cCQua2V5XSkpXG4gKiAgICAgLm1hcChhcnIgPT4gKHsnaWQnOiBwYXJzZUludChhcnJbMF0pLCAndmFsdWVzJzogYXJyLnNsaWNlKDEpfSkpXG4gKiAgICAgLnN1YnNjcmliZShwID0+IGNvbnNvbGUubG9nKHApKTtcbiAqXG4gKiAvLyBkaXNwbGF5czpcbiAqIC8vIHsgaWQ6IDEsIHZhbHVlczogWyAnYXplMScsICdlcmcxJywgJ2RmMScgXSB9XG4gKiAvLyB7IGlkOiAyLCB2YWx1ZXM6IFsgJ3NmMicsICdkZzInLCAnc2ZxZmIyJywgJ3FzZ3FzZmcyJyBdIH1cbiAqIC8vIHsgaWQ6IDMsIHZhbHVlczogWyAncWZzMScgXSB9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IEt9IGtleVNlbGVjdG9yIEEgZnVuY3Rpb24gdGhhdCBleHRyYWN0cyB0aGUga2V5XG4gKiBmb3IgZWFjaCBpdGVtLlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCk6IFJ9IFtlbGVtZW50U2VsZWN0b3JdIEEgZnVuY3Rpb24gdGhhdCBleHRyYWN0cyB0aGVcbiAqIHJldHVybiBlbGVtZW50IGZvciBlYWNoIGl0ZW0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGdyb3VwZWQ6IEdyb3VwZWRPYnNlcnZhYmxlPEssUj4pOiBPYnNlcnZhYmxlPGFueT59IFtkdXJhdGlvblNlbGVjdG9yXVxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gT2JzZXJ2YWJsZSB0byBkZXRlcm1pbmUgaG93IGxvbmcgZWFjaCBncm91cCBzaG91bGRcbiAqIGV4aXN0LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxHcm91cGVkT2JzZXJ2YWJsZTxLLFI+Pn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzXG4gKiBHcm91cGVkT2JzZXJ2YWJsZXMsIGVhY2ggb2Ygd2hpY2ggY29ycmVzcG9uZHMgdG8gYSB1bmlxdWUga2V5IHZhbHVlIGFuZCBlYWNoXG4gKiBvZiB3aGljaCBlbWl0cyB0aG9zZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IHNoYXJlIHRoYXQga2V5XG4gKiB2YWx1ZS5cbiAqIEBtZXRob2QgZ3JvdXBCeVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdyb3VwQnk8VCwgSywgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwga2V5U2VsZWN0b3I6ICh2YWx1ZTogVCkgPT4gSyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTZWxlY3Rvcj86ICgodmFsdWU6IFQpID0+IFIpIHwgdm9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uU2VsZWN0b3I/OiAoZ3JvdXBlZDogR3JvdXBlZE9ic2VydmFibGU8SywgUj4pID0+IE9ic2VydmFibGU8YW55PixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3RTZWxlY3Rvcj86ICgpID0+IFN1YmplY3Q8Uj4pOiBPYnNlcnZhYmxlPEdyb3VwZWRPYnNlcnZhYmxlPEssIFI+PiB7XG4gIHJldHVybiB0aGlzLmxpZnQobmV3IEdyb3VwQnlPcGVyYXRvcihrZXlTZWxlY3RvciwgZWxlbWVudFNlbGVjdG9yLCBkdXJhdGlvblNlbGVjdG9yLCBzdWJqZWN0U2VsZWN0b3IpKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZWZDb3VudFN1YnNjcmlwdGlvbiB7XG4gIGNvdW50OiBudW1iZXI7XG4gIHVuc3Vic2NyaWJlOiAoKSA9PiB2b2lkO1xuICBjbG9zZWQ6IGJvb2xlYW47XG4gIGF0dGVtcHRlZFRvVW5zdWJzY3JpYmU6IGJvb2xlYW47XG59XG5cbmNsYXNzIEdyb3VwQnlPcGVyYXRvcjxULCBLLCBSPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIEdyb3VwZWRPYnNlcnZhYmxlPEssIFI+PiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUga2V5U2VsZWN0b3I6ICh2YWx1ZTogVCkgPT4gSyxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBlbGVtZW50U2VsZWN0b3I/OiAoKHZhbHVlOiBUKSA9PiBSKSB8IHZvaWQsXG4gICAgICAgICAgICAgIHByaXZhdGUgZHVyYXRpb25TZWxlY3Rvcj86IChncm91cGVkOiBHcm91cGVkT2JzZXJ2YWJsZTxLLCBSPikgPT4gT2JzZXJ2YWJsZTxhbnk+LFxuICAgICAgICAgICAgICBwcml2YXRlIHN1YmplY3RTZWxlY3Rvcj86ICgpID0+IFN1YmplY3Q8Uj4pIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxHcm91cGVkT2JzZXJ2YWJsZTxLLCBSPj4sIHNvdXJjZTogYW55KTogYW55IHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgR3JvdXBCeVN1YnNjcmliZXIoXG4gICAgICBzdWJzY3JpYmVyLCB0aGlzLmtleVNlbGVjdG9yLCB0aGlzLmVsZW1lbnRTZWxlY3RvciwgdGhpcy5kdXJhdGlvblNlbGVjdG9yLCB0aGlzLnN1YmplY3RTZWxlY3RvclxuICAgICkpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBHcm91cEJ5U3Vic2NyaWJlcjxULCBLLCBSPiBleHRlbmRzIFN1YnNjcmliZXI8VD4gaW1wbGVtZW50cyBSZWZDb3VudFN1YnNjcmlwdGlvbiB7XG4gIHByaXZhdGUgZ3JvdXBzOiBNYXA8SywgU3ViamVjdDxUfFI+PiA9IG51bGw7XG4gIHB1YmxpYyBhdHRlbXB0ZWRUb1Vuc3Vic2NyaWJlOiBib29sZWFuID0gZmFsc2U7XG4gIHB1YmxpYyBjb3VudDogbnVtYmVyID0gMDtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxHcm91cGVkT2JzZXJ2YWJsZTxLLCBSPj4sXG4gICAgICAgICAgICAgIHByaXZhdGUga2V5U2VsZWN0b3I6ICh2YWx1ZTogVCkgPT4gSyxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBlbGVtZW50U2VsZWN0b3I/OiAoKHZhbHVlOiBUKSA9PiBSKSB8IHZvaWQsXG4gICAgICAgICAgICAgIHByaXZhdGUgZHVyYXRpb25TZWxlY3Rvcj86IChncm91cGVkOiBHcm91cGVkT2JzZXJ2YWJsZTxLLCBSPikgPT4gT2JzZXJ2YWJsZTxhbnk+LFxuICAgICAgICAgICAgICBwcml2YXRlIHN1YmplY3RTZWxlY3Rvcj86ICgpID0+IFN1YmplY3Q8Uj4pIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpOiB2b2lkIHtcbiAgICBsZXQga2V5OiBLO1xuICAgIHRyeSB7XG4gICAgICBrZXkgPSB0aGlzLmtleVNlbGVjdG9yKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9ncm91cCh2YWx1ZSwga2V5KTtcbiAgfVxuXG4gIHByaXZhdGUgX2dyb3VwKHZhbHVlOiBULCBrZXk6IEspIHtcbiAgICBsZXQgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG5cbiAgICBpZiAoIWdyb3Vwcykge1xuICAgICAgZ3JvdXBzID0gdGhpcy5ncm91cHMgPSB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IG5ldyBGYXN0TWFwKCkgOiBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgbGV0IGdyb3VwID0gZ3JvdXBzLmdldChrZXkpO1xuXG4gICAgbGV0IGVsZW1lbnQ6IFI7XG4gICAgaWYgKHRoaXMuZWxlbWVudFNlbGVjdG9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50U2VsZWN0b3IodmFsdWUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudCA9IDxhbnk+dmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKCFncm91cCkge1xuICAgICAgZ3JvdXAgPSB0aGlzLnN1YmplY3RTZWxlY3RvciA/IHRoaXMuc3ViamVjdFNlbGVjdG9yKCkgOiBuZXcgU3ViamVjdDxSPigpO1xuICAgICAgZ3JvdXBzLnNldChrZXksIGdyb3VwKTtcbiAgICAgIGNvbnN0IGdyb3VwZWRPYnNlcnZhYmxlID0gbmV3IEdyb3VwZWRPYnNlcnZhYmxlKGtleSwgZ3JvdXAsIHRoaXMpO1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGdyb3VwZWRPYnNlcnZhYmxlKTtcbiAgICAgIGlmICh0aGlzLmR1cmF0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgbGV0IGR1cmF0aW9uOiBhbnk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uU2VsZWN0b3IobmV3IEdyb3VwZWRPYnNlcnZhYmxlPEssIFI+KGtleSwgPFN1YmplY3Q8Uj4+Z3JvdXApKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhpcy5lcnJvcihlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZChkdXJhdGlvbi5zdWJzY3JpYmUobmV3IEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyKGtleSwgZ3JvdXAsIHRoaXMpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFncm91cC5jbG9zZWQpIHtcbiAgICAgIGdyb3VwLm5leHQoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9lcnJvcihlcnI6IGFueSk6IHZvaWQge1xuICAgIGNvbnN0IGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xuICAgIGlmIChncm91cHMpIHtcbiAgICAgIGdyb3Vwcy5mb3JFYWNoKChncm91cCwga2V5KSA9PiB7XG4gICAgICAgIGdyb3VwLmVycm9yKGVycik7XG4gICAgICB9KTtcblxuICAgICAgZ3JvdXBzLmNsZWFyKCk7XG4gICAgfVxuICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKTogdm9pZCB7XG4gICAgY29uc3QgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG4gICAgaWYgKGdyb3Vwcykge1xuICAgICAgZ3JvdXBzLmZvckVhY2goKGdyb3VwLCBrZXkpID0+IHtcbiAgICAgICAgZ3JvdXAuY29tcGxldGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICBncm91cHMuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICB9XG5cbiAgcmVtb3ZlR3JvdXAoa2V5OiBLKTogdm9pZCB7XG4gICAgdGhpcy5ncm91cHMuZGVsZXRlKGtleSk7XG4gIH1cblxuICB1bnN1YnNjcmliZSgpIHtcbiAgICBpZiAoIXRoaXMuY2xvc2VkKSB7XG4gICAgICB0aGlzLmF0dGVtcHRlZFRvVW5zdWJzY3JpYmUgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgICAgc3VwZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIEdyb3VwRHVyYXRpb25TdWJzY3JpYmVyPEssIFQ+IGV4dGVuZHMgU3Vic2NyaWJlcjxUPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUga2V5OiBLLFxuICAgICAgICAgICAgICBwcml2YXRlIGdyb3VwOiBTdWJqZWN0PFQ+LFxuICAgICAgICAgICAgICBwcml2YXRlIHBhcmVudDogR3JvdXBCeVN1YnNjcmliZXI8YW55LCBLLCBUPikge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpOiB2b2lkIHtcbiAgICB0aGlzLl9jb21wbGV0ZSgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9lcnJvcihlcnI6IGFueSk6IHZvaWQge1xuICAgIGNvbnN0IGdyb3VwID0gdGhpcy5ncm91cDtcbiAgICBpZiAoIWdyb3VwLmNsb3NlZCkge1xuICAgICAgZ3JvdXAuZXJyb3IoZXJyKTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQucmVtb3ZlR3JvdXAodGhpcy5rZXkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jb21wbGV0ZSgpOiB2b2lkIHtcbiAgICBjb25zdCBncm91cCA9IHRoaXMuZ3JvdXA7XG4gICAgaWYgKCFncm91cC5jbG9zZWQpIHtcbiAgICAgIGdyb3VwLmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIHRoaXMucGFyZW50LnJlbW92ZUdyb3VwKHRoaXMua2V5KTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIE9ic2VydmFibGUgcmVwcmVzZW50aW5nIHZhbHVlcyBiZWxvbmdpbmcgdG8gdGhlIHNhbWUgZ3JvdXAgcmVwcmVzZW50ZWQgYnlcbiAqIGEgY29tbW9uIGtleS4gVGhlIHZhbHVlcyBlbWl0dGVkIGJ5IGEgR3JvdXBlZE9ic2VydmFibGUgY29tZSBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIFRoZSBjb21tb24ga2V5IGlzIGF2YWlsYWJsZSBhcyB0aGUgZmllbGQgYGtleWAgb24gYVxuICogR3JvdXBlZE9ic2VydmFibGUgaW5zdGFuY2UuXG4gKlxuICogQGNsYXNzIEdyb3VwZWRPYnNlcnZhYmxlPEssIFQ+XG4gKi9cbmV4cG9ydCBjbGFzcyBHcm91cGVkT2JzZXJ2YWJsZTxLLCBUPiBleHRlbmRzIE9ic2VydmFibGU8VD4ge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMga2V5OiBLLFxuICAgICAgICAgICAgICBwcml2YXRlIGdyb3VwU3ViamVjdDogU3ViamVjdDxUPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSByZWZDb3VudFN1YnNjcmlwdGlvbj86IFJlZkNvdW50U3Vic2NyaXB0aW9uKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4pIHtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG4gICAgY29uc3Qge3JlZkNvdW50U3Vic2NyaXB0aW9uLCBncm91cFN1YmplY3R9ID0gdGhpcztcbiAgICBpZiAocmVmQ291bnRTdWJzY3JpcHRpb24gJiYgIXJlZkNvdW50U3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgc3Vic2NyaXB0aW9uLmFkZChuZXcgSW5uZXJSZWZDb3VudFN1YnNjcmlwdGlvbihyZWZDb3VudFN1YnNjcmlwdGlvbikpO1xuICAgIH1cbiAgICBzdWJzY3JpcHRpb24uYWRkKGdyb3VwU3ViamVjdC5zdWJzY3JpYmUoc3Vic2NyaWJlcikpO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIElubmVyUmVmQ291bnRTdWJzY3JpcHRpb24gZXh0ZW5kcyBTdWJzY3JpcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHBhcmVudDogUmVmQ291bnRTdWJzY3JpcHRpb24pIHtcbiAgICBzdXBlcigpO1xuICAgIHBhcmVudC5jb3VudCsrO1xuICB9XG5cbiAgdW5zdWJzY3JpYmUoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgaWYgKCFwYXJlbnQuY2xvc2VkICYmICF0aGlzLmNsb3NlZCkge1xuICAgICAgc3VwZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgIHBhcmVudC5jb3VudCAtPSAxO1xuICAgICAgaWYgKHBhcmVudC5jb3VudCA9PT0gMCAmJiBwYXJlbnQuYXR0ZW1wdGVkVG9VbnN1YnNjcmliZSkge1xuICAgICAgICBwYXJlbnQudW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvZ3JvdXBCeS50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3V0aWwvbm9vcCc7XG5cbi8qKlxuICogSWdub3JlcyBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIG9ubHkgcGFzc2VzIGNhbGxzIG9mIGBjb21wbGV0ZWAgb3IgYGVycm9yYC5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2lnbm9yZUVsZW1lbnRzLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIGVtcHR5IE9ic2VydmFibGUgdGhhdCBvbmx5IGNhbGxzIGBjb21wbGV0ZWBcbiAqIG9yIGBlcnJvcmAsIGJhc2VkIG9uIHdoaWNoIG9uZSBpcyBjYWxsZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBpZ25vcmVFbGVtZW50c1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlnbm9yZUVsZW1lbnRzPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgSWdub3JlRWxlbWVudHNPcGVyYXRvcigpKTtcbn07XG5cbmNsYXNzIElnbm9yZUVsZW1lbnRzT3BlcmF0b3I8VCwgUj4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBSPiB7XG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxSPiwgc291cmNlOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBJZ25vcmVFbGVtZW50c1N1YnNjcmliZXIoc3Vic2NyaWJlcikpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBJZ25vcmVFbGVtZW50c1N1YnNjcmliZXI8VD4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgcHJvdGVjdGVkIF9uZXh0KHVudXNlZDogVCk6IHZvaWQge1xuICAgIG5vb3AoKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9pZ25vcmVFbGVtZW50cy50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuXG4vKipcbiAqIElmIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBpcyBlbXB0eSBpdCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0cnVlLCBvdGhlcndpc2UgaXQgZW1pdHMgZmFsc2UuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9pc0VtcHR5LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhIEJvb2xlYW4uXG4gKiBAbWV0aG9kIGlzRW1wdHlcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VtcHR5PFQ+KHRoaXM6IE9ic2VydmFibGU8VD4pOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgSXNFbXB0eU9wZXJhdG9yKCkpO1xufVxuXG5jbGFzcyBJc0VtcHR5T3BlcmF0b3IgaW1wbGVtZW50cyBPcGVyYXRvcjxhbnksIGJvb2xlYW4+IHtcbiAgY2FsbCAob2JzZXJ2ZXI6IFN1YnNjcmliZXI8Ym9vbGVhbj4sIHNvdXJjZTogYW55KTogYW55IHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgSXNFbXB0eVN1YnNjcmliZXIob2JzZXJ2ZXIpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgSXNFbXB0eVN1YnNjcmliZXIgZXh0ZW5kcyBTdWJzY3JpYmVyPGFueT4ge1xuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxib29sZWFuPikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgbm90aWZ5Q29tcGxldGUoaXNFbXB0eTogYm9vbGVhbik6IHZvaWQge1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcblxuICAgIGRlc3RpbmF0aW9uLm5leHQoaXNFbXB0eSk7XG4gICAgZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMubm90aWZ5Q29tcGxldGUoZmFsc2UpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jb21wbGV0ZSgpIHtcbiAgICB0aGlzLm5vdGlmeUNvbXBsZXRlKHRydWUpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL2lzRW1wdHkudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IEVtcHR5RXJyb3IgfSBmcm9tICcuLi91dGlsL0VtcHR5RXJyb3InO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmV4cG9ydCBmdW5jdGlvbiBsYXN0PFQsIFMgZXh0ZW5kcyBUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWRpY2F0ZTogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IHZhbHVlIGlzIFMpOiBPYnNlcnZhYmxlPFM+O1xuZXhwb3J0IGZ1bmN0aW9uIGxhc3Q8VCwgUyBleHRlbmRzIFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZGljYXRlOiAodmFsdWU6IFQgfCBTLCBpbmRleDogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IHZhbHVlIGlzIFMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U2VsZWN0b3I6ICh2YWx1ZTogUywgaW5kZXg6IG51bWJlcikgPT4gUiwgZGVmYXVsdFZhbHVlPzogUik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gbGFzdDxULCBTIGV4dGVuZHMgVD4odGhpczogT2JzZXJ2YWJsZTxUPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGU6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiB2YWx1ZSBpcyBTLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFNlbGVjdG9yOiB2b2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT86IFMpOiBPYnNlcnZhYmxlPFM+O1xuZXhwb3J0IGZ1bmN0aW9uIGxhc3Q8VD4odGhpczogT2JzZXJ2YWJsZTxUPixcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWRpY2F0ZT86ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBib29sZWFuKTogT2JzZXJ2YWJsZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBsYXN0PFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGU6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBib29sZWFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U2VsZWN0b3I/OiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IFIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU/OiBSKTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiBsYXN0PFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVkaWNhdGU6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBib29sZWFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0U2VsZWN0b3I6IHZvaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU/OiBUKTogT2JzZXJ2YWJsZTxUPjtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgb25seSB0aGUgbGFzdCBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogSXQgb3B0aW9uYWxseSB0YWtlcyBhIHByZWRpY2F0ZSBmdW5jdGlvbiBhcyBhIHBhcmFtZXRlciwgaW4gd2hpY2ggY2FzZSwgcmF0aGVyIHRoYW4gZW1pdHRpbmdcbiAqIHRoZSBsYXN0IGl0ZW0gZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIHRoZSByZXN1bHRpbmcgT2JzZXJ2YWJsZSB3aWxsIGVtaXQgdGhlIGxhc3QgaXRlbVxuICogZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBzYXRpc2ZpZXMgdGhlIHByZWRpY2F0ZS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL2xhc3QucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHRocm93cyB7RW1wdHlFcnJvcn0gRGVsaXZlcnMgYW4gRW1wdHlFcnJvciB0byB0aGUgT2JzZXJ2ZXIncyBgZXJyb3JgXG4gKiBjYWxsYmFjayBpZiB0aGUgT2JzZXJ2YWJsZSBjb21wbGV0ZXMgYmVmb3JlIGFueSBgbmV4dGAgbm90aWZpY2F0aW9uIHdhcyBzZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gcHJlZGljYXRlIC0gVGhlIGNvbmRpdGlvbiBhbnkgc291cmNlIGVtaXR0ZWQgaXRlbSBoYXMgdG8gc2F0aXNmeS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBvbmx5IHRoZSBsYXN0IGl0ZW0gc2F0aXNmeWluZyB0aGUgZ2l2ZW4gY29uZGl0aW9uXG4gKiBmcm9tIHRoZSBzb3VyY2UsIG9yIGFuIE5vU3VjaEVsZW1lbnRFeGNlcHRpb24gaWYgbm8gc3VjaCBpdGVtcyBhcmUgZW1pdHRlZC5cbiAqIEB0aHJvd3MgLSBUaHJvd3MgaWYgbm8gaXRlbXMgdGhhdCBtYXRjaCB0aGUgcHJlZGljYXRlIGFyZSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgbGFzdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxhc3Q8VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgcHJlZGljYXRlPzogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IGJvb2xlYW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTZWxlY3Rvcj86ICgodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IFIpIHwgdm9pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZT86IFIpOiBPYnNlcnZhYmxlPFQgfCBSPiB7XG4gIHJldHVybiB0aGlzLmxpZnQobmV3IExhc3RPcGVyYXRvcihwcmVkaWNhdGUsIHJlc3VsdFNlbGVjdG9yLCBkZWZhdWx0VmFsdWUsIHRoaXMpKTtcbn1cblxuY2xhc3MgTGFzdE9wZXJhdG9yPFQsIFI+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgUj4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHByZWRpY2F0ZT86ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBib29sZWFuLFxuICAgICAgICAgICAgICBwcml2YXRlIHJlc3VsdFNlbGVjdG9yPzogKCh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gUikgfCB2b2lkLFxuICAgICAgICAgICAgICBwcml2YXRlIGRlZmF1bHRWYWx1ZT86IGFueSxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBzb3VyY2U/OiBPYnNlcnZhYmxlPFQ+KSB7XG4gIH1cblxuICBjYWxsKG9ic2VydmVyOiBTdWJzY3JpYmVyPFI+LCBzb3VyY2U6IGFueSk6IGFueSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IExhc3RTdWJzY3JpYmVyKG9ic2VydmVyLCB0aGlzLnByZWRpY2F0ZSwgdGhpcy5yZXN1bHRTZWxlY3RvciwgdGhpcy5kZWZhdWx0VmFsdWUsIHRoaXMuc291cmNlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIExhc3RTdWJzY3JpYmVyPFQsIFI+IGV4dGVuZHMgU3Vic2NyaWJlcjxUPiB7XG4gIHByaXZhdGUgbGFzdFZhbHVlOiBUIHwgUjtcbiAgcHJpdmF0ZSBoYXNWYWx1ZTogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGluZGV4OiBudW1iZXIgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFI+LFxuICAgICAgICAgICAgICBwcml2YXRlIHByZWRpY2F0ZT86ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBib29sZWFuLFxuICAgICAgICAgICAgICBwcml2YXRlIHJlc3VsdFNlbGVjdG9yPzogKCh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gUikgfCB2b2lkLFxuICAgICAgICAgICAgICBwcml2YXRlIGRlZmF1bHRWYWx1ZT86IGFueSxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBzb3VyY2U/OiBPYnNlcnZhYmxlPFQ+KSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICAgIGlmICh0eXBlb2YgZGVmYXVsdFZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5sYXN0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpOiB2b2lkIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICBpZiAodGhpcy5wcmVkaWNhdGUpIHtcbiAgICAgIHRoaXMuX3RyeVByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5yZXN1bHRTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLl90cnlSZXN1bHRTZWxlY3Rvcih2YWx1ZSwgaW5kZXgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RWYWx1ZSA9IHZhbHVlO1xuICAgICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfdHJ5UHJlZGljYXRlKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSB7XG4gICAgbGV0IHJlc3VsdDogYW55O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIHRoaXMuc291cmNlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgaWYgKHRoaXMucmVzdWx0U2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fdHJ5UmVzdWx0U2VsZWN0b3IodmFsdWUsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXN0VmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX3RyeVJlc3VsdFNlbGVjdG9yKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSB7XG4gICAgbGV0IHJlc3VsdDogYW55O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAoPGFueT50aGlzKS5yZXN1bHRTZWxlY3Rvcih2YWx1ZSwgaW5kZXgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RWYWx1ZSA9IHJlc3VsdDtcbiAgICB0aGlzLmhhc1ZhbHVlID0gdHJ1ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKTogdm9pZCB7XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICBkZXN0aW5hdGlvbi5uZXh0KHRoaXMubGFzdFZhbHVlKTtcbiAgICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlc3RpbmF0aW9uLmVycm9yKG5ldyBFbXB0eUVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvbGFzdC50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcblxuLyoqXG4gKiBAcGFyYW0gZnVuY1xuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn1cbiAqIEBtZXRob2QgbGV0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGV0UHJvdG88VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgZnVuYzogKHNlbGVjdG9yOiBPYnNlcnZhYmxlPFQ+KSA9PiBPYnNlcnZhYmxlPFI+KTogT2JzZXJ2YWJsZTxSPiB7XG4gIHJldHVybiBmdW5jKHRoaXMpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9sZXQudHMiLCJpbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcblxuLyoqXG4gKiBFbWl0cyB0aGUgZ2l2ZW4gY29uc3RhbnQgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGV2ZXJ5IHRpbWUgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5MaWtlIHtAbGluayBtYXB9LCBidXQgaXQgbWFwcyBldmVyeSBzb3VyY2UgdmFsdWUgdG9cbiAqIHRoZSBzYW1lIG91dHB1dCB2YWx1ZSBldmVyeSB0aW1lLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21hcFRvLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFRha2VzIGEgY29uc3RhbnQgYHZhbHVlYCBhcyBhcmd1bWVudCwgYW5kIGVtaXRzIHRoYXQgd2hlbmV2ZXIgdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSBlbWl0cyBhIHZhbHVlLiBJbiBvdGhlciB3b3JkcywgaWdub3JlcyB0aGUgYWN0dWFsIHNvdXJjZSB2YWx1ZSxcbiAqIGFuZCBzaW1wbHkgdXNlcyB0aGUgZW1pc3Npb24gbW9tZW50IHRvIGtub3cgd2hlbiB0byBlbWl0IHRoZSBnaXZlbiBgdmFsdWVgLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk1hcCBldmVyeSBldmVyeSBjbGljayB0byB0aGUgc3RyaW5nICdIaSc8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGdyZWV0aW5ncyA9IGNsaWNrcy5tYXBUbygnSGknKTtcbiAqIGdyZWV0aW5ncy5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgbWFwfVxuICpcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSBUaGUgdmFsdWUgdG8gbWFwIGVhY2ggc291cmNlIHZhbHVlIHRvLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBnaXZlbiBgdmFsdWVgIGV2ZXJ5IHRpbWVcbiAqIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBlbWl0cyBzb21ldGhpbmcuXG4gKiBAbWV0aG9kIG1hcFRvXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwVG88VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgdmFsdWU6IFIpOiBPYnNlcnZhYmxlPFI+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgTWFwVG9PcGVyYXRvcih2YWx1ZSkpO1xufVxuXG5jbGFzcyBNYXBUb09wZXJhdG9yPFQsIFI+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgUj4ge1xuXG4gIHZhbHVlOiBSO1xuXG4gIGNvbnN0cnVjdG9yKHZhbHVlOiBSKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFI+LCBzb3VyY2U6IGFueSk6IGFueSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1hcFRvU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnZhbHVlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIE1hcFRvU3Vic2NyaWJlcjxULCBSPiBleHRlbmRzIFN1YnNjcmliZXI8VD4ge1xuXG4gIHZhbHVlOiBSO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFI+LCB2YWx1ZTogUikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQoeDogVCkge1xuICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLnZhbHVlKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9tYXBUby50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgTm90aWZpY2F0aW9uIH0gZnJvbSAnLi4vTm90aWZpY2F0aW9uJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFsbCBvZiB0aGUgbm90aWZpY2F0aW9ucyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhcyBgbmV4dGBcbiAqIGVtaXNzaW9ucyBtYXJrZWQgd2l0aCB0aGVpciBvcmlnaW5hbCB0eXBlcyB3aXRoaW4ge0BsaW5rIE5vdGlmaWNhdGlvbn1cbiAqIG9iamVjdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPldyYXBzIGBuZXh0YCwgYGVycm9yYCBhbmQgYGNvbXBsZXRlYCBlbWlzc2lvbnMgaW5cbiAqIHtAbGluayBOb3RpZmljYXRpb259IG9iamVjdHMsIGVtaXR0ZWQgYXMgYG5leHRgIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqIDwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL21hdGVyaWFsaXplLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGBtYXRlcmlhbGl6ZWAgcmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYSBgbmV4dGAgbm90aWZpY2F0aW9uIGZvciBlYWNoXG4gKiBgbmV4dGAsIGBlcnJvcmAsIG9yIGBjb21wbGV0ZWAgZW1pc3Npb24gb2YgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBXaGVuIHRoZVxuICogc291cmNlIE9ic2VydmFibGUgZW1pdHMgYGNvbXBsZXRlYCwgdGhlIG91dHB1dCBPYnNlcnZhYmxlIHdpbGwgZW1pdCBgbmV4dGAgYXNcbiAqIGEgTm90aWZpY2F0aW9uIG9mIHR5cGUgXCJjb21wbGV0ZVwiLCBhbmQgdGhlbiBpdCB3aWxsIGVtaXQgYGNvbXBsZXRlYCBhcyB3ZWxsLlxuICogV2hlbiB0aGUgc291cmNlIE9ic2VydmFibGUgZW1pdHMgYGVycm9yYCwgdGhlIG91dHB1dCB3aWxsIGVtaXQgYG5leHRgIGFzIGFcbiAqIE5vdGlmaWNhdGlvbiBvZiB0eXBlIFwiZXJyb3JcIiwgYW5kIHRoZW4gYGNvbXBsZXRlYC5cbiAqXG4gKiBUaGlzIG9wZXJhdG9yIGlzIHVzZWZ1bCBmb3IgcHJvZHVjaW5nIG1ldGFkYXRhIG9mIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgdG9cbiAqIGJlIGNvbnN1bWVkIGFzIGBuZXh0YCBlbWlzc2lvbnMuIFVzZSBpdCBpbiBjb25qdW5jdGlvbiB3aXRoXG4gKiB7QGxpbmsgZGVtYXRlcmlhbGl6ZX0uXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+Q29udmVydCBhIGZhdWx0eSBPYnNlcnZhYmxlIHRvIGFuIE9ic2VydmFibGUgb2YgTm90aWZpY2F0aW9uczwvY2FwdGlvbj5cbiAqIHZhciBsZXR0ZXJzID0gUnguT2JzZXJ2YWJsZS5vZignYScsICdiJywgMTMsICdkJyk7XG4gKiB2YXIgdXBwZXJDYXNlID0gbGV0dGVycy5tYXAoeCA9PiB4LnRvVXBwZXJDYXNlKCkpO1xuICogdmFyIG1hdGVyaWFsaXplZCA9IHVwcGVyQ2FzZS5tYXRlcmlhbGl6ZSgpO1xuICogbWF0ZXJpYWxpemVkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzIGluIHRoZSBmb2xsb3dpbmc6XG4gKiAvLyAtIE5vdGlmaWNhdGlvbiB7a2luZDogXCJOXCIsIHZhbHVlOiBcIkFcIiwgZXJyb3I6IHVuZGVmaW5lZCwgaGFzVmFsdWU6IHRydWV9XG4gKiAvLyAtIE5vdGlmaWNhdGlvbiB7a2luZDogXCJOXCIsIHZhbHVlOiBcIkJcIiwgZXJyb3I6IHVuZGVmaW5lZCwgaGFzVmFsdWU6IHRydWV9XG4gKiAvLyAtIE5vdGlmaWNhdGlvbiB7a2luZDogXCJFXCIsIHZhbHVlOiB1bmRlZmluZWQsIGVycm9yOiBUeXBlRXJyb3I6XG4gKiAvLyAgIHgudG9VcHBlckNhc2UgaXMgbm90IGEgZnVuY3Rpb24gYXQgTWFwU3Vic2NyaWJlci5sZXR0ZXJzLm1hcC54XG4gKiAvLyAgIFthcyBwcm9qZWN0XSAoaHR0cDovLzHigKYsIGhhc1ZhbHVlOiBmYWxzZX1cbiAqXG4gKiBAc2VlIHtAbGluayBOb3RpZmljYXRpb259XG4gKiBAc2VlIHtAbGluayBkZW1hdGVyaWFsaXplfVxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Tm90aWZpY2F0aW9uPFQ+Pn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzXG4gKiB7QGxpbmsgTm90aWZpY2F0aW9ufSBvYmplY3RzIHRoYXQgd3JhcCB0aGUgb3JpZ2luYWwgZW1pc3Npb25zIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZSB3aXRoIG1ldGFkYXRhLlxuICogQG1ldGhvZCBtYXRlcmlhbGl6ZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGVyaWFsaXplPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4pOiBPYnNlcnZhYmxlPE5vdGlmaWNhdGlvbjxUPj4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBNYXRlcmlhbGl6ZU9wZXJhdG9yKCkpO1xufVxuXG5jbGFzcyBNYXRlcmlhbGl6ZU9wZXJhdG9yPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgTm90aWZpY2F0aW9uPFQ+PiB7XG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxOb3RpZmljYXRpb248VD4+LCBzb3VyY2U6IGFueSk6IGFueSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IE1hdGVyaWFsaXplU3Vic2NyaWJlcihzdWJzY3JpYmVyKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIE1hdGVyaWFsaXplU3Vic2NyaWJlcjxUPiBleHRlbmRzIFN1YnNjcmliZXI8VD4ge1xuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxOb3RpZmljYXRpb248VD4+KSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHZhbHVlOiBUKSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KE5vdGlmaWNhdGlvbi5jcmVhdGVOZXh0KHZhbHVlKSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2Vycm9yKGVycjogYW55KSB7XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgIGRlc3RpbmF0aW9uLm5leHQoTm90aWZpY2F0aW9uLmNyZWF0ZUVycm9yKGVycikpO1xuICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbXBsZXRlKCkge1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICBkZXN0aW5hdGlvbi5uZXh0KE5vdGlmaWNhdGlvbi5jcmVhdGVDb21wbGV0ZSgpKTtcbiAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL21hdGVyaWFsaXplLnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgUmVkdWNlT3BlcmF0b3IgfSBmcm9tICcuL3JlZHVjZSc7XG5cbi8qKlxuICogVGhlIE1heCBvcGVyYXRvciBvcGVyYXRlcyBvbiBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgbnVtYmVycyAob3IgaXRlbXMgdGhhdCBjYW4gYmUgY29tcGFyZWQgd2l0aCBhIHByb3ZpZGVkIGZ1bmN0aW9uKSxcbiAqIGFuZCB3aGVuIHNvdXJjZSBPYnNlcnZhYmxlIGNvbXBsZXRlcyBpdCBlbWl0cyBhIHNpbmdsZSBpdGVtOiB0aGUgaXRlbSB3aXRoIHRoZSBsYXJnZXN0IHZhbHVlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWF4LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkdldCB0aGUgbWF4aW1hbCB2YWx1ZSBvZiBhIHNlcmllcyBvZiBudW1iZXJzPC9jYXB0aW9uPlxuICogUnguT2JzZXJ2YWJsZS5vZig1LCA0LCA3LCAyLCA4KVxuICogICAubWF4KClcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTsgLy8gLT4gOFxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlVzZSBhIGNvbXBhcmVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgbWF4aW1hbCBpdGVtPC9jYXB0aW9uPlxuICogaW50ZXJmYWNlIFBlcnNvbiB7XG4gKiAgIGFnZTogbnVtYmVyLFxuICogICBuYW1lOiBzdHJpbmdcbiAqIH1cbiAqIE9ic2VydmFibGUub2Y8UGVyc29uPih7YWdlOiA3LCBuYW1lOiAnRm9vJ30sXG4gKiAgICAgICAgICAgICAgICAgICAgICAge2FnZTogNSwgbmFtZTogJ0Jhcid9LFxuICogICAgICAgICAgICAgICAgICAgICAgIHthZ2U6IDksIG5hbWU6ICdCZWVyJ30pXG4gKiAgICAgICAgICAgLm1heDxQZXJzb24+KChhOiBQZXJzb24sIGI6IFBlcnNvbikgPT4gYS5hZ2UgPCBiLmFnZSA/IC0xIDogMSlcbiAqICAgICAgICAgICAuc3Vic2NyaWJlKCh4OiBQZXJzb24pID0+IGNvbnNvbGUubG9nKHgubmFtZSkpOyAvLyAtPiAnQmVlcidcbiAqIH1cbiAqXG4gKiBAc2VlIHtAbGluayBtaW59XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmVyXSAtIE9wdGlvbmFsIGNvbXBhcmVyIGZ1bmN0aW9uIHRoYXQgaXQgd2lsbCB1c2UgaW5zdGVhZCBvZiBpdHMgZGVmYXVsdCB0byBjb21wYXJlIHRoZVxuICogdmFsdWUgb2YgdHdvIGl0ZW1zLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW0gd2l0aCB0aGUgbGFyZ2VzdCB2YWx1ZS5cbiAqIEBtZXRob2QgbWF4XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF4PFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIGNvbXBhcmVyPzogKHg6IFQsIHk6IFQpID0+IG51bWJlcik6IE9ic2VydmFibGU8VD4ge1xuICBjb25zdCBtYXg6ICh4OiBULCB5OiBUKSA9PiBUID0gKHR5cGVvZiBjb21wYXJlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICA/ICh4LCB5KSA9PiBjb21wYXJlcih4LCB5KSA+IDAgPyB4IDogeVxuICAgIDogKHgsIHkpID0+IHggPiB5ID8geCA6IHk7XG4gIHJldHVybiB0aGlzLmxpZnQobmV3IFJlZHVjZU9wZXJhdG9yKG1heCkpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9tYXgudHMiLCJpbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyB0cnlDYXRjaCB9IGZyb20gJy4uL3V0aWwvdHJ5Q2F0Y2gnO1xuaW1wb3J0IHsgZXJyb3JPYmplY3QgfSBmcm9tICcuLi91dGlsL2Vycm9yT2JqZWN0JztcbmltcG9ydCB7IHN1YnNjcmliZVRvUmVzdWx0IH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCc7XG5pbXBvcnQgeyBPdXRlclN1YnNjcmliZXIgfSBmcm9tICcuLi9PdXRlclN1YnNjcmliZXInO1xuaW1wb3J0IHsgSW5uZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vSW5uZXJTdWJzY3JpYmVyJztcblxuLyoqXG4gKiBBcHBsaWVzIGFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIG92ZXIgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdoZXJlIHRoZVxuICogYWNjdW11bGF0b3IgZnVuY3Rpb24gaXRzZWxmIHJldHVybnMgYW4gT2JzZXJ2YWJsZSwgdGhlbiBlYWNoIGludGVybWVkaWF0ZVxuICogT2JzZXJ2YWJsZSByZXR1cm5lZCBpcyBtZXJnZWQgaW50byB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgc2Nhbn0sIGJ1dCB0aGUgT2JzZXJ2YWJsZXMgcmV0dXJuZWRcbiAqIGJ5IHRoZSBhY2N1bXVsYXRvciBhcmUgbWVyZ2VkIGludG8gdGhlIG91dGVyIE9ic2VydmFibGUuPC9zcGFuPlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvdW50IHRoZSBudW1iZXIgb2YgY2xpY2sgZXZlbnRzPC9jYXB0aW9uPlxuICogY29uc3QgY2xpY2skID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogY29uc3Qgb25lJCA9IGNsaWNrJC5tYXBUbygxKTtcbiAqIGNvbnN0IHNlZWQgPSAwO1xuICogY29uc3QgY291bnQkID0gb25lJC5tZXJnZVNjYW4oKGFjYywgb25lKSA9PiBSeC5PYnNlcnZhYmxlLm9mKGFjYyArIG9uZSksIHNlZWQpO1xuICogY291bnQkLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiAvLyBSZXN1bHRzOlxuICogMVxuICogMlxuICogM1xuICogNFxuICogLy8gLi4uYW5kIHNvIG9uIGZvciBlYWNoIGNsaWNrXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihhY2M6IFIsIHZhbHVlOiBUKTogT2JzZXJ2YWJsZTxSPn0gYWNjdW11bGF0b3JcbiAqIFRoZSBhY2N1bXVsYXRvciBmdW5jdGlvbiBjYWxsZWQgb24gZWFjaCBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0gc2VlZCBUaGUgaW5pdGlhbCBhY2N1bXVsYXRpb24gdmFsdWUuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmN1cnJlbnQ9TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSBNYXhpbXVtIG51bWJlciBvZlxuICogaW5wdXQgT2JzZXJ2YWJsZXMgYmVpbmcgc3Vic2NyaWJlZCB0byBjb25jdXJyZW50bHkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFI+fSBBbiBvYnNlcnZhYmxlIG9mIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZXMuXG4gKiBAbWV0aG9kIG1lcmdlU2NhblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlU2NhbjxULCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2N1bXVsYXRvcjogKGFjYzogUiwgdmFsdWU6IFQpID0+IE9ic2VydmFibGU8Uj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlZWQ6IFIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmN1cnJlbnQ6IG51bWJlciA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk6IE9ic2VydmFibGU8Uj4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBNZXJnZVNjYW5PcGVyYXRvcihhY2N1bXVsYXRvciwgc2VlZCwgY29uY3VycmVudCkpO1xufVxuXG5leHBvcnQgY2xhc3MgTWVyZ2VTY2FuT3BlcmF0b3I8VCwgUj4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBSPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgYWNjdW11bGF0b3I6IChhY2M6IFIsIHZhbHVlOiBUKSA9PiBPYnNlcnZhYmxlPFI+LFxuICAgICAgICAgICAgICBwcml2YXRlIHNlZWQ6IFIsXG4gICAgICAgICAgICAgIHByaXZhdGUgY29uY3VycmVudDogbnVtYmVyKSB7XG4gIH1cblxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8Uj4sIHNvdXJjZTogYW55KTogYW55IHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgTWVyZ2VTY2FuU3Vic2NyaWJlcihcbiAgICAgIHN1YnNjcmliZXIsIHRoaXMuYWNjdW11bGF0b3IsIHRoaXMuc2VlZCwgdGhpcy5jb25jdXJyZW50XG4gICAgKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmV4cG9ydCBjbGFzcyBNZXJnZVNjYW5TdWJzY3JpYmVyPFQsIFI+IGV4dGVuZHMgT3V0ZXJTdWJzY3JpYmVyPFQsIFI+IHtcbiAgcHJpdmF0ZSBoYXNWYWx1ZTogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGhhc0NvbXBsZXRlZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGJ1ZmZlcjogT2JzZXJ2YWJsZTxhbnk+W10gPSBbXTtcbiAgcHJpdmF0ZSBhY3RpdmU6IG51bWJlciA9IDA7XG4gIHByb3RlY3RlZCBpbmRleDogbnVtYmVyID0gMDtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxSPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBhY2N1bXVsYXRvcjogKGFjYzogUiwgdmFsdWU6IFQpID0+IE9ic2VydmFibGU8Uj4sXG4gICAgICAgICAgICAgIHByaXZhdGUgYWNjOiBSLFxuICAgICAgICAgICAgICBwcml2YXRlIGNvbmN1cnJlbnQ6IG51bWJlcikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgaWYgKHRoaXMuYWN0aXZlIDwgdGhpcy5jb25jdXJyZW50KSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXgrKztcbiAgICAgIGNvbnN0IGlzaCA9IHRyeUNhdGNoKHRoaXMuYWNjdW11bGF0b3IpKHRoaXMuYWNjLCB2YWx1ZSk7XG4gICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgICBpZiAoaXNoID09PSBlcnJvck9iamVjdCkge1xuICAgICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnJvck9iamVjdC5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWN0aXZlKys7XG4gICAgICAgIHRoaXMuX2lubmVyU3ViKGlzaCwgdmFsdWUsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5idWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfaW5uZXJTdWIoaXNoOiBhbnksIHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHQ8VCwgUj4odGhpcywgaXNoLCB2YWx1ZSwgaW5kZXgpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKTogdm9pZCB7XG4gICAgdGhpcy5oYXNDb21wbGV0ZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLmFjdGl2ZSA9PT0gMCAmJiB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmICh0aGlzLmhhc1ZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5hY2MpO1xuICAgICAgfVxuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIG5vdGlmeU5leHQob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogUixcbiAgICAgICAgICAgICBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgICBpbm5lclN1YjogSW5uZXJTdWJzY3JpYmVyPFQsIFI+KTogdm9pZCB7XG4gICAgY29uc3QgeyBkZXN0aW5hdGlvbiB9ID0gdGhpcztcbiAgICB0aGlzLmFjYyA9IGlubmVyVmFsdWU7XG4gICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gICAgZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgfVxuXG4gIG5vdGlmeUNvbXBsZXRlKGlubmVyU3ViOiBTdWJzY3JpcHRpb24pOiB2b2lkIHtcbiAgICBjb25zdCBidWZmZXIgPSB0aGlzLmJ1ZmZlcjtcbiAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgdGhpcy5hY3RpdmUtLTtcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuX25leHQoYnVmZmVyLnNoaWZ0KCkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hY3RpdmUgPT09IDAgJiYgdGhpcy5oYXNDb21wbGV0ZWQpIHtcbiAgICAgIGlmICh0aGlzLmhhc1ZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5hY2MpO1xuICAgICAgfVxuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9tZXJnZVNjYW4udHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBSZWR1Y2VPcGVyYXRvciB9IGZyb20gJy4vcmVkdWNlJztcblxuLyoqXG4gKiBUaGUgTWluIG9wZXJhdG9yIG9wZXJhdGVzIG9uIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBudW1iZXJzIChvciBpdGVtcyB0aGF0IGNhbiBiZSBjb21wYXJlZCB3aXRoIGEgcHJvdmlkZWQgZnVuY3Rpb24pLFxuICogYW5kIHdoZW4gc291cmNlIE9ic2VydmFibGUgY29tcGxldGVzIGl0IGVtaXRzIGEgc2luZ2xlIGl0ZW06IHRoZSBpdGVtIHdpdGggdGhlIHNtYWxsZXN0IHZhbHVlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvbWluLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkdldCB0aGUgbWluaW1hbCB2YWx1ZSBvZiBhIHNlcmllcyBvZiBudW1iZXJzPC9jYXB0aW9uPlxuICogUnguT2JzZXJ2YWJsZS5vZig1LCA0LCA3LCAyLCA4KVxuICogICAubWluKClcbiAqICAgLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTsgLy8gLT4gMlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlVzZSBhIGNvbXBhcmVyIGZ1bmN0aW9uIHRvIGdldCB0aGUgbWluaW1hbCBpdGVtPC9jYXB0aW9uPlxuICogaW50ZXJmYWNlIFBlcnNvbiB7XG4gKiAgIGFnZTogbnVtYmVyLFxuICogICBuYW1lOiBzdHJpbmdcbiAqIH1cbiAqIE9ic2VydmFibGUub2Y8UGVyc29uPih7YWdlOiA3LCBuYW1lOiAnRm9vJ30sXG4gKiAgICAgICAgICAgICAgICAgICAgICAge2FnZTogNSwgbmFtZTogJ0Jhcid9LFxuICogICAgICAgICAgICAgICAgICAgICAgIHthZ2U6IDksIG5hbWU6ICdCZWVyJ30pXG4gKiAgICAgICAgICAgLm1pbjxQZXJzb24+KCAoYTogUGVyc29uLCBiOiBQZXJzb24pID0+IGEuYWdlIDwgYi5hZ2UgPyAtMSA6IDEpXG4gKiAgICAgICAgICAgLnN1YnNjcmliZSgoeDogUGVyc29uKSA9PiBjb25zb2xlLmxvZyh4Lm5hbWUpKTsgLy8gLT4gJ0JhcidcbiAqIH1cbiAqXG4gKiBAc2VlIHtAbGluayBtYXh9XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmVyXSAtIE9wdGlvbmFsIGNvbXBhcmVyIGZ1bmN0aW9uIHRoYXQgaXQgd2lsbCB1c2UgaW5zdGVhZCBvZiBpdHMgZGVmYXVsdCB0byBjb21wYXJlIHRoZVxuICogdmFsdWUgb2YgdHdvIGl0ZW1zLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxSPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIGl0ZW0gd2l0aCB0aGUgc21hbGxlc3QgdmFsdWUuXG4gKiBAbWV0aG9kIG1pblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1pbjxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBjb21wYXJlcj86ICh4OiBULCB5OiBUKSA9PiBudW1iZXIpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgY29uc3QgbWluOiAoeDogVCwgeTogVCkgPT4gVCA9ICh0eXBlb2YgY29tcGFyZXIgPT09ICdmdW5jdGlvbicpXG4gICAgPyAoeCwgeSkgPT4gY29tcGFyZXIoeCwgeSkgPCAwID8geCA6IHlcbiAgICA6ICh4LCB5KSA9PiB4IDwgeSA/IHggOiB5O1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBSZWR1Y2VPcGVyYXRvcihtaW4pKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvbWluLnRzIiwiaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5cbi8qKlxuICogR3JvdXBzIHBhaXJzIG9mIGNvbnNlY3V0aXZlIGVtaXNzaW9ucyB0b2dldGhlciBhbmQgZW1pdHMgdGhlbSBhcyBhbiBhcnJheSBvZlxuICogdHdvIHZhbHVlcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+UHV0cyB0aGUgY3VycmVudCB2YWx1ZSBhbmQgcHJldmlvdXMgdmFsdWUgdG9nZXRoZXIgYXNcbiAqIGFuIGFycmF5LCBhbmQgZW1pdHMgdGhhdC48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9wYWlyd2lzZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBUaGUgTnRoIGVtaXNzaW9uIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpbGwgY2F1c2UgdGhlIG91dHB1dCBPYnNlcnZhYmxlXG4gKiB0byBlbWl0IGFuIGFycmF5IFsoTi0xKXRoLCBOdGhdIG9mIHRoZSBwcmV2aW91cyBhbmQgdGhlIGN1cnJlbnQgdmFsdWUsIGFzIGFcbiAqIHBhaXIuIEZvciB0aGlzIHJlYXNvbiwgYHBhaXJ3aXNlYCBlbWl0cyBvbiB0aGUgc2Vjb25kIGFuZCBzdWJzZXF1ZW50XG4gKiBlbWlzc2lvbnMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIGJ1dCBub3Qgb24gdGhlIGZpcnN0IGVtaXNzaW9uLCBiZWNhdXNlXG4gKiB0aGVyZSBpcyBubyBwcmV2aW91cyB2YWx1ZSBpbiB0aGF0IGNhc2UuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+T24gZXZlcnkgY2xpY2sgKHN0YXJ0aW5nIGZyb20gdGhlIHNlY29uZCksIGVtaXQgdGhlIHJlbGF0aXZlIGRpc3RhbmNlIHRvIHRoZSBwcmV2aW91cyBjbGljazwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcGFpcnMgPSBjbGlja3MucGFpcndpc2UoKTtcbiAqIHZhciBkaXN0YW5jZSA9IHBhaXJzLm1hcChwYWlyID0+IHtcbiAqICAgdmFyIHgwID0gcGFpclswXS5jbGllbnRYO1xuICogICB2YXIgeTAgPSBwYWlyWzBdLmNsaWVudFk7XG4gKiAgIHZhciB4MSA9IHBhaXJbMV0uY2xpZW50WDtcbiAqICAgdmFyIHkxID0gcGFpclsxXS5jbGllbnRZO1xuICogICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHgwIC0geDEsIDIpICsgTWF0aC5wb3coeTAgLSB5MSwgMikpO1xuICogfSk7XG4gKiBkaXN0YW5jZS5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYnVmZmVyfVxuICogQHNlZSB7QGxpbmsgYnVmZmVyQ291bnR9XG4gKlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxBcnJheTxUPj59IEFuIE9ic2VydmFibGUgb2YgcGFpcnMgKGFzIGFycmF5cykgb2ZcbiAqIGNvbnNlY3V0aXZlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2QgcGFpcndpc2VcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWlyd2lzZTxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+KTogT2JzZXJ2YWJsZTxbVCwgVF0+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgUGFpcndpc2VPcGVyYXRvcigpKTtcbn1cblxuY2xhc3MgUGFpcndpc2VPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFtULCBUXT4ge1xuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8W1QsIFRdPiwgc291cmNlOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBQYWlyd2lzZVN1YnNjcmliZXIoc3Vic2NyaWJlcikpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBQYWlyd2lzZVN1YnNjcmliZXI8VD4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgcHJpdmF0ZSBwcmV2OiBUO1xuICBwcml2YXRlIGhhc1ByZXY6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxbVCwgVF0+KSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICB9XG5cbiAgX25leHQodmFsdWU6IFQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5oYXNQcmV2KSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoW3RoaXMucHJldiwgdmFsdWVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oYXNQcmV2ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnByZXYgPSB2YWx1ZTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9wYWlyd2lzZS50cyIsImltcG9ydCB7IG5vdCB9IGZyb20gJy4uL3V0aWwvbm90JztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJy4vZmlsdGVyJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcblxuLyoqXG4gKiBTcGxpdHMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGludG8gdHdvLCBvbmUgd2l0aCB2YWx1ZXMgdGhhdCBzYXRpc2Z5IGFcbiAqIHByZWRpY2F0ZSwgYW5kIGFub3RoZXIgd2l0aCB2YWx1ZXMgdGhhdCBkb24ndCBzYXRpc2Z5IHRoZSBwcmVkaWNhdGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgZmlsdGVyfSwgYnV0IHJldHVybnMgdHdvIE9ic2VydmFibGVzOlxuICogb25lIGxpa2UgdGhlIG91dHB1dCBvZiB7QGxpbmsgZmlsdGVyfSwgYW5kIHRoZSBvdGhlciB3aXRoIHZhbHVlcyB0aGF0IGRpZCBub3RcbiAqIHBhc3MgdGhlIGNvbmRpdGlvbi48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9wYXJ0aXRpb24ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHBhcnRpdGlvbmAgb3V0cHV0cyBhbiBhcnJheSB3aXRoIHR3byBPYnNlcnZhYmxlcyB0aGF0IHBhcnRpdGlvbiB0aGUgdmFsdWVzXG4gKiBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aHJvdWdoIHRoZSBnaXZlbiBgcHJlZGljYXRlYCBmdW5jdGlvbi4gVGhlIGZpcnN0XG4gKiBPYnNlcnZhYmxlIGluIHRoYXQgYXJyYXkgZW1pdHMgc291cmNlIHZhbHVlcyBmb3Igd2hpY2ggdGhlIHByZWRpY2F0ZSBhcmd1bWVudFxuICogcmV0dXJucyB0cnVlLiBUaGUgc2Vjb25kIE9ic2VydmFibGUgZW1pdHMgc291cmNlIHZhbHVlcyBmb3Igd2hpY2ggdGhlXG4gKiBwcmVkaWNhdGUgcmV0dXJucyBmYWxzZS4gVGhlIGZpcnN0IGJlaGF2ZXMgbGlrZSB7QGxpbmsgZmlsdGVyfSBhbmQgdGhlIHNlY29uZFxuICogYmVoYXZlcyBsaWtlIHtAbGluayBmaWx0ZXJ9IHdpdGggdGhlIHByZWRpY2F0ZSBuZWdhdGVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlBhcnRpdGlvbiBjbGljayBldmVudHMgaW50byB0aG9zZSBvbiBESVYgZWxlbWVudHMgYW5kIHRob3NlIGVsc2V3aGVyZTwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcGFydHMgPSBjbGlja3MucGFydGl0aW9uKGV2ID0+IGV2LnRhcmdldC50YWdOYW1lID09PSAnRElWJyk7XG4gKiB2YXIgY2xpY2tzT25EaXZzID0gcGFydHNbMF07XG4gKiB2YXIgY2xpY2tzRWxzZXdoZXJlID0gcGFydHNbMV07XG4gKiBjbGlja3NPbkRpdnMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coJ0RJViBjbGlja2VkOiAnLCB4KSk7XG4gKiBjbGlja3NFbHNld2hlcmUuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coJ090aGVyIGNsaWNrZWQ6ICcsIHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBmaWx0ZXJ9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogVCwgaW5kZXg6IG51bWJlcik6IGJvb2xlYW59IHByZWRpY2F0ZSBBIGZ1bmN0aW9uIHRoYXRcbiAqIGV2YWx1YXRlcyBlYWNoIHZhbHVlIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiBpdCByZXR1cm5zIGB0cnVlYCxcbiAqIHRoZSB2YWx1ZSBpcyBlbWl0dGVkIG9uIHRoZSBmaXJzdCBPYnNlcnZhYmxlIGluIHRoZSByZXR1cm5lZCBhcnJheSwgaWZcbiAqIGBmYWxzZWAgdGhlIHZhbHVlIGlzIGVtaXR0ZWQgb24gdGhlIHNlY29uZCBPYnNlcnZhYmxlIGluIHRoZSBhcnJheS4gVGhlXG4gKiBgaW5kZXhgIHBhcmFtZXRlciBpcyB0aGUgbnVtYmVyIGBpYCBmb3IgdGhlIGktdGggc291cmNlIGVtaXNzaW9uIHRoYXQgaGFzXG4gKiBoYXBwZW5lZCBzaW5jZSB0aGUgc3Vic2NyaXB0aW9uLCBzdGFydGluZyBmcm9tIHRoZSBudW1iZXIgYDBgLlxuICogQHBhcmFtIHthbnl9IFt0aGlzQXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIGB0aGlzYFxuICogaW4gdGhlIGBwcmVkaWNhdGVgIGZ1bmN0aW9uLlxuICogQHJldHVybiB7W09ic2VydmFibGU8VD4sIE9ic2VydmFibGU8VD5dfSBBbiBhcnJheSB3aXRoIHR3byBPYnNlcnZhYmxlczogb25lXG4gKiB3aXRoIHZhbHVlcyB0aGF0IHBhc3NlZCB0aGUgcHJlZGljYXRlLCBhbmQgYW5vdGhlciB3aXRoIHZhbHVlcyB0aGF0IGRpZCBub3RcbiAqIHBhc3MgdGhlIHByZWRpY2F0ZS5cbiAqIEBtZXRob2QgcGFydGl0aW9uXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFydGl0aW9uPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIHByZWRpY2F0ZTogKHZhbHVlOiBUKSA9PiBib29sZWFuLCB0aGlzQXJnPzogYW55KTogW09ic2VydmFibGU8VD4sIE9ic2VydmFibGU8VD5dIHtcbiAgcmV0dXJuIFtcbiAgICBmaWx0ZXIuY2FsbCh0aGlzLCBwcmVkaWNhdGUsIHRoaXNBcmcpLFxuICAgIGZpbHRlci5jYWxsKHRoaXMsIG5vdChwcmVkaWNhdGUsIHRoaXNBcmcpKVxuICBdO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9wYXJ0aXRpb24udHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICcuL21hcCc7XG5cbi8qKlxuICogTWFwcyBlYWNoIHNvdXJjZSB2YWx1ZSAoYW4gb2JqZWN0KSB0byBpdHMgc3BlY2lmaWVkIG5lc3RlZCBwcm9wZXJ0eS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TGlrZSB7QGxpbmsgbWFwfSwgYnV0IG1lYW50IG9ubHkgZm9yIHBpY2tpbmcgb25lIG9mXG4gKiB0aGUgbmVzdGVkIHByb3BlcnRpZXMgb2YgZXZlcnkgZW1pdHRlZCBvYmplY3QuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcGx1Y2sucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogR2l2ZW4gYSBsaXN0IG9mIHN0cmluZ3MgZGVzY3JpYmluZyBhIHBhdGggdG8gYW4gb2JqZWN0IHByb3BlcnR5LCByZXRyaWV2ZXNcbiAqIHRoZSB2YWx1ZSBvZiBhIHNwZWNpZmllZCBuZXN0ZWQgcHJvcGVydHkgZnJvbSBhbGwgdmFsdWVzIGluIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIElmIGEgcHJvcGVydHkgY2FuJ3QgYmUgcmVzb2x2ZWQsIGl0IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICogdGhhdCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5NYXAgZXZlcnkgZXZlcnkgY2xpY2sgdG8gdGhlIHRhZ05hbWUgb2YgdGhlIGNsaWNrZWQgdGFyZ2V0IGVsZW1lbnQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHRhZ05hbWVzID0gY2xpY2tzLnBsdWNrKCd0YXJnZXQnLCAndGFnTmFtZScpO1xuICogdGFnTmFtZXMuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIG1hcH1cbiAqXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gcHJvcGVydGllcyBUaGUgbmVzdGVkIHByb3BlcnRpZXMgdG8gcGx1Y2sgZnJvbSBlYWNoIHNvdXJjZVxuICogdmFsdWUgKGFuIG9iamVjdCkuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBIG5ldyBPYnNlcnZhYmxlIG9mIHByb3BlcnR5IHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UgdmFsdWVzLlxuICogQG1ldGhvZCBwbHVja1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBsdWNrPFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIC4uLnByb3BlcnRpZXM6IHN0cmluZ1tdKTogT2JzZXJ2YWJsZTxSPiB7XG4gIGNvbnN0IGxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdsaXN0IG9mIHByb3BlcnRpZXMgY2Fubm90IGJlIGVtcHR5LicpO1xuICB9XG4gIHJldHVybiBtYXAuY2FsbCh0aGlzLCBwbHVja2VyKHByb3BlcnRpZXMsIGxlbmd0aCkpO1xufVxuXG5mdW5jdGlvbiBwbHVja2VyKHByb3BzOiBzdHJpbmdbXSwgbGVuZ3RoOiBudW1iZXIpOiAoeDogc3RyaW5nKSA9PiBhbnkge1xuICBjb25zdCBtYXBwZXIgPSAoeDogc3RyaW5nKSA9PiB7XG4gICAgbGV0IGN1cnJlbnRQcm9wID0geDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBwID0gY3VycmVudFByb3BbcHJvcHNbaV1dO1xuICAgICAgaWYgKHR5cGVvZiBwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjdXJyZW50UHJvcCA9IHA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudFByb3A7XG4gIH07XG5cbiAgcmV0dXJuIG1hcHBlcjtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvcGx1Y2sudHMiLCJpbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAnLi4vU3ViamVjdCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBtdWx0aWNhc3QgfSBmcm9tICcuL211bHRpY2FzdCc7XG5pbXBvcnQgeyBDb25uZWN0YWJsZU9ic2VydmFibGUgfSBmcm9tICcuLi9vYnNlcnZhYmxlL0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZSc7XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHB1Ymxpc2g8VD4odGhpczogT2JzZXJ2YWJsZTxUPik6IENvbm5lY3RhYmxlT2JzZXJ2YWJsZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBwdWJsaXNoPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIHNlbGVjdG9yOiBzZWxlY3RvcjxUPik6IE9ic2VydmFibGU8VD47XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBDb25uZWN0YWJsZU9ic2VydmFibGUsIHdoaWNoIGlzIGEgdmFyaWV0eSBvZiBPYnNlcnZhYmxlIHRoYXQgd2FpdHMgdW50aWwgaXRzIGNvbm5lY3QgbWV0aG9kIGlzIGNhbGxlZFxuICogYmVmb3JlIGl0IGJlZ2lucyBlbWl0dGluZyBpdGVtcyB0byB0aG9zZSBPYnNlcnZlcnMgdGhhdCBoYXZlIHN1YnNjcmliZWQgdG8gaXQuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9wdWJsaXNoLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtzZWxlY3Rvcl0gLSBPcHRpb25hbCBzZWxlY3RvciBmdW5jdGlvbiB3aGljaCBjYW4gdXNlIHRoZSBtdWx0aWNhc3RlZCBzb3VyY2Ugc2VxdWVuY2UgYXMgbWFueSB0aW1lc1xuICogYXMgbmVlZGVkLCB3aXRob3V0IGNhdXNpbmcgbXVsdGlwbGUgc3Vic2NyaXB0aW9ucyB0byB0aGUgc291cmNlIHNlcXVlbmNlLlxuICogU3Vic2NyaWJlcnMgdG8gdGhlIGdpdmVuIHNvdXJjZSB3aWxsIHJlY2VpdmUgYWxsIG5vdGlmaWNhdGlvbnMgb2YgdGhlIHNvdXJjZSBmcm9tIHRoZSB0aW1lIG9mIHRoZSBzdWJzY3JpcHRpb24gb24uXG4gKiBAcmV0dXJuIEEgQ29ubmVjdGFibGVPYnNlcnZhYmxlIHRoYXQgdXBvbiBjb25uZWN0aW9uIGNhdXNlcyB0aGUgc291cmNlIE9ic2VydmFibGUgdG8gZW1pdCBpdGVtcyB0byBpdHMgT2JzZXJ2ZXJzLlxuICogQG1ldGhvZCBwdWJsaXNoXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHVibGlzaDxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBzZWxlY3Rvcj86IChzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IE9ic2VydmFibGU8VD4pOiBPYnNlcnZhYmxlPFQ+IHwgQ29ubmVjdGFibGVPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIHNlbGVjdG9yID8gbXVsdGljYXN0LmNhbGwodGhpcywgKCkgPT4gbmV3IFN1YmplY3Q8VD4oKSwgc2VsZWN0b3IpIDpcbiAgICAgICAgICAgICAgICAgICAgbXVsdGljYXN0LmNhbGwodGhpcywgbmV3IFN1YmplY3Q8VD4oKSk7XG59XG5cbmV4cG9ydCB0eXBlIHNlbGVjdG9yPFQ+ID0gKHNvdXJjZTogT2JzZXJ2YWJsZTxUPikgPT4gT2JzZXJ2YWJsZTxUPjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvcHVibGlzaC50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJy4uL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBtdWx0aWNhc3QgfSBmcm9tICcuL211bHRpY2FzdCc7XG5pbXBvcnQgeyBDb25uZWN0YWJsZU9ic2VydmFibGUgfSBmcm9tICcuLi9vYnNlcnZhYmxlL0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZSc7XG5cbi8qKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJuIHtDb25uZWN0YWJsZU9ic2VydmFibGU8VD59XG4gKiBAbWV0aG9kIHB1Ymxpc2hCZWhhdmlvclxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHB1Ymxpc2hCZWhhdmlvcjxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2YWx1ZTogVCk6IENvbm5lY3RhYmxlT2JzZXJ2YWJsZTxUPiB7XG4gIHJldHVybiBtdWx0aWNhc3QuY2FsbCh0aGlzLCBuZXcgQmVoYXZpb3JTdWJqZWN0PFQ+KHZhbHVlKSk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL3B1Ymxpc2hCZWhhdmlvci50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IEFzeW5jU3ViamVjdCB9IGZyb20gJy4uL0FzeW5jU3ViamVjdCc7XG5pbXBvcnQgeyBtdWx0aWNhc3QgfSBmcm9tICcuL211bHRpY2FzdCc7XG5pbXBvcnQgeyBDb25uZWN0YWJsZU9ic2VydmFibGUgfSBmcm9tICcuLi9vYnNlcnZhYmxlL0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZSc7XG5cbi8qKlxuICogQHJldHVybiB7Q29ubmVjdGFibGVPYnNlcnZhYmxlPFQ+fVxuICogQG1ldGhvZCBwdWJsaXNoTGFzdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHB1Ymxpc2hMYXN0PFQ+KHRoaXM6IE9ic2VydmFibGU8VD4pOiBDb25uZWN0YWJsZU9ic2VydmFibGU8VD4ge1xuICByZXR1cm4gbXVsdGljYXN0LmNhbGwodGhpcywgbmV3IEFzeW5jU3ViamVjdDxUPigpKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvcHVibGlzaExhc3QudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBSZXBsYXlTdWJqZWN0IH0gZnJvbSAnLi4vUmVwbGF5U3ViamVjdCc7XG5pbXBvcnQgeyBJU2NoZWR1bGVyIH0gZnJvbSAnLi4vU2NoZWR1bGVyJztcbmltcG9ydCB7IG11bHRpY2FzdCB9IGZyb20gJy4vbXVsdGljYXN0JztcbmltcG9ydCB7IENvbm5lY3RhYmxlT2JzZXJ2YWJsZSB9IGZyb20gJy4uL29ic2VydmFibGUvQ29ubmVjdGFibGVPYnNlcnZhYmxlJztcblxuLyoqXG4gKiBAcGFyYW0gYnVmZmVyU2l6ZVxuICogQHBhcmFtIHdpbmRvd1RpbWVcbiAqIEBwYXJhbSBzY2hlZHVsZXJcbiAqIEByZXR1cm4ge0Nvbm5lY3RhYmxlT2JzZXJ2YWJsZTxUPn1cbiAqIEBtZXRob2QgcHVibGlzaFJlcGxheVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHB1Ymxpc2hSZXBsYXk8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgYnVmZmVyU2l6ZTogbnVtYmVyID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93VGltZTogbnVtYmVyID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IENvbm5lY3RhYmxlT2JzZXJ2YWJsZTxUPiB7XG4gIHJldHVybiBtdWx0aWNhc3QuY2FsbCh0aGlzLCBuZXcgUmVwbGF5U3ViamVjdDxUPihidWZmZXJTaXplLCB3aW5kb3dUaW1lLCBzY2hlZHVsZXIpKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvcHVibGlzaFJlcGxheS50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgRW1wdHlPYnNlcnZhYmxlIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUnO1xuaW1wb3J0IHsgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgcmVwZWF0cyB0aGUgc3RyZWFtIG9mIGl0ZW1zIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGF0IG1vc3QgY291bnQgdGltZXMuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9yZXBlYXQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudF0gVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgc291cmNlIE9ic2VydmFibGUgaXRlbXMgYXJlIHJlcGVhdGVkLCBhIGNvdW50IG9mIDAgd2lsbCB5aWVsZFxuICogYW4gZW1wdHkgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGV9IEFuIE9ic2VydmFibGUgdGhhdCByZXBlYXRzIHRoZSBzdHJlYW0gb2YgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYXQgbW9zdFxuICogY291bnQgdGltZXMuXG4gKiBAbWV0aG9kIHJlcGVhdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGVhdDxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBjb3VudDogbnVtYmVyID0gLTEpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGU8VD4oKTtcbiAgfSBlbHNlIGlmIChjb3VudCA8IDApIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBSZXBlYXRPcGVyYXRvcigtMSwgdGhpcykpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0aGlzLmxpZnQobmV3IFJlcGVhdE9wZXJhdG9yKGNvdW50IC0gMSwgdGhpcykpO1xuICB9XG59XG5cbmNsYXNzIFJlcGVhdE9wZXJhdG9yPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvdW50OiBudW1iZXIsXG4gICAgICAgICAgICAgIHByaXZhdGUgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSB7XG4gIH1cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+LCBzb3VyY2U6IGFueSk6IFRlYXJkb3duTG9naWMge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBSZXBlYXRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY291bnQsIHRoaXMuc291cmNlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIFJlcGVhdFN1YnNjcmliZXI8VD4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8YW55PixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBjb3VudDogbnVtYmVyLFxuICAgICAgICAgICAgICBwcml2YXRlIHNvdXJjZTogT2JzZXJ2YWJsZTxUPikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuICBjb21wbGV0ZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICBjb25zdCB7IHNvdXJjZSwgY291bnQgfSA9IHRoaXM7XG4gICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNvbXBsZXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKGNvdW50ID4gLTEpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50IC0gMTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZS5zdWJzY3JpYmUodGhpcy5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCkpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9yZXBlYXQudHMiLCJpbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICcuLi9TdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiwgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyB0cnlDYXRjaCB9IGZyb20gJy4uL3V0aWwvdHJ5Q2F0Y2gnO1xuaW1wb3J0IHsgZXJyb3JPYmplY3QgfSBmcm9tICcuLi91dGlsL2Vycm9yT2JqZWN0JztcblxuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vT3V0ZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IElubmVyU3Vic2NyaWJlciB9IGZyb20gJy4uL0lubmVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBzdWJzY3JpYmVUb1Jlc3VsdCB9IGZyb20gJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnO1xuXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IG1pcnJvcnMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBhIGBjb21wbGV0ZWAuIElmIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgY2FsbHMgYGNvbXBsZXRlYCwgdGhpcyBtZXRob2Qgd2lsbCBlbWl0IHRvIHRoZSBPYnNlcnZhYmxlIHJldHVybmVkIGZyb20gYG5vdGlmaWVyYC4gSWYgdGhhdCBPYnNlcnZhYmxlXG4gKiBjYWxscyBgY29tcGxldGVgIG9yIGBlcnJvcmAsIHRoZW4gdGhpcyBtZXRob2Qgd2lsbCBjYWxsIGBjb21wbGV0ZWAgb3IgYGVycm9yYCBvbiB0aGUgY2hpbGQgc3Vic2NyaXB0aW9uLiBPdGhlcndpc2VcbiAqIHRoaXMgbWV0aG9kIHdpbGwgcmVzdWJzY3JpYmUgdG8gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcmVwZWF0V2hlbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG5vdGlmaWNhdGlvbnM6IE9ic2VydmFibGUpOiBPYnNlcnZhYmxlfSBub3RpZmllciAtIFJlY2VpdmVzIGFuIE9ic2VydmFibGUgb2Ygbm90aWZpY2F0aW9ucyB3aXRoXG4gKiB3aGljaCBhIHVzZXIgY2FuIGBjb21wbGV0ZWAgb3IgYGVycm9yYCwgYWJvcnRpbmcgdGhlIHJlcGV0aXRpb24uXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIE9ic2VydmFibGUgbW9kaWZpZWQgd2l0aCByZXBlYXQgbG9naWMuXG4gKiBAbWV0aG9kIHJlcGVhdFdoZW5cbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXBlYXRXaGVuPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIG5vdGlmaWVyOiAobm90aWZpY2F0aW9uczogT2JzZXJ2YWJsZTxhbnk+KSA9PiBPYnNlcnZhYmxlPGFueT4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgUmVwZWF0V2hlbk9wZXJhdG9yKG5vdGlmaWVyKSk7XG59XG5cbmNsYXNzIFJlcGVhdFdoZW5PcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFQ+IHtcbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIG5vdGlmaWVyOiAobm90aWZpY2F0aW9uczogT2JzZXJ2YWJsZTxhbnk+KSA9PiBPYnNlcnZhYmxlPGFueT4pIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPiwgc291cmNlOiBhbnkpOiBUZWFyZG93bkxvZ2ljIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgUmVwZWF0V2hlblN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5ub3RpZmllciwgc291cmNlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIFJlcGVhdFdoZW5TdWJzY3JpYmVyPFQsIFI+IGV4dGVuZHMgT3V0ZXJTdWJzY3JpYmVyPFQsIFI+IHtcblxuICBwcml2YXRlIG5vdGlmaWNhdGlvbnM6IFN1YmplY3Q8YW55PjtcbiAgcHJpdmF0ZSByZXRyaWVzOiBPYnNlcnZhYmxlPGFueT47XG4gIHByaXZhdGUgcmV0cmllc1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIHNvdXJjZUlzQmVpbmdTdWJzY3JpYmVkVG86IGJvb2xlYW4gPSB0cnVlO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFI+LFxuICAgICAgICAgICAgICBwcml2YXRlIG5vdGlmaWVyOiAobm90aWZpY2F0aW9uczogT2JzZXJ2YWJsZTxhbnk+KSA9PiBPYnNlcnZhYmxlPGFueT4sXG4gICAgICAgICAgICAgIHByaXZhdGUgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICB9XG5cbiAgbm90aWZ5TmV4dChvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBSLFxuICAgICAgICAgICAgIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgIGlubmVyU3ViOiBJbm5lclN1YnNjcmliZXI8VCwgUj4pOiB2b2lkIHtcbiAgICB0aGlzLnNvdXJjZUlzQmVpbmdTdWJzY3JpYmVkVG8gPSB0cnVlO1xuICAgIHRoaXMuc291cmNlLnN1YnNjcmliZSh0aGlzKTtcbiAgfVxuXG4gIG5vdGlmeUNvbXBsZXRlKGlubmVyU3ViOiBJbm5lclN1YnNjcmliZXI8VCwgUj4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zb3VyY2VJc0JlaW5nU3Vic2NyaWJlZFRvID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHN1cGVyLmNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgY29tcGxldGUoKSB7XG4gICAgdGhpcy5zb3VyY2VJc0JlaW5nU3Vic2NyaWJlZFRvID0gZmFsc2U7XG5cbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICBpZiAoIXRoaXMucmV0cmllcykge1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvUmV0cmllcygpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5jb21wbGV0ZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91bnN1YnNjcmliZUFuZFJlY3ljbGUoKTtcbiAgICAgIHRoaXMubm90aWZpY2F0aW9ucy5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF91bnN1YnNjcmliZSgpIHtcbiAgICBjb25zdCB7IG5vdGlmaWNhdGlvbnMsIHJldHJpZXNTdWJzY3JpcHRpb24gfSA9IHRoaXM7XG4gICAgaWYgKG5vdGlmaWNhdGlvbnMpIHtcbiAgICAgIG5vdGlmaWNhdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMubm90aWZpY2F0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIGlmIChyZXRyaWVzU3Vic2NyaXB0aW9uKSB7XG4gICAgICByZXRyaWVzU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnJldHJpZXMgPSBudWxsO1xuICB9XG5cbiAgcHJvdGVjdGVkIF91bnN1YnNjcmliZUFuZFJlY3ljbGUoKTogU3Vic2NyaWJlcjxUPiB7XG4gICAgY29uc3QgeyBub3RpZmljYXRpb25zLCByZXRyaWVzLCByZXRyaWVzU3Vic2NyaXB0aW9uIH0gPSB0aGlzO1xuICAgIHRoaXMubm90aWZpY2F0aW9ucyA9IG51bGw7XG4gICAgdGhpcy5yZXRyaWVzID0gbnVsbDtcbiAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSBudWxsO1xuICAgIHN1cGVyLl91bnN1YnNjcmliZUFuZFJlY3ljbGUoKTtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMgPSBub3RpZmljYXRpb25zO1xuICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXM7XG4gICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gcmV0cmllc1N1YnNjcmlwdGlvbjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHByaXZhdGUgc3Vic2NyaWJlVG9SZXRyaWVzKCkge1xuICAgIHRoaXMubm90aWZpY2F0aW9ucyA9IG5ldyBTdWJqZWN0KCk7XG4gICAgY29uc3QgcmV0cmllcyA9IHRyeUNhdGNoKHRoaXMubm90aWZpZXIpKHRoaXMubm90aWZpY2F0aW9ucyk7XG4gICAgaWYgKHJldHJpZXMgPT09IGVycm9yT2JqZWN0KSB7XG4gICAgICByZXR1cm4gc3VwZXIuY29tcGxldGUoKTtcbiAgICB9XG4gICAgdGhpcy5yZXRyaWVzID0gcmV0cmllcztcbiAgICB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXRyaWVzKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9yZXBlYXRXaGVuLnRzIiwiaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBUZWFyZG93bkxvZ2ljIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcblxuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBtaXJyb3JzIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aXRoIHRoZSBleGNlcHRpb24gb2YgYW4gYGVycm9yYC4gSWYgdGhlIHNvdXJjZSBPYnNlcnZhYmxlXG4gKiBjYWxscyBgZXJyb3JgLCB0aGlzIG1ldGhvZCB3aWxsIHJlc3Vic2NyaWJlIHRvIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBmb3IgYSBtYXhpbXVtIG9mIGBjb3VudGAgcmVzdWJzY3JpcHRpb25zIChnaXZlblxuICogYXMgYSBudW1iZXIgcGFyYW1ldGVyKSByYXRoZXIgdGhhbiBwcm9wYWdhdGluZyB0aGUgYGVycm9yYCBjYWxsLlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvcmV0cnkucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQW55IGFuZCBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoZSByZXN1bHRpbmcgT2JzZXJ2YWJsZSwgZXZlbiB0aG9zZSBlbWl0dGVkXG4gKiBkdXJpbmcgZmFpbGVkIHN1YnNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCBpZiBhbiBPYnNlcnZhYmxlIGZhaWxzIGF0IGZpcnN0IGJ1dCBlbWl0cyBbMSwgMl0gdGhlbiBzdWNjZWVkcyB0aGUgc2Vjb25kXG4gKiB0aW1lIGFuZCBlbWl0czogWzEsIDIsIDMsIDQsIDVdIHRoZW4gdGhlIGNvbXBsZXRlIHN0cmVhbSBvZiBlbWlzc2lvbnMgYW5kIG5vdGlmaWNhdGlvbnNcbiAqIHdvdWxkIGJlOiBbMSwgMiwgMSwgMiwgMywgNCwgNSwgYGNvbXBsZXRlYF0uXG4gKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBOdW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgYmVmb3JlIGZhaWxpbmcuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBUaGUgc291cmNlIE9ic2VydmFibGUgbW9kaWZpZWQgd2l0aCB0aGUgcmV0cnkgbG9naWMuXG4gKiBAbWV0aG9kIHJldHJ5XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV0cnk8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgY291bnQ6IG51bWJlciA9IC0xKTogT2JzZXJ2YWJsZTxUPiB7XG4gIHJldHVybiB0aGlzLmxpZnQobmV3IFJldHJ5T3BlcmF0b3IoY291bnQsIHRoaXMpKTtcbn1cblxuY2xhc3MgUmV0cnlPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjb3VudDogbnVtYmVyLFxuICAgICAgICAgICAgICBwcml2YXRlIHNvdXJjZTogT2JzZXJ2YWJsZTxUPikge1xuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+LCBzb3VyY2U6IGFueSk6IFRlYXJkb3duTG9naWMge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBSZXRyeVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5jb3VudCwgdGhpcy5zb3VyY2UpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgUmV0cnlTdWJzY3JpYmVyPFQ+IGV4dGVuZHMgU3Vic2NyaWJlcjxUPiB7XG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPGFueT4sXG4gICAgICAgICAgICAgIHByaXZhdGUgY291bnQ6IG51bWJlcixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBzb3VyY2U6IE9ic2VydmFibGU8VD4pIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gIH1cbiAgZXJyb3IoZXJyOiBhbnkpIHtcbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICBjb25zdCB7IHNvdXJjZSwgY291bnQgfSA9IHRoaXM7XG4gICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVycm9yKGVycik7XG4gICAgICB9IGVsc2UgaWYgKGNvdW50ID4gLTEpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50IC0gMTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZS5zdWJzY3JpYmUodGhpcy5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCkpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9yZXRyeS50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJy4uL1N1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBUZWFyZG93bkxvZ2ljIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IHRyeUNhdGNoIH0gZnJvbSAnLi4vdXRpbC90cnlDYXRjaCc7XG5pbXBvcnQgeyBlcnJvck9iamVjdCB9IGZyb20gJy4uL3V0aWwvZXJyb3JPYmplY3QnO1xuXG5pbXBvcnQgeyBPdXRlclN1YnNjcmliZXIgfSBmcm9tICcuLi9PdXRlclN1YnNjcmliZXInO1xuaW1wb3J0IHsgSW5uZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vSW5uZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IHN1YnNjcmliZVRvUmVzdWx0IH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCc7XG5cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgbWlycm9ycyB0aGUgc291cmNlIE9ic2VydmFibGUgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGFuIGBlcnJvcmAuIElmIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZVxuICogY2FsbHMgYGVycm9yYCwgdGhpcyBtZXRob2Qgd2lsbCBlbWl0IHRoZSBUaHJvd2FibGUgdGhhdCBjYXVzZWQgdGhlIGVycm9yIHRvIHRoZSBPYnNlcnZhYmxlIHJldHVybmVkIGZyb20gYG5vdGlmaWVyYC5cbiAqIElmIHRoYXQgT2JzZXJ2YWJsZSBjYWxscyBgY29tcGxldGVgIG9yIGBlcnJvcmAgdGhlbiB0aGlzIG1ldGhvZCB3aWxsIGNhbGwgYGNvbXBsZXRlYCBvciBgZXJyb3JgIG9uIHRoZSBjaGlsZFxuICogc3Vic2NyaXB0aW9uLiBPdGhlcndpc2UgdGhpcyBtZXRob2Qgd2lsbCByZXN1YnNjcmliZSB0byB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9yZXRyeVdoZW4ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihlcnJvcnM6IE9ic2VydmFibGUpOiBPYnNlcnZhYmxlfSBub3RpZmllciAtIFJlY2VpdmVzIGFuIE9ic2VydmFibGUgb2Ygbm90aWZpY2F0aW9ucyB3aXRoIHdoaWNoIGFcbiAqIHVzZXIgY2FuIGBjb21wbGV0ZWAgb3IgYGVycm9yYCwgYWJvcnRpbmcgdGhlIHJldHJ5LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gVGhlIHNvdXJjZSBPYnNlcnZhYmxlIG1vZGlmaWVkIHdpdGggcmV0cnkgbG9naWMuXG4gKiBAbWV0aG9kIHJldHJ5V2hlblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJldHJ5V2hlbjxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBub3RpZmllcjogKGVycm9yczogT2JzZXJ2YWJsZTxhbnk+KSA9PiBPYnNlcnZhYmxlPGFueT4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgUmV0cnlXaGVuT3BlcmF0b3Iobm90aWZpZXIsIHRoaXMpKTtcbn1cblxuY2xhc3MgUmV0cnlXaGVuT3BlcmF0b3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUPiB7XG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBub3RpZmllcjogKGVycm9yczogT2JzZXJ2YWJsZTxhbnk+KSA9PiBPYnNlcnZhYmxlPGFueT4sXG4gICAgICAgICAgICAgIHByb3RlY3RlZCBzb3VyY2U6IE9ic2VydmFibGU8VD4pIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPiwgc291cmNlOiBhbnkpOiBUZWFyZG93bkxvZ2ljIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgUmV0cnlXaGVuU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm5vdGlmaWVyLCB0aGlzLnNvdXJjZSkpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBSZXRyeVdoZW5TdWJzY3JpYmVyPFQsIFI+IGV4dGVuZHMgT3V0ZXJTdWJzY3JpYmVyPFQsIFI+IHtcblxuICBwcml2YXRlIGVycm9yczogU3ViamVjdDxhbnk+O1xuICBwcml2YXRlIHJldHJpZXM6IE9ic2VydmFibGU8YW55PjtcbiAgcHJpdmF0ZSByZXRyaWVzU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8Uj4sXG4gICAgICAgICAgICAgIHByaXZhdGUgbm90aWZpZXI6IChlcnJvcnM6IE9ic2VydmFibGU8YW55PikgPT4gT2JzZXJ2YWJsZTxhbnk+LFxuICAgICAgICAgICAgICBwcml2YXRlIHNvdXJjZTogT2JzZXJ2YWJsZTxUPikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIGVycm9yKGVycjogYW55KSB7XG4gICAgaWYgKCF0aGlzLmlzU3RvcHBlZCkge1xuXG4gICAgICBsZXQgZXJyb3JzID0gdGhpcy5lcnJvcnM7XG4gICAgICBsZXQgcmV0cmllczogYW55ID0gdGhpcy5yZXRyaWVzO1xuICAgICAgbGV0IHJldHJpZXNTdWJzY3JpcHRpb24gPSB0aGlzLnJldHJpZXNTdWJzY3JpcHRpb247XG5cbiAgICAgIGlmICghcmV0cmllcykge1xuICAgICAgICBlcnJvcnMgPSBuZXcgU3ViamVjdCgpO1xuICAgICAgICByZXRyaWVzID0gdHJ5Q2F0Y2godGhpcy5ub3RpZmllcikoZXJyb3JzKTtcbiAgICAgICAgaWYgKHJldHJpZXMgPT09IGVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIHN1cGVyLmVycm9yKGVycm9yT2JqZWN0LmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHJpZXNTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXRyaWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlKCk7XG5cbiAgICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgdGhpcy5yZXRyaWVzID0gcmV0cmllcztcbiAgICAgIHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbiA9IHJldHJpZXNTdWJzY3JpcHRpb247XG5cbiAgICAgIGVycm9ycy5uZXh0KGVycik7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF91bnN1YnNjcmliZSgpIHtcbiAgICBjb25zdCB7IGVycm9ycywgcmV0cmllc1N1YnNjcmlwdGlvbiB9ID0gdGhpcztcbiAgICBpZiAoZXJyb3JzKSB7XG4gICAgICBlcnJvcnMudW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJldHJpZXNTdWJzY3JpcHRpb24pIHtcbiAgICAgIHJldHJpZXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucmV0cmllcyA9IG51bGw7XG4gIH1cblxuICBub3RpZnlOZXh0KG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IFIsXG4gICAgICAgICAgICAgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICAgaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBSPik6IHZvaWQge1xuICAgIGNvbnN0IHsgZXJyb3JzLCByZXRyaWVzLCByZXRyaWVzU3Vic2NyaXB0aW9uIH0gPSB0aGlzO1xuICAgIHRoaXMuZXJyb3JzID0gbnVsbDtcbiAgICB0aGlzLnJldHJpZXMgPSBudWxsO1xuICAgIHRoaXMucmV0cmllc1N1YnNjcmlwdGlvbiA9IG51bGw7XG5cbiAgICB0aGlzLl91bnN1YnNjcmliZUFuZFJlY3ljbGUoKTtcblxuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRoaXMucmV0cmllcyA9IHJldHJpZXM7XG4gICAgdGhpcy5yZXRyaWVzU3Vic2NyaXB0aW9uID0gcmV0cmllc1N1YnNjcmlwdGlvbjtcblxuICAgIHRoaXMuc291cmNlLnN1YnNjcmliZSh0aGlzKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9yZXRyeVdoZW4udHMiLCJpbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IFRlYXJkb3duTG9naWMgfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vT3V0ZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IElubmVyU3Vic2NyaWJlciB9IGZyb20gJy4uL0lubmVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBzdWJzY3JpYmVUb1Jlc3VsdCB9IGZyb20gJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnO1xuXG4vKipcbiAqIEVtaXRzIHRoZSBtb3N0IHJlY2VudGx5IGVtaXR0ZWQgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgd2hlbmV2ZXJcbiAqIGFub3RoZXIgT2JzZXJ2YWJsZSwgdGhlIGBub3RpZmllcmAsIGVtaXRzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIHNhbXBsZVRpbWV9LCBidXQgc2FtcGxlcyB3aGVuZXZlclxuICogdGhlIGBub3RpZmllcmAgT2JzZXJ2YWJsZSBlbWl0cyBzb21ldGhpbmcuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvc2FtcGxlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFdoZW5ldmVyIHRoZSBgbm90aWZpZXJgIE9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZSBvciBjb21wbGV0ZXMsIGBzYW1wbGVgXG4gKiBsb29rcyBhdCB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIGVtaXRzIHdoaWNoZXZlciB2YWx1ZSBpdCBoYXMgbW9zdCByZWNlbnRseVxuICogZW1pdHRlZCBzaW5jZSB0aGUgcHJldmlvdXMgc2FtcGxpbmcsIHVubGVzcyB0aGUgc291cmNlIGhhcyBub3QgZW1pdHRlZFxuICogYW55dGhpbmcgc2luY2UgdGhlIHByZXZpb3VzIHNhbXBsaW5nLiBUaGUgYG5vdGlmaWVyYCBpcyBzdWJzY3JpYmVkIHRvIGFzIHNvb25cbiAqIGFzIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBpcyBzdWJzY3JpYmVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPk9uIGV2ZXJ5IGNsaWNrLCBzYW1wbGUgdGhlIG1vc3QgcmVjZW50IFwic2Vjb25kc1wiIHRpbWVyPC9jYXB0aW9uPlxuICogdmFyIHNlY29uZHMgPSBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApO1xuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBzZWNvbmRzLnNhbXBsZShjbGlja3MpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdH1cbiAqIEBzZWUge0BsaW5rIGRlYm91bmNlfVxuICogQHNlZSB7QGxpbmsgc2FtcGxlVGltZX1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZTxhbnk+fSBub3RpZmllciBUaGUgT2JzZXJ2YWJsZSB0byB1c2UgZm9yIHNhbXBsaW5nIHRoZVxuICogc291cmNlIE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdHMgb2Ygc2FtcGxpbmcgdGhlXG4gKiB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgd2hlbmV2ZXIgdGhlIG5vdGlmaWVyIE9ic2VydmFibGVcbiAqIGVtaXRzIHZhbHVlIG9yIGNvbXBsZXRlcy5cbiAqIEBtZXRob2Qgc2FtcGxlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FtcGxlPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIG5vdGlmaWVyOiBPYnNlcnZhYmxlPGFueT4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgU2FtcGxlT3BlcmF0b3Iobm90aWZpZXIpKTtcbn1cblxuY2xhc3MgU2FtcGxlT3BlcmF0b3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbm90aWZpZXI6IE9ic2VydmFibGU8YW55Pikge1xuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+LCBzb3VyY2U6IGFueSk6IFRlYXJkb3duTG9naWMge1xuICAgIGNvbnN0IHNhbXBsZVN1YnNjcmliZXIgPSBuZXcgU2FtcGxlU3Vic2NyaWJlcihzdWJzY3JpYmVyKTtcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKHNhbXBsZVN1YnNjcmliZXIpO1xuICAgIHN1YnNjcmlwdGlvbi5hZGQoc3Vic2NyaWJlVG9SZXN1bHQoc2FtcGxlU3Vic2NyaWJlciwgdGhpcy5ub3RpZmllcikpO1xuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIFNhbXBsZVN1YnNjcmliZXI8VCwgUj4gZXh0ZW5kcyBPdXRlclN1YnNjcmliZXI8VCwgUj4ge1xuICBwcml2YXRlIHZhbHVlOiBUO1xuICBwcml2YXRlIGhhc1ZhbHVlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHZhbHVlOiBUKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICB9XG5cbiAgbm90aWZ5TmV4dChvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBSLFxuICAgICAgICAgICAgIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgIGlubmVyU3ViOiBJbm5lclN1YnNjcmliZXI8VCwgUj4pOiB2b2lkIHtcbiAgICB0aGlzLmVtaXRWYWx1ZSgpO1xuICB9XG5cbiAgbm90aWZ5Q29tcGxldGUoKTogdm9pZCB7XG4gICAgdGhpcy5lbWl0VmFsdWUoKTtcbiAgfVxuXG4gIGVtaXRWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5oYXNWYWx1ZSkge1xuICAgICAgdGhpcy5oYXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHRoaXMudmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9zYW1wbGUudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IElTY2hlZHVsZXIgfSBmcm9tICcuLi9TY2hlZHVsZXInO1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi4vc2NoZWR1bGVyL0FjdGlvbic7XG5pbXBvcnQgeyBhc3luYyB9IGZyb20gJy4uL3NjaGVkdWxlci9hc3luYyc7XG5pbXBvcnQgeyBUZWFyZG93bkxvZ2ljIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcblxuLyoqXG4gKiBFbWl0cyB0aGUgbW9zdCByZWNlbnRseSBlbWl0dGVkIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGhpblxuICogcGVyaW9kaWMgdGltZSBpbnRlcnZhbHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlNhbXBsZXMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGF0IHBlcmlvZGljIHRpbWVcbiAqIGludGVydmFscywgZW1pdHRpbmcgd2hhdCBpdCBzYW1wbGVzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3NhbXBsZVRpbWUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHNhbXBsZVRpbWVgIHBlcmlvZGljYWxseSBsb29rcyBhdCB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIGVtaXRzIHdoaWNoZXZlclxuICogdmFsdWUgaXQgaGFzIG1vc3QgcmVjZW50bHkgZW1pdHRlZCBzaW5jZSB0aGUgcHJldmlvdXMgc2FtcGxpbmcsIHVubGVzcyB0aGVcbiAqIHNvdXJjZSBoYXMgbm90IGVtaXR0ZWQgYW55dGhpbmcgc2luY2UgdGhlIHByZXZpb3VzIHNhbXBsaW5nLiBUaGUgc2FtcGxpbmdcbiAqIGhhcHBlbnMgcGVyaW9kaWNhbGx5IGluIHRpbWUgZXZlcnkgYHBlcmlvZGAgbWlsbGlzZWNvbmRzIChvciB0aGUgdGltZSB1bml0XG4gKiBkZWZpbmVkIGJ5IHRoZSBvcHRpb25hbCBgc2NoZWR1bGVyYCBhcmd1bWVudCkuIFRoZSBzYW1wbGluZyBzdGFydHMgYXMgc29vbiBhc1xuICogdGhlIG91dHB1dCBPYnNlcnZhYmxlIGlzIHN1YnNjcmliZWQuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RXZlcnkgc2Vjb25kLCBlbWl0IHRoZSBtb3N0IHJlY2VudCBjbGljayBhdCBtb3N0IG9uY2U8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy5zYW1wbGVUaW1lKDEwMDApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdFRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZVRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWxheX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZX1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlVGltZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gcGVyaW9kIFRoZSBzYW1wbGluZyBwZXJpb2QgZXhwcmVzc2VkIGluIG1pbGxpc2Vjb25kcyBvciB0aGVcbiAqIHRpbWUgdW5pdCBkZXRlcm1pbmVkIGludGVybmFsbHkgYnkgdGhlIG9wdGlvbmFsIGBzY2hlZHVsZXJgLlxuICogQHBhcmFtIHtTY2hlZHVsZXJ9IFtzY2hlZHVsZXI9YXN5bmNdIFRoZSB7QGxpbmsgSVNjaGVkdWxlcn0gdG8gdXNlIGZvclxuICogbWFuYWdpbmcgdGhlIHRpbWVycyB0aGF0IGhhbmRsZSB0aGUgc2FtcGxpbmcuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdHMgb2Ygc2FtcGxpbmcgdGhlXG4gKiB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYXQgdGhlIHNwZWNpZmllZCB0aW1lIGludGVydmFsLlxuICogQG1ldGhvZCBzYW1wbGVUaW1lXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2FtcGxlVGltZTxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBwZXJpb2Q6IG51bWJlciwgc2NoZWR1bGVyOiBJU2NoZWR1bGVyID0gYXN5bmMpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgU2FtcGxlVGltZU9wZXJhdG9yKHBlcmlvZCwgc2NoZWR1bGVyKSk7XG59XG5cbmNsYXNzIFNhbXBsZVRpbWVPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwZXJpb2Q6IG51bWJlcixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBzY2hlZHVsZXI6IElTY2hlZHVsZXIpIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPiwgc291cmNlOiBhbnkpOiBUZWFyZG93bkxvZ2ljIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU2FtcGxlVGltZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wZXJpb2QsIHRoaXMuc2NoZWR1bGVyKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIFNhbXBsZVRpbWVTdWJzY3JpYmVyPFQ+IGV4dGVuZHMgU3Vic2NyaWJlcjxUPiB7XG4gIGxhc3RWYWx1ZTogVDtcbiAgaGFzVmFsdWU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxUPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBwZXJpb2Q6IG51bWJlcixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBzY2hlZHVsZXI6IElTY2hlZHVsZXIpIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gICAgdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoTm90aWZpY2F0aW9uLCBwZXJpb2QsIHsgc3Vic2NyaWJlcjogdGhpcywgcGVyaW9kIH0pKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCkge1xuICAgIHRoaXMubGFzdFZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5oYXNWYWx1ZSA9IHRydWU7XG4gIH1cblxuICBub3RpZnlOZXh0KCkge1xuICAgIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICB0aGlzLmhhc1ZhbHVlID0gZmFsc2U7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodGhpcy5sYXN0VmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaE5vdGlmaWNhdGlvbjxUPih0aGlzOiBBY3Rpb248YW55Piwgc3RhdGU6IGFueSkge1xuICBsZXQgeyBzdWJzY3JpYmVyLCBwZXJpb2QgfSA9IHN0YXRlO1xuICBzdWJzY3JpYmVyLm5vdGlmeU5leHQoKTtcbiAgdGhpcy5zY2hlZHVsZShzdGF0ZSwgcGVyaW9kKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3Ivc2FtcGxlVGltZS50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmV4cG9ydCBmdW5jdGlvbiBzY2FuPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIGFjY3VtdWxhdG9yOiAoYWNjOiBULCB2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gVCwgc2VlZD86IFQpOiBPYnNlcnZhYmxlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIHNjYW48VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgYWNjdW11bGF0b3I6IChhY2M6IFRbXSwgdmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IFRbXSwgc2VlZD86IFRbXSk6IE9ic2VydmFibGU8VFtdPjtcbmV4cG9ydCBmdW5jdGlvbiBzY2FuPFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIGFjY3VtdWxhdG9yOiAoYWNjOiBSLCB2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gUiwgc2VlZD86IFIpOiBPYnNlcnZhYmxlPFI+O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cblxuLyoqXG4gKiBBcHBsaWVzIGFuIGFjY3VtdWxhdG9yIGZ1bmN0aW9uIG92ZXIgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCBhbmQgcmV0dXJucyBlYWNoXG4gKiBpbnRlcm1lZGlhdGUgcmVzdWx0LCB3aXRoIGFuIG9wdGlvbmFsIHNlZWQgdmFsdWUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgcmVkdWNlfSwgYnV0IGVtaXRzIHRoZSBjdXJyZW50XG4gKiBhY2N1bXVsYXRpb24gd2hlbmV2ZXIgdGhlIHNvdXJjZSBlbWl0cyBhIHZhbHVlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3NjYW4ucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQ29tYmluZXMgdG9nZXRoZXIgYWxsIHZhbHVlcyBlbWl0dGVkIG9uIHRoZSBzb3VyY2UsIHVzaW5nIGFuIGFjY3VtdWxhdG9yXG4gKiBmdW5jdGlvbiB0aGF0IGtub3dzIGhvdyB0byBqb2luIGEgbmV3IHNvdXJjZSB2YWx1ZSBpbnRvIHRoZSBhY2N1bXVsYXRpb24gZnJvbVxuICogdGhlIHBhc3QuIElzIHNpbWlsYXIgdG8ge0BsaW5rIHJlZHVjZX0sIGJ1dCBlbWl0cyB0aGUgaW50ZXJtZWRpYXRlXG4gKiBhY2N1bXVsYXRpb25zLlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGFwcGxpZXMgYSBzcGVjaWZpZWQgYGFjY3VtdWxhdG9yYCBmdW5jdGlvbiB0byBlYWNoXG4gKiBpdGVtIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJZiBhIGBzZWVkYCB2YWx1ZSBpcyBzcGVjaWZpZWQsIHRoZW5cbiAqIHRoYXQgdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbml0aWFsIHZhbHVlIGZvciB0aGUgYWNjdW11bGF0b3IuIElmIG5vIHNlZWRcbiAqIHZhbHVlIGlzIHNwZWNpZmllZCwgdGhlIGZpcnN0IGl0ZW0gb2YgdGhlIHNvdXJjZSBpcyB1c2VkIGFzIHRoZSBzZWVkLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkNvdW50IHRoZSBudW1iZXIgb2YgY2xpY2sgZXZlbnRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciBvbmVzID0gY2xpY2tzLm1hcFRvKDEpO1xuICogdmFyIHNlZWQgPSAwO1xuICogdmFyIGNvdW50ID0gb25lcy5zY2FuKChhY2MsIG9uZSkgPT4gYWNjICsgb25lLCBzZWVkKTtcbiAqIGNvdW50LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBleHBhbmR9XG4gKiBAc2VlIHtAbGluayBtZXJnZVNjYW59XG4gKiBAc2VlIHtAbGluayByZWR1Y2V9XG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihhY2M6IFIsIHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogUn0gYWNjdW11bGF0b3JcbiAqIFRoZSBhY2N1bXVsYXRvciBmdW5jdGlvbiBjYWxsZWQgb24gZWFjaCBzb3VyY2UgdmFsdWUuXG4gKiBAcGFyYW0ge1R8Un0gW3NlZWRdIFRoZSBpbml0aWFsIGFjY3VtdWxhdGlvbiB2YWx1ZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj59IEFuIG9ic2VydmFibGUgb2YgdGhlIGFjY3VtdWxhdGVkIHZhbHVlcy5cbiAqIEBtZXRob2Qgc2NhblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNjYW48VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgYWNjdW11bGF0b3I6IChhY2M6IFIsIHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBSLCBzZWVkPzogVCB8IFIpOiBPYnNlcnZhYmxlPFI+IHtcbiAgbGV0IGhhc1NlZWQgPSBmYWxzZTtcbiAgLy8gcHJvdmlkaW5nIGEgc2VlZCBvZiBgdW5kZWZpbmVkYCAqc2hvdWxkKiBiZSB2YWxpZCBhbmQgdHJpZ2dlclxuICAvLyBoYXNTZWVkISBzbyBkb24ndCB1c2UgYHNlZWQgIT09IHVuZGVmaW5lZGAgY2hlY2tzIVxuICAvLyBGb3IgdGhpcyByZWFzb24sIHdlIGhhdmUgdG8gY2hlY2sgaXQgaGVyZSBhdCB0aGUgb3JpZ2luYWwgY2FsbCBzaXRlXG4gIC8vIG90aGVyd2lzZSBpbnNpZGUgT3BlcmF0b3IvU3Vic2NyaWJlciB3ZSB3b24ndCBrbm93IGlmIGB1bmRlZmluZWRgXG4gIC8vIG1lYW5zIHRoZXkgZGlkbid0IHByb3ZpZGUgYW55dGhpbmcgb3IgaWYgdGhleSBsaXRlcmFsbHkgcHJvdmlkZWQgYHVuZGVmaW5lZGBcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMikge1xuICAgIGhhc1NlZWQgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgU2Nhbk9wZXJhdG9yKGFjY3VtdWxhdG9yLCBzZWVkLCBoYXNTZWVkKSk7XG59XG5cbmNsYXNzIFNjYW5PcGVyYXRvcjxULCBSPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFI+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBhY2N1bXVsYXRvcjogKGFjYzogUiwgdmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IFIsIHByaXZhdGUgc2VlZD86IFQgfCBSLCBwcml2YXRlIGhhc1NlZWQ6IGJvb2xlYW4gPSBmYWxzZSkge31cblxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8Uj4sIHNvdXJjZTogYW55KTogYW55IHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU2NhblN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5hY2N1bXVsYXRvciwgdGhpcy5zZWVkLCB0aGlzLmhhc1NlZWQpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgU2NhblN1YnNjcmliZXI8VCwgUj4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgcHJpdmF0ZSBpbmRleDogbnVtYmVyID0gMDtcblxuICBnZXQgc2VlZCgpOiBUIHwgUiB7XG4gICAgcmV0dXJuIHRoaXMuX3NlZWQ7XG4gIH1cblxuICBzZXQgc2VlZCh2YWx1ZTogVCB8IFIpIHtcbiAgICB0aGlzLmhhc1NlZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NlZWQgPSB2YWx1ZTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFI+LCBwcml2YXRlIGFjY3VtdWxhdG9yOiAoYWNjOiBSLCB2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gUiwgcHJpdmF0ZSBfc2VlZDogVCB8IFIsXG4gICAgICAgICAgICAgIHByaXZhdGUgaGFzU2VlZDogYm9vbGVhbikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5oYXNTZWVkKSB7XG4gICAgICB0aGlzLnNlZWQgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl90cnlOZXh0KHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF90cnlOZXh0KHZhbHVlOiBUKTogdm9pZCB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmluZGV4Kys7XG4gICAgbGV0IHJlc3VsdDogYW55O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSB0aGlzLmFjY3VtdWxhdG9yKDxSPnRoaXMuc2VlZCwgdmFsdWUsIGluZGV4KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICB9XG4gICAgdGhpcy5zZWVkID0gcmVzdWx0O1xuICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL3NjYW4udHMiLCJpbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IE9ic2VydmVyIH0gZnJvbSAnLi4vT2JzZXJ2ZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgdHJ5Q2F0Y2ggfSBmcm9tICcuLi91dGlsL3RyeUNhdGNoJztcbmltcG9ydCB7IGVycm9yT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9lcnJvck9iamVjdCc7XG5cbi8qKlxuICogQ29tcGFyZXMgYWxsIHZhbHVlcyBvZiB0d28gb2JzZXJ2YWJsZXMgaW4gc2VxdWVuY2UgdXNpbmcgYW4gb3B0aW9uYWwgY29tcGFyb3IgZnVuY3Rpb25cbiAqIGFuZCByZXR1cm5zIGFuIG9ic2VydmFibGUgb2YgYSBzaW5nbGUgYm9vbGVhbiB2YWx1ZSByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhlIHR3byBzZXF1ZW5jZXNcbiAqIGFyZSBlcXVhbC5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+Q2hlY2tzIHRvIHNlZSBvZiBhbGwgdmFsdWVzIGVtaXR0ZWQgYnkgYm90aCBvYnNlcnZhYmxlcyBhcmUgZXF1YWwsIGluIG9yZGVyLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3NlcXVlbmNlRXF1YWwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHNlcXVlbmNlRXF1YWxgIHN1YnNjcmliZXMgdG8gdHdvIG9ic2VydmFibGVzIGFuZCBidWZmZXJzIGluY29taW5nIHZhbHVlcyBmcm9tIGVhY2ggb2JzZXJ2YWJsZS4gV2hlbmV2ZXIgZWl0aGVyXG4gKiBvYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUsIHRoZSB2YWx1ZSBpcyBidWZmZXJlZCBhbmQgdGhlIGJ1ZmZlcnMgYXJlIHNoaWZ0ZWQgYW5kIGNvbXBhcmVkIGZyb20gdGhlIGJvdHRvbVxuICogdXA7IElmIGFueSB2YWx1ZSBwYWlyIGRvZXNuJ3QgbWF0Y2gsIHRoZSByZXR1cm5lZCBvYnNlcnZhYmxlIHdpbGwgZW1pdCBgZmFsc2VgIGFuZCBjb21wbGV0ZS4gSWYgb25lIG9mIHRoZVxuICogb2JzZXJ2YWJsZXMgY29tcGxldGVzLCB0aGUgb3BlcmF0b3Igd2lsbCB3YWl0IGZvciB0aGUgb3RoZXIgb2JzZXJ2YWJsZSB0byBjb21wbGV0ZTsgSWYgdGhlIG90aGVyXG4gKiBvYnNlcnZhYmxlIGVtaXRzIGJlZm9yZSBjb21wbGV0aW5nLCB0aGUgcmV0dXJuZWQgb2JzZXJ2YWJsZSB3aWxsIGVtaXQgYGZhbHNlYCBhbmQgY29tcGxldGUuIElmIG9uZSBvYnNlcnZhYmxlIG5ldmVyXG4gKiBjb21wbGV0ZXMgb3IgZW1pdHMgYWZ0ZXIgdGhlIG90aGVyIGNvbXBsZXRzLCB0aGUgcmV0dXJuZWQgb2JzZXJ2YWJsZSB3aWxsIG5ldmVyIGNvbXBsZXRlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPmZpZ3VyZSBvdXQgaWYgdGhlIEtvbmFtaSBjb2RlIG1hdGNoZXM8L2NhcHRpb24+XG4gKiB2YXIgY29kZSA9IFJ4Lk9ic2VydmFibGUuZnJvbShbXG4gKiAgXCJBcnJvd1VwXCIsXG4gKiAgXCJBcnJvd1VwXCIsXG4gKiAgXCJBcnJvd0Rvd25cIixcbiAqICBcIkFycm93RG93blwiLFxuICogIFwiQXJyb3dMZWZ0XCIsXG4gKiAgXCJBcnJvd1JpZ2h0XCIsXG4gKiAgXCJBcnJvd0xlZnRcIixcbiAqICBcIkFycm93UmlnaHRcIixcbiAqICBcIktleUJcIixcbiAqICBcIktleUFcIixcbiAqICBcIkVudGVyXCIgLy8gbm8gc3RhcnQga2V5LCBjbGVhcmx5LlxuICogXSk7XG4gKlxuICogdmFyIGtleXMgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2tleXVwJylcbiAqICAubWFwKGUgPT4gZS5jb2RlKTtcbiAqIHZhciBtYXRjaGVzID0ga2V5cy5idWZmZXJDb3VudCgxMSwgMSlcbiAqICAubWVyZ2VNYXAoXG4gKiAgICBsYXN0MTEgPT5cbiAqICAgICAgUnguT2JzZXJ2YWJsZS5mcm9tKGxhc3QxMSlcbiAqICAgICAgICAuc2VxdWVuY2VFcXVhbChjb2RlKVxuICogICApO1xuICogbWF0Y2hlcy5zdWJzY3JpYmUobWF0Y2hlZCA9PiBjb25zb2xlLmxvZygnU3VjY2Vzc2Z1bCBjaGVhdCBhdCBDb250cmE/ICcsIG1hdGNoZWQpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb21iaW5lTGF0ZXN0fVxuICogQHNlZSB7QGxpbmsgemlwfVxuICogQHNlZSB7QGxpbmsgd2l0aExhdGVzdEZyb219XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBjb21wYXJlVG8gVGhlIG9ic2VydmFibGUgc2VxdWVuY2UgdG8gY29tcGFyZSB0aGUgc291cmNlIHNlcXVlbmNlIHRvLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2NvbXBhcm9yXSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byBjb21wYXJlIGVhY2ggdmFsdWUgcGFpclxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiBhIHNpbmdsZSBib29sZWFuIHZhbHVlIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdFxuICogdGhlIHZhbHVlcyBlbWl0dGVkIGJ5IGJvdGggb2JzZXJ2YWJsZXMgd2VyZSBlcXVhbCBpbiBzZXF1ZW5jZS5cbiAqIEBtZXRob2Qgc2VxdWVuY2VFcXVhbFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcXVlbmNlRXF1YWw8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgY29tcGFyZVRvOiBPYnNlcnZhYmxlPFQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGFyb3I/OiAoYTogVCwgYjogVCkgPT4gYm9vbGVhbik6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBTZXF1ZW5jZUVxdWFsT3BlcmF0b3IoY29tcGFyZVRvLCBjb21wYXJvcikpO1xufVxuXG5leHBvcnQgY2xhc3MgU2VxdWVuY2VFcXVhbE9wZXJhdG9yPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgYm9vbGVhbj4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbXBhcmVUbzogT2JzZXJ2YWJsZTxUPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBjb21wYXJvcjogKGE6IFQsIGI6IFQpID0+IGJvb2xlYW4pIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxib29sZWFuPiwgc291cmNlOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTZXF1ZW5jZUVxdWFsU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmNvbXBhcmVUbywgdGhpcy5jb21wYXJvcikpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5leHBvcnQgY2xhc3MgU2VxdWVuY2VFcXVhbFN1YnNjcmliZXI8VCwgUj4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgcHJpdmF0ZSBfYTogVFtdID0gW107XG4gIHByaXZhdGUgX2I6IFRbXSA9IFtdO1xuICBwcml2YXRlIF9vbmVDb21wbGV0ZSA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBPYnNlcnZlcjxSPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBjb21wYXJlVG86IE9ic2VydmFibGU8VD4sXG4gICAgICAgICAgICAgIHByaXZhdGUgY29tcGFyb3I6IChhOiBULCBiOiBUKSA9PiBib29sZWFuKSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICAgIHRoaXMuYWRkKGNvbXBhcmVUby5zdWJzY3JpYmUobmV3IFNlcXVlbmNlRXF1YWxDb21wYXJlVG9TdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCB0aGlzKSkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHZhbHVlOiBUKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX29uZUNvbXBsZXRlICYmIHRoaXMuX2IubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmVtaXQoZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hLnB1c2godmFsdWUpO1xuICAgICAgdGhpcy5jaGVja1ZhbHVlcygpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBfY29tcGxldGUoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX29uZUNvbXBsZXRlKSB7XG4gICAgICB0aGlzLmVtaXQodGhpcy5fYS5sZW5ndGggPT09IDAgJiYgdGhpcy5fYi5sZW5ndGggPT09IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9vbmVDb21wbGV0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgY2hlY2tWYWx1ZXMoKSB7XG4gICAgY29uc3QgeyBfYSwgX2IsIGNvbXBhcm9yIH0gPSB0aGlzO1xuICAgIHdoaWxlIChfYS5sZW5ndGggPiAwICYmIF9iLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBhID0gX2Euc2hpZnQoKTtcbiAgICAgIGxldCBiID0gX2Iuc2hpZnQoKTtcbiAgICAgIGxldCBhcmVFcXVhbCA9IGZhbHNlO1xuICAgICAgaWYgKGNvbXBhcm9yKSB7XG4gICAgICAgIGFyZUVxdWFsID0gdHJ5Q2F0Y2goY29tcGFyb3IpKGEsIGIpO1xuICAgICAgICBpZiAoYXJlRXF1YWwgPT09IGVycm9yT2JqZWN0KSB7XG4gICAgICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvck9iamVjdC5lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJlRXF1YWwgPSBhID09PSBiO1xuICAgICAgfVxuICAgICAgaWYgKCFhcmVFcXVhbCkge1xuICAgICAgICB0aGlzLmVtaXQoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVtaXQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICBjb25zdCB7IGRlc3RpbmF0aW9uIH0gPSB0aGlzO1xuICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gIH1cblxuICBuZXh0Qih2YWx1ZTogVCkge1xuICAgIGlmICh0aGlzLl9vbmVDb21wbGV0ZSAmJiB0aGlzLl9hLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5lbWl0KGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYi5wdXNoKHZhbHVlKTtcbiAgICAgIHRoaXMuY2hlY2tWYWx1ZXMoKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgU2VxdWVuY2VFcXVhbENvbXBhcmVUb1N1YnNjcmliZXI8VCwgUj4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IE9ic2VydmVyPFI+LCBwcml2YXRlIHBhcmVudDogU2VxdWVuY2VFcXVhbFN1YnNjcmliZXI8VCwgUj4pIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpOiB2b2lkIHtcbiAgICB0aGlzLnBhcmVudC5uZXh0Qih2YWx1ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2Vycm9yKGVycjogYW55KTogdm9pZCB7XG4gICAgdGhpcy5wYXJlbnQuZXJyb3IoZXJyKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKTogdm9pZCB7XG4gICAgdGhpcy5wYXJlbnQuX2NvbXBsZXRlKCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3Ivc2VxdWVuY2VFcXVhbC50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IG11bHRpY2FzdCB9IGZyb20gJy4vbXVsdGljYXN0JztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICcuLi9TdWJqZWN0JztcblxuZnVuY3Rpb24gc2hhcmVTdWJqZWN0RmFjdG9yeSgpIHtcbiAgcmV0dXJuIG5ldyBTdWJqZWN0KCk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBPYnNlcnZhYmxlIHRoYXQgbXVsdGljYXN0cyAoc2hhcmVzKSB0aGUgb3JpZ2luYWwgT2JzZXJ2YWJsZS4gQXMgbG9uZyBhcyB0aGVyZSBpcyBhdCBsZWFzdCBvbmVcbiAqIFN1YnNjcmliZXIgdGhpcyBPYnNlcnZhYmxlIHdpbGwgYmUgc3Vic2NyaWJlZCBhbmQgZW1pdHRpbmcgZGF0YS4gV2hlbiBhbGwgc3Vic2NyaWJlcnMgaGF2ZSB1bnN1YnNjcmliZWQgaXQgd2lsbFxuICogdW5zdWJzY3JpYmUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUuIEJlY2F1c2UgdGhlIE9ic2VydmFibGUgaXMgbXVsdGljYXN0aW5nIGl0IG1ha2VzIHRoZSBzdHJlYW0gYGhvdGAuXG4gKiBUaGlzIGlzIGFuIGFsaWFzIGZvciAucHVibGlzaCgpLnJlZkNvdW50KCkuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zaGFyZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgdXBvbiBjb25uZWN0aW9uIGNhdXNlcyB0aGUgc291cmNlIE9ic2VydmFibGUgdG8gZW1pdCBpdGVtcyB0byBpdHMgT2JzZXJ2ZXJzLlxuICogQG1ldGhvZCBzaGFyZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYXJlPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIG11bHRpY2FzdC5jYWxsKHRoaXMsIHNoYXJlU3ViamVjdEZhY3RvcnkpLnJlZkNvdW50KCk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9zaGFyZS50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgT2JzZXJ2ZXIgfSBmcm9tICcuLi9PYnNlcnZlcic7XG5pbXBvcnQgeyBFbXB0eUVycm9yIH0gZnJvbSAnLi4vdXRpbC9FbXB0eUVycm9yJztcbmltcG9ydCB7IFRlYXJkb3duTG9naWMgfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBzaW5nbGUgaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB0aGF0IG1hdGNoZXMgYSBzcGVjaWZpZWRcbiAqIHByZWRpY2F0ZSwgaWYgdGhhdCBPYnNlcnZhYmxlIGVtaXRzIG9uZSBzdWNoIGl0ZW0uIElmIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBlbWl0cyBtb3JlIHRoYW4gb25lIHN1Y2ggaXRlbSBvciBub1xuICogc3VjaCBpdGVtcywgbm90aWZ5IG9mIGFuIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiBvciBOb1N1Y2hFbGVtZW50RXhjZXB0aW9uIHJlc3BlY3RpdmVseS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3NpbmdsZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAdGhyb3dzIHtFbXB0eUVycm9yfSBEZWxpdmVycyBhbiBFbXB0eUVycm9yIHRvIHRoZSBPYnNlcnZlcidzIGBlcnJvcmBcbiAqIGNhbGxiYWNrIGlmIHRoZSBPYnNlcnZhYmxlIGNvbXBsZXRlcyBiZWZvcmUgYW55IGBuZXh0YCBub3RpZmljYXRpb24gd2FzIHNlbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgLSBBIHByZWRpY2F0ZSBmdW5jdGlvbiB0byBldmFsdWF0ZSBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgc2luZ2xlIGl0ZW0gZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgdGhhdCBtYXRjaGVzXG4gKiB0aGUgcHJlZGljYXRlLlxuIC5cbiAqIEBtZXRob2Qgc2luZ2xlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2luZ2xlPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIHByZWRpY2F0ZT86ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlciwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KSA9PiBib29sZWFuKTogT2JzZXJ2YWJsZTxUPiB7XG4gIHJldHVybiB0aGlzLmxpZnQobmV3IFNpbmdsZU9wZXJhdG9yKHByZWRpY2F0ZSwgdGhpcykpO1xufVxuXG5jbGFzcyBTaW5nbGVPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBwcmVkaWNhdGU/OiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIsIHNvdXJjZTogT2JzZXJ2YWJsZTxUPikgPT4gYm9vbGVhbixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBzb3VyY2U/OiBPYnNlcnZhYmxlPFQ+KSB7XG4gIH1cblxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4sIHNvdXJjZTogYW55KTogVGVhcmRvd25Mb2dpYyB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNpbmdsZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcmVkaWNhdGUsIHRoaXMuc291cmNlKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIFNpbmdsZVN1YnNjcmliZXI8VD4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgcHJpdmF0ZSBzZWVuVmFsdWU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBzaW5nbGVWYWx1ZTogVDtcbiAgcHJpdmF0ZSBpbmRleDogbnVtYmVyID0gMDtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogT2JzZXJ2ZXI8VD4sXG4gICAgICAgICAgICAgIHByaXZhdGUgcHJlZGljYXRlPzogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyLCBzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IGJvb2xlYW4sXG4gICAgICAgICAgICAgIHByaXZhdGUgc291cmNlPzogT2JzZXJ2YWJsZTxUPikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgYXBwbHlTaW5nbGVWYWx1ZSh2YWx1ZTogVCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnNlZW5WYWx1ZSkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcignU2VxdWVuY2UgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBlbGVtZW50Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VlblZhbHVlID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2luZ2xlVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpOiB2b2lkIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXgrKztcblxuICAgIGlmICh0aGlzLnByZWRpY2F0ZSkge1xuICAgICAgdGhpcy50cnlOZXh0KHZhbHVlLCBpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXBwbHlTaW5nbGVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cnlOZXh0KHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLnByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIHRoaXMuc291cmNlKSkge1xuICAgICAgICB0aGlzLmFwcGx5U2luZ2xlVmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKTogdm9pZCB7XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuXG4gICAgaWYgKHRoaXMuaW5kZXggPiAwKSB7XG4gICAgICBkZXN0aW5hdGlvbi5uZXh0KHRoaXMuc2VlblZhbHVlID8gdGhpcy5zaW5nbGVWYWx1ZSA6IHVuZGVmaW5lZCk7XG4gICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXN0aW5hdGlvbi5lcnJvcihuZXcgRW1wdHlFcnJvcik7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL3NpbmdsZS50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5cbi8qKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgc2tpcHMgdGhlIGZpcnN0IGBjb3VudGAgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9za2lwLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCAtIFRoZSBudW1iZXIgb2YgdGltZXMsIGl0ZW1zIGVtaXR0ZWQgYnkgc291cmNlIE9ic2VydmFibGUgc2hvdWxkIGJlIHNraXBwZWQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgc2tpcHMgdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICpcbiAqIEBtZXRob2Qgc2tpcFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNraXA8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgY291bnQ6IG51bWJlcik6IE9ic2VydmFibGU8VD4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBTa2lwT3BlcmF0b3IoY291bnQpKTtcbn1cblxuY2xhc3MgU2tpcE9wZXJhdG9yPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRvdGFsOiBudW1iZXIpIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPiwgc291cmNlOiBhbnkpOiBUZWFyZG93bkxvZ2ljIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU2tpcFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy50b3RhbCkpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBTa2lwU3Vic2NyaWJlcjxUPiBleHRlbmRzIFN1YnNjcmliZXI8VD4ge1xuICBjb3VudDogbnVtYmVyID0gMDtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxUPiwgcHJpdmF0ZSB0b3RhbDogbnVtYmVyKSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHg6IFQpIHtcbiAgICBpZiAoKyt0aGlzLmNvdW50ID4gdGhpcy50b3RhbCkge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHgpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci9za2lwLnRzIiwiaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBUZWFyZG93bkxvZ2ljIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE91dGVyU3Vic2NyaWJlciB9IGZyb20gJy4uL091dGVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBJbm5lclN1YnNjcmliZXIgfSBmcm9tICcuLi9Jbm5lclN1YnNjcmliZXInO1xuaW1wb3J0IHsgc3Vic2NyaWJlVG9SZXN1bHQgfSBmcm9tICcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0JztcblxuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBza2lwcyBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB1bnRpbCBhIHNlY29uZCBPYnNlcnZhYmxlIGVtaXRzIGFuIGl0ZW0uXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9za2lwVW50aWwucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlfSBub3RpZmllciAtIFRoZSBzZWNvbmQgT2JzZXJ2YWJsZSB0aGF0IGhhcyB0byBlbWl0IGFuIGl0ZW0gYmVmb3JlIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSdzIGVsZW1lbnRzIGJlZ2luIHRvXG4gKiBiZSBtaXJyb3JlZCBieSB0aGUgcmVzdWx0aW5nIE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgc2tpcHMgaXRlbXMgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUgdW50aWwgdGhlIHNlY29uZCBPYnNlcnZhYmxlIGVtaXRzXG4gKiBhbiBpdGVtLCB0aGVuIGVtaXRzIHRoZSByZW1haW5pbmcgaXRlbXMuXG4gKiBAbWV0aG9kIHNraXBVbnRpbFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNraXBVbnRpbDxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBub3RpZmllcjogT2JzZXJ2YWJsZTxhbnk+KTogT2JzZXJ2YWJsZTxUPiB7XG4gIHJldHVybiB0aGlzLmxpZnQobmV3IFNraXBVbnRpbE9wZXJhdG9yKG5vdGlmaWVyKSk7XG59XG5cbmNsYXNzIFNraXBVbnRpbE9wZXJhdG9yPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIG5vdGlmaWVyOiBPYnNlcnZhYmxlPGFueT4pIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPiwgc291cmNlOiBhbnkpOiBUZWFyZG93bkxvZ2ljIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgU2tpcFVudGlsU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm5vdGlmaWVyKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIFNraXBVbnRpbFN1YnNjcmliZXI8VCwgUj4gZXh0ZW5kcyBPdXRlclN1YnNjcmliZXI8VCwgUj4ge1xuXG4gIHByaXZhdGUgaGFzVmFsdWU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBpc0lubmVyU3RvcHBlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPGFueT4sXG4gICAgICAgICAgICAgIG5vdGlmaWVyOiBPYnNlcnZhYmxlPGFueT4pIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gICAgdGhpcy5hZGQoc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgbm90aWZpZXIpKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCkge1xuICAgIGlmICh0aGlzLmhhc1ZhbHVlKSB7XG4gICAgICBzdXBlci5fbmV4dCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9jb21wbGV0ZSgpIHtcbiAgICBpZiAodGhpcy5pc0lubmVyU3RvcHBlZCkge1xuICAgICAgc3VwZXIuX2NvbXBsZXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICBub3RpZnlOZXh0KG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IFIsXG4gICAgICAgICAgICAgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICAgaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBSPik6IHZvaWQge1xuICAgIHRoaXMuaGFzVmFsdWUgPSB0cnVlO1xuICB9XG5cbiAgbm90aWZ5Q29tcGxldGUoKTogdm9pZCB7XG4gICAgdGhpcy5pc0lubmVyU3RvcHBlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICBzdXBlci5fY29tcGxldGUoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3Ivc2tpcFVudGlsLnRzIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBUZWFyZG93bkxvZ2ljIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcblxuLyoqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBza2lwcyBhbGwgaXRlbXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYXMgbG9uZyBhcyBhIHNwZWNpZmllZCBjb25kaXRpb24gaG9sZHNcbiAqIHRydWUsIGJ1dCBlbWl0cyBhbGwgZnVydGhlciBzb3VyY2UgaXRlbXMgYXMgc29vbiBhcyB0aGUgY29uZGl0aW9uIGJlY29tZXMgZmFsc2UuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9za2lwV2hpbGUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIC0gQSBmdW5jdGlvbiB0byB0ZXN0IGVhY2ggaXRlbSBlbWl0dGVkIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGJlZ2lucyBlbWl0dGluZyBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB3aGVuIHRoZVxuICogc3BlY2lmaWVkIHByZWRpY2F0ZSBiZWNvbWVzIGZhbHNlLlxuICogQG1ldGhvZCBza2lwV2hpbGVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBza2lwV2hpbGU8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgcHJlZGljYXRlOiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IGJvb2xlYW4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgU2tpcFdoaWxlT3BlcmF0b3IocHJlZGljYXRlKSk7XG59XG5cbmNsYXNzIFNraXBXaGlsZU9wZXJhdG9yPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHByZWRpY2F0ZTogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBib29sZWFuKSB7XG4gIH1cblxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4sIHNvdXJjZTogYW55KTogVGVhcmRvd25Mb2dpYyB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFNraXBXaGlsZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5wcmVkaWNhdGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgU2tpcFdoaWxlU3Vic2NyaWJlcjxUPiBleHRlbmRzIFN1YnNjcmliZXI8VD4ge1xuICBwcml2YXRlIHNraXBwaW5nOiBib29sZWFuID0gdHJ1ZTtcbiAgcHJpdmF0ZSBpbmRleDogbnVtYmVyID0gMDtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxUPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBwcmVkaWNhdGU6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gYm9vbGVhbikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICBpZiAodGhpcy5za2lwcGluZykge1xuICAgICAgdGhpcy50cnlDYWxsUHJlZGljYXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc2tpcHBpbmcpIHtcbiAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdHJ5Q2FsbFByZWRpY2F0ZSh2YWx1ZTogVCk6IHZvaWQge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnByZWRpY2F0ZSh2YWx1ZSwgdGhpcy5pbmRleCsrKTtcbiAgICAgIHRoaXMuc2tpcHBpbmcgPSBCb29sZWFuKHJlc3VsdCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL3NraXBXaGlsZS50cyIsImltcG9ydCB7IElTY2hlZHVsZXIgfSBmcm9tICcuLi9TY2hlZHVsZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgQXJyYXlPYnNlcnZhYmxlIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9BcnJheU9ic2VydmFibGUnO1xuaW1wb3J0IHsgU2NhbGFyT2JzZXJ2YWJsZSB9IGZyb20gJy4uL29ic2VydmFibGUvU2NhbGFyT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBFbXB0eU9ic2VydmFibGUgfSBmcm9tICcuLi9vYnNlcnZhYmxlL0VtcHR5T2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBjb25jYXRTdGF0aWMgfSBmcm9tICcuL2NvbmNhdCc7XG5pbXBvcnQgeyBpc1NjaGVkdWxlciB9IGZyb20gJy4uL3V0aWwvaXNTY2hlZHVsZXInO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydFdpdGg8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgdjE6IFQsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0V2l0aDxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MTogVCwgdjI6IFQsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0V2l0aDxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MTogVCwgdjI6IFQsIHYzOiBULCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBzdGFydFdpdGg8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgdjE6IFQsIHYyOiBULCB2MzogVCwgdjQ6IFQsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0V2l0aDxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MTogVCwgdjI6IFQsIHYzOiBULCB2NDogVCwgdjU6IFQsIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0V2l0aDxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MTogVCwgdjI6IFQsIHYzOiBULCB2NDogVCwgdjU6IFQsIHY2OiBULCBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxUPjtcbmV4cG9ydCBmdW5jdGlvbiBzdGFydFdpdGg8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgLi4uYXJyYXk6IEFycmF5PFQgfCBJU2NoZWR1bGVyPik6IE9ic2VydmFibGU8VD47XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuXG4vKipcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyB5b3Ugc3BlY2lmeSBhcyBhcmd1bWVudHMgYmVmb3JlIGl0IGJlZ2lucyB0byBlbWl0XG4gKiBpdGVtcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3N0YXJ0V2l0aC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0gey4uLlR9IHZhbHVlcyAtIEl0ZW1zIHlvdSB3YW50IHRoZSBtb2RpZmllZCBPYnNlcnZhYmxlIHRvIGVtaXQgZmlyc3QuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl0gLSBBIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yIHNjaGVkdWxpbmdcbiAqIHRoZSBlbWlzc2lvbnMgb2YgdGhlIGBuZXh0YCBub3RpZmljYXRpb25zLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSBpdGVtcyBpbiB0aGUgc3BlY2lmaWVkIEl0ZXJhYmxlIGFuZCB0aGVuIGVtaXRzIHRoZSBpdGVtc1xuICogZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHN0YXJ0V2l0aFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0V2l0aDxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCAuLi5hcnJheTogQXJyYXk8VCB8IElTY2hlZHVsZXI+KTogT2JzZXJ2YWJsZTxUPiB7XG4gIGxldCBzY2hlZHVsZXIgPSA8SVNjaGVkdWxlcj5hcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgaWYgKGlzU2NoZWR1bGVyKHNjaGVkdWxlcikpIHtcbiAgICBhcnJheS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzY2hlZHVsZXIgPSBudWxsO1xuICB9XG5cbiAgY29uc3QgbGVuID0gYXJyYXkubGVuZ3RoO1xuICBpZiAobGVuID09PSAxKSB7XG4gICAgcmV0dXJuIGNvbmNhdFN0YXRpYyhuZXcgU2NhbGFyT2JzZXJ2YWJsZTxUPig8VD5hcnJheVswXSwgc2NoZWR1bGVyKSwgPE9ic2VydmFibGU8VD4+dGhpcyk7XG4gIH0gZWxzZSBpZiAobGVuID4gMSkge1xuICAgIHJldHVybiBjb25jYXRTdGF0aWMobmV3IEFycmF5T2JzZXJ2YWJsZTxUPig8VFtdPmFycmF5LCBzY2hlZHVsZXIpLCA8T2JzZXJ2YWJsZTxUPj50aGlzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29uY2F0U3RhdGljKG5ldyBFbXB0eU9ic2VydmFibGU8VD4oc2NoZWR1bGVyKSwgPE9ic2VydmFibGU8VD4+dGhpcyk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3Ivc3RhcnRXaXRoLnRzIiwiaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBJU2NoZWR1bGVyIH0gZnJvbSAnLi4vU2NoZWR1bGVyJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFRlYXJkb3duTG9naWMgfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgU3Vic2NyaWJlT25PYnNlcnZhYmxlIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9TdWJzY3JpYmVPbk9ic2VydmFibGUnO1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHN1YnNjcmliZXMgT2JzZXJ2ZXJzIHRvIHRoaXMgT2JzZXJ2YWJsZSBvbiB0aGUgc3BlY2lmaWVkIElTY2hlZHVsZXIuXG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zdWJzY3JpYmVPbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gc2NoZWR1bGVyIC0gVGhlIElTY2hlZHVsZXIgdG8gcGVyZm9ybSBzdWJzY3JpcHRpb24gYWN0aW9ucyBvbi5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IFRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBtb2RpZmllZCBzbyB0aGF0IGl0cyBzdWJzY3JpcHRpb25zIGhhcHBlbiBvbiB0aGUgc3BlY2lmaWVkIElTY2hlZHVsZXIuXG4gLlxuICogQG1ldGhvZCBzdWJzY3JpYmVPblxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1YnNjcmliZU9uPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIHNjaGVkdWxlcjogSVNjaGVkdWxlciwgZGVsYXk6IG51bWJlciA9IDApOiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgU3Vic2NyaWJlT25PcGVyYXRvcjxUPihzY2hlZHVsZXIsIGRlbGF5KSk7XG59XG5cbmNsYXNzIFN1YnNjcmliZU9uT3BlcmF0b3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgc2NoZWR1bGVyOiBJU2NoZWR1bGVyLFxuICAgICAgICAgICAgICBwcml2YXRlIGRlbGF5OiBudW1iZXIpIHtcbiAgfVxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4sIHNvdXJjZTogYW55KTogVGVhcmRvd25Mb2dpYyB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVPbk9ic2VydmFibGUoXG4gICAgICBzb3VyY2UsIHRoaXMuZGVsYXksIHRoaXMuc2NoZWR1bGVyXG4gICAgKS5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3Ivc3Vic2NyaWJlT24udHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBPdXRlclN1YnNjcmliZXIgfSBmcm9tICcuLi9PdXRlclN1YnNjcmliZXInO1xuaW1wb3J0IHsgSW5uZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vSW5uZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IHN1YnNjcmliZVRvUmVzdWx0IH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCc7XG5cbi8qKlxuICogQ29udmVydHMgYSBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZSBpbnRvIGEgZmlyc3Qtb3JkZXIgT2JzZXJ2YWJsZSBieVxuICogc3Vic2NyaWJpbmcgdG8gb25seSB0aGUgbW9zdCByZWNlbnRseSBlbWl0dGVkIG9mIHRob3NlIGlubmVyIE9ic2VydmFibGVzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5GbGF0dGVucyBhbiBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzIGJ5IGRyb3BwaW5nIHRoZVxuICogcHJldmlvdXMgaW5uZXIgT2JzZXJ2YWJsZSBvbmNlIGEgbmV3IG9uZSBhcHBlYXJzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3N3aXRjaC5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgc3dpdGNoYCBzdWJzY3JpYmVzIHRvIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBPYnNlcnZhYmxlcywgYWxzbyBrbm93biBhcyBhXG4gKiBoaWdoZXItb3JkZXIgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZSBlbWl0dGVkIGlubmVyXG4gKiBPYnNlcnZhYmxlcywgdGhlIG91dHB1dCBPYnNlcnZhYmxlIHN1YnNjcmliZXMgdG8gdGhlIGlubmVyIE9ic2VydmFibGUgYW5kXG4gKiBiZWdpbnMgZW1pdHRpbmcgdGhlIGl0ZW1zIGVtaXR0ZWQgYnkgdGhhdC4gU28gZmFyLCBpdCBiZWhhdmVzXG4gKiBsaWtlIHtAbGluayBtZXJnZUFsbH0uIEhvd2V2ZXIsIHdoZW4gYSBuZXcgaW5uZXIgT2JzZXJ2YWJsZSBpcyBlbWl0dGVkLFxuICogYHN3aXRjaGAgdW5zdWJzY3JpYmVzIGZyb20gdGhlIGVhcmxpZXItZW1pdHRlZCBpbm5lciBPYnNlcnZhYmxlIGFuZFxuICogc3Vic2NyaWJlcyB0byB0aGUgbmV3IGlubmVyIE9ic2VydmFibGUgYW5kIGJlZ2lucyBlbWl0dGluZyBpdGVtcyBmcm9tIGl0LiBJdFxuICogY29udGludWVzIHRvIGJlaGF2ZSBsaWtlIHRoaXMgZm9yIHN1YnNlcXVlbnQgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmVydW4gYW4gaW50ZXJ2YWwgT2JzZXJ2YWJsZSBvbiBldmVyeSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiAvLyBFYWNoIGNsaWNrIGV2ZW50IGlzIG1hcHBlZCB0byBhbiBPYnNlcnZhYmxlIHRoYXQgdGlja3MgZXZlcnkgc2Vjb25kXG4gKiB2YXIgaGlnaGVyT3JkZXIgPSBjbGlja3MubWFwKChldikgPT4gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiB2YXIgc3dpdGNoZWQgPSBoaWdoZXJPcmRlci5zd2l0Y2goKTtcbiAqIC8vIFRoZSBvdXRjb21lIGlzIHRoYXQgYHN3aXRjaGVkYCBpcyBlc3NlbnRpYWxseSBhIHRpbWVyIHRoYXQgcmVzdGFydHNcbiAqIC8vIG9uIGV2ZXJ5IGNsaWNrLiBUaGUgaW50ZXJ2YWwgT2JzZXJ2YWJsZXMgZnJvbSBvbGRlciBjbGlja3MgZG8gbm90IG1lcmdlXG4gKiAvLyB3aXRoIHRoZSBjdXJyZW50IGludGVydmFsIE9ic2VydmFibGUuXG4gKiBzd2l0Y2hlZC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUFsbH1cbiAqIEBzZWUge0BsaW5rIGNvbmNhdEFsbH1cbiAqIEBzZWUge0BsaW5rIGV4aGF1c3R9XG4gKiBAc2VlIHtAbGluayBtZXJnZUFsbH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcH1cbiAqIEBzZWUge0BsaW5rIHN3aXRjaE1hcFRvfVxuICogQHNlZSB7QGxpbmsgemlwQWxsfVxuICpcbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB0aGUgaXRlbXMgZW1pdHRlZCBieSB0aGVcbiAqIE9ic2VydmFibGUgbW9zdCByZWNlbnRseSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgc3dpdGNoXG4gKiBAbmFtZSBzd2l0Y2hcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc3dpdGNoPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4pOiBUIHtcbiAgcmV0dXJuIDxhbnk+dGhpcy5saWZ0PGFueT4obmV3IFN3aXRjaE9wZXJhdG9yKCkpO1xufVxuXG5jbGFzcyBTd2l0Y2hPcGVyYXRvcjxULCBSPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFI+IHtcbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFI+LCBzb3VyY2U6IGFueSk6IGFueSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFN3aXRjaFN1YnNjcmliZXIoc3Vic2NyaWJlcikpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBTd2l0Y2hTdWJzY3JpYmVyPFQsIFI+IGV4dGVuZHMgT3V0ZXJTdWJzY3JpYmVyPFQsIFI+IHtcbiAgcHJpdmF0ZSBhY3RpdmU6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgaGFzQ29tcGxldGVkOiBib29sZWFuID0gZmFsc2U7XG4gIGlubmVyU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8Uj4pIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpOiB2b2lkIHtcbiAgICB0aGlzLnVuc3Vic2NyaWJlSW5uZXIoKTtcbiAgICB0aGlzLmFjdGl2ZSsrO1xuICAgIHRoaXMuYWRkKHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCB2YWx1ZSkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jb21wbGV0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLmhhc0NvbXBsZXRlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuYWN0aXZlID09PSAwKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1bnN1YnNjcmliZUlubmVyKCk6IHZvaWQge1xuICAgIHRoaXMuYWN0aXZlID0gdGhpcy5hY3RpdmUgPiAwID8gdGhpcy5hY3RpdmUgLSAxIDogMDtcbiAgICBjb25zdCBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgaWYgKGlubmVyU3Vic2NyaXB0aW9uKSB7XG4gICAgICBpbm5lclN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWJzY3JpcHRpb24pO1xuICAgIH1cbiAgfVxuXG4gIG5vdGlmeU5leHQob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogUixcbiAgICAgICAgICAgICBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgICBpbm5lclN1YjogSW5uZXJTdWJzY3JpYmVyPFQsIFI+KTogdm9pZCB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICB9XG5cbiAgbm90aWZ5RXJyb3IoZXJyOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gIH1cblxuICBub3RpZnlDb21wbGV0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLnVuc3Vic2NyaWJlSW5uZXIoKTtcbiAgICBpZiAodGhpcy5oYXNDb21wbGV0ZWQgJiYgdGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3Ivc3dpdGNoLnRzIiwiaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZhYmxlSW5wdXQgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBPdXRlclN1YnNjcmliZXIgfSBmcm9tICcuLi9PdXRlclN1YnNjcmliZXInO1xuaW1wb3J0IHsgSW5uZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vSW5uZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IHN1YnNjcmliZVRvUmVzdWx0IH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCc7XG5cbi8qIHRzbGludDpkaXNhYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN3aXRjaE1hcDxULCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBwcm9qZWN0OiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IE9ic2VydmFibGVJbnB1dDxSPik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gc3dpdGNoTWFwPFQsIEksIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHByb2plY3Q6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gT2JzZXJ2YWJsZUlucHV0PEk+LCByZXN1bHRTZWxlY3RvcjogKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKSA9PiBSKTogT2JzZXJ2YWJsZTxSPjtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbi8qKlxuICogUHJvamVjdHMgZWFjaCBzb3VyY2UgdmFsdWUgdG8gYW4gT2JzZXJ2YWJsZSB3aGljaCBpcyBtZXJnZWQgaW4gdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSwgZW1pdHRpbmcgdmFsdWVzIG9ubHkgZnJvbSB0aGUgbW9zdCByZWNlbnRseSBwcm9qZWN0ZWQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TWFwcyBlYWNoIHZhbHVlIHRvIGFuIE9ic2VydmFibGUsIHRoZW4gZmxhdHRlbnMgYWxsIG9mXG4gKiB0aGVzZSBpbm5lciBPYnNlcnZhYmxlcyB1c2luZyB7QGxpbmsgc3dpdGNofS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zd2l0Y2hNYXAucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgYmFzZWQgb24gYXBwbHlpbmcgYSBmdW5jdGlvbiB0aGF0IHlvdVxuICogc3VwcGx5IHRvIGVhY2ggaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgd2hlcmUgdGhhdCBmdW5jdGlvblxuICogcmV0dXJucyBhbiAoc28tY2FsbGVkIFwiaW5uZXJcIikgT2JzZXJ2YWJsZS4gRWFjaCB0aW1lIGl0IG9ic2VydmVzIG9uZSBvZiB0aGVzZVxuICogaW5uZXIgT2JzZXJ2YWJsZXMsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBiZWdpbnMgZW1pdHRpbmcgdGhlIGl0ZW1zIGVtaXR0ZWQgYnlcbiAqIHRoYXQgaW5uZXIgT2JzZXJ2YWJsZS4gV2hlbiBhIG5ldyBpbm5lciBPYnNlcnZhYmxlIGlzIGVtaXR0ZWQsIGBzd2l0Y2hNYXBgXG4gKiBzdG9wcyBlbWl0dGluZyBpdGVtcyBmcm9tIHRoZSBlYXJsaWVyLWVtaXR0ZWQgaW5uZXIgT2JzZXJ2YWJsZSBhbmQgYmVnaW5zXG4gKiBlbWl0dGluZyBpdGVtcyBmcm9tIHRoZSBuZXcgb25lLiBJdCBjb250aW51ZXMgdG8gYmVoYXZlIGxpa2UgdGhpcyBmb3JcbiAqIHN1YnNlcXVlbnQgaW5uZXIgT2JzZXJ2YWJsZXMuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+UmVydW4gYW4gaW50ZXJ2YWwgT2JzZXJ2YWJsZSBvbiBldmVyeSBjbGljayBldmVudDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnN3aXRjaE1hcCgoZXYpID0+IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCkpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBjb25jYXRNYXB9XG4gKiBAc2VlIHtAbGluayBleGhhdXN0TWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXB9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2h9XG4gKiBAc2VlIHtAbGluayBzd2l0Y2hNYXBUb31cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCA/aW5kZXg6IG51bWJlcik6IE9ic2VydmFibGVJbnB1dH0gcHJvamVjdCBBIGZ1bmN0aW9uXG4gKiB0aGF0LCB3aGVuIGFwcGxpZWQgdG8gYW4gaXRlbSBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgcmV0dXJucyBhblxuICogT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGVcbiAqIHByb2plY3Rpb24gZnVuY3Rpb24gKGFuZCB0aGUgb3B0aW9uYWwgYHJlc3VsdFNlbGVjdG9yYCkgdG8gZWFjaCBpdGVtIGVtaXR0ZWRcbiAqIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBhbmQgdGFraW5nIG9ubHkgdGhlIHZhbHVlcyBmcm9tIHRoZSBtb3N0IHJlY2VudGx5XG4gKiBwcm9qZWN0ZWQgaW5uZXIgT2JzZXJ2YWJsZS5cbiAqIEBtZXRob2Qgc3dpdGNoTWFwXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3dpdGNoTWFwPFQsIEksIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHByb2plY3Q6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gT2JzZXJ2YWJsZUlucHV0PEk+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTZWxlY3Rvcj86IChvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcikgPT4gUik6IE9ic2VydmFibGU8SSB8IFI+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgU3dpdGNoTWFwT3BlcmF0b3IocHJvamVjdCwgcmVzdWx0U2VsZWN0b3IpKTtcbn1cblxuY2xhc3MgU3dpdGNoTWFwT3BlcmF0b3I8VCwgSSwgUj4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBJPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcHJvamVjdDogKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKSA9PiBPYnNlcnZhYmxlSW5wdXQ8ST4sXG4gICAgICAgICAgICAgIHByaXZhdGUgcmVzdWx0U2VsZWN0b3I/OiAob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpID0+IFIpIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxJPiwgc291cmNlOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBTd2l0Y2hNYXBTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMucHJvamVjdCwgdGhpcy5yZXN1bHRTZWxlY3RvcikpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBTd2l0Y2hNYXBTdWJzY3JpYmVyPFQsIEksIFI+IGV4dGVuZHMgT3V0ZXJTdWJzY3JpYmVyPFQsIEk+IHtcbiAgcHJpdmF0ZSBpbmRleDogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBpbm5lclN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPEk+LFxuICAgICAgICAgICAgICBwcml2YXRlIHByb2plY3Q6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gT2JzZXJ2YWJsZUlucHV0PEk+LFxuICAgICAgICAgICAgICBwcml2YXRlIHJlc3VsdFNlbGVjdG9yPzogKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKSA9PiBSKSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHZhbHVlOiBUKSB7XG4gICAgbGV0IHJlc3VsdDogT2JzZXJ2YWJsZUlucHV0PEk+O1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleCsrO1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QodmFsdWUsIGluZGV4KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2lubmVyU3ViKHJlc3VsdCwgdmFsdWUsIGluZGV4KTtcbiAgfVxuXG4gIHByaXZhdGUgX2lubmVyU3ViKHJlc3VsdDogT2JzZXJ2YWJsZUlucHV0PEk+LCB2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikge1xuICAgIGNvbnN0IGlubmVyU3Vic2NyaXB0aW9uID0gdGhpcy5pbm5lclN1YnNjcmlwdGlvbjtcbiAgICBpZiAoaW5uZXJTdWJzY3JpcHRpb24pIHtcbiAgICAgIGlubmVyU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHRoaXMuYWRkKHRoaXMuaW5uZXJTdWJzY3JpcHRpb24gPSBzdWJzY3JpYmVUb1Jlc3VsdCh0aGlzLCByZXN1bHQsIHZhbHVlLCBpbmRleCkpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jb21wbGV0ZSgpOiB2b2lkIHtcbiAgICBjb25zdCB7aW5uZXJTdWJzY3JpcHRpb259ID0gdGhpcztcbiAgICBpZiAoIWlubmVyU3Vic2NyaXB0aW9uIHx8IGlubmVyU3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgc3VwZXIuX2NvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF91bnN1YnNjcmliZSgpIHtcbiAgICB0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgfVxuXG4gIG5vdGlmeUNvbXBsZXRlKGlubmVyU3ViOiBTdWJzY3JpcHRpb24pOiB2b2lkIHtcbiAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgdGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICBzdXBlci5fY29tcGxldGUoKTtcbiAgICB9XG4gIH1cblxuICBub3RpZnlOZXh0KG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksXG4gICAgICAgICAgICAgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICAgaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBJPik6IHZvaWQge1xuICAgIGlmICh0aGlzLnJlc3VsdFNlbGVjdG9yKSB7XG4gICAgICB0aGlzLl90cnlOb3RpZnlOZXh0KG91dGVyVmFsdWUsIGlubmVyVmFsdWUsIG91dGVySW5kZXgsIGlubmVySW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQoaW5uZXJWYWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfdHJ5Tm90aWZ5TmV4dChvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgIGxldCByZXN1bHQ6IFI7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IHRoaXMucmVzdWx0U2VsZWN0b3Iob3V0ZXJWYWx1ZSwgaW5uZXJWYWx1ZSwgb3V0ZXJJbmRleCwgaW5uZXJJbmRleCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL3N3aXRjaE1hcC50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgT2JzZXJ2YWJsZUlucHV0IH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vT3V0ZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IElubmVyU3Vic2NyaWJlciB9IGZyb20gJy4uL0lubmVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBzdWJzY3JpYmVUb1Jlc3VsdCB9IGZyb20gJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmV4cG9ydCBmdW5jdGlvbiBzd2l0Y2hNYXBUbzxULCBSPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBvYnNlcnZhYmxlOiBPYnNlcnZhYmxlSW5wdXQ8Uj4pOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIHN3aXRjaE1hcFRvPFQsIEksIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIG9ic2VydmFibGU6IE9ic2VydmFibGVJbnB1dDxJPiwgcmVzdWx0U2VsZWN0b3I6IChvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcikgPT4gUik6IE9ic2VydmFibGU8Uj47XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuXG4vKipcbiAqIFByb2plY3RzIGVhY2ggc291cmNlIHZhbHVlIHRvIHRoZSBzYW1lIE9ic2VydmFibGUgd2hpY2ggaXMgZmxhdHRlbmVkIG11bHRpcGxlXG4gKiB0aW1lcyB3aXRoIHtAbGluayBzd2l0Y2h9IGluIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBzd2l0Y2hNYXB9LCBidXQgbWFwcyBlYWNoIHZhbHVlXG4gKiBhbHdheXMgdG8gdGhlIHNhbWUgaW5uZXIgT2JzZXJ2YWJsZS48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy9zd2l0Y2hNYXBUby5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBNYXBzIGVhY2ggc291cmNlIHZhbHVlIHRvIHRoZSBnaXZlbiBPYnNlcnZhYmxlIGBpbm5lck9ic2VydmFibGVgIHJlZ2FyZGxlc3NcbiAqIG9mIHRoZSBzb3VyY2UgdmFsdWUsIGFuZCB0aGVuIGZsYXR0ZW5zIHRob3NlIHJlc3VsdGluZyBPYnNlcnZhYmxlcyBpbnRvIG9uZVxuICogc2luZ2xlIE9ic2VydmFibGUsIHdoaWNoIGlzIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlc1xuICogZW1pdHMgdmFsdWVzIG9ubHkgZnJvbSB0aGUgbW9zdCByZWNlbnRseSBlbWl0dGVkIGluc3RhbmNlIG9mXG4gKiBgaW5uZXJPYnNlcnZhYmxlYC5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5SZXJ1biBhbiBpbnRlcnZhbCBPYnNlcnZhYmxlIG9uIGV2ZXJ5IGNsaWNrIGV2ZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3Muc3dpdGNoTWFwVG8oUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKSk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIGNvbmNhdE1hcFRvfVxuICogQHNlZSB7QGxpbmsgc3dpdGNofVxuICogQHNlZSB7QGxpbmsgc3dpdGNoTWFwfVxuICogQHNlZSB7QGxpbmsgbWVyZ2VNYXBUb31cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGVJbnB1dH0gaW5uZXJPYnNlcnZhYmxlIEFuIE9ic2VydmFibGUgdG8gcmVwbGFjZSBlYWNoIHZhbHVlIGZyb21cbiAqIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogSSwgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiBhbnl9IFtyZXN1bHRTZWxlY3Rvcl1cbiAqIEEgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdmFsdWUgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlIGJhc2VkIG9uIHRoZSB2YWx1ZXNcbiAqIGFuZCB0aGUgaW5kaWNlcyBvZiB0aGUgc291cmNlIChvdXRlcikgZW1pc3Npb24gYW5kIHRoZSBpbm5lciBPYnNlcnZhYmxlXG4gKiBlbWlzc2lvbi4gVGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmU6XG4gKiAtIGBvdXRlclZhbHVlYDogdGhlIHZhbHVlIHRoYXQgY2FtZSBmcm9tIHRoZSBzb3VyY2VcbiAqIC0gYGlubmVyVmFsdWVgOiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiAtIGBvdXRlckluZGV4YDogdGhlIFwiaW5kZXhcIiBvZiB0aGUgdmFsdWUgdGhhdCBjYW1lIGZyb20gdGhlIHNvdXJjZVxuICogLSBgaW5uZXJJbmRleGA6IHRoZSBcImluZGV4XCIgb2YgdGhlIHZhbHVlIGZyb20gdGhlIHByb2plY3RlZCBPYnNlcnZhYmxlXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlfSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgaXRlbXMgZnJvbSB0aGUgZ2l2ZW5cbiAqIGBpbm5lck9ic2VydmFibGVgIChhbmQgb3B0aW9uYWxseSB0cmFuc2Zvcm1lZCB0aHJvdWdoIGByZXN1bHRTZWxlY3RvcmApIGV2ZXJ5XG4gKiB0aW1lIGEgdmFsdWUgaXMgZW1pdHRlZCBvbiB0aGUgc291cmNlIE9ic2VydmFibGUsIGFuZCB0YWtpbmcgb25seSB0aGUgdmFsdWVzXG4gKiBmcm9tIHRoZSBtb3N0IHJlY2VudGx5IHByb2plY3RlZCBpbm5lciBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCBzd2l0Y2hNYXBUb1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN3aXRjaE1hcFRvPFQsIEksIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIGlubmVyT2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxJPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRTZWxlY3Rvcj86IChvdXRlclZhbHVlOiBULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyVmFsdWU6IEksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJJbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVySW5kZXg6IG51bWJlcikgPT4gUik6IE9ic2VydmFibGU8SSB8IFI+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgU3dpdGNoTWFwVG9PcGVyYXRvcihpbm5lck9ic2VydmFibGUsIHJlc3VsdFNlbGVjdG9yKSk7XG59XG5cbmNsYXNzIFN3aXRjaE1hcFRvT3BlcmF0b3I8VCwgSSwgUj4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBJPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgb2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxJPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSByZXN1bHRTZWxlY3Rvcj86IChvdXRlclZhbHVlOiBULCBpbm5lclZhbHVlOiBJLCBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcikgPT4gUikge1xuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPEk+LCBzb3VyY2U6IGFueSk6IGFueSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFN3aXRjaE1hcFRvU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLm9ic2VydmFibGUsIHRoaXMucmVzdWx0U2VsZWN0b3IpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgU3dpdGNoTWFwVG9TdWJzY3JpYmVyPFQsIEksIFI+IGV4dGVuZHMgT3V0ZXJTdWJzY3JpYmVyPFQsIEk+IHtcbiAgcHJpdmF0ZSBpbmRleDogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBpbm5lclN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPEk+LFxuICAgICAgICAgICAgICBwcml2YXRlIGlubmVyOiBPYnNlcnZhYmxlPEk+LFxuICAgICAgICAgICAgICBwcml2YXRlIHJlc3VsdFNlbGVjdG9yPzogKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksIG91dGVySW5kZXg6IG51bWJlciwgaW5uZXJJbmRleDogbnVtYmVyKSA9PiBSKSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHZhbHVlOiBhbnkpIHtcbiAgICBjb25zdCBpbm5lclN1YnNjcmlwdGlvbiA9IHRoaXMuaW5uZXJTdWJzY3JpcHRpb247XG4gICAgaWYgKGlubmVyU3Vic2NyaXB0aW9uKSB7XG4gICAgICBpbm5lclN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICB0aGlzLmFkZCh0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgdGhpcy5pbm5lciwgdmFsdWUsIHRoaXMuaW5kZXgrKykpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jb21wbGV0ZSgpIHtcbiAgICBjb25zdCB7aW5uZXJTdWJzY3JpcHRpb259ID0gdGhpcztcbiAgICBpZiAoIWlubmVyU3Vic2NyaXB0aW9uIHx8IGlubmVyU3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgc3VwZXIuX2NvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF91bnN1YnNjcmliZSgpIHtcbiAgICB0aGlzLmlubmVyU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgfVxuXG4gIG5vdGlmeUNvbXBsZXRlKGlubmVyU3ViOiBTdWJzY3JpcHRpb24pIHtcbiAgICB0aGlzLnJlbW92ZShpbm5lclN1Yik7XG4gICAgdGhpcy5pbm5lclN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgaWYgKHRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICBzdXBlci5fY29tcGxldGUoKTtcbiAgICB9XG4gIH1cblxuICBub3RpZnlOZXh0KG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksXG4gICAgICAgICAgICAgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICAgaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBJPik6IHZvaWQge1xuICAgIGNvbnN0IHsgcmVzdWx0U2VsZWN0b3IsIGRlc3RpbmF0aW9uIH0gPSB0aGlzO1xuICAgIGlmIChyZXN1bHRTZWxlY3Rvcikge1xuICAgICAgdGhpcy50cnlSZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVzdGluYXRpb24ubmV4dChpbm5lclZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHRyeVJlc3VsdFNlbGVjdG9yKG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IEksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICBjb25zdCB7IHJlc3VsdFNlbGVjdG9yLCBkZXN0aW5hdGlvbiB9ID0gdGhpcztcbiAgICBsZXQgcmVzdWx0OiBSO1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSByZXN1bHRTZWxlY3RvcihvdXRlclZhbHVlLCBpbm5lclZhbHVlLCBvdXRlckluZGV4LCBpbm5lckluZGV4KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL3N3aXRjaE1hcFRvLnRzIiwiaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvciB9IGZyb20gJy4uL3V0aWwvQXJndW1lbnRPdXRPZlJhbmdlRXJyb3InO1xuaW1wb3J0IHsgRW1wdHlPYnNlcnZhYmxlIH0gZnJvbSAnLi4vb2JzZXJ2YWJsZS9FbXB0eU9ic2VydmFibGUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5cbi8qKlxuICogRW1pdHMgb25seSB0aGUgZmlyc3QgYGNvdW50YCB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlRha2VzIHRoZSBmaXJzdCBgY291bnRgIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2UsIHRoZW5cbiAqIGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90YWtlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGB0YWtlYCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBvbmx5IHRoZSBmaXJzdCBgY291bnRgIHZhbHVlcyBlbWl0dGVkXG4gKiBieSB0aGUgc291cmNlIE9ic2VydmFibGUuIElmIHRoZSBzb3VyY2UgZW1pdHMgZmV3ZXIgdGhhbiBgY291bnRgIHZhbHVlcyB0aGVuXG4gKiBhbGwgb2YgaXRzIHZhbHVlcyBhcmUgZW1pdHRlZC4gQWZ0ZXIgdGhhdCwgaXQgY29tcGxldGVzLCByZWdhcmRsZXNzIGlmIHRoZVxuICogc291cmNlIGNvbXBsZXRlcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5UYWtlIHRoZSBmaXJzdCA1IHNlY29uZHMgb2YgYW4gaW5maW5pdGUgMS1zZWNvbmQgaW50ZXJ2YWwgT2JzZXJ2YWJsZTwvY2FwdGlvbj5cbiAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgZml2ZSA9IGludGVydmFsLnRha2UoNSk7XG4gKiBmaXZlLnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayB0YWtlTGFzdH1cbiAqIEBzZWUge0BsaW5rIHRha2VVbnRpbH1cbiAqIEBzZWUge0BsaW5rIHRha2VXaGlsZX1cbiAqIEBzZWUge0BsaW5rIHNraXB9XG4gKlxuICogQHRocm93cyB7QXJndW1lbnRPdXRPZlJhbmdlRXJyb3J9IFdoZW4gdXNpbmcgYHRha2UoaSlgLCBpdCBkZWxpdmVycyBhblxuICogQXJndW1lbnRPdXRPclJhbmdlRXJyb3IgdG8gdGhlIE9ic2VydmVyJ3MgYGVycm9yYCBjYWxsYmFjayBpZiBgaSA8IDBgLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBUaGUgbWF4aW11bSBudW1iZXIgb2YgYG5leHRgIHZhbHVlcyB0byBlbWl0LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIG9ubHkgdGhlIGZpcnN0IGBjb3VudGBcbiAqIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgb3IgYWxsIG9mIHRoZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBpZiB0aGUgc291cmNlIGVtaXRzIGZld2VyIHRoYW4gYGNvdW50YCB2YWx1ZXMuXG4gKiBAbWV0aG9kIHRha2VcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0YWtlPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIGNvdW50OiBudW1iZXIpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGU8VD4oKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBUYWtlT3BlcmF0b3IoY291bnQpKTtcbiAgfVxufVxuXG5jbGFzcyBUYWtlT3BlcmF0b3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgdG90YWw6IG51bWJlcikge1xuICAgIGlmICh0aGlzLnRvdGFsIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yO1xuICAgIH1cbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPiwgc291cmNlOiBhbnkpOiBUZWFyZG93bkxvZ2ljIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy50b3RhbCkpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBUYWtlU3Vic2NyaWJlcjxUPiBleHRlbmRzIFN1YnNjcmliZXI8VD4ge1xuICBwcml2YXRlIGNvdW50OiBudW1iZXIgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFQ+LCBwcml2YXRlIHRvdGFsOiBudW1iZXIpIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpOiB2b2lkIHtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMudG90YWw7XG4gICAgY29uc3QgY291bnQgPSArK3RoaXMuY291bnQ7XG4gICAgaWYgKGNvdW50IDw9IHRvdGFsKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgICAgaWYgKGNvdW50ID09PSB0b3RhbCkge1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvdGFrZS50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3IgfSBmcm9tICcuLi91dGlsL0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yJztcbmltcG9ydCB7IEVtcHR5T2JzZXJ2YWJsZSB9IGZyb20gJy4uL29ic2VydmFibGUvRW1wdHlPYnNlcnZhYmxlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFRlYXJkb3duTG9naWMgfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuXG4vKipcbiAqIEVtaXRzIG9ubHkgdGhlIGxhc3QgYGNvdW50YCB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlJlbWVtYmVycyB0aGUgbGF0ZXN0IGBjb3VudGAgdmFsdWVzLCB0aGVuIGVtaXRzIHRob3NlXG4gKiBvbmx5IHdoZW4gdGhlIHNvdXJjZSBjb21wbGV0ZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvdGFrZUxhc3QucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHRha2VMYXN0YCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyBhdCBtb3N0IHRoZSBsYXN0IGBjb3VudGAgdmFsdWVzXG4gKiBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gSWYgdGhlIHNvdXJjZSBlbWl0cyBmZXdlciB0aGFuIGBjb3VudGBcbiAqIHZhbHVlcyB0aGVuIGFsbCBvZiBpdHMgdmFsdWVzIGFyZSBlbWl0dGVkLiBUaGlzIG9wZXJhdG9yIG11c3Qgd2FpdCB1bnRpbCB0aGVcbiAqIGBjb21wbGV0ZWAgbm90aWZpY2F0aW9uIGVtaXNzaW9uIGZyb20gdGhlIHNvdXJjZSBpbiBvcmRlciB0byBlbWl0IHRoZSBgbmV4dGBcbiAqIHZhbHVlcyBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGUsIGJlY2F1c2Ugb3RoZXJ3aXNlIGl0IGlzIGltcG9zc2libGUgdG8ga25vd1xuICogd2hldGhlciBvciBub3QgbW9yZSB2YWx1ZXMgd2lsbCBiZSBlbWl0dGVkIG9uIHRoZSBzb3VyY2UuIEZvciB0aGlzIHJlYXNvbixcbiAqIGFsbCB2YWx1ZXMgYXJlIGVtaXR0ZWQgc3luY2hyb25vdXNseSwgZm9sbG93ZWQgYnkgdGhlIGNvbXBsZXRlIG5vdGlmaWNhdGlvbi5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5UYWtlIHRoZSBsYXN0IDMgdmFsdWVzIG9mIGFuIE9ic2VydmFibGUgd2l0aCBtYW55IHZhbHVlczwvY2FwdGlvbj5cbiAqIHZhciBtYW55ID0gUnguT2JzZXJ2YWJsZS5yYW5nZSgxLCAxMDApO1xuICogdmFyIGxhc3RUaHJlZSA9IG1hbnkudGFrZUxhc3QoMyk7XG4gKiBsYXN0VGhyZWUuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHRha2V9XG4gKiBAc2VlIHtAbGluayB0YWtlVW50aWx9XG4gKiBAc2VlIHtAbGluayB0YWtlV2hpbGV9XG4gKiBAc2VlIHtAbGluayBza2lwfVxuICpcbiAqIEB0aHJvd3Mge0FyZ3VtZW50T3V0T2ZSYW5nZUVycm9yfSBXaGVuIHVzaW5nIGB0YWtlTGFzdChpKWAsIGl0IGRlbGl2ZXJzIGFuXG4gKiBBcmd1bWVudE91dE9yUmFuZ2VFcnJvciB0byB0aGUgT2JzZXJ2ZXIncyBgZXJyb3JgIGNhbGxiYWNrIGlmIGBpIDwgMGAuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IFRoZSBtYXhpbXVtIG51bWJlciBvZiB2YWx1ZXMgdG8gZW1pdCBmcm9tIHRoZSBlbmQgb2ZcbiAqIHRoZSBzZXF1ZW5jZSBvZiB2YWx1ZXMgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgYXQgbW9zdCB0aGUgbGFzdCBjb3VudFxuICogdmFsdWVzIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCB0YWtlTGFzdFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRha2VMYXN0PFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIGNvdW50OiBudW1iZXIpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBFbXB0eU9ic2VydmFibGU8VD4oKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdGhpcy5saWZ0KG5ldyBUYWtlTGFzdE9wZXJhdG9yKGNvdW50KSk7XG4gIH1cbn1cblxuY2xhc3MgVGFrZUxhc3RPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB0b3RhbDogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMudG90YWwgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgQXJndW1lbnRPdXRPZlJhbmdlRXJyb3I7XG4gICAgfVxuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+LCBzb3VyY2U6IGFueSk6IFRlYXJkb3duTG9naWMge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUYWtlTGFzdFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy50b3RhbCkpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBUYWtlTGFzdFN1YnNjcmliZXI8VD4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgcHJpdmF0ZSByaW5nOiBBcnJheTxUPiA9IG5ldyBBcnJheSgpO1xuICBwcml2YXRlIGNvdW50OiBudW1iZXIgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFQ+LCBwcml2YXRlIHRvdGFsOiBudW1iZXIpIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpOiB2b2lkIHtcbiAgICBjb25zdCByaW5nID0gdGhpcy5yaW5nO1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy50b3RhbDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuY291bnQrKztcblxuICAgIGlmIChyaW5nLmxlbmd0aCA8IHRvdGFsKSB7XG4gICAgICByaW5nLnB1c2godmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpbmRleCA9IGNvdW50ICUgdG90YWw7XG4gICAgICByaW5nW2luZGV4XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKTogdm9pZCB7XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgIGxldCBjb3VudCA9IHRoaXMuY291bnQ7XG5cbiAgICBpZiAoY291bnQgPiAwKSB7XG4gICAgICBjb25zdCB0b3RhbCA9IHRoaXMuY291bnQgPj0gdGhpcy50b3RhbCA/IHRoaXMudG90YWwgOiB0aGlzLmNvdW50O1xuICAgICAgY29uc3QgcmluZyAgPSB0aGlzLnJpbmc7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xuICAgICAgICBjb25zdCBpZHggPSAoY291bnQrKykgJSB0b3RhbDtcbiAgICAgICAgZGVzdGluYXRpb24ubmV4dChyaW5nW2lkeF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvdGFrZUxhc3QudHMiLCJpbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IFRlYXJkb3duTG9naWMgfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuXG5pbXBvcnQgeyBPdXRlclN1YnNjcmliZXIgfSBmcm9tICcuLi9PdXRlclN1YnNjcmliZXInO1xuaW1wb3J0IHsgSW5uZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vSW5uZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IHN1YnNjcmliZVRvUmVzdWx0IH0gZnJvbSAnLi4vdXRpbC9zdWJzY3JpYmVUb1Jlc3VsdCc7XG5cbi8qKlxuICogRW1pdHMgdGhlIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB1bnRpbCBhIGBub3RpZmllcmBcbiAqIE9ic2VydmFibGUgZW1pdHMgYSB2YWx1ZS5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+TGV0cyB2YWx1ZXMgcGFzcyB1bnRpbCBhIHNlY29uZCBPYnNlcnZhYmxlLFxuICogYG5vdGlmaWVyYCwgZW1pdHMgc29tZXRoaW5nLiBUaGVuLCBpdCBjb21wbGV0ZXMuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvdGFrZVVudGlsLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGB0YWtlVW50aWxgIHN1YnNjcmliZXMgYW5kIGJlZ2lucyBtaXJyb3JpbmcgdGhlIHNvdXJjZSBPYnNlcnZhYmxlLiBJdCBhbHNvXG4gKiBtb25pdG9ycyBhIHNlY29uZCBPYnNlcnZhYmxlLCBgbm90aWZpZXJgIHRoYXQgeW91IHByb3ZpZGUuIElmIHRoZSBgbm90aWZpZXJgXG4gKiBlbWl0cyBhIHZhbHVlIG9yIGEgY29tcGxldGUgbm90aWZpY2F0aW9uLCB0aGUgb3V0cHV0IE9ic2VydmFibGUgc3RvcHNcbiAqIG1pcnJvcmluZyB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIGNvbXBsZXRlcy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5UaWNrIGV2ZXJ5IHNlY29uZCB1bnRpbCB0aGUgZmlyc3QgY2xpY2sgaGFwcGVuczwvY2FwdGlvbj5cbiAqIHZhciBpbnRlcnZhbCA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGludGVydmFsLnRha2VVbnRpbChjbGlja3MpO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayB0YWtlfVxuICogQHNlZSB7QGxpbmsgdGFrZUxhc3R9XG4gKiBAc2VlIHtAbGluayB0YWtlV2hpbGV9XG4gKiBAc2VlIHtAbGluayBza2lwfVxuICpcbiAqIEBwYXJhbSB7T2JzZXJ2YWJsZX0gbm90aWZpZXIgVGhlIE9ic2VydmFibGUgd2hvc2UgZmlyc3QgZW1pdHRlZCB2YWx1ZSB3aWxsXG4gKiBjYXVzZSB0aGUgb3V0cHV0IE9ic2VydmFibGUgb2YgYHRha2VVbnRpbGAgdG8gc3RvcCBlbWl0dGluZyB2YWx1ZXMgZnJvbSB0aGVcbiAqIHNvdXJjZSBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHRoZSB2YWx1ZXMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIHVudGlsIHN1Y2ggdGltZSBhcyBgbm90aWZpZXJgIGVtaXRzIGl0cyBmaXJzdCB2YWx1ZS5cbiAqIEBtZXRob2QgdGFrZVVudGlsXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGFrZVVudGlsPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIG5vdGlmaWVyOiBPYnNlcnZhYmxlPGFueT4pOiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgVGFrZVVudGlsT3BlcmF0b3Iobm90aWZpZXIpKTtcbn1cblxuY2xhc3MgVGFrZVVudGlsT3BlcmF0b3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgbm90aWZpZXI6IE9ic2VydmFibGU8YW55Pikge1xuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+LCBzb3VyY2U6IGFueSk6IFRlYXJkb3duTG9naWMge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUYWtlVW50aWxTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMubm90aWZpZXIpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgVGFrZVVudGlsU3Vic2NyaWJlcjxULCBSPiBleHRlbmRzIE91dGVyU3Vic2NyaWJlcjxULCBSPiB7XG5cbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8YW55PixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBub3RpZmllcjogT2JzZXJ2YWJsZTxhbnk+KSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICAgIHRoaXMuYWRkKHN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIG5vdGlmaWVyKSk7XG4gIH1cblxuICBub3RpZnlOZXh0KG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IFIsXG4gICAgICAgICAgICAgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICAgaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBSPik6IHZvaWQge1xuICAgIHRoaXMuY29tcGxldGUoKTtcbiAgfVxuXG4gIG5vdGlmeUNvbXBsZXRlKCk6IHZvaWQge1xuICAgIC8vIG5vb3BcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci90YWtlVW50aWwudHMiLCJpbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IFRlYXJkb3duTG9naWMgfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuXG4vKipcbiAqIEVtaXRzIHZhbHVlcyBlbWl0dGVkIGJ5IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSBzbyBsb25nIGFzIGVhY2ggdmFsdWUgc2F0aXNmaWVzXG4gKiB0aGUgZ2l2ZW4gYHByZWRpY2F0ZWAsIGFuZCB0aGVuIGNvbXBsZXRlcyBhcyBzb29uIGFzIHRoaXMgYHByZWRpY2F0ZWAgaXMgbm90XG4gKiBzYXRpc2ZpZWQuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlRha2VzIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2Ugb25seSB3aGlsZSB0aGV5IHBhc3MgdGhlXG4gKiBjb25kaXRpb24gZ2l2ZW4uIFdoZW4gdGhlIGZpcnN0IHZhbHVlIGRvZXMgbm90IHNhdGlzZnksIGl0IGNvbXBsZXRlcy48L3NwYW4+XG4gKlxuICogPGltZyBzcmM9XCIuL2ltZy90YWtlV2hpbGUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogYHRha2VXaGlsZWAgc3Vic2NyaWJlcyBhbmQgYmVnaW5zIG1pcnJvcmluZyB0aGUgc291cmNlIE9ic2VydmFibGUuIEVhY2ggdmFsdWVcbiAqIGVtaXR0ZWQgb24gdGhlIHNvdXJjZSBpcyBnaXZlbiB0byB0aGUgYHByZWRpY2F0ZWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhXG4gKiBib29sZWFuLCByZXByZXNlbnRpbmcgYSBjb25kaXRpb24gdG8gYmUgc2F0aXNmaWVkIGJ5IHRoZSBzb3VyY2UgdmFsdWVzLiBUaGVcbiAqIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzIHRoZSBzb3VyY2UgdmFsdWVzIHVudGlsIHN1Y2ggdGltZSBhcyB0aGUgYHByZWRpY2F0ZWBcbiAqIHJldHVybnMgZmFsc2UsIGF0IHdoaWNoIHBvaW50IGB0YWtlV2hpbGVgIHN0b3BzIG1pcnJvcmluZyB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlIGFuZCBjb21wbGV0ZXMgdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgY2xpY2sgZXZlbnRzIG9ubHkgd2hpbGUgdGhlIGNsaWVudFggcHJvcGVydHkgaXMgZ3JlYXRlciB0aGFuIDIwMDwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLnRha2VXaGlsZShldiA9PiBldi5jbGllbnRYID4gMjAwKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgdGFrZX1cbiAqIEBzZWUge0BsaW5rIHRha2VMYXN0fVxuICogQHNlZSB7QGxpbmsgdGFrZVVudGlsfVxuICogQHNlZSB7QGxpbmsgc2tpcH1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBULCBpbmRleDogbnVtYmVyKTogYm9vbGVhbn0gcHJlZGljYXRlIEEgZnVuY3Rpb24gdGhhdFxuICogZXZhbHVhdGVzIGEgdmFsdWUgZW1pdHRlZCBieSB0aGUgc291cmNlIE9ic2VydmFibGUgYW5kIHJldHVybnMgYSBib29sZWFuLlxuICogQWxzbyB0YWtlcyB0aGUgKHplcm8tYmFzZWQpIGluZGV4IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPFQ+fSBBbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgdGhlIHZhbHVlcyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgc28gbG9uZyBhcyBlYWNoIHZhbHVlIHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIGRlZmluZWQgYnkgdGhlXG4gKiBgcHJlZGljYXRlYCwgdGhlbiBjb21wbGV0ZXMuXG4gKiBAbWV0aG9kIHRha2VXaGlsZVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRha2VXaGlsZTxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBwcmVkaWNhdGU6ICh2YWx1ZTogVCwgaW5kZXg6IG51bWJlcikgPT4gYm9vbGVhbik6IE9ic2VydmFibGU8VD4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBUYWtlV2hpbGVPcGVyYXRvcihwcmVkaWNhdGUpKTtcbn1cblxuY2xhc3MgVGFrZVdoaWxlT3BlcmF0b3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUPiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcHJlZGljYXRlOiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IGJvb2xlYW4pIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPiwgc291cmNlOiBhbnkpOiBUZWFyZG93bkxvZ2ljIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZVdoaWxlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLnByZWRpY2F0ZSkpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBUYWtlV2hpbGVTdWJzY3JpYmVyPFQ+IGV4dGVuZHMgU3Vic2NyaWJlcjxUPiB7XG4gIHByaXZhdGUgaW5kZXg6IG51bWJlciA9IDA7XG5cbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8VD4sXG4gICAgICAgICAgICAgIHByaXZhdGUgcHJlZGljYXRlOiAodmFsdWU6IFQsIGluZGV4OiBudW1iZXIpID0+IGJvb2xlYW4pIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpOiB2b2lkIHtcbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG4gICAgbGV0IHJlc3VsdDogYm9vbGVhbjtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5wcmVkaWNhdGUodmFsdWUsIHRoaXMuaW5kZXgrKyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBkZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm5leHRPckNvbXBsZXRlKHZhbHVlLCByZXN1bHQpO1xuICB9XG5cbiAgcHJpdmF0ZSBuZXh0T3JDb21wbGV0ZSh2YWx1ZTogVCwgcHJlZGljYXRlUmVzdWx0OiBib29sZWFuKTogdm9pZCB7XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgIGlmIChCb29sZWFuKHByZWRpY2F0ZVJlc3VsdCkpIHtcbiAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci90YWtlV2hpbGUudHMiLCJpbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YnNjcmliYWJsZU9yUHJvbWlzZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBUZWFyZG93bkxvZ2ljIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcblxuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vT3V0ZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IElubmVyU3Vic2NyaWJlciB9IGZyb20gJy4uL0lubmVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBzdWJzY3JpYmVUb1Jlc3VsdCB9IGZyb20gJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnO1xuXG4vKipcbiAqIEVtaXRzIGEgdmFsdWUgZnJvbSB0aGUgc291cmNlIE9ic2VydmFibGUsIHRoZW4gaWdub3JlcyBzdWJzZXF1ZW50IHNvdXJjZVxuICogdmFsdWVzIGZvciBhIGR1cmF0aW9uIGRldGVybWluZWQgYnkgYW5vdGhlciBPYnNlcnZhYmxlLCB0aGVuIHJlcGVhdHMgdGhpc1xuICogcHJvY2Vzcy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayB0aHJvdHRsZVRpbWV9LCBidXQgdGhlIHNpbGVuY2luZ1xuICogZHVyYXRpb24gaXMgZGV0ZXJtaW5lZCBieSBhIHNlY29uZCBPYnNlcnZhYmxlLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3Rocm90dGxlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGB0aHJvdHRsZWAgZW1pdHMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBvbiB0aGUgb3V0cHV0IE9ic2VydmFibGVcbiAqIHdoZW4gaXRzIGludGVybmFsIHRpbWVyIGlzIGRpc2FibGVkLCBhbmQgaWdub3JlcyBzb3VyY2UgdmFsdWVzIHdoZW4gdGhlIHRpbWVyXG4gKiBpcyBlbmFibGVkLiBJbml0aWFsbHksIHRoZSB0aW1lciBpcyBkaXNhYmxlZC4gQXMgc29vbiBhcyB0aGUgZmlyc3Qgc291cmNlXG4gKiB2YWx1ZSBhcnJpdmVzLCBpdCBpcyBmb3J3YXJkZWQgdG8gdGhlIG91dHB1dCBPYnNlcnZhYmxlLCBhbmQgdGhlbiB0aGUgdGltZXJcbiAqIGlzIGVuYWJsZWQgYnkgY2FsbGluZyB0aGUgYGR1cmF0aW9uU2VsZWN0b3JgIGZ1bmN0aW9uIHdpdGggdGhlIHNvdXJjZSB2YWx1ZSxcbiAqIHdoaWNoIHJldHVybnMgdGhlIFwiZHVyYXRpb25cIiBPYnNlcnZhYmxlLiBXaGVuIHRoZSBkdXJhdGlvbiBPYnNlcnZhYmxlIGVtaXRzIGFcbiAqIHZhbHVlIG9yIGNvbXBsZXRlcywgdGhlIHRpbWVyIGlzIGRpc2FibGVkLCBhbmQgdGhpcyBwcm9jZXNzIHJlcGVhdHMgZm9yIHRoZVxuICogbmV4dCBzb3VyY2UgdmFsdWUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBjbGlja3MgYXQgYSByYXRlIG9mIGF0IG1vc3Qgb25lIGNsaWNrIHBlciBzZWNvbmQ8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy50aHJvdHRsZShldiA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDApKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgYXVkaXR9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZX1cbiAqIEBzZWUge0BsaW5rIGRlbGF5V2hlbn1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZX1cbiAqIEBzZWUge0BsaW5rIHRocm90dGxlVGltZX1cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHZhbHVlOiBUKTogU3Vic2NyaWJhYmxlT3JQcm9taXNlfSBkdXJhdGlvblNlbGVjdG9yIEEgZnVuY3Rpb25cbiAqIHRoYXQgcmVjZWl2ZXMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSwgZm9yIGNvbXB1dGluZyB0aGUgc2lsZW5jaW5nXG4gKiBkdXJhdGlvbiBmb3IgZWFjaCBzb3VyY2UgdmFsdWUsIHJldHVybmVkIGFzIGFuIE9ic2VydmFibGUgb3IgYSBQcm9taXNlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxUPn0gQW4gT2JzZXJ2YWJsZSB0aGF0IHBlcmZvcm1zIHRoZSB0aHJvdHRsZSBvcGVyYXRpb24gdG9cbiAqIGxpbWl0IHRoZSByYXRlIG9mIGVtaXNzaW9ucyBmcm9tIHRoZSBzb3VyY2UuXG4gKiBAbWV0aG9kIHRocm90dGxlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGU8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgZHVyYXRpb25TZWxlY3RvcjogKHZhbHVlOiBUKSA9PiBTdWJzY3JpYmFibGVPclByb21pc2U8bnVtYmVyPik6IE9ic2VydmFibGU8VD4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBUaHJvdHRsZU9wZXJhdG9yKGR1cmF0aW9uU2VsZWN0b3IpKTtcbn1cblxuY2xhc3MgVGhyb3R0bGVPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBkdXJhdGlvblNlbGVjdG9yOiAodmFsdWU6IFQpID0+IFN1YnNjcmliYWJsZU9yUHJvbWlzZTxudW1iZXI+KSB7XG4gIH1cblxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8VD4sIHNvdXJjZTogYW55KTogVGVhcmRvd25Mb2dpYyB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRocm90dGxlU3Vic2NyaWJlcihzdWJzY3JpYmVyLCB0aGlzLmR1cmF0aW9uU2VsZWN0b3IpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgVGhyb3R0bGVTdWJzY3JpYmVyPFQsIFI+IGV4dGVuZHMgT3V0ZXJTdWJzY3JpYmVyPFQsIFI+IHtcbiAgcHJpdmF0ZSB0aHJvdHRsZWQ6IFN1YnNjcmlwdGlvbjtcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZGVzdGluYXRpb246IFN1YnNjcmliZXI8VD4sXG4gICAgICAgICAgICAgIHByaXZhdGUgZHVyYXRpb25TZWxlY3RvcjogKHZhbHVlOiBUKSA9PiBTdWJzY3JpYmFibGVPclByb21pc2U8bnVtYmVyPikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIGlmICghdGhpcy50aHJvdHRsZWQpIHtcbiAgICAgIHRoaXMudHJ5RHVyYXRpb25TZWxlY3Rvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB0cnlEdXJhdGlvblNlbGVjdG9yKHZhbHVlOiBUKTogdm9pZCB7XG4gICAgbGV0IGR1cmF0aW9uOiBTdWJzY3JpYmFibGVPclByb21pc2U8bnVtYmVyPiA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGR1cmF0aW9uID0gdGhpcy5kdXJhdGlvblNlbGVjdG9yKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0QW5kVGhyb3R0bGUodmFsdWUsIGR1cmF0aW9uKTtcbiAgfVxuXG4gIHByaXZhdGUgZW1pdEFuZFRocm90dGxlKHZhbHVlOiBULCBkdXJhdGlvbjogU3Vic2NyaWJhYmxlT3JQcm9taXNlPG51bWJlcj4pIHtcbiAgICB0aGlzLmFkZCh0aGlzLnRocm90dGxlZCA9IHN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGR1cmF0aW9uKSk7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfdW5zdWJzY3JpYmUoKSB7XG4gICAgY29uc3QgdGhyb3R0bGVkID0gdGhpcy50aHJvdHRsZWQ7XG4gICAgaWYgKHRocm90dGxlZCkge1xuICAgICAgdGhpcy5yZW1vdmUodGhyb3R0bGVkKTtcbiAgICAgIHRoaXMudGhyb3R0bGVkID0gbnVsbDtcbiAgICAgIHRocm90dGxlZC51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuXG4gIG5vdGlmeU5leHQob3V0ZXJWYWx1ZTogVCwgaW5uZXJWYWx1ZTogUixcbiAgICAgICAgICAgICBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgICBpbm5lclN1YjogSW5uZXJTdWJzY3JpYmVyPFQsIFI+KTogdm9pZCB7XG4gICAgdGhpcy5fdW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIG5vdGlmeUNvbXBsZXRlKCk6IHZvaWQge1xuICAgIHRoaXMuX3Vuc3Vic2NyaWJlKCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvdGhyb3R0bGUudHMiLCJpbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IElTY2hlZHVsZXIgfSBmcm9tICcuLi9TY2hlZHVsZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uLCBUZWFyZG93bkxvZ2ljIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGFzeW5jIH0gZnJvbSAnLi4vc2NoZWR1bGVyL2FzeW5jJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcblxuLyoqXG4gKiBFbWl0cyBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBPYnNlcnZhYmxlLCB0aGVuIGlnbm9yZXMgc3Vic2VxdWVudCBzb3VyY2VcbiAqIHZhbHVlcyBmb3IgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHMsIHRoZW4gcmVwZWF0cyB0aGlzIHByb2Nlc3MuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkxldHMgYSB2YWx1ZSBwYXNzLCB0aGVuIGlnbm9yZXMgc291cmNlIHZhbHVlcyBmb3IgdGhlXG4gKiBuZXh0IGBkdXJhdGlvbmAgbWlsbGlzZWNvbmRzLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3Rocm90dGxlVGltZS5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBgdGhyb3R0bGVUaW1lYCBlbWl0cyB0aGUgc291cmNlIE9ic2VydmFibGUgdmFsdWVzIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZVxuICogd2hlbiBpdHMgaW50ZXJuYWwgdGltZXIgaXMgZGlzYWJsZWQsIGFuZCBpZ25vcmVzIHNvdXJjZSB2YWx1ZXMgd2hlbiB0aGUgdGltZXJcbiAqIGlzIGVuYWJsZWQuIEluaXRpYWxseSwgdGhlIHRpbWVyIGlzIGRpc2FibGVkLiBBcyBzb29uIGFzIHRoZSBmaXJzdCBzb3VyY2VcbiAqIHZhbHVlIGFycml2ZXMsIGl0IGlzIGZvcndhcmRlZCB0byB0aGUgb3V0cHV0IE9ic2VydmFibGUsIGFuZCB0aGVuIHRoZSB0aW1lclxuICogaXMgZW5hYmxlZC4gQWZ0ZXIgYGR1cmF0aW9uYCBtaWxsaXNlY29uZHMgKG9yIHRoZSB0aW1lIHVuaXQgZGV0ZXJtaW5lZFxuICogaW50ZXJuYWxseSBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmApIGhhcyBwYXNzZWQsIHRoZSB0aW1lciBpcyBkaXNhYmxlZCxcbiAqIGFuZCB0aGlzIHByb2Nlc3MgcmVwZWF0cyBmb3IgdGhlIG5leHQgc291cmNlIHZhbHVlLiBPcHRpb25hbGx5IHRha2VzIGFcbiAqIHtAbGluayBJU2NoZWR1bGVyfSBmb3IgbWFuYWdpbmcgdGltZXJzLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkVtaXQgY2xpY2tzIGF0IGEgcmF0ZSBvZiBhdCBtb3N0IG9uZSBjbGljayBwZXIgc2Vjb25kPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3MudGhyb3R0bGVUaW1lKDEwMDApO1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayBhdWRpdFRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWJvdW5jZVRpbWV9XG4gKiBAc2VlIHtAbGluayBkZWxheX1cbiAqIEBzZWUge0BsaW5rIHNhbXBsZVRpbWV9XG4gKiBAc2VlIHtAbGluayB0aHJvdHRsZX1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gVGltZSB0byB3YWl0IGJlZm9yZSBlbWl0dGluZyBhbm90aGVyIHZhbHVlIGFmdGVyXG4gKiBlbWl0dGluZyB0aGUgbGFzdCB2YWx1ZSwgbWVhc3VyZWQgaW4gbWlsbGlzZWNvbmRzIG9yIHRoZSB0aW1lIHVuaXQgZGV0ZXJtaW5lZFxuICogaW50ZXJuYWxseSBieSB0aGUgb3B0aW9uYWwgYHNjaGVkdWxlcmAuXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcj1hc3luY10gVGhlIHtAbGluayBJU2NoZWR1bGVyfSB0byB1c2UgZm9yXG4gKiBtYW5hZ2luZyB0aGUgdGltZXJzIHRoYXQgaGFuZGxlIHRoZSBzYW1wbGluZy5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8VD59IEFuIE9ic2VydmFibGUgdGhhdCBwZXJmb3JtcyB0aGUgdGhyb3R0bGUgb3BlcmF0aW9uIHRvXG4gKiBsaW1pdCB0aGUgcmF0ZSBvZiBlbWlzc2lvbnMgZnJvbSB0aGUgc291cmNlLlxuICogQG1ldGhvZCB0aHJvdHRsZVRpbWVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0aHJvdHRsZVRpbWU8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgZHVyYXRpb246IG51bWJlciwgc2NoZWR1bGVyOiBJU2NoZWR1bGVyID0gYXN5bmMpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgVGhyb3R0bGVUaW1lT3BlcmF0b3IoZHVyYXRpb24sIHNjaGVkdWxlcikpO1xufVxuXG5jbGFzcyBUaHJvdHRsZVRpbWVPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBkdXJhdGlvbjogbnVtYmVyLFxuICAgICAgICAgICAgICBwcml2YXRlIHNjaGVkdWxlcjogSVNjaGVkdWxlcikge1xuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+LCBzb3VyY2U6IGFueSk6IFRlYXJkb3duTG9naWMge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUaHJvdHRsZVRpbWVTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuZHVyYXRpb24sIHRoaXMuc2NoZWR1bGVyKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIFRocm90dGxlVGltZVN1YnNjcmliZXI8VD4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgcHJpdmF0ZSB0aHJvdHRsZWQ6IFN1YnNjcmlwdGlvbjtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxUPixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBkdXJhdGlvbjogbnVtYmVyLFxuICAgICAgICAgICAgICBwcml2YXRlIHNjaGVkdWxlcjogSVNjaGVkdWxlcikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCkge1xuICAgIGlmICghdGhpcy50aHJvdHRsZWQpIHtcbiAgICAgIHRoaXMuYWRkKHRoaXMudGhyb3R0bGVkID0gdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hOZXh0LCB0aGlzLmR1cmF0aW9uLCB7IHN1YnNjcmliZXI6IHRoaXMgfSkpO1xuICAgICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBjbGVhclRocm90dGxlKCkge1xuICAgIGNvbnN0IHRocm90dGxlZCA9IHRoaXMudGhyb3R0bGVkO1xuICAgIGlmICh0aHJvdHRsZWQpIHtcbiAgICAgIHRocm90dGxlZC51bnN1YnNjcmliZSgpO1xuICAgICAgdGhpcy5yZW1vdmUodGhyb3R0bGVkKTtcbiAgICAgIHRoaXMudGhyb3R0bGVkID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuaW50ZXJmYWNlIERpc3BhdGNoQXJnPFQ+IHtcbiAgc3Vic2NyaWJlcjogVGhyb3R0bGVUaW1lU3Vic2NyaWJlcjxUPjtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hOZXh0PFQ+KGFyZzogRGlzcGF0Y2hBcmc8VD4pIHtcbiAgY29uc3QgeyBzdWJzY3JpYmVyIH0gPSBhcmc7XG4gIHN1YnNjcmliZXIuY2xlYXJUaHJvdHRsZSgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci90aHJvdHRsZVRpbWUudHMiLCJpbXBvcnQgeyBBY3Rpb24gfSBmcm9tICcuLi9zY2hlZHVsZXIvQWN0aW9uJztcbmltcG9ydCB7IGFzeW5jIH0gZnJvbSAnLi4vc2NoZWR1bGVyL2FzeW5jJztcbmltcG9ydCB7IGlzRGF0ZSB9IGZyb20gJy4uL3V0aWwvaXNEYXRlJztcbmltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgSVNjaGVkdWxlciB9IGZyb20gJy4uL1NjaGVkdWxlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBUZWFyZG93bkxvZ2ljIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IFRpbWVvdXRFcnJvciB9IGZyb20gJy4uL3V0aWwvVGltZW91dEVycm9yJztcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gZHVlXG4gKiBAcGFyYW0ge1NjaGVkdWxlcn0gW3NjaGVkdWxlcl1cbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj58V2ViU29ja2V0U3ViamVjdDxUPnxPYnNlcnZhYmxlPFQ+fVxuICogQG1ldGhvZCB0aW1lb3V0XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGltZW91dDxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVlOiBudW1iZXIgfCBEYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NoZWR1bGVyOiBJU2NoZWR1bGVyID0gYXN5bmMpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgY29uc3QgYWJzb2x1dGVUaW1lb3V0ID0gaXNEYXRlKGR1ZSk7XG4gIGNvbnN0IHdhaXRGb3IgPSBhYnNvbHV0ZVRpbWVvdXQgPyAoK2R1ZSAtIHNjaGVkdWxlci5ub3coKSkgOiBNYXRoLmFicyg8bnVtYmVyPmR1ZSk7XG4gIHJldHVybiB0aGlzLmxpZnQobmV3IFRpbWVvdXRPcGVyYXRvcih3YWl0Rm9yLCBhYnNvbHV0ZVRpbWVvdXQsIHNjaGVkdWxlciwgbmV3IFRpbWVvdXRFcnJvcigpKSk7XG59XG5cbmNsYXNzIFRpbWVvdXRPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFQ+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB3YWl0Rm9yOiBudW1iZXIsXG4gICAgICAgICAgICAgIHByaXZhdGUgYWJzb2x1dGVUaW1lb3V0OiBib29sZWFuLFxuICAgICAgICAgICAgICBwcml2YXRlIHNjaGVkdWxlcjogSVNjaGVkdWxlcixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBlcnJvckluc3RhbmNlOiBUaW1lb3V0RXJyb3IpIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPiwgc291cmNlOiBhbnkpOiBUZWFyZG93bkxvZ2ljIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGltZW91dFN1YnNjcmliZXI8VD4oXG4gICAgICBzdWJzY3JpYmVyLCB0aGlzLmFic29sdXRlVGltZW91dCwgdGhpcy53YWl0Rm9yLCB0aGlzLnNjaGVkdWxlciwgdGhpcy5lcnJvckluc3RhbmNlXG4gICAgKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIFRpbWVvdXRTdWJzY3JpYmVyPFQ+IGV4dGVuZHMgU3Vic2NyaWJlcjxUPiB7XG5cbiAgcHJpdmF0ZSBhY3Rpb246IEFjdGlvbjxUaW1lb3V0U3Vic2NyaWJlcjxUPj4gPSBudWxsO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFQ+LFxuICAgICAgICAgICAgICBwcml2YXRlIGFic29sdXRlVGltZW91dDogYm9vbGVhbixcbiAgICAgICAgICAgICAgcHJpdmF0ZSB3YWl0Rm9yOiBudW1iZXIsXG4gICAgICAgICAgICAgIHByaXZhdGUgc2NoZWR1bGVyOiBJU2NoZWR1bGVyLFxuICAgICAgICAgICAgICBwcml2YXRlIGVycm9ySW5zdGFuY2U6IFRpbWVvdXRFcnJvcikge1xuICAgIHN1cGVyKGRlc3RpbmF0aW9uKTtcbiAgICB0aGlzLnNjaGVkdWxlVGltZW91dCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZGlzcGF0Y2hUaW1lb3V0PFQ+KHN1YnNjcmliZXI6IFRpbWVvdXRTdWJzY3JpYmVyPFQ+KTogdm9pZCB7XG4gICAgc3Vic2NyaWJlci5lcnJvcihzdWJzY3JpYmVyLmVycm9ySW5zdGFuY2UpO1xuICB9XG5cbiAgcHJpdmF0ZSBzY2hlZHVsZVRpbWVvdXQoKTogdm9pZCB7XG4gICAgY29uc3QgeyBhY3Rpb24gfSA9IHRoaXM7XG4gICAgaWYgKGFjdGlvbikge1xuICAgICAgLy8gUmVjeWNsZSB0aGUgYWN0aW9uIGlmIHdlJ3ZlIGFscmVhZHkgc2NoZWR1bGVkIG9uZS4gQWxsIHRoZSBwcm9kdWN0aW9uXG4gICAgICAvLyBTY2hlZHVsZXIgQWN0aW9ucyBtdXRhdGUgdGhlaXIgc3RhdGUvZGVsYXkgdGltZSBhbmQgcmV0dXJuIHRoZW1lc2VsdmVzLlxuICAgICAgLy8gVmlydHVhbEFjdGlvbnMgYXJlIGltbXV0YWJsZSwgc28gdGhleSBjcmVhdGUgYW5kIHJldHVybiBhIGNsb25lLiBJbiB0aGlzXG4gICAgICAvLyBjYXNlLCB3ZSBuZWVkIHRvIHNldCB0aGUgYWN0aW9uIHJlZmVyZW5jZSB0byB0aGUgbW9zdCByZWNlbnQgVmlydHVhbEFjdGlvbixcbiAgICAgIC8vIHRvIGVuc3VyZSB0aGF0J3MgdGhlIG9uZSB3ZSBjbG9uZSBmcm9tIG5leHQgdGltZS5cbiAgICAgIHRoaXMuYWN0aW9uID0gKDxBY3Rpb248VGltZW91dFN1YnNjcmliZXI8VD4+PiBhY3Rpb24uc2NoZWR1bGUodGhpcywgdGhpcy53YWl0Rm9yKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKHRoaXMuYWN0aW9uID0gKDxBY3Rpb248VGltZW91dFN1YnNjcmliZXI8VD4+PiB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZShcbiAgICAgICAgVGltZW91dFN1YnNjcmliZXIuZGlzcGF0Y2hUaW1lb3V0LCB0aGlzLndhaXRGb3IsIHRoaXNcbiAgICAgICkpKTtcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuYWJzb2x1dGVUaW1lb3V0KSB7XG4gICAgICB0aGlzLnNjaGVkdWxlVGltZW91dCgpO1xuICAgIH1cbiAgICBzdXBlci5fbmV4dCh2YWx1ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3Vuc3Vic2NyaWJlKCkge1xuICAgIHRoaXMuYWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLnNjaGVkdWxlciA9IG51bGw7XG4gICAgdGhpcy5lcnJvckluc3RhbmNlID0gbnVsbDtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci90aW1lb3V0LnRzIiwiaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi4vc2NoZWR1bGVyL0FjdGlvbic7XG5pbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IElTY2hlZHVsZXIgfSBmcm9tICcuLi9TY2hlZHVsZXInO1xuaW1wb3J0IHsgYXN5bmMgfSBmcm9tICcuLi9zY2hlZHVsZXIvYXN5bmMnO1xuaW1wb3J0IHsgVGVhcmRvd25Mb2dpYyB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZhYmxlSW5wdXQgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGlzRGF0ZSB9IGZyb20gJy4uL3V0aWwvaXNEYXRlJztcbmltcG9ydCB7IE91dGVyU3Vic2NyaWJlciB9IGZyb20gJy4uL091dGVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBzdWJzY3JpYmVUb1Jlc3VsdCB9IGZyb20gJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmV4cG9ydCBmdW5jdGlvbiB0aW1lb3V0V2l0aDxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBkdWU6IG51bWJlciB8IERhdGUsIHdpdGhPYnNlcnZhYmxlOiBPYnNlcnZhYmxlSW5wdXQ8VD4sIHNjaGVkdWxlcj86IElTY2hlZHVsZXIpOiBPYnNlcnZhYmxlPFQ+O1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVvdXRXaXRoPFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIGR1ZTogbnVtYmVyIHwgRGF0ZSwgd2l0aE9ic2VydmFibGU6IE9ic2VydmFibGVJbnB1dDxSPiwgc2NoZWR1bGVyPzogSVNjaGVkdWxlcik6IE9ic2VydmFibGU8VCB8IFI+O1xuLyogdHNsaW50OmVuYWJsZTptYXgtbGluZS1sZW5ndGggKi9cblxuLyoqXG4gKiBAcGFyYW0gZHVlXG4gKiBAcGFyYW0gd2l0aE9ic2VydmFibGVcbiAqIEBwYXJhbSBzY2hlZHVsZXJcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj58V2ViU29ja2V0U3ViamVjdDxUPnxPYnNlcnZhYmxlPFQ+fVxuICogQG1ldGhvZCB0aW1lb3V0V2l0aFxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWVvdXRXaXRoPFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIGR1ZTogbnVtYmVyIHwgRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aXRoT2JzZXJ2YWJsZTogT2JzZXJ2YWJsZUlucHV0PFI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlcjogSVNjaGVkdWxlciA9IGFzeW5jKTogT2JzZXJ2YWJsZTxUIHwgUj4ge1xuICBsZXQgYWJzb2x1dGVUaW1lb3V0ID0gaXNEYXRlKGR1ZSk7XG4gIGxldCB3YWl0Rm9yID0gYWJzb2x1dGVUaW1lb3V0ID8gKCtkdWUgLSBzY2hlZHVsZXIubm93KCkpIDogTWF0aC5hYnMoPG51bWJlcj5kdWUpO1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBUaW1lb3V0V2l0aE9wZXJhdG9yKHdhaXRGb3IsIGFic29sdXRlVGltZW91dCwgd2l0aE9ic2VydmFibGUsIHNjaGVkdWxlcikpO1xufVxuXG5jbGFzcyBUaW1lb3V0V2l0aE9wZXJhdG9yPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVD4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHdhaXRGb3I6IG51bWJlcixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBhYnNvbHV0ZVRpbWVvdXQ6IGJvb2xlYW4sXG4gICAgICAgICAgICAgIHByaXZhdGUgd2l0aE9ic2VydmFibGU6IE9ic2VydmFibGVJbnB1dDxhbnk+LFxuICAgICAgICAgICAgICBwcml2YXRlIHNjaGVkdWxlcjogSVNjaGVkdWxlcikge1xuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPFQ+LCBzb3VyY2U6IGFueSk6IFRlYXJkb3duTG9naWMge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUaW1lb3V0V2l0aFN1YnNjcmliZXIoXG4gICAgICBzdWJzY3JpYmVyLCB0aGlzLmFic29sdXRlVGltZW91dCwgdGhpcy53YWl0Rm9yLCB0aGlzLndpdGhPYnNlcnZhYmxlLCB0aGlzLnNjaGVkdWxlclxuICAgICkpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBUaW1lb3V0V2l0aFN1YnNjcmliZXI8VCwgUj4gZXh0ZW5kcyBPdXRlclN1YnNjcmliZXI8VCwgUj4ge1xuXG4gIHByaXZhdGUgYWN0aW9uOiBBY3Rpb248VGltZW91dFdpdGhTdWJzY3JpYmVyPFQsIFI+PiA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8VD4sXG4gICAgICAgICAgICAgIHByaXZhdGUgYWJzb2x1dGVUaW1lb3V0OiBib29sZWFuLFxuICAgICAgICAgICAgICBwcml2YXRlIHdhaXRGb3I6IG51bWJlcixcbiAgICAgICAgICAgICAgcHJpdmF0ZSB3aXRoT2JzZXJ2YWJsZTogT2JzZXJ2YWJsZUlucHV0PGFueT4sXG4gICAgICAgICAgICAgIHByaXZhdGUgc2NoZWR1bGVyOiBJU2NoZWR1bGVyKSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICAgIHRoaXMuc2NoZWR1bGVUaW1lb3V0KCk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBkaXNwYXRjaFRpbWVvdXQ8VCwgUj4oc3Vic2NyaWJlcjogVGltZW91dFdpdGhTdWJzY3JpYmVyPFQsIFI+KTogdm9pZCB7XG4gICAgY29uc3QgeyB3aXRoT2JzZXJ2YWJsZSB9ID0gc3Vic2NyaWJlcjtcbiAgICAoPGFueT4gc3Vic2NyaWJlcikuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSgpO1xuICAgIHN1YnNjcmliZXIuYWRkKHN1YnNjcmliZVRvUmVzdWx0KHN1YnNjcmliZXIsIHdpdGhPYnNlcnZhYmxlKSk7XG4gIH1cblxuICBwcml2YXRlIHNjaGVkdWxlVGltZW91dCgpOiB2b2lkIHtcbiAgICBjb25zdCB7IGFjdGlvbiB9ID0gdGhpcztcbiAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAvLyBSZWN5Y2xlIHRoZSBhY3Rpb24gaWYgd2UndmUgYWxyZWFkeSBzY2hlZHVsZWQgb25lLiBBbGwgdGhlIHByb2R1Y3Rpb25cbiAgICAgIC8vIFNjaGVkdWxlciBBY3Rpb25zIG11dGF0ZSB0aGVpciBzdGF0ZS9kZWxheSB0aW1lIGFuZCByZXR1cm4gdGhlbWVzZWx2ZXMuXG4gICAgICAvLyBWaXJ0dWFsQWN0aW9ucyBhcmUgaW1tdXRhYmxlLCBzbyB0aGV5IGNyZWF0ZSBhbmQgcmV0dXJuIGEgY2xvbmUuIEluIHRoaXNcbiAgICAgIC8vIGNhc2UsIHdlIG5lZWQgdG8gc2V0IHRoZSBhY3Rpb24gcmVmZXJlbmNlIHRvIHRoZSBtb3N0IHJlY2VudCBWaXJ0dWFsQWN0aW9uLFxuICAgICAgLy8gdG8gZW5zdXJlIHRoYXQncyB0aGUgb25lIHdlIGNsb25lIGZyb20gbmV4dCB0aW1lLlxuICAgICAgdGhpcy5hY3Rpb24gPSAoPEFjdGlvbjxUaW1lb3V0V2l0aFN1YnNjcmliZXI8VCwgUj4+PiBhY3Rpb24uc2NoZWR1bGUodGhpcywgdGhpcy53YWl0Rm9yKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKHRoaXMuYWN0aW9uID0gKDxBY3Rpb248VGltZW91dFdpdGhTdWJzY3JpYmVyPFQsIFI+Pj4gdGhpcy5zY2hlZHVsZXIuc2NoZWR1bGUoXG4gICAgICAgIFRpbWVvdXRXaXRoU3Vic2NyaWJlci5kaXNwYXRjaFRpbWVvdXQsIHRoaXMud2FpdEZvciwgdGhpc1xuICAgICAgKSkpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIGlmICghdGhpcy5hYnNvbHV0ZVRpbWVvdXQpIHtcbiAgICAgIHRoaXMuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgfVxuICAgIHN1cGVyLl9uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfdW5zdWJzY3JpYmUoKSB7XG4gICAgdGhpcy5hY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuc2NoZWR1bGVyID0gbnVsbDtcbiAgICB0aGlzLndpdGhPYnNlcnZhYmxlID0gbnVsbDtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci90aW1lb3V0V2l0aC50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuXG4vKipcbiAqIEByZXR1cm4ge09ic2VydmFibGU8YW55W10+fFdlYlNvY2tldFN1YmplY3Q8VD58T2JzZXJ2YWJsZTxUPn1cbiAqIEBtZXRob2QgdG9BcnJheVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQXJyYXk8VD4odGhpczogT2JzZXJ2YWJsZTxUPik6IE9ic2VydmFibGU8VFtdPiB7XG4gIHJldHVybiB0aGlzLmxpZnQobmV3IFRvQXJyYXlPcGVyYXRvcigpKTtcbn1cblxuY2xhc3MgVG9BcnJheU9wZXJhdG9yPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgVFtdPiB7XG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUW10+LCBzb3VyY2U6IGFueSk6IGFueSB7XG4gICAgcmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUobmV3IFRvQXJyYXlTdWJzY3JpYmVyKHN1YnNjcmliZXIpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgVG9BcnJheVN1YnNjcmliZXI8VD4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcblxuICBwcml2YXRlIGFycmF5OiBUW10gPSBbXTtcblxuICBjb25zdHJ1Y3RvcihkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxUW10+KSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHg6IFQpIHtcbiAgICB0aGlzLmFycmF5LnB1c2goeCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbXBsZXRlKCkge1xuICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dCh0aGlzLmFycmF5KTtcbiAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3IvdG9BcnJheS50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHJvb3QgfSBmcm9tICcuLi91dGlsL3Jvb3QnO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTptYXgtbGluZS1sZW5ndGggKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1Byb21pc2U8VD4odGhpczogT2JzZXJ2YWJsZTxUPik6IFByb21pc2U8VD47XG5leHBvcnQgZnVuY3Rpb24gdG9Qcm9taXNlPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIFByb21pc2VDdG9yOiB0eXBlb2YgUHJvbWlzZSk6IFByb21pc2U8VD47XG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIE9ic2VydmFibGUgc2VxdWVuY2UgdG8gYSBFUzIwMTUgY29tcGxpYW50IHByb21pc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFVzaW5nIG5vcm1hbCBFUzIwMTVcbiAqIGxldCBzb3VyY2UgPSBSeC5PYnNlcnZhYmxlXG4gKiAgIC5qdXN0KDQyKVxuICogICAudG9Qcm9taXNlKCk7XG4gKlxuICogc291cmNlLnRoZW4oKHZhbHVlKSA9PiBjb25zb2xlLmxvZygnVmFsdWU6ICVzJywgdmFsdWUpKTtcbiAqIC8vID0+IFZhbHVlOiA0MlxuICpcbiAqIC8vIFJlamVjdGVkIFByb21pc2VcbiAqIC8vIFVzaW5nIG5vcm1hbCBFUzIwMTVcbiAqIGxldCBzb3VyY2UgPSBSeC5PYnNlcnZhYmxlXG4gKiAgIC50aHJvdyhuZXcgRXJyb3IoJ3dvb3BzJykpXG4gKiAgIC50b1Byb21pc2UoKTtcbiAqXG4gKiBzb3VyY2VcbiAqICAgLnRoZW4oKHZhbHVlKSA9PiBjb25zb2xlLmxvZygnVmFsdWU6ICVzJywgdmFsdWUpKVxuICogICAuY2F0Y2goKGVycikgPT4gY29uc29sZS5sb2coJ0Vycm9yOiAlcycsIGVycikpO1xuICogLy8gPT4gRXJyb3I6IEVycm9yOiB3b29wc1xuICpcbiAqIC8vIFNldHRpbmcgdmlhIHRoZSBjb25maWdcbiAqIFJ4LmNvbmZpZy5Qcm9taXNlID0gUlNWUC5Qcm9taXNlO1xuICpcbiAqIGxldCBzb3VyY2UgPSBSeC5PYnNlcnZhYmxlXG4gKiAgIC5vZig0MilcbiAqICAgLnRvUHJvbWlzZSgpO1xuICpcbiAqIHNvdXJjZS50aGVuKCh2YWx1ZSkgPT4gY29uc29sZS5sb2coJ1ZhbHVlOiAlcycsIHZhbHVlKSk7XG4gKiAvLyA9PiBWYWx1ZTogNDJcbiAqXG4gKiAvLyBTZXR0aW5nIHZpYSB0aGUgbWV0aG9kXG4gKiBsZXQgc291cmNlID0gUnguT2JzZXJ2YWJsZVxuICogICAuanVzdCg0MilcbiAqICAgLnRvUHJvbWlzZShSU1ZQLlByb21pc2UpO1xuICpcbiAqIHNvdXJjZS50aGVuKCh2YWx1ZSkgPT4gY29uc29sZS5sb2coJ1ZhbHVlOiAlcycsIHZhbHVlKSk7XG4gKiAvLyA9PiBWYWx1ZTogNDJcbiAqXG4gKiBAcGFyYW0gUHJvbWlzZUN0b3IgcHJvbWlzZSBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHByb21pc2UuIElmIG5vdCBwcm92aWRlZCxcbiAqIGl0IHdpbGwgbG9vayBmb3IgYSBjb25zdHJ1Y3RvciBmaXJzdCBpbiBSeC5jb25maWcuUHJvbWlzZSB0aGVuIGZhbGwgYmFjayB0b1xuICogdGhlIG5hdGl2ZSBQcm9taXNlIGNvbnN0cnVjdG9yIGlmIGF2YWlsYWJsZS5cbiAqIEByZXR1cm4ge1Byb21pc2U8VD59IEFuIEVTMjAxNSBjb21wYXRpYmxlIHByb21pc2Ugd2l0aCB0aGUgbGFzdCB2YWx1ZSBmcm9tXG4gKiB0aGUgb2JzZXJ2YWJsZSBzZXF1ZW5jZS5cbiAqIEBtZXRob2QgdG9Qcm9taXNlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Qcm9taXNlPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIFByb21pc2VDdG9yPzogdHlwZW9mIFByb21pc2UpOiBQcm9taXNlPFQ+IHtcbiAgaWYgKCFQcm9taXNlQ3Rvcikge1xuICAgIGlmIChyb290LlJ4ICYmIHJvb3QuUnguY29uZmlnICYmIHJvb3QuUnguY29uZmlnLlByb21pc2UpIHtcbiAgICAgIFByb21pc2VDdG9yID0gcm9vdC5SeC5jb25maWcuUHJvbWlzZTtcbiAgICB9IGVsc2UgaWYgKHJvb3QuUHJvbWlzZSkge1xuICAgICAgUHJvbWlzZUN0b3IgPSByb290LlByb21pc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFQcm9taXNlQ3Rvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignbm8gUHJvbWlzZSBpbXBsIGZvdW5kJyk7XG4gIH1cblxuICByZXR1cm4gbmV3IFByb21pc2VDdG9yKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsZXQgdmFsdWU6IGFueTtcbiAgICB0aGlzLnN1YnNjcmliZSgoeDogVCkgPT4gdmFsdWUgPSB4LCAoZXJyOiBhbnkpID0+IHJlamVjdChlcnIpLCAoKSA9PiByZXNvbHZlKHZhbHVlKSk7XG4gIH0pO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci90b1Byb21pc2UudHMiLCJpbXBvcnQgeyBPcGVyYXRvciB9IGZyb20gJy4uL09wZXJhdG9yJztcbmltcG9ydCB7IFN1YnNjcmliZXIgfSBmcm9tICcuLi9TdWJzY3JpYmVyJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICcuLi9TdWJqZWN0JztcblxuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vT3V0ZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IElubmVyU3Vic2NyaWJlciB9IGZyb20gJy4uL0lubmVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBzdWJzY3JpYmVUb1Jlc3VsdCB9IGZyb20gJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnO1xuXG4vKipcbiAqIEJyYW5jaCBvdXQgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBhcyBhIG5lc3RlZCBPYnNlcnZhYmxlIHdoZW5ldmVyXG4gKiBgd2luZG93Qm91bmRhcmllc2AgZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYnVmZmVyfSwgYnV0IGVtaXRzIGEgbmVzdGVkIE9ic2VydmFibGVcbiAqIGluc3RlYWQgb2YgYW4gYXJyYXkuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvd2luZG93LnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdpbmRvd3Mgb2YgaXRlbXMgaXQgY29sbGVjdHMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgZW1pdHMgY29ubmVjdGVkLCBub24tb3ZlcmxhcHBpbmdcbiAqIHdpbmRvd3MuIEl0IGVtaXRzIHRoZSBjdXJyZW50IHdpbmRvdyBhbmQgb3BlbnMgYSBuZXcgb25lIHdoZW5ldmVyIHRoZVxuICogT2JzZXJ2YWJsZSBgd2luZG93Qm91bmRhcmllc2AgZW1pdHMgYW4gaXRlbS4gQmVjYXVzZSBlYWNoIHdpbmRvdyBpcyBhblxuICogT2JzZXJ2YWJsZSwgdGhlIG91dHB1dCBpcyBhIGhpZ2hlci1vcmRlciBPYnNlcnZhYmxlLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkluIGV2ZXJ5IHdpbmRvdyBvZiAxIHNlY29uZCBlYWNoLCBlbWl0IGF0IG1vc3QgMiBjbGljayBldmVudHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIGludGVydmFsID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3Mud2luZG93KGludGVydmFsKVxuICogICAubWFwKHdpbiA9PiB3aW4udGFrZSgyKSkgLy8gZWFjaCB3aW5kb3cgaGFzIGF0IG1vc3QgMiBlbWlzc2lvbnNcbiAqICAgLm1lcmdlQWxsKCk7IC8vIGZsYXR0ZW4gdGhlIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXNcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgd2luZG93Q291bnR9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUaW1lfVxuICogQHNlZSB7QGxpbmsgd2luZG93VG9nZ2xlfVxuICogQHNlZSB7QGxpbmsgd2luZG93V2hlbn1cbiAqIEBzZWUge0BsaW5rIGJ1ZmZlcn1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGU8YW55Pn0gd2luZG93Qm91bmRhcmllcyBBbiBPYnNlcnZhYmxlIHRoYXQgY29tcGxldGVzIHRoZVxuICogcHJldmlvdXMgd2luZG93IGFuZCBzdGFydHMgYSBuZXcgd2luZG93LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxPYnNlcnZhYmxlPFQ+Pn0gQW4gT2JzZXJ2YWJsZSBvZiB3aW5kb3dzLCB3aGljaCBhcmVcbiAqIE9ic2VydmFibGVzIGVtaXR0aW5nIHZhbHVlcyBvZiB0aGUgc291cmNlIE9ic2VydmFibGUuXG4gKiBAbWV0aG9kIHdpbmRvd1xuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpbmRvdzxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB3aW5kb3dCb3VuZGFyaWVzOiBPYnNlcnZhYmxlPGFueT4pOiBPYnNlcnZhYmxlPE9ic2VydmFibGU8VD4+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgV2luZG93T3BlcmF0b3I8VD4od2luZG93Qm91bmRhcmllcykpO1xufVxuXG5jbGFzcyBXaW5kb3dPcGVyYXRvcjxUPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIE9ic2VydmFibGU8VD4+IHtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHdpbmRvd0JvdW5kYXJpZXM6IE9ic2VydmFibGU8YW55Pikge1xuICB9XG5cbiAgY2FsbChzdWJzY3JpYmVyOiBTdWJzY3JpYmVyPE9ic2VydmFibGU8VD4+LCBzb3VyY2U6IGFueSk6IGFueSB7XG4gICAgY29uc3Qgd2luZG93U3Vic2NyaWJlciA9IG5ldyBXaW5kb3dTdWJzY3JpYmVyKHN1YnNjcmliZXIpO1xuICAgIGNvbnN0IHNvdXJjZVN1YnNjcmlwdGlvbiA9IHNvdXJjZS5zdWJzY3JpYmUod2luZG93U3Vic2NyaWJlcik7XG4gICAgaWYgKCFzb3VyY2VTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICB3aW5kb3dTdWJzY3JpYmVyLmFkZChzdWJzY3JpYmVUb1Jlc3VsdCh3aW5kb3dTdWJzY3JpYmVyLCB0aGlzLndpbmRvd0JvdW5kYXJpZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZVN1YnNjcmlwdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgV2luZG93U3Vic2NyaWJlcjxUPiBleHRlbmRzIE91dGVyU3Vic2NyaWJlcjxULCBhbnk+IHtcblxuICBwcml2YXRlIHdpbmRvdzogU3ViamVjdDxUPiA9IG5ldyBTdWJqZWN0PFQ+KCk7XG5cbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8T2JzZXJ2YWJsZTxUPj4pIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gICAgZGVzdGluYXRpb24ubmV4dCh0aGlzLndpbmRvdyk7XG4gIH1cblxuICBub3RpZnlOZXh0KG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IGFueSxcbiAgICAgICAgICAgICBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgICBpbm5lclN1YjogSW5uZXJTdWJzY3JpYmVyPFQsIGFueT4pOiB2b2lkIHtcbiAgICB0aGlzLm9wZW5XaW5kb3coKTtcbiAgfVxuXG4gIG5vdGlmeUVycm9yKGVycm9yOiBhbnksIGlubmVyU3ViOiBJbm5lclN1YnNjcmliZXI8VCwgYW55Pik6IHZvaWQge1xuICAgIHRoaXMuX2Vycm9yKGVycm9yKTtcbiAgfVxuXG4gIG5vdGlmeUNvbXBsZXRlKGlubmVyU3ViOiBJbm5lclN1YnNjcmliZXI8VCwgYW55Pik6IHZvaWQge1xuICAgIHRoaXMuX2NvbXBsZXRlKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpOiB2b2lkIHtcbiAgICB0aGlzLndpbmRvdy5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfZXJyb3IoZXJyOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLndpbmRvdy5lcnJvcihlcnIpO1xuICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY29tcGxldGUoKTogdm9pZCB7XG4gICAgdGhpcy53aW5kb3cuY29tcGxldGUoKTtcbiAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3Vuc3Vic2NyaWJlKCkge1xuICAgIHRoaXMud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgb3BlbldpbmRvdygpOiB2b2lkICB7XG4gICAgY29uc3QgcHJldldpbmRvdyA9IHRoaXMud2luZG93O1xuICAgIGlmIChwcmV2V2luZG93KSB7XG4gICAgICBwcmV2V2luZG93LmNvbXBsZXRlKCk7XG4gICAgfVxuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gdGhpcy5kZXN0aW5hdGlvbjtcbiAgICBjb25zdCBuZXdXaW5kb3cgPSB0aGlzLndpbmRvdyA9IG5ldyBTdWJqZWN0PFQ+KCk7XG4gICAgZGVzdGluYXRpb24ubmV4dChuZXdXaW5kb3cpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL3dpbmRvdy50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJy4uL1N1YmplY3QnO1xuXG4vKipcbiAqIEJyYW5jaCBvdXQgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBhcyBhIG5lc3RlZCBPYnNlcnZhYmxlIHdpdGggZWFjaFxuICogbmVzdGVkIE9ic2VydmFibGUgZW1pdHRpbmcgYXQgbW9zdCBgd2luZG93U2l6ZWAgdmFsdWVzLlxuICpcbiAqIDxzcGFuIGNsYXNzPVwiaW5mb3JtYWxcIj5JdCdzIGxpa2Uge0BsaW5rIGJ1ZmZlckNvdW50fSwgYnV0IGVtaXRzIGEgbmVzdGVkXG4gKiBPYnNlcnZhYmxlIGluc3RlYWQgb2YgYW4gYXJyYXkuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvd2luZG93Q291bnQucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2luZG93cyBvZiBpdGVtcyBpdCBjb2xsZWN0cyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBlbWl0cyB3aW5kb3dzIGV2ZXJ5IGBzdGFydFdpbmRvd0V2ZXJ5YFxuICogaXRlbXMsIGVhY2ggY29udGFpbmluZyBubyBtb3JlIHRoYW4gYHdpbmRvd1NpemVgIGl0ZW1zLiBXaGVuIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUgY29tcGxldGVzIG9yIGVuY291bnRlcnMgYW4gZXJyb3IsIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBlbWl0c1xuICogdGhlIGN1cnJlbnQgd2luZG93IGFuZCBwcm9wYWdhdGVzIHRoZSBub3RpZmljYXRpb24gZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBJZiBgc3RhcnRXaW5kb3dFdmVyeWAgaXMgbm90IHByb3ZpZGVkLCB0aGVuIG5ldyB3aW5kb3dzIGFyZVxuICogc3RhcnRlZCBpbW1lZGlhdGVseSBhdCB0aGUgc3RhcnQgb2YgdGhlIHNvdXJjZSBhbmQgd2hlbiBlYWNoIHdpbmRvdyBjb21wbGV0ZXNcbiAqIHdpdGggc2l6ZSBgd2luZG93U2l6ZWAuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+SWdub3JlIGV2ZXJ5IDNyZCBjbGljayBldmVudCwgc3RhcnRpbmcgZnJvbSB0aGUgZmlyc3Qgb25lPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3Mud2luZG93Q291bnQoMylcbiAqICAgLm1hcCh3aW4gPT4gd2luLnNraXAoMSkpIC8vIHNraXAgZmlyc3Qgb2YgZXZlcnkgMyBjbGlja3NcbiAqICAgLm1lcmdlQWxsKCk7IC8vIGZsYXR0ZW4gdGhlIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXNcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+SWdub3JlIGV2ZXJ5IDNyZCBjbGljayBldmVudCwgc3RhcnRpbmcgZnJvbSB0aGUgdGhpcmQgb25lPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3Mud2luZG93Q291bnQoMiwgMylcbiAqICAgLm1lcmdlQWxsKCk7IC8vIGZsYXR0ZW4gdGhlIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXNcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgd2luZG93fVxuICogQHNlZSB7QGxpbmsgd2luZG93VGltZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RvZ2dsZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1doZW59XG4gKiBAc2VlIHtAbGluayBidWZmZXJDb3VudH1cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gd2luZG93U2l6ZSBUaGUgbWF4aW11bSBudW1iZXIgb2YgdmFsdWVzIGVtaXR0ZWQgYnkgZWFjaFxuICogd2luZG93LlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydFdpbmRvd0V2ZXJ5XSBJbnRlcnZhbCBhdCB3aGljaCB0byBzdGFydCBhIG5ldyB3aW5kb3cuXG4gKiBGb3IgZXhhbXBsZSBpZiBgc3RhcnRXaW5kb3dFdmVyeWAgaXMgYDJgLCB0aGVuIGEgbmV3IHdpbmRvdyB3aWxsIGJlIHN0YXJ0ZWRcbiAqIG9uIGV2ZXJ5IG90aGVyIHZhbHVlIGZyb20gdGhlIHNvdXJjZS4gQSBuZXcgd2luZG93IGlzIHN0YXJ0ZWQgYXQgdGhlXG4gKiBiZWdpbm5pbmcgb2YgdGhlIHNvdXJjZSBieSBkZWZhdWx0LlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxPYnNlcnZhYmxlPFQ+Pn0gQW4gT2JzZXJ2YWJsZSBvZiB3aW5kb3dzLCB3aGljaCBpbiB0dXJuXG4gKiBhcmUgT2JzZXJ2YWJsZSBvZiB2YWx1ZXMuXG4gKiBAbWV0aG9kIHdpbmRvd0NvdW50XG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gd2luZG93Q291bnQ8VD4odGhpczogT2JzZXJ2YWJsZTxUPiwgd2luZG93U2l6ZTogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0V2luZG93RXZlcnk6IG51bWJlciA9IDApOiBPYnNlcnZhYmxlPE9ic2VydmFibGU8VD4+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgV2luZG93Q291bnRPcGVyYXRvcjxUPih3aW5kb3dTaXplLCBzdGFydFdpbmRvd0V2ZXJ5KSk7XG59XG5cbmNsYXNzIFdpbmRvd0NvdW50T3BlcmF0b3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBPYnNlcnZhYmxlPFQ+PiB7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB3aW5kb3dTaXplOiBudW1iZXIsXG4gICAgICAgICAgICAgIHByaXZhdGUgc3RhcnRXaW5kb3dFdmVyeTogbnVtYmVyKSB7XG4gIH1cblxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8T2JzZXJ2YWJsZTxUPj4sIHNvdXJjZTogYW55KTogYW55IHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgV2luZG93Q291bnRTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMud2luZG93U2l6ZSwgdGhpcy5zdGFydFdpbmRvd0V2ZXJ5KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIFdpbmRvd0NvdW50U3Vic2NyaWJlcjxUPiBleHRlbmRzIFN1YnNjcmliZXI8VD4ge1xuICBwcml2YXRlIHdpbmRvd3M6IFN1YmplY3Q8VD5bXSA9IFsgbmV3IFN1YmplY3Q8VD4oKSBdO1xuICBwcml2YXRlIGNvdW50OiBudW1iZXIgPSAwO1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBkZXN0aW5hdGlvbjogU3Vic2NyaWJlcjxPYnNlcnZhYmxlPFQ+PixcbiAgICAgICAgICAgICAgcHJpdmF0ZSB3aW5kb3dTaXplOiBudW1iZXIsXG4gICAgICAgICAgICAgIHByaXZhdGUgc3RhcnRXaW5kb3dFdmVyeTogbnVtYmVyKSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuICAgIGRlc3RpbmF0aW9uLm5leHQodGhpcy53aW5kb3dzWzBdKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCkge1xuICAgIGNvbnN0IHN0YXJ0V2luZG93RXZlcnkgPSAodGhpcy5zdGFydFdpbmRvd0V2ZXJ5ID4gMCkgPyB0aGlzLnN0YXJ0V2luZG93RXZlcnkgOiB0aGlzLndpbmRvd1NpemU7XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgIGNvbnN0IHdpbmRvd1NpemUgPSB0aGlzLndpbmRvd1NpemU7XG4gICAgY29uc3Qgd2luZG93cyA9IHRoaXMud2luZG93cztcbiAgICBjb25zdCBsZW4gPSB3aW5kb3dzLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuICYmICF0aGlzLmNsb3NlZDsgaSsrKSB7XG4gICAgICB3aW5kb3dzW2ldLm5leHQodmFsdWUpO1xuICAgIH1cbiAgICBjb25zdCBjID0gdGhpcy5jb3VudCAtIHdpbmRvd1NpemUgKyAxO1xuICAgIGlmIChjID49IDAgJiYgYyAlIHN0YXJ0V2luZG93RXZlcnkgPT09IDAgJiYgIXRoaXMuY2xvc2VkKSB7XG4gICAgICB3aW5kb3dzLnNoaWZ0KCkuY29tcGxldGUoKTtcbiAgICB9XG4gICAgaWYgKCsrdGhpcy5jb3VudCAlIHN0YXJ0V2luZG93RXZlcnkgPT09IDAgJiYgIXRoaXMuY2xvc2VkKSB7XG4gICAgICBjb25zdCB3aW5kb3cgPSBuZXcgU3ViamVjdDxUPigpO1xuICAgICAgd2luZG93cy5wdXNoKHdpbmRvdyk7XG4gICAgICBkZXN0aW5hdGlvbi5uZXh0KHdpbmRvdyk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9lcnJvcihlcnI6IGFueSkge1xuICAgIGNvbnN0IHdpbmRvd3MgPSB0aGlzLndpbmRvd3M7XG4gICAgaWYgKHdpbmRvd3MpIHtcbiAgICAgIHdoaWxlICh3aW5kb3dzLmxlbmd0aCA+IDAgJiYgIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgIHdpbmRvd3Muc2hpZnQoKS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbXBsZXRlKCkge1xuICAgIGNvbnN0IHdpbmRvd3MgPSB0aGlzLndpbmRvd3M7XG4gICAgaWYgKHdpbmRvd3MpIHtcbiAgICAgIHdoaWxlICh3aW5kb3dzLmxlbmd0aCA+IDAgJiYgIXRoaXMuY2xvc2VkKSB7XG4gICAgICAgIHdpbmRvd3Muc2hpZnQoKS5jb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX3Vuc3Vic2NyaWJlKCkge1xuICAgIHRoaXMuY291bnQgPSAwO1xuICAgIHRoaXMud2luZG93cyA9IG51bGw7XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvb3BlcmF0b3Ivd2luZG93Q291bnQudHMiLCJpbXBvcnQgeyBJU2NoZWR1bGVyIH0gZnJvbSAnLi4vU2NoZWR1bGVyJztcbmltcG9ydCB7IEFjdGlvbiB9IGZyb20gJy4uL3NjaGVkdWxlci9BY3Rpb24nO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJy4uL1N1YmplY3QnO1xuaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBhc3luYyB9IGZyb20gJy4uL3NjaGVkdWxlci9hc3luYyc7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgaXNOdW1lcmljIH0gZnJvbSAnLi4vdXRpbC9pc051bWVyaWMnO1xuaW1wb3J0IHsgaXNTY2hlZHVsZXIgfSBmcm9tICcuLi91dGlsL2lzU2NoZWR1bGVyJztcblxuLyoqXG4gKiBCcmFuY2ggb3V0IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgYXMgYSBuZXN0ZWQgT2JzZXJ2YWJsZSBwZXJpb2RpY2FsbHlcbiAqIGluIHRpbWUuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYnVmZmVyVGltZX0sIGJ1dCBlbWl0cyBhIG5lc3RlZFxuICogT2JzZXJ2YWJsZSBpbnN0ZWFkIG9mIGFuIGFycmF5Ljwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3dpbmRvd1RpbWUucG5nXCIgd2lkdGg9XCIxMDAlXCI+XG4gKlxuICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHRoYXQgZW1pdHMgd2luZG93cyBvZiBpdGVtcyBpdCBjb2xsZWN0cyBmcm9tIHRoZSBzb3VyY2VcbiAqIE9ic2VydmFibGUuIFRoZSBvdXRwdXQgT2JzZXJ2YWJsZSBzdGFydHMgYSBuZXcgd2luZG93IHBlcmlvZGljYWxseSwgYXNcbiAqIGRldGVybWluZWQgYnkgdGhlIGB3aW5kb3dDcmVhdGlvbkludGVydmFsYCBhcmd1bWVudC4gSXQgZW1pdHMgZWFjaCB3aW5kb3dcbiAqIGFmdGVyIGEgZml4ZWQgdGltZXNwYW4sIHNwZWNpZmllZCBieSB0aGUgYHdpbmRvd1RpbWVTcGFuYCBhcmd1bWVudC4gV2hlbiB0aGVcbiAqIHNvdXJjZSBPYnNlcnZhYmxlIGNvbXBsZXRlcyBvciBlbmNvdW50ZXJzIGFuIGVycm9yLCB0aGUgb3V0cHV0IE9ic2VydmFibGVcbiAqIGVtaXRzIHRoZSBjdXJyZW50IHdpbmRvdyBhbmQgcHJvcGFnYXRlcyB0aGUgbm90aWZpY2F0aW9uIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gSWYgYHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWxgIGlzIG5vdCBwcm92aWRlZCwgdGhlIG91dHB1dFxuICogT2JzZXJ2YWJsZSBzdGFydHMgYSBuZXcgd2luZG93IHdoZW4gdGhlIHByZXZpb3VzIHdpbmRvdyBvZiBkdXJhdGlvblxuICogYHdpbmRvd1RpbWVTcGFuYCBjb21wbGV0ZXMuIElmIGBtYXhXaW5kb3dDb3VudGAgaXMgcHJvdmlkZWQsIGVhY2ggd2luZG93XG4gKiB3aWxsIGVtaXQgYXQgbW9zdCBmaXhlZCBudW1iZXIgb2YgdmFsdWVzLiBXaW5kb3cgd2lsbCBjb21wbGV0ZSBpbW1lZGlhdGVseVxuICogYWZ0ZXIgZW1pdHRpbmcgbGFzdCB2YWx1ZSBhbmQgbmV4dCBvbmUgc3RpbGwgd2lsbCBvcGVuIGFzIHNwZWNpZmllZCBieVxuICogYHdpbmRvd1RpbWVTcGFuYCBhbmQgYHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWxgIGFyZ3VtZW50cy5cbiAqXG4gKiBAZXhhbXBsZSA8Y2FwdGlvbj5JbiBldmVyeSB3aW5kb3cgb2YgMSBzZWNvbmQgZWFjaCwgZW1pdCBhdCBtb3N0IDIgY2xpY2sgZXZlbnRzPC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3Mud2luZG93VGltZSgxMDAwKVxuICogICAubWFwKHdpbiA9PiB3aW4udGFrZSgyKSkgLy8gZWFjaCB3aW5kb3cgaGFzIGF0IG1vc3QgMiBlbWlzc2lvbnNcbiAqICAgLm1lcmdlQWxsKCk7IC8vIGZsYXR0ZW4gdGhlIE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXNcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RXZlcnkgNSBzZWNvbmRzIHN0YXJ0IGEgd2luZG93IDEgc2Vjb25kIGxvbmcsIGFuZCBlbWl0IGF0IG1vc3QgMiBjbGljayBldmVudHMgcGVyIHdpbmRvdzwvY2FwdGlvbj5cbiAqIHZhciBjbGlja3MgPSBSeC5PYnNlcnZhYmxlLmZyb21FdmVudChkb2N1bWVudCwgJ2NsaWNrJyk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLndpbmRvd1RpbWUoMTAwMCwgNTAwMClcbiAqICAgLm1hcCh3aW4gPT4gd2luLnRha2UoMikpIC8vIGVhY2ggd2luZG93IGhhcyBhdCBtb3N0IDIgZW1pc3Npb25zXG4gKiAgIC5tZXJnZUFsbCgpOyAvLyBmbGF0dGVuIHRoZSBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzXG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPlNhbWUgYXMgZXhhbXBsZSBhYm92ZSBidXQgd2l0aCBtYXhXaW5kb3dDb3VudCBpbnN0ZWFkIG9mIHRha2U8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrcy53aW5kb3dUaW1lKDEwMDAsIDUwMDAsIDIpIC8vIGVhY2ggd2luZG93IGhhcyBzdGlsbCBhdCBtb3N0IDIgZW1pc3Npb25zXG4gKiAgIC5tZXJnZUFsbCgpOyAvLyBmbGF0dGVuIHRoZSBPYnNlcnZhYmxlLW9mLU9ic2VydmFibGVzXG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuXG4gKiBAc2VlIHtAbGluayB3aW5kb3d9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dDb3VudH1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RvZ2dsZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1doZW59XG4gKiBAc2VlIHtAbGluayBidWZmZXJUaW1lfVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aW5kb3dUaW1lU3BhbiBUaGUgYW1vdW50IG9mIHRpbWUgdG8gZmlsbCBlYWNoIHdpbmRvdy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2luZG93Q3JlYXRpb25JbnRlcnZhbF0gVGhlIGludGVydmFsIGF0IHdoaWNoIHRvIHN0YXJ0IG5ld1xuICogd2luZG93cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4V2luZG93U2l6ZT1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldIE1heCBudW1iZXIgb2ZcbiAqIHZhbHVlcyBlYWNoIHdpbmRvdyBjYW4gZW1pdCBiZWZvcmUgY29tcGxldGlvbi5cbiAqIEBwYXJhbSB7U2NoZWR1bGVyfSBbc2NoZWR1bGVyPWFzeW5jXSBUaGUgc2NoZWR1bGVyIG9uIHdoaWNoIHRvIHNjaGVkdWxlIHRoZVxuICogaW50ZXJ2YWxzIHRoYXQgZGV0ZXJtaW5lIHdpbmRvdyBib3VuZGFyaWVzLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZTxPYnNlcnZhYmxlPFQ+Pn0gQW4gb2JzZXJ2YWJsZSBvZiB3aW5kb3dzLCB3aGljaCBpbiB0dXJuXG4gKiBhcmUgT2JzZXJ2YWJsZXMuXG4gKiBAbWV0aG9kIHdpbmRvd1RpbWVcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aW5kb3dUaW1lPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIHdpbmRvd1RpbWVTcGFuOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxPYnNlcnZhYmxlPFQ+PjtcbmV4cG9ydCBmdW5jdGlvbiB3aW5kb3dUaW1lPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIHdpbmRvd1RpbWVTcGFuOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dDcmVhdGlvbkludGVydmFsOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxPYnNlcnZhYmxlPFQ+PjtcbmV4cG9ydCBmdW5jdGlvbiB3aW5kb3dUaW1lPFQ+KHRoaXM6IE9ic2VydmFibGU8VD4sIHdpbmRvd1RpbWVTcGFuOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3dDcmVhdGlvbkludGVydmFsOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhXaW5kb3dTaXplOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZXI/OiBJU2NoZWR1bGVyKTogT2JzZXJ2YWJsZTxPYnNlcnZhYmxlPFQ+PjtcblxuZXhwb3J0IGZ1bmN0aW9uIHdpbmRvd1RpbWU8VD4odGhpczogT2JzZXJ2YWJsZTxUPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvd1RpbWVTcGFuOiBudW1iZXIpOiBPYnNlcnZhYmxlPE9ic2VydmFibGU8VD4+IHtcblxuICBsZXQgc2NoZWR1bGVyOiBJU2NoZWR1bGVyID0gYXN5bmM7XG4gIGxldCB3aW5kb3dDcmVhdGlvbkludGVydmFsOiBudW1iZXIgPSBudWxsO1xuICBsZXQgbWF4V2luZG93U2l6ZTogbnVtYmVyID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4gIGlmIChpc1NjaGVkdWxlcihhcmd1bWVudHNbM10pKSB7XG4gICAgc2NoZWR1bGVyID0gYXJndW1lbnRzWzNdO1xuICB9XG5cbiAgaWYgKGlzU2NoZWR1bGVyKGFyZ3VtZW50c1syXSkpIHtcbiAgICBzY2hlZHVsZXIgPSBhcmd1bWVudHNbMl07XG4gIH0gZWxzZSBpZiAoaXNOdW1lcmljKGFyZ3VtZW50c1syXSkpIHtcbiAgICBtYXhXaW5kb3dTaXplID0gYXJndW1lbnRzWzJdO1xuICB9XG5cbiAgaWYgKGlzU2NoZWR1bGVyKGFyZ3VtZW50c1sxXSkpIHtcbiAgICBzY2hlZHVsZXIgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSBpZiAoaXNOdW1lcmljKGFyZ3VtZW50c1sxXSkpIHtcbiAgICB3aW5kb3dDcmVhdGlvbkludGVydmFsID0gYXJndW1lbnRzWzFdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgV2luZG93VGltZU9wZXJhdG9yPFQ+KHdpbmRvd1RpbWVTcGFuLCB3aW5kb3dDcmVhdGlvbkludGVydmFsLCBtYXhXaW5kb3dTaXplLCBzY2hlZHVsZXIpKTtcbn1cblxuY2xhc3MgV2luZG93VGltZU9wZXJhdG9yPFQ+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgT2JzZXJ2YWJsZTxUPj4ge1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgd2luZG93VGltZVNwYW46IG51bWJlcixcbiAgICAgICAgICAgICAgcHJpdmF0ZSB3aW5kb3dDcmVhdGlvbkludGVydmFsOiBudW1iZXIgfCBudWxsLFxuICAgICAgICAgICAgICBwcml2YXRlIG1heFdpbmRvd1NpemU6IG51bWJlcixcbiAgICAgICAgICAgICAgcHJpdmF0ZSBzY2hlZHVsZXI6IElTY2hlZHVsZXIpIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxPYnNlcnZhYmxlPFQ+Piwgc291cmNlOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBXaW5kb3dUaW1lU3Vic2NyaWJlcihcbiAgICAgIHN1YnNjcmliZXIsIHRoaXMud2luZG93VGltZVNwYW4sIHRoaXMud2luZG93Q3JlYXRpb25JbnRlcnZhbCwgdGhpcy5tYXhXaW5kb3dTaXplLCB0aGlzLnNjaGVkdWxlclxuICAgICkpO1xuICB9XG59XG5cbmludGVyZmFjZSBDcmVhdGlvblN0YXRlPFQ+IHtcbiAgd2luZG93VGltZVNwYW46IG51bWJlcjtcbiAgd2luZG93Q3JlYXRpb25JbnRlcnZhbDogbnVtYmVyO1xuICBzdWJzY3JpYmVyOiBXaW5kb3dUaW1lU3Vic2NyaWJlcjxUPjtcbiAgc2NoZWR1bGVyOiBJU2NoZWR1bGVyO1xufVxuXG5pbnRlcmZhY2UgVGltZVNwYW5Pbmx5U3RhdGU8VD4ge1xuICAgIHdpbmRvdzogQ291bnRlZFN1YmplY3Q8VD47XG4gICAgd2luZG93VGltZVNwYW46IG51bWJlcjtcbiAgICBzdWJzY3JpYmVyOiBXaW5kb3dUaW1lU3Vic2NyaWJlcjxUPjtcbiAgfVxuXG5pbnRlcmZhY2UgQ2xvc2VXaW5kb3dDb250ZXh0PFQ+IHtcbiAgYWN0aW9uOiBBY3Rpb248Q3JlYXRpb25TdGF0ZTxUPj47XG4gIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xufVxuXG5pbnRlcmZhY2UgQ2xvc2VTdGF0ZTxUPiB7XG4gIHN1YnNjcmliZXI6IFdpbmRvd1RpbWVTdWJzY3JpYmVyPFQ+O1xuICB3aW5kb3c6IENvdW50ZWRTdWJqZWN0PFQ+O1xuICBjb250ZXh0OiBDbG9zZVdpbmRvd0NvbnRleHQ8VD47XG59XG5cbmNsYXNzIENvdW50ZWRTdWJqZWN0PFQ+IGV4dGVuZHMgU3ViamVjdDxUPiB7XG4gIHByaXZhdGUgX251bWJlck9mTmV4dGVkVmFsdWVzOiBudW1iZXIgPSAwO1xuXG4gIG5leHQodmFsdWU/OiBUKTogdm9pZCB7XG4gICAgdGhpcy5fbnVtYmVyT2ZOZXh0ZWRWYWx1ZXMrKztcbiAgICBzdXBlci5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIGdldCBudW1iZXJPZk5leHRlZFZhbHVlcygpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl9udW1iZXJPZk5leHRlZFZhbHVlcztcbiAgfVxufVxuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuY2xhc3MgV2luZG93VGltZVN1YnNjcmliZXI8VD4gZXh0ZW5kcyBTdWJzY3JpYmVyPFQ+IHtcbiAgcHJpdmF0ZSB3aW5kb3dzOiBDb3VudGVkU3ViamVjdDxUPltdID0gW107XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPE9ic2VydmFibGU8VD4+LFxuICAgICAgICAgICAgICBwcml2YXRlIHdpbmRvd1RpbWVTcGFuOiBudW1iZXIsXG4gICAgICAgICAgICAgIHByaXZhdGUgd2luZG93Q3JlYXRpb25JbnRlcnZhbDogbnVtYmVyIHwgbnVsbCxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBtYXhXaW5kb3dTaXplOiBudW1iZXIsXG4gICAgICAgICAgICAgIHByaXZhdGUgc2NoZWR1bGVyOiBJU2NoZWR1bGVyKSB7XG4gICAgc3VwZXIoZGVzdGluYXRpb24pO1xuXG4gICAgY29uc3Qgd2luZG93ID0gdGhpcy5vcGVuV2luZG93KCk7XG4gICAgaWYgKHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwgIT09IG51bGwgJiYgd2luZG93Q3JlYXRpb25JbnRlcnZhbCA+PSAwKSB7XG4gICAgICBjb25zdCBjbG9zZVN0YXRlOiBDbG9zZVN0YXRlPFQ+ID0geyBzdWJzY3JpYmVyOiB0aGlzLCB3aW5kb3csIGNvbnRleHQ6IDxhbnk+bnVsbCB9O1xuICAgICAgY29uc3QgY3JlYXRpb25TdGF0ZTogQ3JlYXRpb25TdGF0ZTxUPiA9IHsgd2luZG93VGltZVNwYW4sIHdpbmRvd0NyZWF0aW9uSW50ZXJ2YWwsIHN1YnNjcmliZXI6IHRoaXMsIHNjaGVkdWxlciB9O1xuICAgICAgdGhpcy5hZGQoc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoV2luZG93Q2xvc2UsIHdpbmRvd1RpbWVTcGFuLCBjbG9zZVN0YXRlKSk7XG4gICAgICB0aGlzLmFkZChzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2hXaW5kb3dDcmVhdGlvbiwgd2luZG93Q3JlYXRpb25JbnRlcnZhbCwgY3JlYXRpb25TdGF0ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0aW1lU3Bhbk9ubHlTdGF0ZTogVGltZVNwYW5Pbmx5U3RhdGU8VD4gPSB7IHN1YnNjcmliZXI6IHRoaXMsIHdpbmRvdywgd2luZG93VGltZVNwYW4gfTtcbiAgICAgIHRoaXMuYWRkKHNjaGVkdWxlci5zY2hlZHVsZShkaXNwYXRjaFdpbmRvd1RpbWVTcGFuT25seSwgd2luZG93VGltZVNwYW4sIHRpbWVTcGFuT25seVN0YXRlKSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXh0KHZhbHVlOiBUKTogdm9pZCB7XG4gICAgY29uc3Qgd2luZG93cyA9IHRoaXMud2luZG93cztcbiAgICBjb25zdCBsZW4gPSB3aW5kb3dzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCB3aW5kb3cgPSB3aW5kb3dzW2ldO1xuICAgICAgaWYgKCF3aW5kb3cuY2xvc2VkKSB7XG4gICAgICAgIHdpbmRvdy5uZXh0KHZhbHVlKTtcbiAgICAgICAgaWYgKHdpbmRvdy5udW1iZXJPZk5leHRlZFZhbHVlcyA+PSB0aGlzLm1heFdpbmRvd1NpemUpIHtcbiAgICAgICAgICB0aGlzLmNsb3NlV2luZG93KHdpbmRvdyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgX2Vycm9yKGVycjogYW55KTogdm9pZCB7XG4gICAgY29uc3Qgd2luZG93cyA9IHRoaXMud2luZG93cztcbiAgICB3aGlsZSAod2luZG93cy5sZW5ndGggPiAwKSB7XG4gICAgICB3aW5kb3dzLnNoaWZ0KCkuZXJyb3IoZXJyKTtcbiAgICB9XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9jb21wbGV0ZSgpOiB2b2lkIHtcbiAgICBjb25zdCB3aW5kb3dzID0gdGhpcy53aW5kb3dzO1xuICAgIHdoaWxlICh3aW5kb3dzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHdpbmRvdyA9IHdpbmRvd3Muc2hpZnQoKTtcbiAgICAgIGlmICghd2luZG93LmNsb3NlZCkge1xuICAgICAgICB3aW5kb3cuY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICB9XG5cbiAgcHVibGljIG9wZW5XaW5kb3coKTogQ291bnRlZFN1YmplY3Q8VD4ge1xuICAgIGNvbnN0IHdpbmRvdyA9IG5ldyBDb3VudGVkU3ViamVjdDxUPigpO1xuICAgIHRoaXMud2luZG93cy5wdXNoKHdpbmRvdyk7XG4gICAgY29uc3QgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuICAgIGRlc3RpbmF0aW9uLm5leHQod2luZG93KTtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgcHVibGljIGNsb3NlV2luZG93KHdpbmRvdzogQ291bnRlZFN1YmplY3Q8VD4pOiB2b2lkIHtcbiAgICB3aW5kb3cuY29tcGxldGUoKTtcbiAgICBjb25zdCB3aW5kb3dzID0gdGhpcy53aW5kb3dzO1xuICAgIHdpbmRvd3Muc3BsaWNlKHdpbmRvd3MuaW5kZXhPZih3aW5kb3cpLCAxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaFdpbmRvd1RpbWVTcGFuT25seTxUPih0aGlzOiBBY3Rpb248VGltZVNwYW5Pbmx5U3RhdGU8VD4+LCBzdGF0ZTogVGltZVNwYW5Pbmx5U3RhdGU8VD4pOiB2b2lkIHtcbiAgY29uc3QgeyBzdWJzY3JpYmVyLCB3aW5kb3dUaW1lU3Bhbiwgd2luZG93IH0gPSBzdGF0ZTtcbiAgaWYgKHdpbmRvdykge1xuICAgIHN1YnNjcmliZXIuY2xvc2VXaW5kb3cod2luZG93KTtcbiAgfVxuICBzdGF0ZS53aW5kb3cgPSBzdWJzY3JpYmVyLm9wZW5XaW5kb3coKTtcbiAgdGhpcy5zY2hlZHVsZShzdGF0ZSwgd2luZG93VGltZVNwYW4pO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaFdpbmRvd0NyZWF0aW9uPFQ+KHRoaXM6IEFjdGlvbjxDcmVhdGlvblN0YXRlPFQ+Piwgc3RhdGU6IENyZWF0aW9uU3RhdGU8VD4pOiB2b2lkIHtcbiAgY29uc3QgeyB3aW5kb3dUaW1lU3Bhbiwgc3Vic2NyaWJlciwgc2NoZWR1bGVyLCB3aW5kb3dDcmVhdGlvbkludGVydmFsIH0gPSBzdGF0ZTtcbiAgY29uc3Qgd2luZG93ID0gc3Vic2NyaWJlci5vcGVuV2luZG93KCk7XG4gIGNvbnN0IGFjdGlvbiA9IHRoaXM7XG4gIGxldCBjb250ZXh0OiBDbG9zZVdpbmRvd0NvbnRleHQ8VD4gPSB7IGFjdGlvbiwgc3Vic2NyaXB0aW9uOiA8YW55Pm51bGwgfTtcbiAgY29uc3QgdGltZVNwYW5TdGF0ZTogQ2xvc2VTdGF0ZTxUPiA9IHsgc3Vic2NyaWJlciwgd2luZG93LCBjb250ZXh0IH07XG4gIGNvbnRleHQuc3Vic2NyaXB0aW9uID0gc2NoZWR1bGVyLnNjaGVkdWxlKGRpc3BhdGNoV2luZG93Q2xvc2UsIHdpbmRvd1RpbWVTcGFuLCB0aW1lU3BhblN0YXRlKTtcbiAgYWN0aW9uLmFkZChjb250ZXh0LnN1YnNjcmlwdGlvbik7XG4gIGFjdGlvbi5zY2hlZHVsZShzdGF0ZSwgd2luZG93Q3JlYXRpb25JbnRlcnZhbCk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoV2luZG93Q2xvc2U8VD4oc3RhdGU6IENsb3NlU3RhdGU8VD4pOiB2b2lkIHtcbiAgY29uc3QgeyBzdWJzY3JpYmVyLCB3aW5kb3csIGNvbnRleHQgfSA9IHN0YXRlO1xuICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmFjdGlvbiAmJiBjb250ZXh0LnN1YnNjcmlwdGlvbikge1xuICAgIGNvbnRleHQuYWN0aW9uLnJlbW92ZShjb250ZXh0LnN1YnNjcmlwdGlvbik7XG4gIH1cbiAgc3Vic2NyaWJlci5jbG9zZVdpbmRvdyh3aW5kb3cpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci93aW5kb3dUaW1lLnRzIiwiaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAnLi4vU3ViamVjdCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICcuLi9TdWJzY3JpcHRpb24nO1xuXG5pbXBvcnQgeyB0cnlDYXRjaCB9IGZyb20gJy4uL3V0aWwvdHJ5Q2F0Y2gnO1xuaW1wb3J0IHsgZXJyb3JPYmplY3QgfSBmcm9tICcuLi91dGlsL2Vycm9yT2JqZWN0JztcblxuaW1wb3J0IHsgT3V0ZXJTdWJzY3JpYmVyIH0gZnJvbSAnLi4vT3V0ZXJTdWJzY3JpYmVyJztcbmltcG9ydCB7IElubmVyU3Vic2NyaWJlciB9IGZyb20gJy4uL0lubmVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBzdWJzY3JpYmVUb1Jlc3VsdCB9IGZyb20gJy4uL3V0aWwvc3Vic2NyaWJlVG9SZXN1bHQnO1xuXG4vKipcbiAqIEJyYW5jaCBvdXQgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHZhbHVlcyBhcyBhIG5lc3RlZCBPYnNlcnZhYmxlIHN0YXJ0aW5nIGZyb21cbiAqIGFuIGVtaXNzaW9uIGZyb20gYG9wZW5pbmdzYCBhbmQgZW5kaW5nIHdoZW4gdGhlIG91dHB1dCBvZiBgY2xvc2luZ1NlbGVjdG9yYFxuICogZW1pdHMuXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPkl0J3MgbGlrZSB7QGxpbmsgYnVmZmVyVG9nZ2xlfSwgYnV0IGVtaXRzIGEgbmVzdGVkXG4gKiBPYnNlcnZhYmxlIGluc3RlYWQgb2YgYW4gYXJyYXkuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvd2luZG93VG9nZ2xlLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIFJldHVybnMgYW4gT2JzZXJ2YWJsZSB0aGF0IGVtaXRzIHdpbmRvd3Mgb2YgaXRlbXMgaXQgY29sbGVjdHMgZnJvbSB0aGUgc291cmNlXG4gKiBPYnNlcnZhYmxlLiBUaGUgb3V0cHV0IE9ic2VydmFibGUgZW1pdHMgd2luZG93cyB0aGF0IGNvbnRhaW4gdGhvc2UgaXRlbXNcbiAqIGVtaXR0ZWQgYnkgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGJldHdlZW4gdGhlIHRpbWUgd2hlbiB0aGUgYG9wZW5pbmdzYFxuICogT2JzZXJ2YWJsZSBlbWl0cyBhbiBpdGVtIGFuZCB3aGVuIHRoZSBPYnNlcnZhYmxlIHJldHVybmVkIGJ5XG4gKiBgY2xvc2luZ1NlbGVjdG9yYCBlbWl0cyBhbiBpdGVtLlxuICpcbiAqIEBleGFtcGxlIDxjYXB0aW9uPkV2ZXJ5IG90aGVyIHNlY29uZCwgZW1pdCB0aGUgY2xpY2sgZXZlbnRzIGZyb20gdGhlIG5leHQgNTAwbXM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIG9wZW5pbmdzID0gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCgxMDAwKTtcbiAqIHZhciByZXN1bHQgPSBjbGlja3Mud2luZG93VG9nZ2xlKG9wZW5pbmdzLCBpID0+XG4gKiAgIGkgJSAyID8gUnguT2JzZXJ2YWJsZS5pbnRlcnZhbCg1MDApIDogUnguT2JzZXJ2YWJsZS5lbXB0eSgpXG4gKiApLm1lcmdlQWxsKCk7XG4gKiByZXN1bHQuc3Vic2NyaWJlKHggPT4gY29uc29sZS5sb2coeCkpO1xuICpcbiAqIEBzZWUge0BsaW5rIHdpbmRvd31cbiAqIEBzZWUge0BsaW5rIHdpbmRvd0NvdW50fVxuICogQHNlZSB7QGxpbmsgd2luZG93VGltZX1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1doZW59XG4gKiBAc2VlIHtAbGluayBidWZmZXJUb2dnbGV9XG4gKlxuICogQHBhcmFtIHtPYnNlcnZhYmxlPE8+fSBvcGVuaW5ncyBBbiBvYnNlcnZhYmxlIG9mIG5vdGlmaWNhdGlvbnMgdG8gc3RhcnQgbmV3XG4gKiB3aW5kb3dzLlxuICogQHBhcmFtIHtmdW5jdGlvbih2YWx1ZTogTyk6IE9ic2VydmFibGV9IGNsb3NpbmdTZWxlY3RvciBBIGZ1bmN0aW9uIHRoYXQgdGFrZXNcbiAqIHRoZSB2YWx1ZSBlbWl0dGVkIGJ5IHRoZSBgb3BlbmluZ3NgIG9ic2VydmFibGUgYW5kIHJldHVybnMgYW4gT2JzZXJ2YWJsZSxcbiAqIHdoaWNoLCB3aGVuIGl0IGVtaXRzIChlaXRoZXIgYG5leHRgIG9yIGBjb21wbGV0ZWApLCBzaWduYWxzIHRoYXQgdGhlXG4gKiBhc3NvY2lhdGVkIHdpbmRvdyBzaG91bGQgY29tcGxldGUuXG4gKiBAcmV0dXJuIHtPYnNlcnZhYmxlPE9ic2VydmFibGU8VD4+fSBBbiBvYnNlcnZhYmxlIG9mIHdpbmRvd3MsIHdoaWNoIGluIHR1cm5cbiAqIGFyZSBPYnNlcnZhYmxlcy5cbiAqIEBtZXRob2Qgd2luZG93VG9nZ2xlXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gd2luZG93VG9nZ2xlPFQsIE8+KHRoaXM6IE9ic2VydmFibGU8VD4sIG9wZW5pbmdzOiBPYnNlcnZhYmxlPE8+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zaW5nU2VsZWN0b3I6IChvcGVuVmFsdWU6IE8pID0+IE9ic2VydmFibGU8YW55Pik6IE9ic2VydmFibGU8T2JzZXJ2YWJsZTxUPj4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBXaW5kb3dUb2dnbGVPcGVyYXRvcjxULCBPPihvcGVuaW5ncywgY2xvc2luZ1NlbGVjdG9yKSk7XG59XG5cbmNsYXNzIFdpbmRvd1RvZ2dsZU9wZXJhdG9yPFQsIE8+IGltcGxlbWVudHMgT3BlcmF0b3I8VCwgT2JzZXJ2YWJsZTxUPj4ge1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgb3BlbmluZ3M6IE9ic2VydmFibGU8Tz4sXG4gICAgICAgICAgICAgIHByaXZhdGUgY2xvc2luZ1NlbGVjdG9yOiAob3BlblZhbHVlOiBPKSA9PiBPYnNlcnZhYmxlPGFueT4pIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxPYnNlcnZhYmxlPFQ+Piwgc291cmNlOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyKFxuICAgICAgc3Vic2NyaWJlciwgdGhpcy5vcGVuaW5ncywgdGhpcy5jbG9zaW5nU2VsZWN0b3JcbiAgICApKTtcbiAgfVxufVxuXG5pbnRlcmZhY2UgV2luZG93Q29udGV4dDxUPiB7XG4gIHdpbmRvdzogU3ViamVjdDxUPjtcbiAgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBXaW5kb3dUb2dnbGVTdWJzY3JpYmVyPFQsIE8+IGV4dGVuZHMgT3V0ZXJTdWJzY3JpYmVyPFQsIGFueT4ge1xuICBwcml2YXRlIGNvbnRleHRzOiBXaW5kb3dDb250ZXh0PFQ+W10gPSBbXTtcbiAgcHJpdmF0ZSBvcGVuU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IoZGVzdGluYXRpb246IFN1YnNjcmliZXI8T2JzZXJ2YWJsZTxUPj4sXG4gICAgICAgICAgICAgIHByaXZhdGUgb3BlbmluZ3M6IE9ic2VydmFibGU8Tz4sXG4gICAgICAgICAgICAgIHByaXZhdGUgY2xvc2luZ1NlbGVjdG9yOiAob3BlblZhbHVlOiBPKSA9PiBPYnNlcnZhYmxlPGFueT4pIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gICAgdGhpcy5hZGQodGhpcy5vcGVuU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgb3BlbmluZ3MsIG9wZW5pbmdzKSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX25leHQodmFsdWU6IFQpIHtcbiAgICBjb25zdCB7IGNvbnRleHRzIH0gPSB0aGlzO1xuICAgIGlmIChjb250ZXh0cykge1xuICAgICAgY29uc3QgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb250ZXh0c1tpXS53aW5kb3cubmV4dCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIF9lcnJvcihlcnI6IGFueSkge1xuXG4gICAgY29uc3QgeyBjb250ZXh0cyB9ID0gdGhpcztcbiAgICB0aGlzLmNvbnRleHRzID0gbnVsbDtcblxuICAgIGlmIChjb250ZXh0cykge1xuICAgICAgY29uc3QgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgbGV0IGluZGV4ID0gLTE7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjb250ZXh0c1tpbmRleF07XG4gICAgICAgIGNvbnRleHQud2luZG93LmVycm9yKGVycik7XG4gICAgICAgIGNvbnRleHQuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3VwZXIuX2Vycm9yKGVycik7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbXBsZXRlKCkge1xuICAgIGNvbnN0IHsgY29udGV4dHMgfSA9IHRoaXM7XG4gICAgdGhpcy5jb250ZXh0cyA9IG51bGw7XG4gICAgaWYgKGNvbnRleHRzKSB7XG4gICAgICBjb25zdCBsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG4gICAgICBsZXQgaW5kZXggPSAtMTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjb250ZXh0c1tpbmRleF07XG4gICAgICAgIGNvbnRleHQud2luZG93LmNvbXBsZXRlKCk7XG4gICAgICAgIGNvbnRleHQuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLl9jb21wbGV0ZSgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF91bnN1YnNjcmliZSgpIHtcbiAgICBjb25zdCB7IGNvbnRleHRzIH0gPSB0aGlzO1xuICAgIHRoaXMuY29udGV4dHMgPSBudWxsO1xuICAgIGlmIChjb250ZXh0cykge1xuICAgICAgY29uc3QgbGVuID0gY29udGV4dHMubGVuZ3RoO1xuICAgICAgbGV0IGluZGV4ID0gLTE7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbikge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY29udGV4dHNbaW5kZXhdO1xuICAgICAgICBjb250ZXh0LndpbmRvdy51bnN1YnNjcmliZSgpO1xuICAgICAgICBjb250ZXh0LnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5vdGlmeU5leHQob3V0ZXJWYWx1ZTogYW55LCBpbm5lclZhbHVlOiBhbnksXG4gICAgICAgICAgICAgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICAgaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBhbnk+KTogdm9pZCB7XG5cbiAgICBpZiAob3V0ZXJWYWx1ZSA9PT0gdGhpcy5vcGVuaW5ncykge1xuXG4gICAgICBjb25zdCB7IGNsb3NpbmdTZWxlY3RvciB9ID0gdGhpcztcbiAgICAgIGNvbnN0IGNsb3NpbmdOb3RpZmllciA9IHRyeUNhdGNoKGNsb3NpbmdTZWxlY3RvcikoaW5uZXJWYWx1ZSk7XG5cbiAgICAgIGlmIChjbG9zaW5nTm90aWZpZXIgPT09IGVycm9yT2JqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVycm9yKGVycm9yT2JqZWN0LmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgd2luZG93ID0gbmV3IFN1YmplY3Q8VD4oKTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0geyB3aW5kb3csIHN1YnNjcmlwdGlvbiB9O1xuICAgICAgICB0aGlzLmNvbnRleHRzLnB1c2goY29udGV4dCk7XG4gICAgICAgIGNvbnN0IGlubmVyU3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlVG9SZXN1bHQodGhpcywgY2xvc2luZ05vdGlmaWVyLCBjb250ZXh0KTtcblxuICAgICAgICBpZiAoaW5uZXJTdWJzY3JpcHRpb24uY2xvc2VkKSB7XG4gICAgICAgICAgdGhpcy5jbG9zZVdpbmRvdyh0aGlzLmNvbnRleHRzLmxlbmd0aCAtIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICg8YW55PiBpbm5lclN1YnNjcmlwdGlvbikuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uLmFkZChpbm5lclN1YnNjcmlwdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQod2luZG93KTtcblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsb3NlV2luZG93KHRoaXMuY29udGV4dHMuaW5kZXhPZihvdXRlclZhbHVlKSk7XG4gICAgfVxuICB9XG5cbiAgbm90aWZ5RXJyb3IoZXJyOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLmVycm9yKGVycik7XG4gIH1cblxuICBub3RpZnlDb21wbGV0ZShpbm5lcjogU3Vic2NyaXB0aW9uKTogdm9pZCB7XG4gICAgaWYgKGlubmVyICE9PSB0aGlzLm9wZW5TdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuY2xvc2VXaW5kb3codGhpcy5jb250ZXh0cy5pbmRleE9mKCg8YW55PiBpbm5lcikuY29udGV4dCkpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY2xvc2VXaW5kb3coaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7IGNvbnRleHRzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNvbnRleHQgPSBjb250ZXh0c1tpbmRleF07XG4gICAgY29uc3QgeyB3aW5kb3csIHN1YnNjcmlwdGlvbiB9ID0gY29udGV4dDtcbiAgICBjb250ZXh0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHdpbmRvdy5jb21wbGV0ZSgpO1xuICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL3dpbmRvd1RvZ2dsZS50cyIsImltcG9ydCB7IE9wZXJhdG9yIH0gZnJvbSAnLi4vT3BlcmF0b3InO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4uL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJy4uL1N1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcblxuaW1wb3J0IHsgdHJ5Q2F0Y2ggfSBmcm9tICcuLi91dGlsL3RyeUNhdGNoJztcbmltcG9ydCB7IGVycm9yT2JqZWN0IH0gZnJvbSAnLi4vdXRpbC9lcnJvck9iamVjdCc7XG5cbmltcG9ydCB7IE91dGVyU3Vic2NyaWJlciB9IGZyb20gJy4uL091dGVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBJbm5lclN1YnNjcmliZXIgfSBmcm9tICcuLi9Jbm5lclN1YnNjcmliZXInO1xuaW1wb3J0IHsgc3Vic2NyaWJlVG9SZXN1bHQgfSBmcm9tICcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0JztcblxuLyoqXG4gKiBCcmFuY2ggb3V0IHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSB2YWx1ZXMgYXMgYSBuZXN0ZWQgT2JzZXJ2YWJsZSB1c2luZyBhXG4gKiBmYWN0b3J5IGZ1bmN0aW9uIG9mIGNsb3NpbmcgT2JzZXJ2YWJsZXMgdG8gZGV0ZXJtaW5lIHdoZW4gdG8gc3RhcnQgYSBuZXdcbiAqIHdpbmRvdy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+SXQncyBsaWtlIHtAbGluayBidWZmZXJXaGVufSwgYnV0IGVtaXRzIGEgbmVzdGVkXG4gKiBPYnNlcnZhYmxlIGluc3RlYWQgb2YgYW4gYXJyYXkuPC9zcGFuPlxuICpcbiAqIDxpbWcgc3JjPVwiLi9pbWcvd2luZG93V2hlbi5wbmdcIiB3aWR0aD1cIjEwMCVcIj5cbiAqXG4gKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBlbWl0cyB3aW5kb3dzIG9mIGl0ZW1zIGl0IGNvbGxlY3RzIGZyb20gdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gVGhlIG91dHB1dCBPYnNlcnZhYmxlIGVtaXRzIGNvbm5lY3RlZCwgbm9uLW92ZXJsYXBwaW5nIHdpbmRvd3MuXG4gKiBJdCBlbWl0cyB0aGUgY3VycmVudCB3aW5kb3cgYW5kIG9wZW5zIGEgbmV3IG9uZSB3aGVuZXZlciB0aGUgT2JzZXJ2YWJsZVxuICogcHJvZHVjZWQgYnkgdGhlIHNwZWNpZmllZCBgY2xvc2luZ1NlbGVjdG9yYCBmdW5jdGlvbiBlbWl0cyBhbiBpdGVtLiBUaGUgZmlyc3RcbiAqIHdpbmRvdyBpcyBvcGVuZWQgaW1tZWRpYXRlbHkgd2hlbiBzdWJzY3JpYmluZyB0byB0aGUgb3V0cHV0IE9ic2VydmFibGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+RW1pdCBvbmx5IHRoZSBmaXJzdCB0d28gY2xpY2tzIGV2ZW50cyBpbiBldmVyeSB3aW5kb3cgb2YgWzEtNV0gcmFuZG9tIHNlY29uZHM8L2NhcHRpb24+XG4gKiB2YXIgY2xpY2tzID0gUnguT2JzZXJ2YWJsZS5mcm9tRXZlbnQoZG9jdW1lbnQsICdjbGljaycpO1xuICogdmFyIHJlc3VsdCA9IGNsaWNrc1xuICogICAud2luZG93V2hlbigoKSA9PiBSeC5PYnNlcnZhYmxlLmludGVydmFsKDEwMDAgKyBNYXRoLnJhbmRvbSgpICogNDAwMCkpXG4gKiAgIC5tYXAod2luID0+IHdpbi50YWtlKDIpKSAvLyBlYWNoIHdpbmRvdyBoYXMgYXQgbW9zdCAyIGVtaXNzaW9uc1xuICogICAubWVyZ2VBbGwoKTsgLy8gZmxhdHRlbiB0aGUgT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlc1xuICogcmVzdWx0LnN1YnNjcmliZSh4ID0+IGNvbnNvbGUubG9nKHgpKTtcbiAqXG4gKiBAc2VlIHtAbGluayB3aW5kb3d9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dDb3VudH1cbiAqIEBzZWUge0BsaW5rIHdpbmRvd1RpbWV9XG4gKiBAc2VlIHtAbGluayB3aW5kb3dUb2dnbGV9XG4gKiBAc2VlIHtAbGluayBidWZmZXJXaGVufVxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTogT2JzZXJ2YWJsZX0gY2xvc2luZ1NlbGVjdG9yIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBub1xuICogYXJndW1lbnRzIGFuZCByZXR1cm5zIGFuIE9ic2VydmFibGUgdGhhdCBzaWduYWxzIChvbiBlaXRoZXIgYG5leHRgIG9yXG4gKiBgY29tcGxldGVgKSB3aGVuIHRvIGNsb3NlIHRoZSBwcmV2aW91cyB3aW5kb3cgYW5kIHN0YXJ0IGEgbmV3IG9uZS5cbiAqIEByZXR1cm4ge09ic2VydmFibGU8T2JzZXJ2YWJsZTxUPj59IEFuIG9ic2VydmFibGUgb2Ygd2luZG93cywgd2hpY2ggaW4gdHVyblxuICogYXJlIE9ic2VydmFibGVzLlxuICogQG1ldGhvZCB3aW5kb3dXaGVuXG4gKiBAb3duZXIgT2JzZXJ2YWJsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gd2luZG93V2hlbjxUPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCBjbG9zaW5nU2VsZWN0b3I6ICgpID0+IE9ic2VydmFibGU8YW55Pik6IE9ic2VydmFibGU8T2JzZXJ2YWJsZTxUPj4ge1xuICByZXR1cm4gdGhpcy5saWZ0KG5ldyBXaW5kb3dPcGVyYXRvcjxUPihjbG9zaW5nU2VsZWN0b3IpKTtcbn1cblxuY2xhc3MgV2luZG93T3BlcmF0b3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBPYnNlcnZhYmxlPFQ+PiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY2xvc2luZ1NlbGVjdG9yOiAoKSA9PiBPYnNlcnZhYmxlPGFueT4pIHtcbiAgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxPYnNlcnZhYmxlPFQ+Piwgc291cmNlOiBhbnkpOiBhbnkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBXaW5kb3dTdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMuY2xvc2luZ1NlbGVjdG9yKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmNsYXNzIFdpbmRvd1N1YnNjcmliZXI8VD4gZXh0ZW5kcyBPdXRlclN1YnNjcmliZXI8VCwgYW55PiB7XG4gIHByaXZhdGUgd2luZG93OiBTdWJqZWN0PFQ+O1xuICBwcml2YXRlIGNsb3NpbmdOb3RpZmljYXRpb246IFN1YnNjcmlwdGlvbjtcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgZGVzdGluYXRpb246IFN1YnNjcmliZXI8T2JzZXJ2YWJsZTxUPj4sXG4gICAgICAgICAgICAgIHByaXZhdGUgY2xvc2luZ1NlbGVjdG9yOiAoKSA9PiBPYnNlcnZhYmxlPGFueT4pIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gICAgdGhpcy5vcGVuV2luZG93KCk7XG4gIH1cblxuICBub3RpZnlOZXh0KG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IGFueSxcbiAgICAgICAgICAgICBvdXRlckluZGV4OiBudW1iZXIsIGlubmVySW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgICBpbm5lclN1YjogSW5uZXJTdWJzY3JpYmVyPFQsIGFueT4pOiB2b2lkIHtcbiAgICB0aGlzLm9wZW5XaW5kb3coaW5uZXJTdWIpO1xuICB9XG5cbiAgbm90aWZ5RXJyb3IoZXJyb3I6IGFueSwgaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBhbnk+KTogdm9pZCB7XG4gICAgdGhpcy5fZXJyb3IoZXJyb3IpO1xuICB9XG5cbiAgbm90aWZ5Q29tcGxldGUoaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBhbnk+KTogdm9pZCB7XG4gICAgdGhpcy5vcGVuV2luZG93KGlubmVyU3ViKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCk6IHZvaWQge1xuICAgIHRoaXMud2luZG93Lm5leHQodmFsdWUpO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9lcnJvcihlcnI6IGFueSk6IHZvaWQge1xuICAgIHRoaXMud2luZG93LmVycm9yKGVycik7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIHRoaXMudW5zdWJzY3JpYmVDbG9zaW5nTm90aWZpY2F0aW9uKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbXBsZXRlKCk6IHZvaWQge1xuICAgIHRoaXMud2luZG93LmNvbXBsZXRlKCk7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIHRoaXMudW5zdWJzY3JpYmVDbG9zaW5nTm90aWZpY2F0aW9uKCk7XG4gIH1cblxuICBwcml2YXRlIHVuc3Vic2NyaWJlQ2xvc2luZ05vdGlmaWNhdGlvbigpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jbG9zaW5nTm90aWZpY2F0aW9uKSB7XG4gICAgICB0aGlzLmNsb3NpbmdOb3RpZmljYXRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIG9wZW5XaW5kb3coaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBhbnk+ID0gbnVsbCk6IHZvaWQge1xuICAgIGlmIChpbm5lclN1Yikge1xuICAgICAgdGhpcy5yZW1vdmUoaW5uZXJTdWIpO1xuICAgICAgaW5uZXJTdWIudW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBwcmV2V2luZG93ID0gdGhpcy53aW5kb3c7XG4gICAgaWYgKHByZXZXaW5kb3cpIHtcbiAgICAgIHByZXZXaW5kb3cuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBjb25zdCB3aW5kb3cgPSB0aGlzLndpbmRvdyA9IG5ldyBTdWJqZWN0PFQ+KCk7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHdpbmRvdyk7XG5cbiAgICBjb25zdCBjbG9zaW5nTm90aWZpZXIgPSB0cnlDYXRjaCh0aGlzLmNsb3NpbmdTZWxlY3RvcikoKTtcbiAgICBpZiAoY2xvc2luZ05vdGlmaWVyID09PSBlcnJvck9iamVjdCkge1xuICAgICAgY29uc3QgZXJyID0gZXJyb3JPYmplY3QuZTtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uZXJyb3IoZXJyKTtcbiAgICAgIHRoaXMud2luZG93LmVycm9yKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKHRoaXMuY2xvc2luZ05vdGlmaWNhdGlvbiA9IHN1YnNjcmliZVRvUmVzdWx0KHRoaXMsIGNsb3NpbmdOb3RpZmllcikpO1xuICAgIH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci93aW5kb3dXaGVuLnRzIiwiaW1wb3J0IHsgT3BlcmF0b3IgfSBmcm9tICcuLi9PcGVyYXRvcic7XG5pbXBvcnQgeyBTdWJzY3JpYmVyIH0gZnJvbSAnLi4vU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBPYnNlcnZhYmxlSW5wdXQgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IE91dGVyU3Vic2NyaWJlciB9IGZyb20gJy4uL091dGVyU3Vic2NyaWJlcic7XG5pbXBvcnQgeyBJbm5lclN1YnNjcmliZXIgfSBmcm9tICcuLi9Jbm5lclN1YnNjcmliZXInO1xuaW1wb3J0IHsgc3Vic2NyaWJlVG9SZXN1bHQgfSBmcm9tICcuLi91dGlsL3N1YnNjcmliZVRvUmVzdWx0JztcblxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5leHBvcnQgZnVuY3Rpb24gd2l0aExhdGVzdEZyb208VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgcHJvamVjdDogKHYxOiBUKSA9PiBSKTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiB3aXRoTGF0ZXN0RnJvbTxULCBUMiwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHByb2plY3Q6ICh2MTogVCwgdjI6IFQyKSA9PiBSKTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiB3aXRoTGF0ZXN0RnJvbTxULCBUMiwgVDMsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgcHJvamVjdDogKHYxOiBULCB2MjogVDIsIHYzOiBUMykgPT4gUik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gd2l0aExhdGVzdEZyb208VCwgVDIsIFQzLCBUNCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCB2NDogT2JzZXJ2YWJsZUlucHV0PFQ0PiwgcHJvamVjdDogKHYxOiBULCB2MjogVDIsIHYzOiBUMywgdjQ6IFQ0KSA9PiBSKTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiB3aXRoTGF0ZXN0RnJvbTxULCBUMiwgVDMsIFQ0LCBUNSwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgdjI6IE9ic2VydmFibGVJbnB1dDxUMj4sIHYzOiBPYnNlcnZhYmxlSW5wdXQ8VDM+LCB2NDogT2JzZXJ2YWJsZUlucHV0PFQ0PiwgdjU6IE9ic2VydmFibGVJbnB1dDxUNT4sIHByb2plY3Q6ICh2MTogVCwgdjI6IFQyLCB2MzogVDMsIHY0OiBUNCwgdjU6IFQ1KSA9PiBSKTogT2JzZXJ2YWJsZTxSPjtcbmV4cG9ydCBmdW5jdGlvbiB3aXRoTGF0ZXN0RnJvbTxULCBUMiwgVDMsIFQ0LCBUNSwgVDYsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIHYyOiBPYnNlcnZhYmxlSW5wdXQ8VDI+LCB2MzogT2JzZXJ2YWJsZUlucHV0PFQzPiwgdjQ6IE9ic2VydmFibGVJbnB1dDxUND4sIHY1OiBPYnNlcnZhYmxlSW5wdXQ8VDU+LCB2NjogT2JzZXJ2YWJsZUlucHV0PFQ2PiwgcHJvamVjdDogKHYxOiBULCB2MjogVDIsIHYzOiBUMywgdjQ6IFQ0LCB2NTogVDUsIHY2OiBUNikgPT4gUik6IE9ic2VydmFibGU8Uj4gO1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhMYXRlc3RGcm9tPFQsIFQyPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPik6IE9ic2VydmFibGU8W1QsIFQyXT47XG5leHBvcnQgZnVuY3Rpb24gd2l0aExhdGVzdEZyb208VCwgVDIsIFQzPih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4pOiBPYnNlcnZhYmxlPFtULCBUMiwgVDNdPjtcbmV4cG9ydCBmdW5jdGlvbiB3aXRoTGF0ZXN0RnJvbTxULCBUMiwgVDMsIFQ0Pih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+KTogT2JzZXJ2YWJsZTxbVCwgVDIsIFQzLCBUNF0+O1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhMYXRlc3RGcm9tPFQsIFQyLCBUMywgVDQsIFQ1Pih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCB2NTogT2JzZXJ2YWJsZUlucHV0PFQ1Pik6IE9ic2VydmFibGU8W1QsIFQyLCBUMywgVDQsIFQ1XT47XG5leHBvcnQgZnVuY3Rpb24gd2l0aExhdGVzdEZyb208VCwgVDIsIFQzLCBUNCwgVDUsIFQ2Pih0aGlzOiBPYnNlcnZhYmxlPFQ+LCB2MjogT2JzZXJ2YWJsZUlucHV0PFQyPiwgdjM6IE9ic2VydmFibGVJbnB1dDxUMz4sIHY0OiBPYnNlcnZhYmxlSW5wdXQ8VDQ+LCB2NTogT2JzZXJ2YWJsZUlucHV0PFQ1PiwgdjY6IE9ic2VydmFibGVJbnB1dDxUNj4pOiBPYnNlcnZhYmxlPFtULCBUMiwgVDMsIFQ0LCBUNSwgVDZdPiA7XG5leHBvcnQgZnVuY3Rpb24gd2l0aExhdGVzdEZyb208VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgLi4ub2JzZXJ2YWJsZXM6IEFycmF5PE9ic2VydmFibGVJbnB1dDxhbnk+IHwgKCguLi52YWx1ZXM6IEFycmF5PGFueT4pID0+IFIpPik6IE9ic2VydmFibGU8Uj47XG5leHBvcnQgZnVuY3Rpb24gd2l0aExhdGVzdEZyb208VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgYXJyYXk6IE9ic2VydmFibGVJbnB1dDxhbnk+W10pOiBPYnNlcnZhYmxlPFI+O1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhMYXRlc3RGcm9tPFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIGFycmF5OiBPYnNlcnZhYmxlSW5wdXQ8YW55PltdLCBwcm9qZWN0OiAoLi4udmFsdWVzOiBBcnJheTxhbnk+KSA9PiBSKTogT2JzZXJ2YWJsZTxSPjtcbi8qIHRzbGludDplbmFibGU6bWF4LWxpbmUtbGVuZ3RoICovXG5cbi8qKlxuICogQ29tYmluZXMgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIHdpdGggb3RoZXIgT2JzZXJ2YWJsZXMgdG8gY3JlYXRlIGFuIE9ic2VydmFibGVcbiAqIHdob3NlIHZhbHVlcyBhcmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBsYXRlc3QgdmFsdWVzIG9mIGVhY2gsIG9ubHkgd2hlbiB0aGVcbiAqIHNvdXJjZSBlbWl0cy5cbiAqXG4gKiA8c3BhbiBjbGFzcz1cImluZm9ybWFsXCI+V2hlbmV2ZXIgdGhlIHNvdXJjZSBPYnNlcnZhYmxlIGVtaXRzIGEgdmFsdWUsIGl0XG4gKiBjb21wdXRlcyBhIGZvcm11bGEgdXNpbmcgdGhhdCB2YWx1ZSBwbHVzIHRoZSBsYXRlc3QgdmFsdWVzIGZyb20gb3RoZXIgaW5wdXRcbiAqIE9ic2VydmFibGVzLCB0aGVuIGVtaXRzIHRoZSBvdXRwdXQgb2YgdGhhdCBmb3JtdWxhLjwvc3Bhbj5cbiAqXG4gKiA8aW1nIHNyYz1cIi4vaW1nL3dpdGhMYXRlc3RGcm9tLnBuZ1wiIHdpZHRoPVwiMTAwJVwiPlxuICpcbiAqIGB3aXRoTGF0ZXN0RnJvbWAgY29tYmluZXMgZWFjaCB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZSAodGhlXG4gKiBpbnN0YW5jZSkgd2l0aCB0aGUgbGF0ZXN0IHZhbHVlcyBmcm9tIHRoZSBvdGhlciBpbnB1dCBPYnNlcnZhYmxlcyBvbmx5IHdoZW5cbiAqIHRoZSBzb3VyY2UgZW1pdHMgYSB2YWx1ZSwgb3B0aW9uYWxseSB1c2luZyBhIGBwcm9qZWN0YCBmdW5jdGlvbiB0byBkZXRlcm1pbmVcbiAqIHRoZSB2YWx1ZSB0byBiZSBlbWl0dGVkIG9uIHRoZSBvdXRwdXQgT2JzZXJ2YWJsZS4gQWxsIGlucHV0IE9ic2VydmFibGVzIG11c3RcbiAqIGVtaXQgYXQgbGVhc3Qgb25lIHZhbHVlIGJlZm9yZSB0aGUgb3V0cHV0IE9ic2VydmFibGUgd2lsbCBlbWl0IGEgdmFsdWUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+T24gZXZlcnkgY2xpY2sgZXZlbnQsIGVtaXQgYW4gYXJyYXkgd2l0aCB0aGUgbGF0ZXN0IHRpbWVyIGV2ZW50IHBsdXMgdGhlIGNsaWNrIGV2ZW50PC9jYXB0aW9uPlxuICogdmFyIGNsaWNrcyA9IFJ4Lk9ic2VydmFibGUuZnJvbUV2ZW50KGRvY3VtZW50LCAnY2xpY2snKTtcbiAqIHZhciB0aW1lciA9IFJ4Lk9ic2VydmFibGUuaW50ZXJ2YWwoMTAwMCk7XG4gKiB2YXIgcmVzdWx0ID0gY2xpY2tzLndpdGhMYXRlc3RGcm9tKHRpbWVyKTtcbiAqIHJlc3VsdC5zdWJzY3JpYmUoeCA9PiBjb25zb2xlLmxvZyh4KSk7XG4gKlxuICogQHNlZSB7QGxpbmsgY29tYmluZUxhdGVzdH1cbiAqXG4gKiBAcGFyYW0ge09ic2VydmFibGVJbnB1dH0gb3RoZXIgQW4gaW5wdXQgT2JzZXJ2YWJsZSB0byBjb21iaW5lIHdpdGggdGhlIHNvdXJjZVxuICogT2JzZXJ2YWJsZS4gTW9yZSB0aGFuIG9uZSBpbnB1dCBPYnNlcnZhYmxlcyBtYXkgYmUgZ2l2ZW4gYXMgYXJndW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJvamVjdF0gUHJvamVjdGlvbiBmdW5jdGlvbiBmb3IgY29tYmluaW5nIHZhbHVlc1xuICogdG9nZXRoZXIuIFJlY2VpdmVzIGFsbCB2YWx1ZXMgaW4gb3JkZXIgb2YgdGhlIE9ic2VydmFibGVzIHBhc3NlZCwgd2hlcmUgdGhlXG4gKiBmaXJzdCBwYXJhbWV0ZXIgaXMgYSB2YWx1ZSBmcm9tIHRoZSBzb3VyY2UgT2JzZXJ2YWJsZS4gKGUuZy5cbiAqIGBhLndpdGhMYXRlc3RGcm9tKGIsIGMsIChhMSwgYjEsIGMxKSA9PiBhMSArIGIxICsgYzEpYCkuIElmIHRoaXMgaXMgbm90XG4gKiBwYXNzZWQsIGFycmF5cyB3aWxsIGJlIGVtaXR0ZWQgb24gdGhlIG91dHB1dCBPYnNlcnZhYmxlLlxuICogQHJldHVybiB7T2JzZXJ2YWJsZX0gQW4gT2JzZXJ2YWJsZSBvZiBwcm9qZWN0ZWQgdmFsdWVzIGZyb20gdGhlIG1vc3QgcmVjZW50XG4gKiB2YWx1ZXMgZnJvbSBlYWNoIGlucHV0IE9ic2VydmFibGUsIG9yIGFuIGFycmF5IG9mIHRoZSBtb3N0IHJlY2VudCB2YWx1ZXMgZnJvbVxuICogZWFjaCBpbnB1dCBPYnNlcnZhYmxlLlxuICogQG1ldGhvZCB3aXRoTGF0ZXN0RnJvbVxuICogQG93bmVyIE9ic2VydmFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhMYXRlc3RGcm9tPFQsIFI+KHRoaXM6IE9ic2VydmFibGU8VD4sIC4uLmFyZ3M6IEFycmF5PE9ic2VydmFibGVJbnB1dDxhbnk+IHwgKCguLi52YWx1ZXM6IEFycmF5PGFueT4pID0+IFIpPik6IE9ic2VydmFibGU8Uj4ge1xuICBsZXQgcHJvamVjdDogYW55O1xuICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHByb2plY3QgPSBhcmdzLnBvcCgpO1xuICB9XG4gIGNvbnN0IG9ic2VydmFibGVzID0gPE9ic2VydmFibGU8YW55PltdPmFyZ3M7XG4gIHJldHVybiB0aGlzLmxpZnQobmV3IFdpdGhMYXRlc3RGcm9tT3BlcmF0b3Iob2JzZXJ2YWJsZXMsIHByb2plY3QpKTtcbn1cblxuY2xhc3MgV2l0aExhdGVzdEZyb21PcGVyYXRvcjxULCBSPiBpbXBsZW1lbnRzIE9wZXJhdG9yPFQsIFI+IHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBvYnNlcnZhYmxlczogT2JzZXJ2YWJsZTxhbnk+W10sXG4gICAgICAgICAgICAgIHByaXZhdGUgcHJvamVjdD86ICguLi52YWx1ZXM6IGFueVtdKSA9PiBPYnNlcnZhYmxlPFI+KSB7XG4gIH1cblxuICBjYWxsKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8Uj4sIHNvdXJjZTogYW55KTogYW55IHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgV2l0aExhdGVzdEZyb21TdWJzY3JpYmVyKHN1YnNjcmliZXIsIHRoaXMub2JzZXJ2YWJsZXMsIHRoaXMucHJvamVjdCkpO1xuICB9XG59XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5jbGFzcyBXaXRoTGF0ZXN0RnJvbVN1YnNjcmliZXI8VCwgUj4gZXh0ZW5kcyBPdXRlclN1YnNjcmliZXI8VCwgUj4ge1xuICBwcml2YXRlIHZhbHVlczogYW55W107XG4gIHByaXZhdGUgdG9SZXNwb25kOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGRlc3RpbmF0aW9uOiBTdWJzY3JpYmVyPFI+LFxuICAgICAgICAgICAgICBwcml2YXRlIG9ic2VydmFibGVzOiBPYnNlcnZhYmxlPGFueT5bXSxcbiAgICAgICAgICAgICAgcHJpdmF0ZSBwcm9qZWN0PzogKC4uLnZhbHVlczogYW55W10pID0+IE9ic2VydmFibGU8Uj4pIHtcbiAgICBzdXBlcihkZXN0aW5hdGlvbik7XG4gICAgY29uc3QgbGVuID0gb2JzZXJ2YWJsZXMubGVuZ3RoO1xuICAgIHRoaXMudmFsdWVzID0gbmV3IEFycmF5KGxlbik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLnRvUmVzcG9uZC5wdXNoKGkpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGxldCBvYnNlcnZhYmxlID0gb2JzZXJ2YWJsZXNbaV07XG4gICAgICB0aGlzLmFkZChzdWJzY3JpYmVUb1Jlc3VsdDxULCBSPih0aGlzLCBvYnNlcnZhYmxlLCA8YW55Pm9ic2VydmFibGUsIGkpKTtcbiAgICB9XG4gIH1cblxuICBub3RpZnlOZXh0KG91dGVyVmFsdWU6IFQsIGlubmVyVmFsdWU6IFIsXG4gICAgICAgICAgICAgb3V0ZXJJbmRleDogbnVtYmVyLCBpbm5lckluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICAgaW5uZXJTdWI6IElubmVyU3Vic2NyaWJlcjxULCBSPik6IHZvaWQge1xuICAgIHRoaXMudmFsdWVzW291dGVySW5kZXhdID0gaW5uZXJWYWx1ZTtcbiAgICBjb25zdCB0b1Jlc3BvbmQgPSB0aGlzLnRvUmVzcG9uZDtcbiAgICBpZiAodG9SZXNwb25kLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGZvdW5kID0gdG9SZXNwb25kLmluZGV4T2Yob3V0ZXJJbmRleCk7XG4gICAgICBpZiAoZm91bmQgIT09IC0xKSB7XG4gICAgICAgIHRvUmVzcG9uZC5zcGxpY2UoZm91bmQsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5vdGlmeUNvbXBsZXRlKCkge1xuICAgIC8vIG5vb3BcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV4dCh2YWx1ZTogVCkge1xuICAgIGlmICh0aGlzLnRvUmVzcG9uZC5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSBbdmFsdWUsIC4uLnRoaXMudmFsdWVzXTtcbiAgICAgIGlmICh0aGlzLnByb2plY3QpIHtcbiAgICAgICAgdGhpcy5fdHJ5UHJvamVjdChhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF90cnlQcm9qZWN0KGFyZ3M6IGFueVtdKSB7XG4gICAgbGV0IHJlc3VsdDogYW55O1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnByb2plY3QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGVzdGluYXRpb24ubmV4dChyZXN1bHQpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL29wZXJhdG9yL3dpdGhMYXRlc3RGcm9tLnRzIiwiaW1wb3J0IHsgWmlwT3BlcmF0b3IgfSBmcm9tICcuL3ppcCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5cbi8qKlxuICogQHBhcmFtIHByb2plY3RcbiAqIEByZXR1cm4ge09ic2VydmFibGU8Uj58V2ViU29ja2V0U3ViamVjdDxUPnxPYnNlcnZhYmxlPFQ+fVxuICogQG1ldGhvZCB6aXBBbGxcbiAqIEBvd25lciBPYnNlcnZhYmxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB6aXBBbGw8VCwgUj4odGhpczogT2JzZXJ2YWJsZTxUPiwgcHJvamVjdD86ICguLi52YWx1ZXM6IEFycmF5PGFueT4pID0+IFIpOiBPYnNlcnZhYmxlPFI+IHtcbiAgcmV0dXJuIHRoaXMubGlmdChuZXcgWmlwT3BlcmF0b3IocHJvamVjdCkpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9vcGVyYXRvci96aXBBbGwudHMiLCJpbXBvcnQgeyBTY2hlZHVsZXIgfSBmcm9tICcuLi9TY2hlZHVsZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcblxuLyoqXG4gKiBBIHVuaXQgb2Ygd29yayB0byBiZSBleGVjdXRlZCBpbiBhIHtAbGluayBTY2hlZHVsZXJ9LiBBbiBhY3Rpb24gaXMgdHlwaWNhbGx5XG4gKiBjcmVhdGVkIGZyb20gd2l0aGluIGEgU2NoZWR1bGVyIGFuZCBhbiBSeEpTIHVzZXIgZG9lcyBub3QgbmVlZCB0byBjb25jZXJuXG4gKiB0aGVtc2VsdmVzIGFib3V0IGNyZWF0aW5nIGFuZCBtYW5pcHVsYXRpbmcgYW4gQWN0aW9uLlxuICpcbiAqIGBgYHRzXG4gKiBjbGFzcyBBY3Rpb248VD4gZXh0ZW5kcyBTdWJzY3JpcHRpb24ge1xuICogICBuZXcgKHNjaGVkdWxlcjogU2NoZWR1bGVyLCB3b3JrOiAoc3RhdGU/OiBUKSA9PiB2b2lkKTtcbiAqICAgc2NoZWR1bGUoc3RhdGU/OiBULCBkZWxheTogbnVtYmVyID0gMCk6IFN1YnNjcmlwdGlvbjtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBjbGFzcyBBY3Rpb248VD5cbiAqL1xuZXhwb3J0IGNsYXNzIEFjdGlvbjxUPiBleHRlbmRzIFN1YnNjcmlwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHNjaGVkdWxlcjogU2NoZWR1bGVyLCB3b3JrOiAodGhpczogQWN0aW9uPFQ+LCBzdGF0ZT86IFQpID0+IHZvaWQpIHtcbiAgICBzdXBlcigpO1xuICB9XG4gIC8qKlxuICAgKiBTY2hlZHVsZXMgdGhpcyBhY3Rpb24gb24gaXRzIHBhcmVudCBTY2hlZHVsZXIgZm9yIGV4ZWN1dGlvbi4gTWF5IGJlIHBhc3NlZFxuICAgKiBzb21lIGNvbnRleHQgb2JqZWN0LCBgc3RhdGVgLiBNYXkgaGFwcGVuIGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZSxcbiAgICogYWNjb3JkaW5nIHRvIHRoZSBgZGVsYXlgIHBhcmFtZXRlciwgaWYgc3BlY2lmaWVkLlxuICAgKiBAcGFyYW0ge1R9IFtzdGF0ZV0gU29tZSBjb250ZXh0dWFsIGRhdGEgdGhhdCB0aGUgYHdvcmtgIGZ1bmN0aW9uIHVzZXMgd2hlblxuICAgKiBjYWxsZWQgYnkgdGhlIFNjaGVkdWxlci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheV0gVGltZSB0byB3YWl0IGJlZm9yZSBleGVjdXRpbmcgdGhlIHdvcmssIHdoZXJlIHRoZVxuICAgKiB0aW1lIHVuaXQgaXMgaW1wbGljaXQgYW5kIGRlZmluZWQgYnkgdGhlIFNjaGVkdWxlci5cbiAgICogQHJldHVybiB7dm9pZH1cbiAgICovXG4gIHB1YmxpYyBzY2hlZHVsZShzdGF0ZT86IFQsIGRlbGF5OiBudW1iZXIgPSAwKTogU3Vic2NyaXB0aW9uIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9zY2hlZHVsZXIvQWN0aW9uLnRzIiwiaW1wb3J0IHsgQXN5bmNBY3Rpb24gfSBmcm9tICcuL0FzeW5jQWN0aW9uJztcbmltcG9ydCB7IEFuaW1hdGlvbkZyYW1lIH0gZnJvbSAnLi4vdXRpbC9BbmltYXRpb25GcmFtZSc7XG5pbXBvcnQgeyBBbmltYXRpb25GcmFtZVNjaGVkdWxlciB9IGZyb20gJy4vQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXInO1xuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuZXhwb3J0IGNsYXNzIEFuaW1hdGlvbkZyYW1lQWN0aW9uPFQ+IGV4dGVuZHMgQXN5bmNBY3Rpb248VD4ge1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBzY2hlZHVsZXI6IEFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLFxuICAgICAgICAgICAgICBwcm90ZWN0ZWQgd29yazogKHRoaXM6IEFuaW1hdGlvbkZyYW1lQWN0aW9uPFQ+LCBzdGF0ZT86IFQpID0+IHZvaWQpIHtcbiAgICBzdXBlcihzY2hlZHVsZXIsIHdvcmspO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlcXVlc3RBc3luY0lkKHNjaGVkdWxlcjogQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIsIGlkPzogYW55LCBkZWxheTogbnVtYmVyID0gMCk6IGFueSB7XG4gICAgLy8gSWYgZGVsYXkgaXMgZ3JlYXRlciB0aGFuIDAsIHJlcXVlc3QgYXMgYW4gYXN5bmMgYWN0aW9uLlxuICAgIGlmIChkZWxheSAhPT0gbnVsbCAmJiBkZWxheSA+IDApIHtcbiAgICAgIHJldHVybiBzdXBlci5yZXF1ZXN0QXN5bmNJZChzY2hlZHVsZXIsIGlkLCBkZWxheSk7XG4gICAgfVxuICAgIC8vIFB1c2ggdGhlIGFjdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBzY2hlZHVsZXIgcXVldWUuXG4gICAgc2NoZWR1bGVyLmFjdGlvbnMucHVzaCh0aGlzKTtcbiAgICAvLyBJZiBhbiBhbmltYXRpb24gZnJhbWUgaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWQsIGRvbid0IHJlcXVlc3QgYW5vdGhlclxuICAgIC8vIG9uZS4gSWYgYW4gYW5pbWF0aW9uIGZyYW1lIGhhc24ndCBiZWVuIHJlcXVlc3RlZCB5ZXQsIHJlcXVlc3Qgb25lLiBSZXR1cm5cbiAgICAvLyB0aGUgY3VycmVudCBhbmltYXRpb24gZnJhbWUgcmVxdWVzdCBpZC5cbiAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlZCB8fCAoc2NoZWR1bGVyLnNjaGVkdWxlZCA9IEFuaW1hdGlvbkZyYW1lLnJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgIHNjaGVkdWxlci5mbHVzaC5iaW5kKHNjaGVkdWxlciwgbnVsbClcbiAgICApKTtcbiAgfVxuICBwcm90ZWN0ZWQgcmVjeWNsZUFzeW5jSWQoc2NoZWR1bGVyOiBBbmltYXRpb25GcmFtZVNjaGVkdWxlciwgaWQ/OiBhbnksIGRlbGF5OiBudW1iZXIgPSAwKTogYW55IHtcbiAgICAvLyBJZiBkZWxheSBleGlzdHMgYW5kIGlzIGdyZWF0ZXIgdGhhbiAwLCBvciBpZiB0aGUgZGVsYXkgaXMgbnVsbCAodGhlXG4gICAgLy8gYWN0aW9uIHdhc24ndCByZXNjaGVkdWxlZCkgYnV0IHdhcyBvcmlnaW5hbGx5IHNjaGVkdWxlZCBhcyBhbiBhc3luY1xuICAgIC8vIGFjdGlvbiwgdGhlbiByZWN5Y2xlIGFzIGFuIGFzeW5jIGFjdGlvbi5cbiAgICBpZiAoKGRlbGF5ICE9PSBudWxsICYmIGRlbGF5ID4gMCkgfHwgKGRlbGF5ID09PSBudWxsICYmIHRoaXMuZGVsYXkgPiAwKSkge1xuICAgICAgcmV0dXJuIHN1cGVyLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIGRlbGF5KTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHNjaGVkdWxlciBxdWV1ZSBpcyBlbXB0eSwgY2FuY2VsIHRoZSByZXF1ZXN0ZWQgYW5pbWF0aW9uIGZyYW1lIGFuZFxuICAgIC8vIHNldCB0aGUgc2NoZWR1bGVkIGZsYWcgdG8gdW5kZWZpbmVkIHNvIHRoZSBuZXh0IEFuaW1hdGlvbkZyYW1lQWN0aW9uIHdpbGxcbiAgICAvLyByZXF1ZXN0IGl0cyBvd24uXG4gICAgaWYgKHNjaGVkdWxlci5hY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgQW5pbWF0aW9uRnJhbWUuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpO1xuICAgICAgc2NoZWR1bGVyLnNjaGVkdWxlZCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gUmV0dXJuIHVuZGVmaW5lZCBzbyB0aGUgYWN0aW9uIGtub3dzIHRvIHJlcXVlc3QgYSBuZXcgYXN5bmMgaWQgaWYgaXQncyByZXNjaGVkdWxlZC5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3NjaGVkdWxlci9BbmltYXRpb25GcmFtZUFjdGlvbi50cyIsImltcG9ydCB7IEFzeW5jQWN0aW9uIH0gZnJvbSAnLi9Bc3luY0FjdGlvbic7XG5pbXBvcnQgeyBBc3luY1NjaGVkdWxlciB9IGZyb20gJy4vQXN5bmNTY2hlZHVsZXInO1xuXG5leHBvcnQgY2xhc3MgQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIgZXh0ZW5kcyBBc3luY1NjaGVkdWxlciB7XG4gIHB1YmxpYyBmbHVzaChhY3Rpb24/OiBBc3luY0FjdGlvbjxhbnk+KTogdm9pZCB7XG5cbiAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5zY2hlZHVsZWQgPSB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCB7YWN0aW9uc30gPSB0aGlzO1xuICAgIGxldCBlcnJvcjogYW55O1xuICAgIGxldCBpbmRleDogbnVtYmVyID0gLTE7XG4gICAgbGV0IGNvdW50OiBudW1iZXIgPSBhY3Rpb25zLmxlbmd0aDtcbiAgICBhY3Rpb24gPSBhY3Rpb24gfHwgYWN0aW9ucy5zaGlmdCgpO1xuXG4gICAgZG8ge1xuICAgICAgaWYgKGVycm9yID0gYWN0aW9uLmV4ZWN1dGUoYWN0aW9uLnN0YXRlLCBhY3Rpb24uZGVsYXkpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKCsraW5kZXggPCBjb3VudCAmJiAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKSk7XG5cbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGNvdW50ICYmIChhY3Rpb24gPSBhY3Rpb25zLnNoaWZ0KCkpKSB7XG4gICAgICAgIGFjdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3NjaGVkdWxlci9BbmltYXRpb25GcmFtZVNjaGVkdWxlci50cyIsImltcG9ydCB7IEltbWVkaWF0ZSB9IGZyb20gJy4uL3V0aWwvSW1tZWRpYXRlJztcbmltcG9ydCB7IEFzeW5jQWN0aW9uIH0gZnJvbSAnLi9Bc3luY0FjdGlvbic7XG5pbXBvcnQgeyBBc2FwU2NoZWR1bGVyIH0gZnJvbSAnLi9Bc2FwU2NoZWR1bGVyJztcblxuLyoqXG4gKiBXZSBuZWVkIHRoaXMgSlNEb2MgY29tbWVudCBmb3IgYWZmZWN0aW5nIEVTRG9jLlxuICogQGlnbm9yZVxuICogQGV4dGVuZHMge0lnbm9yZWR9XG4gKi9cbmV4cG9ydCBjbGFzcyBBc2FwQWN0aW9uPFQ+IGV4dGVuZHMgQXN5bmNBY3Rpb248VD4ge1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBzY2hlZHVsZXI6IEFzYXBTY2hlZHVsZXIsXG4gICAgICAgICAgICAgIHByb3RlY3RlZCB3b3JrOiAodGhpczogQXNhcEFjdGlvbjxUPiwgc3RhdGU/OiBUKSA9PiB2b2lkKSB7XG4gICAgc3VwZXIoc2NoZWR1bGVyLCB3b3JrKTtcbiAgfVxuXG4gIHByb3RlY3RlZCByZXF1ZXN0QXN5bmNJZChzY2hlZHVsZXI6IEFzYXBTY2hlZHVsZXIsIGlkPzogYW55LCBkZWxheTogbnVtYmVyID0gMCk6IGFueSB7XG4gICAgLy8gSWYgZGVsYXkgaXMgZ3JlYXRlciB0aGFuIDAsIHJlcXVlc3QgYXMgYW4gYXN5bmMgYWN0aW9uLlxuICAgIGlmIChkZWxheSAhPT0gbnVsbCAmJiBkZWxheSA+IDApIHtcbiAgICAgIHJldHVybiBzdXBlci5yZXF1ZXN0QXN5bmNJZChzY2hlZHVsZXIsIGlkLCBkZWxheSk7XG4gICAgfVxuICAgIC8vIFB1c2ggdGhlIGFjdGlvbiB0byB0aGUgZW5kIG9mIHRoZSBzY2hlZHVsZXIgcXVldWUuXG4gICAgc2NoZWR1bGVyLmFjdGlvbnMucHVzaCh0aGlzKTtcbiAgICAvLyBJZiBhIG1pY3JvdGFzayBoYXMgYWxyZWFkeSBiZWVuIHNjaGVkdWxlZCwgZG9uJ3Qgc2NoZWR1bGUgYW5vdGhlclxuICAgIC8vIG9uZS4gSWYgYSBtaWNyb3Rhc2sgaGFzbid0IGJlZW4gc2NoZWR1bGVkIHlldCwgc2NoZWR1bGUgb25lIG5vdy4gUmV0dXJuXG4gICAgLy8gdGhlIGN1cnJlbnQgc2NoZWR1bGVkIG1pY3JvdGFzayBpZC5cbiAgICByZXR1cm4gc2NoZWR1bGVyLnNjaGVkdWxlZCB8fCAoc2NoZWR1bGVyLnNjaGVkdWxlZCA9IEltbWVkaWF0ZS5zZXRJbW1lZGlhdGUoXG4gICAgICBzY2hlZHVsZXIuZmx1c2guYmluZChzY2hlZHVsZXIsIG51bGwpXG4gICAgKSk7XG4gIH1cbiAgcHJvdGVjdGVkIHJlY3ljbGVBc3luY0lkKHNjaGVkdWxlcjogQXNhcFNjaGVkdWxlciwgaWQ/OiBhbnksIGRlbGF5OiBudW1iZXIgPSAwKTogYW55IHtcbiAgICAvLyBJZiBkZWxheSBleGlzdHMgYW5kIGlzIGdyZWF0ZXIgdGhhbiAwLCBvciBpZiB0aGUgZGVsYXkgaXMgbnVsbCAodGhlXG4gICAgLy8gYWN0aW9uIHdhc24ndCByZXNjaGVkdWxlZCkgYnV0IHdhcyBvcmlnaW5hbGx5IHNjaGVkdWxlZCBhcyBhbiBhc3luY1xuICAgIC8vIGFjdGlvbiwgdGhlbiByZWN5Y2xlIGFzIGFuIGFzeW5jIGFjdGlvbi5cbiAgICBpZiAoKGRlbGF5ICE9PSBudWxsICYmIGRlbGF5ID4gMCkgfHwgKGRlbGF5ID09PSBudWxsICYmIHRoaXMuZGVsYXkgPiAwKSkge1xuICAgICAgcmV0dXJuIHN1cGVyLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIGRlbGF5KTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIHNjaGVkdWxlciBxdWV1ZSBpcyBlbXB0eSwgY2FuY2VsIHRoZSByZXF1ZXN0ZWQgbWljcm90YXNrIGFuZFxuICAgIC8vIHNldCB0aGUgc2NoZWR1bGVkIGZsYWcgdG8gdW5kZWZpbmVkIHNvIHRoZSBuZXh0IEFzYXBBY3Rpb24gd2lsbCBzY2hlZHVsZVxuICAgIC8vIGl0cyBvd24uXG4gICAgaWYgKHNjaGVkdWxlci5hY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgSW1tZWRpYXRlLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICAgIHNjaGVkdWxlci5zY2hlZHVsZWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIFJldHVybiB1bmRlZmluZWQgc28gdGhlIGFjdGlvbiBrbm93cyB0byByZXF1ZXN0IGEgbmV3IGFzeW5jIGlkIGlmIGl0J3MgcmVzY2hlZHVsZWQuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9zY2hlZHVsZXIvQXNhcEFjdGlvbi50cyIsImltcG9ydCB7IEFzeW5jQWN0aW9uIH0gZnJvbSAnLi9Bc3luY0FjdGlvbic7XG5pbXBvcnQgeyBBc3luY1NjaGVkdWxlciB9IGZyb20gJy4vQXN5bmNTY2hlZHVsZXInO1xuXG5leHBvcnQgY2xhc3MgQXNhcFNjaGVkdWxlciBleHRlbmRzIEFzeW5jU2NoZWR1bGVyIHtcbiAgcHVibGljIGZsdXNoKGFjdGlvbj86IEFzeW5jQWN0aW9uPGFueT4pOiB2b2lkIHtcblxuICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLnNjaGVkdWxlZCA9IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0IHthY3Rpb25zfSA9IHRoaXM7XG4gICAgbGV0IGVycm9yOiBhbnk7XG4gICAgbGV0IGluZGV4OiBudW1iZXIgPSAtMTtcbiAgICBsZXQgY291bnQ6IG51bWJlciA9IGFjdGlvbnMubGVuZ3RoO1xuICAgIGFjdGlvbiA9IGFjdGlvbiB8fCBhY3Rpb25zLnNoaWZ0KCk7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoZXJyb3IgPSBhY3Rpb24uZXhlY3V0ZShhY3Rpb24uc3RhdGUsIGFjdGlvbi5kZWxheSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoKytpbmRleCA8IGNvdW50ICYmIChhY3Rpb24gPSBhY3Rpb25zLnNoaWZ0KCkpKTtcblxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgY291bnQgJiYgKGFjdGlvbiA9IGFjdGlvbnMuc2hpZnQoKSkpIHtcbiAgICAgICAgYWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvc2NoZWR1bGVyL0FzYXBTY2hlZHVsZXIudHMiLCJpbXBvcnQgeyBBc3luY0FjdGlvbiB9IGZyb20gJy4vQXN5bmNBY3Rpb24nO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IFF1ZXVlU2NoZWR1bGVyIH0gZnJvbSAnLi9RdWV1ZVNjaGVkdWxlcic7XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5leHBvcnQgY2xhc3MgUXVldWVBY3Rpb248VD4gZXh0ZW5kcyBBc3luY0FjdGlvbjxUPiB7XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHNjaGVkdWxlcjogUXVldWVTY2hlZHVsZXIsXG4gICAgICAgICAgICAgIHByb3RlY3RlZCB3b3JrOiAodGhpczogUXVldWVBY3Rpb248VD4sIHN0YXRlPzogVCkgPT4gdm9pZCkge1xuICAgIHN1cGVyKHNjaGVkdWxlciwgd29yayk7XG4gIH1cblxuICBwdWJsaWMgc2NoZWR1bGUoc3RhdGU/OiBULCBkZWxheTogbnVtYmVyID0gMCk6IFN1YnNjcmlwdGlvbiB7XG4gICAgaWYgKGRlbGF5ID4gMCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnNjaGVkdWxlKHN0YXRlLCBkZWxheSk7XG4gICAgfVxuICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5zY2hlZHVsZXIuZmx1c2godGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwdWJsaWMgZXhlY3V0ZShzdGF0ZTogVCwgZGVsYXk6IG51bWJlcik6IGFueSB7XG4gICAgcmV0dXJuIChkZWxheSA+IDAgfHwgdGhpcy5jbG9zZWQpID9cbiAgICAgIHN1cGVyLmV4ZWN1dGUoc3RhdGUsIGRlbGF5KSA6XG4gICAgICB0aGlzLl9leGVjdXRlKHN0YXRlLCBkZWxheSkgO1xuICB9XG5cbiAgcHJvdGVjdGVkIHJlcXVlc3RBc3luY0lkKHNjaGVkdWxlcjogUXVldWVTY2hlZHVsZXIsIGlkPzogYW55LCBkZWxheTogbnVtYmVyID0gMCk6IGFueSB7XG4gICAgLy8gSWYgZGVsYXkgZXhpc3RzIGFuZCBpcyBncmVhdGVyIHRoYW4gMCwgb3IgaWYgdGhlIGRlbGF5IGlzIG51bGwgKHRoZVxuICAgIC8vIGFjdGlvbiB3YXNuJ3QgcmVzY2hlZHVsZWQpIGJ1dCB3YXMgb3JpZ2luYWxseSBzY2hlZHVsZWQgYXMgYW4gYXN5bmNcbiAgICAvLyBhY3Rpb24sIHRoZW4gcmVjeWNsZSBhcyBhbiBhc3luYyBhY3Rpb24uXG4gICAgaWYgKChkZWxheSAhPT0gbnVsbCAmJiBkZWxheSA+IDApIHx8IChkZWxheSA9PT0gbnVsbCAmJiB0aGlzLmRlbGF5ID4gMCkpIHtcbiAgICAgIHJldHVybiBzdXBlci5yZXF1ZXN0QXN5bmNJZChzY2hlZHVsZXIsIGlkLCBkZWxheSk7XG4gICAgfVxuICAgIC8vIE90aGVyd2lzZSBmbHVzaCB0aGUgc2NoZWR1bGVyIHN0YXJ0aW5nIHdpdGggdGhpcyBhY3Rpb24uXG4gICAgcmV0dXJuIHNjaGVkdWxlci5mbHVzaCh0aGlzKTtcbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy9zY2hlZHVsZXIvUXVldWVBY3Rpb24udHMiLCJpbXBvcnQgeyBBc3luY1NjaGVkdWxlciB9IGZyb20gJy4vQXN5bmNTY2hlZHVsZXInO1xuXG5leHBvcnQgY2xhc3MgUXVldWVTY2hlZHVsZXIgZXh0ZW5kcyBBc3luY1NjaGVkdWxlciB7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3NjaGVkdWxlci9RdWV1ZVNjaGVkdWxlci50cyIsImltcG9ydCB7IEFuaW1hdGlvbkZyYW1lQWN0aW9uIH0gZnJvbSAnLi9BbmltYXRpb25GcmFtZUFjdGlvbic7XG5pbXBvcnQgeyBBbmltYXRpb25GcmFtZVNjaGVkdWxlciB9IGZyb20gJy4vQW5pbWF0aW9uRnJhbWVTY2hlZHVsZXInO1xuXG4vKipcbiAqXG4gKiBBbmltYXRpb24gRnJhbWUgU2NoZWR1bGVyXG4gKlxuICogPHNwYW4gY2xhc3M9XCJpbmZvcm1hbFwiPlBlcmZvcm0gdGFzayB3aGVuIGB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lYCB3b3VsZCBmaXJlPC9zcGFuPlxuICpcbiAqIFdoZW4gYGFuaW1hdGlvbkZyYW1lYCBzY2hlZHVsZXIgaXMgdXNlZCB3aXRoIGRlbGF5LCBpdCB3aWxsIGZhbGwgYmFjayB0byB7QGxpbmsgYXN5bmN9IHNjaGVkdWxlclxuICogYmVoYXZpb3VyLlxuICpcbiAqIFdpdGhvdXQgZGVsYXksIGBhbmltYXRpb25GcmFtZWAgc2NoZWR1bGVyIGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBzbW9vdGggYnJvd3NlciBhbmltYXRpb25zLlxuICogSXQgbWFrZXMgc3VyZSBzY2hlZHVsZWQgdGFzayB3aWxsIGhhcHBlbiBqdXN0IGJlZm9yZSBuZXh0IGJyb3dzZXIgY29udGVudCByZXBhaW50LFxuICogdGh1cyBwZXJmb3JtaW5nIGFuaW1hdGlvbnMgYXMgZWZmaWNpZW50bHkgYXMgcG9zc2libGUuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+U2NoZWR1bGUgZGl2IGhlaWdodCBhbmltYXRpb248L2NhcHRpb24+XG4gKiBjb25zdCBkaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc29tZS1kaXYnKTtcbiAqXG4gKiBSeC5TY2hlZHVsZXIuc2NoZWR1bGUoZnVuY3Rpb24oaGVpZ2h0KSB7XG4gKiAgIGRpdi5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBcInB4XCI7XG4gKlxuICogICB0aGlzLnNjaGVkdWxlKGhlaWdodCArIDEpOyAgLy8gYHRoaXNgIHJlZmVyZW5jZXMgY3VycmVudGx5IGV4ZWN1dGluZyBBY3Rpb24sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB3ZSByZXNjaGVkdWxlIHdpdGggbmV3IHN0YXRlXG4gKiB9LCAwLCAwKTtcbiAqXG4gKiAvLyBZb3Ugd2lsbCBzZWUgLnNvbWUtZGl2IGVsZW1lbnQgZ3Jvd2luZyBpbiBoZWlnaHRcbiAqXG4gKlxuICogQHN0YXRpYyB0cnVlXG4gKiBAbmFtZSBhbmltYXRpb25GcmFtZVxuICogQG93bmVyIFNjaGVkdWxlclxuICovXG5cbmV4cG9ydCBjb25zdCBhbmltYXRpb25GcmFtZSA9IG5ldyBBbmltYXRpb25GcmFtZVNjaGVkdWxlcihBbmltYXRpb25GcmFtZUFjdGlvbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3NjaGVkdWxlci9hbmltYXRpb25GcmFtZS50cyIsImltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICcuLi9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBTY2hlZHVsZXIgfSBmcm9tICcuLi9TY2hlZHVsZXInO1xuaW1wb3J0IHsgVGVzdE1lc3NhZ2UgfSBmcm9tICcuL1Rlc3RNZXNzYWdlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbkxvZyB9IGZyb20gJy4vU3Vic2NyaXB0aW9uTG9nJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbkxvZ2dhYmxlIH0gZnJvbSAnLi9TdWJzY3JpcHRpb25Mb2dnYWJsZSc7XG5pbXBvcnQgeyBhcHBseU1peGlucyB9IGZyb20gJy4uL3V0aWwvYXBwbHlNaXhpbnMnO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuXG4vKipcbiAqIFdlIG5lZWQgdGhpcyBKU0RvYyBjb21tZW50IGZvciBhZmZlY3RpbmcgRVNEb2MuXG4gKiBAaWdub3JlXG4gKiBAZXh0ZW5kcyB7SWdub3JlZH1cbiAqL1xuZXhwb3J0IGNsYXNzIENvbGRPYnNlcnZhYmxlPFQ+IGV4dGVuZHMgT2JzZXJ2YWJsZTxUPiBpbXBsZW1lbnRzIFN1YnNjcmlwdGlvbkxvZ2dhYmxlIHtcbiAgcHVibGljIHN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbkxvZ1tdID0gW107XG4gIHNjaGVkdWxlcjogU2NoZWR1bGVyO1xuICBsb2dTdWJzY3JpYmVkRnJhbWU6ICgpID0+IG51bWJlcjtcbiAgbG9nVW5zdWJzY3JpYmVkRnJhbWU6IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBtZXNzYWdlczogVGVzdE1lc3NhZ2VbXSxcbiAgICAgICAgICAgICAgc2NoZWR1bGVyOiBTY2hlZHVsZXIpIHtcbiAgICBzdXBlcihmdW5jdGlvbiAodGhpczogQ29sZE9ic2VydmFibGU8VD4sIHN1YnNjcmliZXI6IFN1YnNjcmliZXI8YW55Pikge1xuICAgICAgY29uc3Qgb2JzZXJ2YWJsZTogQ29sZE9ic2VydmFibGU8VD4gPSB0aGlzO1xuICAgICAgY29uc3QgaW5kZXggPSBvYnNlcnZhYmxlLmxvZ1N1YnNjcmliZWRGcmFtZSgpO1xuICAgICAgc3Vic2NyaWJlci5hZGQobmV3IFN1YnNjcmlwdGlvbigoKSA9PiB7XG4gICAgICAgIG9ic2VydmFibGUubG9nVW5zdWJzY3JpYmVkRnJhbWUoaW5kZXgpO1xuICAgICAgfSkpO1xuICAgICAgb2JzZXJ2YWJsZS5zY2hlZHVsZU1lc3NhZ2VzKHN1YnNjcmliZXIpO1xuICAgICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gICAgfSk7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gIH1cblxuICBzY2hlZHVsZU1lc3NhZ2VzKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8YW55Pikge1xuICAgIGNvbnN0IG1lc3NhZ2VzTGVuZ3RoID0gdGhpcy5tZXNzYWdlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlc0xlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5tZXNzYWdlc1tpXTtcbiAgICAgIHN1YnNjcmliZXIuYWRkKFxuICAgICAgICB0aGlzLnNjaGVkdWxlci5zY2hlZHVsZSgoe21lc3NhZ2UsIHN1YnNjcmliZXJ9KSA9PiB7IG1lc3NhZ2Uubm90aWZpY2F0aW9uLm9ic2VydmUoc3Vic2NyaWJlcik7IH0sXG4gICAgICAgICAgbWVzc2FnZS5mcmFtZSxcbiAgICAgICAgICB7bWVzc2FnZSwgc3Vic2NyaWJlcn0pXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuYXBwbHlNaXhpbnMoQ29sZE9ic2VydmFibGUsIFtTdWJzY3JpcHRpb25Mb2dnYWJsZV0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy90ZXN0aW5nL0NvbGRPYnNlcnZhYmxlLnRzIiwiaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJy4uL1N1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi4vU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IFNjaGVkdWxlciB9IGZyb20gJy4uL1NjaGVkdWxlcic7XG5pbXBvcnQgeyBUZXN0TWVzc2FnZSB9IGZyb20gJy4vVGVzdE1lc3NhZ2UnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uTG9nIH0gZnJvbSAnLi9TdWJzY3JpcHRpb25Mb2cnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uTG9nZ2FibGUgfSBmcm9tICcuL1N1YnNjcmlwdGlvbkxvZ2dhYmxlJztcbmltcG9ydCB7IGFwcGx5TWl4aW5zIH0gZnJvbSAnLi4vdXRpbC9hcHBseU1peGlucyc7XG5cbi8qKlxuICogV2UgbmVlZCB0aGlzIEpTRG9jIGNvbW1lbnQgZm9yIGFmZmVjdGluZyBFU0RvYy5cbiAqIEBpZ25vcmVcbiAqIEBleHRlbmRzIHtJZ25vcmVkfVxuICovXG5leHBvcnQgY2xhc3MgSG90T2JzZXJ2YWJsZTxUPiBleHRlbmRzIFN1YmplY3Q8VD4gaW1wbGVtZW50cyBTdWJzY3JpcHRpb25Mb2dnYWJsZSB7XG4gIHB1YmxpYyBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25Mb2dbXSA9IFtdO1xuICBzY2hlZHVsZXI6IFNjaGVkdWxlcjtcbiAgbG9nU3Vic2NyaWJlZEZyYW1lOiAoKSA9PiBudW1iZXI7XG4gIGxvZ1Vuc3Vic2NyaWJlZEZyYW1lOiAoaW5kZXg6IG51bWJlcikgPT4gdm9pZDtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgbWVzc2FnZXM6IFRlc3RNZXNzYWdlW10sXG4gICAgICAgICAgICAgIHNjaGVkdWxlcjogU2NoZWR1bGVyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcbiAgfVxuXG4gIHByb3RlY3RlZCBfc3Vic2NyaWJlKHN1YnNjcmliZXI6IFN1YnNjcmliZXI8YW55Pik6IFN1YnNjcmlwdGlvbiB7XG4gICAgY29uc3Qgc3ViamVjdDogSG90T2JzZXJ2YWJsZTxUPiA9IHRoaXM7XG4gICAgY29uc3QgaW5kZXggPSBzdWJqZWN0LmxvZ1N1YnNjcmliZWRGcmFtZSgpO1xuICAgIHN1YnNjcmliZXIuYWRkKG5ldyBTdWJzY3JpcHRpb24oKCkgPT4ge1xuICAgICAgc3ViamVjdC5sb2dVbnN1YnNjcmliZWRGcmFtZShpbmRleCk7XG4gICAgfSkpO1xuICAgIHJldHVybiBzdXBlci5fc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICB9XG5cbiAgc2V0dXAoKSB7XG4gICAgY29uc3Qgc3ViamVjdCA9IHRoaXM7XG4gICAgY29uc3QgbWVzc2FnZXNMZW5ndGggPSBzdWJqZWN0Lm1lc3NhZ2VzLmxlbmd0aDtcbiAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpuby12YXIta2V5d29yZCAqL1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXNMZW5ndGg7IGkrKykge1xuICAgICAgKCgpID0+IHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBzdWJqZWN0Lm1lc3NhZ2VzW2ldO1xuICAgLyogdHNsaW50OmVuYWJsZSAqL1xuICAgICAgICBzdWJqZWN0LnNjaGVkdWxlci5zY2hlZHVsZShcbiAgICAgICAgICAoKSA9PiB7IG1lc3NhZ2Uubm90aWZpY2F0aW9uLm9ic2VydmUoc3ViamVjdCk7IH0sXG4gICAgICAgICAgbWVzc2FnZS5mcmFtZVxuICAgICAgICApO1xuICAgICAgfSkoKTtcbiAgICB9XG4gIH1cbn1cbmFwcGx5TWl4aW5zKEhvdE9ic2VydmFibGUsIFtTdWJzY3JpcHRpb25Mb2dnYWJsZV0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy90ZXN0aW5nL0hvdE9ic2VydmFibGUudHMiLCJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAnLi4vT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBOb3RpZmljYXRpb24gfSBmcm9tICcuLi9Ob3RpZmljYXRpb24nO1xuaW1wb3J0IHsgQ29sZE9ic2VydmFibGUgfSBmcm9tICcuL0NvbGRPYnNlcnZhYmxlJztcbmltcG9ydCB7IEhvdE9ic2VydmFibGUgfSBmcm9tICcuL0hvdE9ic2VydmFibGUnO1xuaW1wb3J0IHsgVGVzdE1lc3NhZ2UgfSBmcm9tICcuL1Rlc3RNZXNzYWdlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbkxvZyB9IGZyb20gJy4vU3Vic2NyaXB0aW9uTG9nJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJy4uL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBWaXJ0dWFsVGltZVNjaGVkdWxlciwgVmlydHVhbEFjdGlvbiB9IGZyb20gJy4uL3NjaGVkdWxlci9WaXJ0dWFsVGltZVNjaGVkdWxlcic7XG5cbmNvbnN0IGRlZmF1bHRNYXhGcmFtZTogbnVtYmVyID0gNzUwO1xuXG5pbnRlcmZhY2UgRmx1c2hhYmxlVGVzdCB7XG4gIHJlYWR5OiBib29sZWFuO1xuICBhY3R1YWw/OiBhbnlbXTtcbiAgZXhwZWN0ZWQ/OiBhbnlbXTtcbn1cblxuZXhwb3J0IHR5cGUgb2JzZXJ2YWJsZVRvQmVGbiA9IChtYXJibGVzOiBzdHJpbmcsIHZhbHVlcz86IGFueSwgZXJyb3JWYWx1ZT86IGFueSkgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIHN1YnNjcmlwdGlvbkxvZ3NUb0JlRm4gPSAobWFyYmxlczogc3RyaW5nIHwgc3RyaW5nW10pID0+IHZvaWQ7XG5cbmV4cG9ydCBjbGFzcyBUZXN0U2NoZWR1bGVyIGV4dGVuZHMgVmlydHVhbFRpbWVTY2hlZHVsZXIge1xuICBwcml2YXRlIGhvdE9ic2VydmFibGVzOiBIb3RPYnNlcnZhYmxlPGFueT5bXSA9IFtdO1xuICBwcml2YXRlIGNvbGRPYnNlcnZhYmxlczogQ29sZE9ic2VydmFibGU8YW55PltdID0gW107XG4gIHByaXZhdGUgZmx1c2hUZXN0czogRmx1c2hhYmxlVGVzdFtdID0gW107XG5cbiAgY29uc3RydWN0b3IocHVibGljIGFzc2VydERlZXBFcXVhbDogKGFjdHVhbDogYW55LCBleHBlY3RlZDogYW55KSA9PiBib29sZWFuIHwgdm9pZCkge1xuICAgIHN1cGVyKFZpcnR1YWxBY3Rpb24sIGRlZmF1bHRNYXhGcmFtZSk7XG4gIH1cblxuICBjcmVhdGVUaW1lKG1hcmJsZXM6IHN0cmluZyk6IG51bWJlciB7XG4gICAgY29uc3QgaW5kZXhPZjogbnVtYmVyID0gbWFyYmxlcy5pbmRleE9mKCd8Jyk7XG4gICAgaWYgKGluZGV4T2YgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcmJsZSBkaWFncmFtIGZvciB0aW1lIHNob3VsZCBoYXZlIGEgY29tcGxldGlvbiBtYXJrZXIgXCJ8XCInKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4T2YgKiBUZXN0U2NoZWR1bGVyLmZyYW1lVGltZUZhY3RvcjtcbiAgfVxuXG4gIGNyZWF0ZUNvbGRPYnNlcnZhYmxlPFQ+KG1hcmJsZXM6IHN0cmluZywgdmFsdWVzPzogYW55LCBlcnJvcj86IGFueSk6IENvbGRPYnNlcnZhYmxlPFQ+IHtcbiAgICBpZiAobWFyYmxlcy5pbmRleE9mKCdeJykgIT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbGQgb2JzZXJ2YWJsZSBjYW5ub3QgaGF2ZSBzdWJzY3JpcHRpb24gb2Zmc2V0IFwiXlwiJyk7XG4gICAgfVxuICAgIGlmIChtYXJibGVzLmluZGV4T2YoJyEnKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY29sZCBvYnNlcnZhYmxlIGNhbm5vdCBoYXZlIHVuc3Vic2NyaXB0aW9uIG1hcmtlciBcIiFcIicpO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IFRlc3RTY2hlZHVsZXIucGFyc2VNYXJibGVzKG1hcmJsZXMsIHZhbHVlcywgZXJyb3IpO1xuICAgIGNvbnN0IGNvbGQgPSBuZXcgQ29sZE9ic2VydmFibGU8VD4obWVzc2FnZXMsIHRoaXMpO1xuICAgIHRoaXMuY29sZE9ic2VydmFibGVzLnB1c2goY29sZCk7XG4gICAgcmV0dXJuIGNvbGQ7XG4gIH1cblxuICBjcmVhdGVIb3RPYnNlcnZhYmxlPFQ+KG1hcmJsZXM6IHN0cmluZywgdmFsdWVzPzogYW55LCBlcnJvcj86IGFueSk6IEhvdE9ic2VydmFibGU8VD4ge1xuICAgIGlmIChtYXJibGVzLmluZGV4T2YoJyEnKSAhPT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaG90IG9ic2VydmFibGUgY2Fubm90IGhhdmUgdW5zdWJzY3JpcHRpb24gbWFya2VyIFwiIVwiJyk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gVGVzdFNjaGVkdWxlci5wYXJzZU1hcmJsZXMobWFyYmxlcywgdmFsdWVzLCBlcnJvcik7XG4gICAgY29uc3Qgc3ViamVjdCA9IG5ldyBIb3RPYnNlcnZhYmxlPFQ+KG1lc3NhZ2VzLCB0aGlzKTtcbiAgICB0aGlzLmhvdE9ic2VydmFibGVzLnB1c2goc3ViamVjdCk7XG4gICAgcmV0dXJuIHN1YmplY3Q7XG4gIH1cblxuICBwcml2YXRlIG1hdGVyaWFsaXplSW5uZXJPYnNlcnZhYmxlKG9ic2VydmFibGU6IE9ic2VydmFibGU8YW55PixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRlckZyYW1lOiBudW1iZXIpOiBUZXN0TWVzc2FnZVtdIHtcbiAgICBjb25zdCBtZXNzYWdlczogVGVzdE1lc3NhZ2VbXSA9IFtdO1xuICAgIG9ic2VydmFibGUuc3Vic2NyaWJlKCh2YWx1ZSkgPT4ge1xuICAgICAgbWVzc2FnZXMucHVzaCh7IGZyYW1lOiB0aGlzLmZyYW1lIC0gb3V0ZXJGcmFtZSwgbm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb24uY3JlYXRlTmV4dCh2YWx1ZSkgfSk7XG4gICAgfSwgKGVycikgPT4ge1xuICAgICAgbWVzc2FnZXMucHVzaCh7IGZyYW1lOiB0aGlzLmZyYW1lIC0gb3V0ZXJGcmFtZSwgbm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb24uY3JlYXRlRXJyb3IoZXJyKSB9KTtcbiAgICB9LCAoKSA9PiB7XG4gICAgICBtZXNzYWdlcy5wdXNoKHsgZnJhbWU6IHRoaXMuZnJhbWUgLSBvdXRlckZyYW1lLCBub3RpZmljYXRpb246IE5vdGlmaWNhdGlvbi5jcmVhdGVDb21wbGV0ZSgpIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBtZXNzYWdlcztcbiAgfVxuXG4gIGV4cGVjdE9ic2VydmFibGUob2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxhbnk+LFxuICAgICAgICAgICAgICAgICAgIHVuc3Vic2NyaXB0aW9uTWFyYmxlczogc3RyaW5nID0gbnVsbCk6ICh7IHRvQmU6IG9ic2VydmFibGVUb0JlRm4gfSkge1xuICAgIGNvbnN0IGFjdHVhbDogVGVzdE1lc3NhZ2VbXSA9IFtdO1xuICAgIGNvbnN0IGZsdXNoVGVzdDogRmx1c2hhYmxlVGVzdCA9IHsgYWN0dWFsLCByZWFkeTogZmFsc2UgfTtcbiAgICBjb25zdCB1bnN1YnNjcmlwdGlvbkZyYW1lID0gVGVzdFNjaGVkdWxlclxuICAgICAgLnBhcnNlTWFyYmxlc0FzU3Vic2NyaXB0aW9ucyh1bnN1YnNjcmlwdGlvbk1hcmJsZXMpLnVuc3Vic2NyaWJlZEZyYW1lO1xuICAgIGxldCBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIHRoaXMuc2NoZWR1bGUoKCkgPT4ge1xuICAgICAgc3Vic2NyaXB0aW9uID0gb2JzZXJ2YWJsZS5zdWJzY3JpYmUoeCA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHg7XG4gICAgICAgIC8vIFN1cHBvcnQgT2JzZXJ2YWJsZS1vZi1PYnNlcnZhYmxlc1xuICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMubWF0ZXJpYWxpemVJbm5lck9ic2VydmFibGUodmFsdWUsIHRoaXMuZnJhbWUpO1xuICAgICAgICB9XG4gICAgICAgIGFjdHVhbC5wdXNoKHsgZnJhbWU6IHRoaXMuZnJhbWUsIG5vdGlmaWNhdGlvbjogTm90aWZpY2F0aW9uLmNyZWF0ZU5leHQodmFsdWUpIH0pO1xuICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICBhY3R1YWwucHVzaCh7IGZyYW1lOiB0aGlzLmZyYW1lLCBub3RpZmljYXRpb246IE5vdGlmaWNhdGlvbi5jcmVhdGVFcnJvcihlcnIpIH0pO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgICBhY3R1YWwucHVzaCh7IGZyYW1lOiB0aGlzLmZyYW1lLCBub3RpZmljYXRpb246IE5vdGlmaWNhdGlvbi5jcmVhdGVDb21wbGV0ZSgpIH0pO1xuICAgICAgfSk7XG4gICAgfSwgMCk7XG5cbiAgICBpZiAodW5zdWJzY3JpcHRpb25GcmFtZSAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSB7XG4gICAgICB0aGlzLnNjaGVkdWxlKCgpID0+IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpLCB1bnN1YnNjcmlwdGlvbkZyYW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLmZsdXNoVGVzdHMucHVzaChmbHVzaFRlc3QpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRvQmUobWFyYmxlczogc3RyaW5nLCB2YWx1ZXM/OiBhbnksIGVycm9yVmFsdWU/OiBhbnkpIHtcbiAgICAgICAgZmx1c2hUZXN0LnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgZmx1c2hUZXN0LmV4cGVjdGVkID0gVGVzdFNjaGVkdWxlci5wYXJzZU1hcmJsZXMobWFyYmxlcywgdmFsdWVzLCBlcnJvclZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZXhwZWN0U3Vic2NyaXB0aW9ucyhhY3R1YWxTdWJzY3JpcHRpb25Mb2dzOiBTdWJzY3JpcHRpb25Mb2dbXSk6ICh7IHRvQmU6IHN1YnNjcmlwdGlvbkxvZ3NUb0JlRm4gfSkge1xuICAgIGNvbnN0IGZsdXNoVGVzdDogRmx1c2hhYmxlVGVzdCA9IHsgYWN0dWFsOiBhY3R1YWxTdWJzY3JpcHRpb25Mb2dzLCByZWFkeTogZmFsc2UgfTtcbiAgICB0aGlzLmZsdXNoVGVzdHMucHVzaChmbHVzaFRlc3QpO1xuICAgIHJldHVybiB7XG4gICAgICB0b0JlKG1hcmJsZXM6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG4gICAgICAgIGNvbnN0IG1hcmJsZXNBcnJheTogc3RyaW5nW10gPSAodHlwZW9mIG1hcmJsZXMgPT09ICdzdHJpbmcnKSA/IFttYXJibGVzXSA6IG1hcmJsZXM7XG4gICAgICAgIGZsdXNoVGVzdC5yZWFkeSA9IHRydWU7XG4gICAgICAgIGZsdXNoVGVzdC5leHBlY3RlZCA9IG1hcmJsZXNBcnJheS5tYXAobWFyYmxlcyA9PlxuICAgICAgICAgIFRlc3RTY2hlZHVsZXIucGFyc2VNYXJibGVzQXNTdWJzY3JpcHRpb25zKG1hcmJsZXMpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGZsdXNoKCkge1xuICAgIGNvbnN0IGhvdE9ic2VydmFibGVzID0gdGhpcy5ob3RPYnNlcnZhYmxlcztcbiAgICB3aGlsZSAoaG90T2JzZXJ2YWJsZXMubGVuZ3RoID4gMCkge1xuICAgICAgaG90T2JzZXJ2YWJsZXMuc2hpZnQoKS5zZXR1cCgpO1xuICAgIH1cblxuICAgIHN1cGVyLmZsdXNoKCk7XG4gICAgY29uc3QgcmVhZHlGbHVzaFRlc3RzID0gdGhpcy5mbHVzaFRlc3RzLmZpbHRlcih0ZXN0ID0+IHRlc3QucmVhZHkpO1xuICAgIHdoaWxlIChyZWFkeUZsdXNoVGVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgdGVzdCA9IHJlYWR5Rmx1c2hUZXN0cy5zaGlmdCgpO1xuICAgICAgdGhpcy5hc3NlcnREZWVwRXF1YWwodGVzdC5hY3R1YWwsIHRlc3QuZXhwZWN0ZWQpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwYXJzZU1hcmJsZXNBc1N1YnNjcmlwdGlvbnMobWFyYmxlczogc3RyaW5nKTogU3Vic2NyaXB0aW9uTG9nIHtcbiAgICBpZiAodHlwZW9mIG1hcmJsZXMgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbkxvZyhOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSBtYXJibGVzLmxlbmd0aDtcbiAgICBsZXQgZ3JvdXBTdGFydCA9IC0xO1xuICAgIGxldCBzdWJzY3JpcHRpb25GcmFtZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgdW5zdWJzY3JpcHRpb25GcmFtZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGZyYW1lID0gaSAqIHRoaXMuZnJhbWVUaW1lRmFjdG9yO1xuICAgICAgY29uc3QgYyA9IG1hcmJsZXNbaV07XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICBncm91cFN0YXJ0ID0gZnJhbWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJyknOlxuICAgICAgICAgIGdyb3VwU3RhcnQgPSAtMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbkZyYW1lICE9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZm91bmQgYSBzZWNvbmQgc3Vic2NyaXB0aW9uIHBvaW50IFxcJ15cXCcgaW4gYSAnICtcbiAgICAgICAgICAgICAgJ3N1YnNjcmlwdGlvbiBtYXJibGUgZGlhZ3JhbS4gVGhlcmUgY2FuIG9ubHkgYmUgb25lLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdWJzY3JpcHRpb25GcmFtZSA9IGdyb3VwU3RhcnQgPiAtMSA/IGdyb3VwU3RhcnQgOiBmcmFtZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgaWYgKHVuc3Vic2NyaXB0aW9uRnJhbWUgIT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmb3VuZCBhIHNlY29uZCBzdWJzY3JpcHRpb24gcG9pbnQgXFwnXlxcJyBpbiBhICcgK1xuICAgICAgICAgICAgICAnc3Vic2NyaXB0aW9uIG1hcmJsZSBkaWFncmFtLiBUaGVyZSBjYW4gb25seSBiZSBvbmUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVuc3Vic2NyaXB0aW9uRnJhbWUgPSBncm91cFN0YXJ0ID4gLTEgPyBncm91cFN0YXJ0IDogZnJhbWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGVyZSBjYW4gb25seSBiZSBcXCdeXFwnIGFuZCBcXCchXFwnIG1hcmtlcnMgaW4gYSAnICtcbiAgICAgICAgICAgICdzdWJzY3JpcHRpb24gbWFyYmxlIGRpYWdyYW0uIEZvdW5kIGluc3RlYWQgXFwnJyArIGMgKyAnXFwnLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1bnN1YnNjcmlwdGlvbkZyYW1lIDwgMCkge1xuICAgICAgcmV0dXJuIG5ldyBTdWJzY3JpcHRpb25Mb2coc3Vic2NyaXB0aW9uRnJhbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbkxvZyhzdWJzY3JpcHRpb25GcmFtZSwgdW5zdWJzY3JpcHRpb25GcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHBhcnNlTWFyYmxlcyhtYXJibGVzOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWVzPzogYW55LFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yVmFsdWU/OiBhbnksXG4gICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxpemVJbm5lck9ic2VydmFibGVzOiBib29sZWFuID0gZmFsc2UpOiBUZXN0TWVzc2FnZVtdIHtcbiAgICBpZiAobWFyYmxlcy5pbmRleE9mKCchJykgIT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnZlbnRpb25hbCBtYXJibGUgZGlhZ3JhbXMgY2Fubm90IGhhdmUgdGhlICcgK1xuICAgICAgICAndW5zdWJzY3JpcHRpb24gbWFya2VyIFwiIVwiJyk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IG1hcmJsZXMubGVuZ3RoO1xuICAgIGNvbnN0IHRlc3RNZXNzYWdlczogVGVzdE1lc3NhZ2VbXSA9IFtdO1xuICAgIGNvbnN0IHN1YkluZGV4ID0gbWFyYmxlcy5pbmRleE9mKCdeJyk7XG4gICAgY29uc3QgZnJhbWVPZmZzZXQgPSBzdWJJbmRleCA9PT0gLTEgPyAwIDogKHN1YkluZGV4ICogLXRoaXMuZnJhbWVUaW1lRmFjdG9yKTtcbiAgICBjb25zdCBnZXRWYWx1ZSA9IHR5cGVvZiB2YWx1ZXMgIT09ICdvYmplY3QnID9cbiAgICAgICh4OiBhbnkpID0+IHggOlxuICAgICAgKHg6IGFueSkgPT4ge1xuICAgICAgICAvLyBTdXBwb3J0IE9ic2VydmFibGUtb2YtT2JzZXJ2YWJsZXNcbiAgICAgICAgaWYgKG1hdGVyaWFsaXplSW5uZXJPYnNlcnZhYmxlcyAmJiB2YWx1ZXNbeF0gaW5zdGFuY2VvZiBDb2xkT2JzZXJ2YWJsZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZXNbeF0ubWVzc2FnZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlc1t4XTtcbiAgICAgIH07XG4gICAgbGV0IGdyb3VwU3RhcnQgPSAtMTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGZyYW1lID0gaSAqIHRoaXMuZnJhbWVUaW1lRmFjdG9yICsgZnJhbWVPZmZzZXQ7XG4gICAgICBsZXQgbm90aWZpY2F0aW9uOiBOb3RpZmljYXRpb248YW55PjtcbiAgICAgIGNvbnN0IGMgPSBtYXJibGVzW2ldO1xuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnKCc6XG4gICAgICAgICAgZ3JvdXBTdGFydCA9IGZyYW1lO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcpJzpcbiAgICAgICAgICBncm91cFN0YXJ0ID0gLTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgIG5vdGlmaWNhdGlvbiA9IE5vdGlmaWNhdGlvbi5jcmVhdGVDb21wbGV0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdeJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgbm90aWZpY2F0aW9uID0gTm90aWZpY2F0aW9uLmNyZWF0ZUVycm9yKGVycm9yVmFsdWUgfHwgJ2Vycm9yJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbm90aWZpY2F0aW9uID0gTm90aWZpY2F0aW9uLmNyZWF0ZU5leHQoZ2V0VmFsdWUoYykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAobm90aWZpY2F0aW9uKSB7XG4gICAgICAgIHRlc3RNZXNzYWdlcy5wdXNoKHsgZnJhbWU6IGdyb3VwU3RhcnQgPiAtMSA/IGdyb3VwU3RhcnQgOiBmcmFtZSwgbm90aWZpY2F0aW9uIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGVzdE1lc3NhZ2VzO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3Rlc3RpbmcvVGVzdFNjaGVkdWxlci50cyIsImltcG9ydCB7ICByb290ICB9IGZyb20gJy4vcm9vdCc7XG5cbmV4cG9ydCBjbGFzcyBSZXF1ZXN0QW5pbWF0aW9uRnJhbWVEZWZpbml0aW9uIHtcbiAgY2FuY2VsQW5pbWF0aW9uRnJhbWU6IChoYW5kbGU6IG51bWJlcikgPT4gdm9pZDtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lOiAoY2I6ICgpID0+IHZvaWQpID0+IG51bWJlcjtcbiAgY29uc3RydWN0b3Iocm9vdDogYW55KSB7XG4gICAgaWYgKHJvb3QucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gcm9vdC5jYW5jZWxBbmltYXRpb25GcmFtZS5iaW5kKHJvb3QpO1xuICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByb290LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHJvb3QpO1xuICAgIH0gZWxzZSBpZiAocm9vdC5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSByb290Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lLmJpbmQocm9vdCk7XG4gICAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHJvb3QubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQocm9vdCk7XG4gICAgfSBlbHNlIGlmIChyb290LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHJvb3Qud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcm9vdC53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICB9IGVsc2UgaWYgKHJvb3QubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcbiAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSByb290Lm1zQ2FuY2VsQW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcm9vdC5tc1JlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHJvb3QpO1xuICAgIH0gZWxzZSBpZiAocm9vdC5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gcm9vdC5vQ2FuY2VsQW5pbWF0aW9uRnJhbWUuYmluZChyb290KTtcbiAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcm9vdC5vUmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQocm9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSByb290LmNsZWFyVGltZW91dC5iaW5kKHJvb3QpO1xuICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihjYikgeyByZXR1cm4gcm9vdC5zZXRUaW1lb3V0KGNiLCAxMDAwIC8gNjApOyB9O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQW5pbWF0aW9uRnJhbWUgPSBuZXcgUmVxdWVzdEFuaW1hdGlvbkZyYW1lRGVmaW5pdGlvbihyb290KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcnhqcy9zcmMvdXRpbC9BbmltYXRpb25GcmFtZS50cyIsImV4cG9ydCBjbGFzcyBGYXN0TWFwIHtcbiAgcHJpdmF0ZSB2YWx1ZXM6IE9iamVjdCA9IHt9O1xuXG4gIGRlbGV0ZShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRoaXMudmFsdWVzW2tleV0gPSBudWxsO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgc2V0KGtleTogc3RyaW5nLCB2YWx1ZTogYW55KTogRmFzdE1hcCB7XG4gICAgdGhpcy52YWx1ZXNba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KGtleTogc3RyaW5nKTogYW55IHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNba2V5XTtcbiAgfVxuXG4gIGZvckVhY2goY2I6ICh2YWx1ZTogYW55LCBrZXk6IGFueSkgPT4gdm9pZCwgdGhpc0FyZz86IGFueSk6IHZvaWQge1xuICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgIGZvciAobGV0IGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiB2YWx1ZXNba2V5XSAhPT0gbnVsbCkge1xuICAgICAgICBjYi5jYWxsKHRoaXNBcmcsIHZhbHVlc1trZXldLCBrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNsZWFyKCk6IHZvaWQge1xuICAgIHRoaXMudmFsdWVzID0ge307XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3V0aWwvRmFzdE1hcC50cyIsIi8qKlxuU29tZSBjcmVkaXQgZm9yIHRoaXMgaGVscGVyIGdvZXMgdG8gaHR0cDovL2dpdGh1Yi5jb20vWXV6dUpTL3NldEltbWVkaWF0ZVxuKi9cblxuaW1wb3J0IHsgIHJvb3QgIH0gZnJvbSAnLi9yb290JztcblxuZXhwb3J0IGNsYXNzIEltbWVkaWF0ZURlZmluaXRpb24ge1xuICBzZXRJbW1lZGlhdGU6IChjYjogKCkgPT4gdm9pZCkgPT4gbnVtYmVyO1xuXG4gIGNsZWFySW1tZWRpYXRlOiAoaGFuZGxlOiBudW1iZXIpID0+IHZvaWQ7XG5cbiAgcHJpdmF0ZSBpZGVudGlmeShvOiBhbnkpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnJvb3QuT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xuICB9XG5cbiAgdGFza3NCeUhhbmRsZTogYW55O1xuXG4gIG5leHRIYW5kbGU6IG51bWJlcjtcblxuICBjdXJyZW50bHlSdW5uaW5nQVRhc2s6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByb290OiBhbnkpIHtcbiAgICBpZiAocm9vdC5zZXRJbW1lZGlhdGUgJiYgdHlwZW9mIHJvb3Quc2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLnNldEltbWVkaWF0ZSA9IHJvb3Quc2V0SW1tZWRpYXRlLmJpbmQocm9vdCk7XG4gICAgICB0aGlzLmNsZWFySW1tZWRpYXRlID0gcm9vdC5jbGVhckltbWVkaWF0ZS5iaW5kKHJvb3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5leHRIYW5kbGUgPSAxO1xuICAgICAgdGhpcy50YXNrc0J5SGFuZGxlID0ge307XG4gICAgICB0aGlzLmN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuXG4gICAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgICBpZiAodGhpcy5jYW5Vc2VQcm9jZXNzTmV4dFRpY2soKSkge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIHRoaXMuc2V0SW1tZWRpYXRlID0gdGhpcy5jcmVhdGVQcm9jZXNzTmV4dFRpY2tTZXRJbW1lZGlhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgdGhpcy5zZXRJbW1lZGlhdGUgPSB0aGlzLmNyZWF0ZVBvc3RNZXNzYWdlU2V0SW1tZWRpYXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY2FuVXNlTWVzc2FnZUNoYW5uZWwoKSkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICB0aGlzLnNldEltbWVkaWF0ZSA9IHRoaXMuY3JlYXRlTWVzc2FnZUNoYW5uZWxTZXRJbW1lZGlhdGUoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jYW5Vc2VSZWFkeVN0YXRlQ2hhbmdlKCkpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIHRoaXMuc2V0SW1tZWRpYXRlID0gdGhpcy5jcmVhdGVSZWFkeVN0YXRlQ2hhbmdlU2V0SW1tZWRpYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgdGhpcy5zZXRJbW1lZGlhdGUgPSB0aGlzLmNyZWF0ZVNldFRpbWVvdXRTZXRJbW1lZGlhdGUoKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGNpID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlOiBhbnkpIHtcbiAgICAgICAgZGVsZXRlICg8YW55PmNsZWFySW1tZWRpYXRlKS5pbnN0YW5jZS50YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICB9O1xuXG4gICAgICAoPGFueT5jaSkuaW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgICB0aGlzLmNsZWFySW1tZWRpYXRlID0gY2k7XG4gICAgfVxuICB9XG5cbiAgY2FuVXNlUHJvY2Vzc05leHRUaWNrKCkge1xuICAgIHJldHVybiB0aGlzLmlkZW50aWZ5KHRoaXMucm9vdC5wcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nO1xuICB9XG5cbiAgY2FuVXNlTWVzc2FnZUNoYW5uZWwoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5yb290Lk1lc3NhZ2VDaGFubmVsKTtcbiAgfVxuXG4gIGNhblVzZVJlYWR5U3RhdGVDaGFuZ2UoKSB7XG4gICAgY29uc3QgZG9jdW1lbnQgPSB0aGlzLnJvb3QuZG9jdW1lbnQ7XG4gICAgcmV0dXJuIEJvb2xlYW4oZG9jdW1lbnQgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpO1xuICB9XG5cbiAgY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMucm9vdDtcbiAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgLy8gd2hlcmUgYHJvb3QucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgIGlmIChyb290LnBvc3RNZXNzYWdlICYmICFyb290LmltcG9ydFNjcmlwdHMpIHtcbiAgICAgIGxldCBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgIGxldCBvbGRPbk1lc3NhZ2UgPSByb290Lm9ubWVzc2FnZTtcbiAgICAgIHJvb3Qub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgIH07XG4gICAgICByb290LnBvc3RNZXNzYWdlKCcnLCAnKicpO1xuICAgICAgcm9vdC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIHNldEltbWVkaWF0ZSwgYnV0XG4gIC8vIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJlcXVpcmVzIG5vIGFyZ3VtZW50cy5cbiAgcGFydGlhbGx5QXBwbGllZChoYW5kbGVyOiBhbnksIC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgbGV0IGZuID0gZnVuY3Rpb24gcmVzdWx0ICgpIHtcbiAgICAgIGNvbnN0IHsgaGFuZGxlciwgYXJncyB9ID0gPGFueT5yZXN1bHQ7XG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaGFuZGxlci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKG5ldyBGdW5jdGlvbignJyArIGhhbmRsZXIpKSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAoPGFueT5mbikuaGFuZGxlciA9IGhhbmRsZXI7XG4gICAgKDxhbnk+Zm4pLmFyZ3MgPSBhcmdzO1xuXG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmdzOiBhbnlbXSkge1xuICAgIHRoaXMudGFza3NCeUhhbmRsZVt0aGlzLm5leHRIYW5kbGVdID0gdGhpcy5wYXJ0aWFsbHlBcHBsaWVkLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgcmV0dXJuIHRoaXMubmV4dEhhbmRsZSsrO1xuICB9XG5cbiAgY3JlYXRlUHJvY2Vzc05leHRUaWNrU2V0SW1tZWRpYXRlKCkge1xuICAgIGxldCBmbiA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZSgpIHtcbiAgICAgIGNvbnN0IHsgaW5zdGFuY2UgfSA9ICg8YW55PnNldEltbWVkaWF0ZSk7XG4gICAgICBsZXQgaGFuZGxlID0gaW5zdGFuY2UuYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgaW5zdGFuY2Uucm9vdC5wcm9jZXNzLm5leHRUaWNrKGluc3RhbmNlLnBhcnRpYWxseUFwcGxpZWQoaW5zdGFuY2UucnVuSWZQcmVzZW50LCBoYW5kbGUpKTtcbiAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgfTtcblxuICAgICg8YW55PmZuKS5pbnN0YW5jZSA9IHRoaXM7XG5cbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBjcmVhdGVQb3N0TWVzc2FnZVNldEltbWVkaWF0ZSgpIHtcbiAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG4gICAgY29uc3Qgcm9vdCA9IHRoaXMucm9vdDtcblxuICAgIGxldCBtZXNzYWdlUHJlZml4ID0gJ3NldEltbWVkaWF0ZSQnICsgcm9vdC5NYXRoLnJhbmRvbSgpICsgJyQnO1xuICAgIGxldCBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbiBnbG9iYWxNZXNzYWdlSGFuZGxlcihldmVudDogYW55KSB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9ICg8YW55Pmdsb2JhbE1lc3NhZ2VIYW5kbGVyKS5pbnN0YW5jZTtcbiAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IHJvb3QgJiZcbiAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICBpbnN0YW5jZS5ydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgICg8YW55Pm9uR2xvYmFsTWVzc2FnZSkuaW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgcm9vdC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG5cbiAgICBsZXQgZm4gPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2VQcmVmaXgsIGluc3RhbmNlIH0gPSAoPGFueT5zZXRJbW1lZGlhdGUpO1xuICAgICAgbGV0IGhhbmRsZSA9IGluc3RhbmNlLmFkZEZyb21TZXRJbW1lZGlhdGVBcmd1bWVudHMoYXJndW1lbnRzKTtcbiAgICAgIGluc3RhbmNlLnJvb3QucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgJyonKTtcbiAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgfTtcblxuICAgICg8YW55PmZuKS5pbnN0YW5jZSA9IHRoaXM7XG4gICAgKDxhbnk+Zm4pLm1lc3NhZ2VQcmVmaXggPSBtZXNzYWdlUHJlZml4O1xuXG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgcnVuSWZQcmVzZW50KGhhbmRsZTogYW55KSB7XG4gICAgLy8gRnJvbSB0aGUgc3BlYzogJ1dhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLidcbiAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgIGlmICh0aGlzLmN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgIC8vICd0b28gbXVjaCByZWN1cnNpb24nIGVycm9yLlxuICAgICAgdGhpcy5yb290LnNldFRpbWVvdXQodGhpcy5wYXJ0aWFsbHlBcHBsaWVkKHRoaXMucnVuSWZQcmVzZW50LCBoYW5kbGUpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHRhc2sgPSB0aGlzLnRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgIHRoaXMuY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0YXNrKCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdGhpcy5jbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgIHRoaXMuY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjcmVhdGVNZXNzYWdlQ2hhbm5lbFNldEltbWVkaWF0ZSgpIHtcbiAgICBsZXQgY2hhbm5lbCA9IG5ldyB0aGlzLnJvb3QuTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IChldmVudDogYW55KSA9PiB7XG4gICAgICBsZXQgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgIHRoaXMucnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgfTtcblxuICAgIGxldCBmbiA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZSgpIHtcbiAgICAgIGNvbnN0IHsgY2hhbm5lbCwgaW5zdGFuY2UgfSA9ICg8YW55PnNldEltbWVkaWF0ZSk7XG4gICAgICBsZXQgaGFuZGxlID0gaW5zdGFuY2UuYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICB9O1xuXG4gICAgKDxhbnk+Zm4pLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICg8YW55PmZuKS5pbnN0YW5jZSA9IHRoaXM7XG5cbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBjcmVhdGVSZWFkeVN0YXRlQ2hhbmdlU2V0SW1tZWRpYXRlKCkge1xuICAgIGxldCBmbiA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZSgpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gKDxhbnk+c2V0SW1tZWRpYXRlKS5pbnN0YW5jZTtcbiAgICAgIGNvbnN0IHJvb3QgPSBpbnN0YW5jZS5yb290O1xuICAgICAgY29uc3QgZG9jID0gcm9vdC5kb2N1bWVudDtcbiAgICAgIGNvbnN0IGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICBsZXQgaGFuZGxlID0gaW5zdGFuY2UuYWRkRnJvbVNldEltbWVkaWF0ZUFyZ3VtZW50cyhhcmd1bWVudHMpO1xuICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgbGV0IHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgIGluc3RhbmNlLnJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgfTtcbiAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgIHJldHVybiBoYW5kbGU7XG4gICAgfTtcblxuICAgICg8YW55PmZuKS5pbnN0YW5jZSA9IHRoaXM7XG5cbiAgICByZXR1cm4gZm47XG4gIH1cblxuICBjcmVhdGVTZXRUaW1lb3V0U2V0SW1tZWRpYXRlKCkge1xuICAgIGxldCBmbiA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZSgpIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gKDxhbnk+c2V0SW1tZWRpYXRlKS5pbnN0YW5jZTtcbiAgICAgIGxldCBoYW5kbGUgPSBpbnN0YW5jZS5hZGRGcm9tU2V0SW1tZWRpYXRlQXJndW1lbnRzKGFyZ3VtZW50cyk7XG4gICAgICBpbnN0YW5jZS5yb290LnNldFRpbWVvdXQoaW5zdGFuY2UucGFydGlhbGx5QXBwbGllZChpbnN0YW5jZS5ydW5JZlByZXNlbnQsIGhhbmRsZSksIDApO1xuICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICB9O1xuXG4gICAgKDxhbnk+Zm4pLmluc3RhbmNlID0gdGhpcztcblxuICAgIHJldHVybiBmbjtcbiAgfVxufVxuZXhwb3J0IGNvbnN0IEltbWVkaWF0ZSA9IG5ldyBJbW1lZGlhdGVEZWZpbml0aW9uKHJvb3QpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy91dGlsL0ltbWVkaWF0ZS50cyIsImltcG9ydCB7IHJvb3QgfSBmcm9tICcuL3Jvb3QnO1xuaW1wb3J0IHsgTWFwUG9seWZpbGwgfSBmcm9tICcuL01hcFBvbHlmaWxsJztcblxuZXhwb3J0IGNvbnN0IE1hcCA9IHJvb3QuTWFwIHx8ICgoKSA9PiBNYXBQb2x5ZmlsbCkoKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3V0aWwvTWFwLnRzIiwiZXhwb3J0IGNsYXNzIE1hcFBvbHlmaWxsIHtcbiAgcHVibGljIHNpemUgPSAwO1xuICBwcml2YXRlIF92YWx1ZXM6IGFueVtdID0gW107XG4gIHByaXZhdGUgX2tleXM6IGFueVtdID0gW107XG5cbiAgZ2V0KGtleTogYW55KSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX2tleXMuaW5kZXhPZihrZXkpO1xuICAgIHJldHVybiBpID09PSAtMSA/IHVuZGVmaW5lZCA6IHRoaXMuX3ZhbHVlc1tpXTtcbiAgfVxuXG4gIHNldChrZXk6IGFueSwgdmFsdWU6IGFueSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9rZXlzLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgIHRoaXMuX2tleXMucHVzaChrZXkpO1xuICAgICAgdGhpcy5fdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgdGhpcy5zaXplKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3ZhbHVlc1tpXSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGRlbGV0ZShrZXk6IGFueSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9rZXlzLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAoaSA9PT0gLTEpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgdGhpcy5fdmFsdWVzLnNwbGljZShpLCAxKTtcbiAgICB0aGlzLl9rZXlzLnNwbGljZShpLCAxKTtcbiAgICB0aGlzLnNpemUtLTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNsZWFyKCk6IHZvaWQge1xuICAgIHRoaXMuX2tleXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl92YWx1ZXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnNpemUgPSAwO1xuICB9XG5cbiAgZm9yRWFjaChjYjogRnVuY3Rpb24sIHRoaXNBcmc6IGFueSk6IHZvaWQge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zaXplOyBpKyspIHtcbiAgICAgIGNiLmNhbGwodGhpc0FyZywgdGhpcy5fdmFsdWVzW2ldLCB0aGlzLl9rZXlzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3V0aWwvTWFwUG9seWZpbGwudHMiLCJpbXBvcnQgeyByb290IH0gZnJvbSAnLi9yb290JztcblxuZXhwb3J0IGludGVyZmFjZSBJU2V0Q3RvciB7XG4gIG5ldzxUPigpOiBJU2V0PFQ+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElTZXQ8VD4ge1xuICBhZGQodmFsdWU6IFQpOiB2b2lkO1xuICBoYXModmFsdWU6IFQpOiBib29sZWFuO1xuICBzaXplOiBudW1iZXI7XG4gIGNsZWFyKCk6IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtaW5pbWFsU2V0SW1wbDxUPigpOiBJU2V0Q3RvciB7XG4gIC8vIFRISVMgSVMgTk9UIGEgZnVsbCBpbXBsIG9mIFNldCwgdGhpcyBpcyBqdXN0IHRoZSBtaW5pbXVtXG4gIC8vIGJpdHMgb2YgZnVuY3Rpb25hbGl0eSB3ZSBuZWVkIGZvciB0aGlzIGxpYnJhcnkuXG4gIHJldHVybiBjbGFzcyBNaW5pbWFsU2V0PFQ+IGltcGxlbWVudHMgSVNldDxUPiB7XG4gICAgcHJpdmF0ZSBfdmFsdWVzOiBUW10gPSBbXTtcblxuICAgIGFkZCh2YWx1ZTogVCk6IHZvaWQge1xuICAgICAgaWYgKCF0aGlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhcyh2YWx1ZTogVCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlcy5pbmRleE9mKHZhbHVlKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgZ2V0IHNpemUoKTogbnVtYmVyIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZXMubGVuZ3RoO1xuICAgIH1cblxuICAgIGNsZWFyKCk6IHZvaWQge1xuICAgICAgdGhpcy5fdmFsdWVzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgY29uc3QgU2V0OiBJU2V0Q3RvciA9IHJvb3QuU2V0IHx8IG1pbmltYWxTZXRJbXBsKCk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy91dGlsL1NldC50cyIsImltcG9ydCB7IHJvb3QgfSBmcm9tICcuL3Jvb3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduSW1wbCh0YXJnZXQ6IE9iamVjdCwgLi4uc291cmNlczogT2JqZWN0W10pIHtcbiAgY29uc3QgbGVuID0gc291cmNlcy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgIGZvciAobGV0IGsgaW4gc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgIHRhcmdldFtrXSA9IHNvdXJjZVtrXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBc3NpZ24ocm9vdDogYW55KSB7XG4gIHJldHVybiByb290Lk9iamVjdC5hc3NpZ24gfHwgYXNzaWduSW1wbDtcbn1cblxuZXhwb3J0IGNvbnN0IGFzc2lnbiA9IGdldEFzc2lnbihyb290KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3V0aWwvYXNzaWduLnRzIiwiZXhwb3J0IGZ1bmN0aW9uIG5vdChwcmVkOiBGdW5jdGlvbiwgdGhpc0FyZzogYW55KTogRnVuY3Rpb24ge1xuICBmdW5jdGlvbiBub3RQcmVkKCk6IGFueSB7XG4gICAgcmV0dXJuICEoKDxhbnk+IG5vdFByZWQpLnByZWQuYXBwbHkoKDxhbnk+IG5vdFByZWQpLnRoaXNBcmcsIGFyZ3VtZW50cykpO1xuICB9XG4gICg8YW55PiBub3RQcmVkKS5wcmVkID0gcHJlZDtcbiAgKDxhbnk+IG5vdFByZWQpLnRoaXNBcmcgPSB0aGlzQXJnO1xuICByZXR1cm4gbm90UHJlZDtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3J4anMvc3JjL3V0aWwvbm90LnRzIiwiaW1wb3J0IHsgU3Vic2NyaWJlciB9IGZyb20gJy4uL1N1YnNjcmliZXInO1xuaW1wb3J0IHsgcnhTdWJzY3JpYmVyIGFzIHJ4U3Vic2NyaWJlclN5bWJvbCB9IGZyb20gJy4uL3N5bWJvbC9yeFN1YnNjcmliZXInO1xuaW1wb3J0IHsgUGFydGlhbE9ic2VydmVyLCBlbXB0eSBhcyBlbXB0eU9ic2VydmVyIH0gZnJvbSAnLi4vT2JzZXJ2ZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gdG9TdWJzY3JpYmVyPFQ+KFxuICBuZXh0T3JPYnNlcnZlcj86IFBhcnRpYWxPYnNlcnZlcjxUPiB8ICgodmFsdWU6IFQpID0+IHZvaWQpLFxuICBlcnJvcj86IChlcnJvcjogYW55KSA9PiB2b2lkLFxuICBjb21wbGV0ZT86ICgpID0+IHZvaWQpOiBTdWJzY3JpYmVyPFQ+IHtcblxuICBpZiAobmV4dE9yT2JzZXJ2ZXIpIHtcbiAgICBpZiAobmV4dE9yT2JzZXJ2ZXIgaW5zdGFuY2VvZiBTdWJzY3JpYmVyKSB7XG4gICAgICByZXR1cm4gKDxTdWJzY3JpYmVyPFQ+PiBuZXh0T3JPYnNlcnZlcik7XG4gICAgfVxuXG4gICAgaWYgKG5leHRPck9ic2VydmVyW3J4U3Vic2NyaWJlclN5bWJvbF0pIHtcbiAgICAgIHJldHVybiBuZXh0T3JPYnNlcnZlcltyeFN1YnNjcmliZXJTeW1ib2xdKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFuZXh0T3JPYnNlcnZlciAmJiAhZXJyb3IgJiYgIWNvbXBsZXRlKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyKGVtcHR5T2JzZXJ2ZXIpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yeGpzL3NyYy91dGlsL3RvU3Vic2NyaWJlci50cyIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAzNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==